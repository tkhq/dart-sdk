// ignore_for_file: type=lint

import 'package:json_annotation/json_annotation.dart';
import 'package:json_annotation/json_annotation.dart' as json;
import 'package:collection/collection.dart';
import 'dart:convert';

import 'public_api.enums.swagger.dart' as enums;
export 'public_api.enums.swagger.dart';

part 'public_api.swagger.g.dart';

@JsonSerializable(explicitToJson: true)
class AcceptInvitationIntent {
  const AcceptInvitationIntent({
    required this.invitationId,
    required this.userId,
    required this.authenticator,
  });

  factory AcceptInvitationIntent.fromJson(Map<String, dynamic> json) =>
      _$AcceptInvitationIntentFromJson(json);

  static const toJsonFactory = _$AcceptInvitationIntentToJson;
  Map<String, dynamic> toJson() => _$AcceptInvitationIntentToJson(this);

  @JsonKey(name: 'invitationId')
  final String invitationId;
  @JsonKey(name: 'userId')
  final String userId;
  @JsonKey(name: 'authenticator')
  final AuthenticatorParams authenticator;
  static const fromJsonFactory = _$AcceptInvitationIntentFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is AcceptInvitationIntent &&
            (identical(other.invitationId, invitationId) ||
                const DeepCollectionEquality()
                    .equals(other.invitationId, invitationId)) &&
            (identical(other.userId, userId) ||
                const DeepCollectionEquality().equals(other.userId, userId)) &&
            (identical(other.authenticator, authenticator) ||
                const DeepCollectionEquality()
                    .equals(other.authenticator, authenticator)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(invitationId) ^
      const DeepCollectionEquality().hash(userId) ^
      const DeepCollectionEquality().hash(authenticator) ^
      runtimeType.hashCode;
}

extension $AcceptInvitationIntentExtension on AcceptInvitationIntent {
  AcceptInvitationIntent copyWith(
      {String? invitationId,
      String? userId,
      AuthenticatorParams? authenticator}) {
    return AcceptInvitationIntent(
        invitationId: invitationId ?? this.invitationId,
        userId: userId ?? this.userId,
        authenticator: authenticator ?? this.authenticator);
  }

  AcceptInvitationIntent copyWithWrapped(
      {Wrapped<String>? invitationId,
      Wrapped<String>? userId,
      Wrapped<AuthenticatorParams>? authenticator}) {
    return AcceptInvitationIntent(
        invitationId:
            (invitationId != null ? invitationId.value : this.invitationId),
        userId: (userId != null ? userId.value : this.userId),
        authenticator:
            (authenticator != null ? authenticator.value : this.authenticator));
  }
}

@JsonSerializable(explicitToJson: true)
class AcceptInvitationIntentV2 {
  const AcceptInvitationIntentV2({
    required this.invitationId,
    required this.userId,
    required this.authenticator,
  });

  factory AcceptInvitationIntentV2.fromJson(Map<String, dynamic> json) =>
      _$AcceptInvitationIntentV2FromJson(json);

  static const toJsonFactory = _$AcceptInvitationIntentV2ToJson;
  Map<String, dynamic> toJson() => _$AcceptInvitationIntentV2ToJson(this);

  @JsonKey(name: 'invitationId')
  final String invitationId;
  @JsonKey(name: 'userId')
  final String userId;
  @JsonKey(name: 'authenticator')
  final AuthenticatorParamsV2 authenticator;
  static const fromJsonFactory = _$AcceptInvitationIntentV2FromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is AcceptInvitationIntentV2 &&
            (identical(other.invitationId, invitationId) ||
                const DeepCollectionEquality()
                    .equals(other.invitationId, invitationId)) &&
            (identical(other.userId, userId) ||
                const DeepCollectionEquality().equals(other.userId, userId)) &&
            (identical(other.authenticator, authenticator) ||
                const DeepCollectionEquality()
                    .equals(other.authenticator, authenticator)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(invitationId) ^
      const DeepCollectionEquality().hash(userId) ^
      const DeepCollectionEquality().hash(authenticator) ^
      runtimeType.hashCode;
}

extension $AcceptInvitationIntentV2Extension on AcceptInvitationIntentV2 {
  AcceptInvitationIntentV2 copyWith(
      {String? invitationId,
      String? userId,
      AuthenticatorParamsV2? authenticator}) {
    return AcceptInvitationIntentV2(
        invitationId: invitationId ?? this.invitationId,
        userId: userId ?? this.userId,
        authenticator: authenticator ?? this.authenticator);
  }

  AcceptInvitationIntentV2 copyWithWrapped(
      {Wrapped<String>? invitationId,
      Wrapped<String>? userId,
      Wrapped<AuthenticatorParamsV2>? authenticator}) {
    return AcceptInvitationIntentV2(
        invitationId:
            (invitationId != null ? invitationId.value : this.invitationId),
        userId: (userId != null ? userId.value : this.userId),
        authenticator:
            (authenticator != null ? authenticator.value : this.authenticator));
  }
}

@JsonSerializable(explicitToJson: true)
class AcceptInvitationResult {
  const AcceptInvitationResult({
    required this.invitationId,
    required this.userId,
  });

  factory AcceptInvitationResult.fromJson(Map<String, dynamic> json) =>
      _$AcceptInvitationResultFromJson(json);

  static const toJsonFactory = _$AcceptInvitationResultToJson;
  Map<String, dynamic> toJson() => _$AcceptInvitationResultToJson(this);

  @JsonKey(name: 'invitationId')
  final String invitationId;
  @JsonKey(name: 'userId')
  final String userId;
  static const fromJsonFactory = _$AcceptInvitationResultFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is AcceptInvitationResult &&
            (identical(other.invitationId, invitationId) ||
                const DeepCollectionEquality()
                    .equals(other.invitationId, invitationId)) &&
            (identical(other.userId, userId) ||
                const DeepCollectionEquality().equals(other.userId, userId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(invitationId) ^
      const DeepCollectionEquality().hash(userId) ^
      runtimeType.hashCode;
}

extension $AcceptInvitationResultExtension on AcceptInvitationResult {
  AcceptInvitationResult copyWith({String? invitationId, String? userId}) {
    return AcceptInvitationResult(
        invitationId: invitationId ?? this.invitationId,
        userId: userId ?? this.userId);
  }

  AcceptInvitationResult copyWithWrapped(
      {Wrapped<String>? invitationId, Wrapped<String>? userId}) {
    return AcceptInvitationResult(
        invitationId:
            (invitationId != null ? invitationId.value : this.invitationId),
        userId: (userId != null ? userId.value : this.userId));
  }
}

@JsonSerializable(explicitToJson: true)
class ActivateBillingTierIntent {
  const ActivateBillingTierIntent({
    required this.productId,
  });

  factory ActivateBillingTierIntent.fromJson(Map<String, dynamic> json) =>
      _$ActivateBillingTierIntentFromJson(json);

  static const toJsonFactory = _$ActivateBillingTierIntentToJson;
  Map<String, dynamic> toJson() => _$ActivateBillingTierIntentToJson(this);

  @JsonKey(name: 'productId')
  final String productId;
  static const fromJsonFactory = _$ActivateBillingTierIntentFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ActivateBillingTierIntent &&
            (identical(other.productId, productId) ||
                const DeepCollectionEquality()
                    .equals(other.productId, productId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(productId) ^ runtimeType.hashCode;
}

extension $ActivateBillingTierIntentExtension on ActivateBillingTierIntent {
  ActivateBillingTierIntent copyWith({String? productId}) {
    return ActivateBillingTierIntent(productId: productId ?? this.productId);
  }

  ActivateBillingTierIntent copyWithWrapped({Wrapped<String>? productId}) {
    return ActivateBillingTierIntent(
        productId: (productId != null ? productId.value : this.productId));
  }
}

@JsonSerializable(explicitToJson: true)
class ActivateBillingTierResult {
  const ActivateBillingTierResult({
    required this.productId,
  });

  factory ActivateBillingTierResult.fromJson(Map<String, dynamic> json) =>
      _$ActivateBillingTierResultFromJson(json);

  static const toJsonFactory = _$ActivateBillingTierResultToJson;
  Map<String, dynamic> toJson() => _$ActivateBillingTierResultToJson(this);

  @JsonKey(name: 'productId')
  final String productId;
  static const fromJsonFactory = _$ActivateBillingTierResultFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ActivateBillingTierResult &&
            (identical(other.productId, productId) ||
                const DeepCollectionEquality()
                    .equals(other.productId, productId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(productId) ^ runtimeType.hashCode;
}

extension $ActivateBillingTierResultExtension on ActivateBillingTierResult {
  ActivateBillingTierResult copyWith({String? productId}) {
    return ActivateBillingTierResult(productId: productId ?? this.productId);
  }

  ActivateBillingTierResult copyWithWrapped({Wrapped<String>? productId}) {
    return ActivateBillingTierResult(
        productId: (productId != null ? productId.value : this.productId));
  }
}

@JsonSerializable(explicitToJson: true)
class Activity {
  const Activity({
    required this.id,
    required this.organizationId,
    required this.status,
    required this.type,
    required this.intent,
    required this.result,
    required this.votes,
    required this.fingerprint,
    required this.canApprove,
    required this.canReject,
    required this.createdAt,
    required this.updatedAt,
    this.failure,
  });

  factory Activity.fromJson(Map<String, dynamic> json) =>
      _$ActivityFromJson(json);

  static const toJsonFactory = _$ActivityToJson;
  Map<String, dynamic> toJson() => _$ActivityToJson(this);

  @JsonKey(name: 'id')
  final String id;
  @JsonKey(name: 'organizationId')
  final String organizationId;
  @JsonKey(
    name: 'status',
    toJson: activityStatusToJson,
    fromJson: activityStatusFromJson,
  )
  final enums.ActivityStatus status;
  @JsonKey(
    name: 'type',
    toJson: activityTypeToJson,
    fromJson: activityTypeFromJson,
  )
  final enums.ActivityType type;
  @JsonKey(name: 'intent')
  final Intent intent;
  @JsonKey(name: 'result')
  final Result result;
  @JsonKey(name: 'votes', defaultValue: <Vote>[])
  final List<Vote> votes;
  @JsonKey(name: 'fingerprint')
  final String fingerprint;
  @JsonKey(name: 'canApprove')
  final bool canApprove;
  @JsonKey(name: 'canReject')
  final bool canReject;
  @JsonKey(name: 'createdAt')
  final ExternalDataV1Timestamp createdAt;
  @JsonKey(name: 'updatedAt')
  final ExternalDataV1Timestamp updatedAt;
  @JsonKey(name: 'failure')
  final Status? failure;
  static const fromJsonFactory = _$ActivityFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is Activity &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.organizationId, organizationId) ||
                const DeepCollectionEquality()
                    .equals(other.organizationId, organizationId)) &&
            (identical(other.status, status) ||
                const DeepCollectionEquality().equals(other.status, status)) &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.intent, intent) ||
                const DeepCollectionEquality().equals(other.intent, intent)) &&
            (identical(other.result, result) ||
                const DeepCollectionEquality().equals(other.result, result)) &&
            (identical(other.votes, votes) ||
                const DeepCollectionEquality().equals(other.votes, votes)) &&
            (identical(other.fingerprint, fingerprint) ||
                const DeepCollectionEquality()
                    .equals(other.fingerprint, fingerprint)) &&
            (identical(other.canApprove, canApprove) ||
                const DeepCollectionEquality()
                    .equals(other.canApprove, canApprove)) &&
            (identical(other.canReject, canReject) ||
                const DeepCollectionEquality()
                    .equals(other.canReject, canReject)) &&
            (identical(other.createdAt, createdAt) ||
                const DeepCollectionEquality()
                    .equals(other.createdAt, createdAt)) &&
            (identical(other.updatedAt, updatedAt) ||
                const DeepCollectionEquality()
                    .equals(other.updatedAt, updatedAt)) &&
            (identical(other.failure, failure) ||
                const DeepCollectionEquality().equals(other.failure, failure)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(organizationId) ^
      const DeepCollectionEquality().hash(status) ^
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(intent) ^
      const DeepCollectionEquality().hash(result) ^
      const DeepCollectionEquality().hash(votes) ^
      const DeepCollectionEquality().hash(fingerprint) ^
      const DeepCollectionEquality().hash(canApprove) ^
      const DeepCollectionEquality().hash(canReject) ^
      const DeepCollectionEquality().hash(createdAt) ^
      const DeepCollectionEquality().hash(updatedAt) ^
      const DeepCollectionEquality().hash(failure) ^
      runtimeType.hashCode;
}

extension $ActivityExtension on Activity {
  Activity copyWith(
      {String? id,
      String? organizationId,
      enums.ActivityStatus? status,
      enums.ActivityType? type,
      Intent? intent,
      Result? result,
      List<Vote>? votes,
      String? fingerprint,
      bool? canApprove,
      bool? canReject,
      ExternalDataV1Timestamp? createdAt,
      ExternalDataV1Timestamp? updatedAt,
      Status? failure}) {
    return Activity(
        id: id ?? this.id,
        organizationId: organizationId ?? this.organizationId,
        status: status ?? this.status,
        type: type ?? this.type,
        intent: intent ?? this.intent,
        result: result ?? this.result,
        votes: votes ?? this.votes,
        fingerprint: fingerprint ?? this.fingerprint,
        canApprove: canApprove ?? this.canApprove,
        canReject: canReject ?? this.canReject,
        createdAt: createdAt ?? this.createdAt,
        updatedAt: updatedAt ?? this.updatedAt,
        failure: failure ?? this.failure);
  }

  Activity copyWithWrapped(
      {Wrapped<String>? id,
      Wrapped<String>? organizationId,
      Wrapped<enums.ActivityStatus>? status,
      Wrapped<enums.ActivityType>? type,
      Wrapped<Intent>? intent,
      Wrapped<Result>? result,
      Wrapped<List<Vote>>? votes,
      Wrapped<String>? fingerprint,
      Wrapped<bool>? canApprove,
      Wrapped<bool>? canReject,
      Wrapped<ExternalDataV1Timestamp>? createdAt,
      Wrapped<ExternalDataV1Timestamp>? updatedAt,
      Wrapped<Status?>? failure}) {
    return Activity(
        id: (id != null ? id.value : this.id),
        organizationId: (organizationId != null
            ? organizationId.value
            : this.organizationId),
        status: (status != null ? status.value : this.status),
        type: (type != null ? type.value : this.type),
        intent: (intent != null ? intent.value : this.intent),
        result: (result != null ? result.value : this.result),
        votes: (votes != null ? votes.value : this.votes),
        fingerprint:
            (fingerprint != null ? fingerprint.value : this.fingerprint),
        canApprove: (canApprove != null ? canApprove.value : this.canApprove),
        canReject: (canReject != null ? canReject.value : this.canReject),
        createdAt: (createdAt != null ? createdAt.value : this.createdAt),
        updatedAt: (updatedAt != null ? updatedAt.value : this.updatedAt),
        failure: (failure != null ? failure.value : this.failure));
  }
}

@JsonSerializable(explicitToJson: true)
class ActivityResponse {
  const ActivityResponse({
    required this.activity,
  });

  factory ActivityResponse.fromJson(Map<String, dynamic> json) =>
      _$ActivityResponseFromJson(json);

  static const toJsonFactory = _$ActivityResponseToJson;
  Map<String, dynamic> toJson() => _$ActivityResponseToJson(this);

  @JsonKey(name: 'activity')
  final Activity activity;
  static const fromJsonFactory = _$ActivityResponseFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ActivityResponse &&
            (identical(other.activity, activity) ||
                const DeepCollectionEquality()
                    .equals(other.activity, activity)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(activity) ^ runtimeType.hashCode;
}

extension $ActivityResponseExtension on ActivityResponse {
  ActivityResponse copyWith({Activity? activity}) {
    return ActivityResponse(activity: activity ?? this.activity);
  }

  ActivityResponse copyWithWrapped({Wrapped<Activity>? activity}) {
    return ActivityResponse(
        activity: (activity != null ? activity.value : this.activity));
  }
}

@JsonSerializable(explicitToJson: true)
class Any {
  const Any({
    this.type,
  });

  factory Any.fromJson(Map<String, dynamic> json) => _$AnyFromJson(json);

  static const toJsonFactory = _$AnyToJson;
  Map<String, dynamic> toJson() => _$AnyToJson(this);

  @JsonKey(name: '@type')
  final String? type;
  static const fromJsonFactory = _$AnyFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is Any &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(type) ^ runtimeType.hashCode;
}

extension $AnyExtension on Any {
  Any copyWith({String? type}) {
    return Any(type: type ?? this.type);
  }

  Any copyWithWrapped({Wrapped<String?>? type}) {
    return Any(type: (type != null ? type.value : this.type));
  }
}

@JsonSerializable(explicitToJson: true)
class ApiKey {
  const ApiKey({
    required this.credential,
    required this.apiKeyId,
    required this.apiKeyName,
    required this.createdAt,
    required this.updatedAt,
    this.expirationSeconds,
  });

  factory ApiKey.fromJson(Map<String, dynamic> json) => _$ApiKeyFromJson(json);

  static const toJsonFactory = _$ApiKeyToJson;
  Map<String, dynamic> toJson() => _$ApiKeyToJson(this);

  @JsonKey(name: 'credential')
  final ExternalDataV1Credential credential;
  @JsonKey(name: 'apiKeyId')
  final String apiKeyId;
  @JsonKey(name: 'apiKeyName')
  final String apiKeyName;
  @JsonKey(name: 'createdAt')
  final ExternalDataV1Timestamp createdAt;
  @JsonKey(name: 'updatedAt')
  final ExternalDataV1Timestamp updatedAt;
  @JsonKey(name: 'expirationSeconds')
  final String? expirationSeconds;
  static const fromJsonFactory = _$ApiKeyFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ApiKey &&
            (identical(other.credential, credential) ||
                const DeepCollectionEquality()
                    .equals(other.credential, credential)) &&
            (identical(other.apiKeyId, apiKeyId) ||
                const DeepCollectionEquality()
                    .equals(other.apiKeyId, apiKeyId)) &&
            (identical(other.apiKeyName, apiKeyName) ||
                const DeepCollectionEquality()
                    .equals(other.apiKeyName, apiKeyName)) &&
            (identical(other.createdAt, createdAt) ||
                const DeepCollectionEquality()
                    .equals(other.createdAt, createdAt)) &&
            (identical(other.updatedAt, updatedAt) ||
                const DeepCollectionEquality()
                    .equals(other.updatedAt, updatedAt)) &&
            (identical(other.expirationSeconds, expirationSeconds) ||
                const DeepCollectionEquality()
                    .equals(other.expirationSeconds, expirationSeconds)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(credential) ^
      const DeepCollectionEquality().hash(apiKeyId) ^
      const DeepCollectionEquality().hash(apiKeyName) ^
      const DeepCollectionEquality().hash(createdAt) ^
      const DeepCollectionEquality().hash(updatedAt) ^
      const DeepCollectionEquality().hash(expirationSeconds) ^
      runtimeType.hashCode;
}

extension $ApiKeyExtension on ApiKey {
  ApiKey copyWith(
      {ExternalDataV1Credential? credential,
      String? apiKeyId,
      String? apiKeyName,
      ExternalDataV1Timestamp? createdAt,
      ExternalDataV1Timestamp? updatedAt,
      String? expirationSeconds}) {
    return ApiKey(
        credential: credential ?? this.credential,
        apiKeyId: apiKeyId ?? this.apiKeyId,
        apiKeyName: apiKeyName ?? this.apiKeyName,
        createdAt: createdAt ?? this.createdAt,
        updatedAt: updatedAt ?? this.updatedAt,
        expirationSeconds: expirationSeconds ?? this.expirationSeconds);
  }

  ApiKey copyWithWrapped(
      {Wrapped<ExternalDataV1Credential>? credential,
      Wrapped<String>? apiKeyId,
      Wrapped<String>? apiKeyName,
      Wrapped<ExternalDataV1Timestamp>? createdAt,
      Wrapped<ExternalDataV1Timestamp>? updatedAt,
      Wrapped<String?>? expirationSeconds}) {
    return ApiKey(
        credential: (credential != null ? credential.value : this.credential),
        apiKeyId: (apiKeyId != null ? apiKeyId.value : this.apiKeyId),
        apiKeyName: (apiKeyName != null ? apiKeyName.value : this.apiKeyName),
        createdAt: (createdAt != null ? createdAt.value : this.createdAt),
        updatedAt: (updatedAt != null ? updatedAt.value : this.updatedAt),
        expirationSeconds: (expirationSeconds != null
            ? expirationSeconds.value
            : this.expirationSeconds));
  }
}

@JsonSerializable(explicitToJson: true)
class ApiKeyParams {
  const ApiKeyParams({
    required this.apiKeyName,
    required this.publicKey,
    this.expirationSeconds,
  });

  factory ApiKeyParams.fromJson(Map<String, dynamic> json) =>
      _$ApiKeyParamsFromJson(json);

  static const toJsonFactory = _$ApiKeyParamsToJson;
  Map<String, dynamic> toJson() => _$ApiKeyParamsToJson(this);

  @JsonKey(name: 'apiKeyName')
  final String apiKeyName;
  @JsonKey(name: 'publicKey')
  final String publicKey;
  @JsonKey(name: 'expirationSeconds')
  final String? expirationSeconds;
  static const fromJsonFactory = _$ApiKeyParamsFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ApiKeyParams &&
            (identical(other.apiKeyName, apiKeyName) ||
                const DeepCollectionEquality()
                    .equals(other.apiKeyName, apiKeyName)) &&
            (identical(other.publicKey, publicKey) ||
                const DeepCollectionEquality()
                    .equals(other.publicKey, publicKey)) &&
            (identical(other.expirationSeconds, expirationSeconds) ||
                const DeepCollectionEquality()
                    .equals(other.expirationSeconds, expirationSeconds)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(apiKeyName) ^
      const DeepCollectionEquality().hash(publicKey) ^
      const DeepCollectionEquality().hash(expirationSeconds) ^
      runtimeType.hashCode;
}

extension $ApiKeyParamsExtension on ApiKeyParams {
  ApiKeyParams copyWith(
      {String? apiKeyName, String? publicKey, String? expirationSeconds}) {
    return ApiKeyParams(
        apiKeyName: apiKeyName ?? this.apiKeyName,
        publicKey: publicKey ?? this.publicKey,
        expirationSeconds: expirationSeconds ?? this.expirationSeconds);
  }

  ApiKeyParams copyWithWrapped(
      {Wrapped<String>? apiKeyName,
      Wrapped<String>? publicKey,
      Wrapped<String?>? expirationSeconds}) {
    return ApiKeyParams(
        apiKeyName: (apiKeyName != null ? apiKeyName.value : this.apiKeyName),
        publicKey: (publicKey != null ? publicKey.value : this.publicKey),
        expirationSeconds: (expirationSeconds != null
            ? expirationSeconds.value
            : this.expirationSeconds));
  }
}

@JsonSerializable(explicitToJson: true)
class ApiKeyParamsV2 {
  const ApiKeyParamsV2({
    required this.apiKeyName,
    required this.publicKey,
    required this.curveType,
    this.expirationSeconds,
  });

  factory ApiKeyParamsV2.fromJson(Map<String, dynamic> json) =>
      _$ApiKeyParamsV2FromJson(json);

  static const toJsonFactory = _$ApiKeyParamsV2ToJson;
  Map<String, dynamic> toJson() => _$ApiKeyParamsV2ToJson(this);

  @JsonKey(name: 'apiKeyName')
  final String apiKeyName;
  @JsonKey(name: 'publicKey')
  final String publicKey;
  @JsonKey(
    name: 'curveType',
    toJson: apiKeyCurveToJson,
    fromJson: apiKeyCurveFromJson,
  )
  final enums.ApiKeyCurve curveType;
  @JsonKey(name: 'expirationSeconds')
  final String? expirationSeconds;
  static const fromJsonFactory = _$ApiKeyParamsV2FromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ApiKeyParamsV2 &&
            (identical(other.apiKeyName, apiKeyName) ||
                const DeepCollectionEquality()
                    .equals(other.apiKeyName, apiKeyName)) &&
            (identical(other.publicKey, publicKey) ||
                const DeepCollectionEquality()
                    .equals(other.publicKey, publicKey)) &&
            (identical(other.curveType, curveType) ||
                const DeepCollectionEquality()
                    .equals(other.curveType, curveType)) &&
            (identical(other.expirationSeconds, expirationSeconds) ||
                const DeepCollectionEquality()
                    .equals(other.expirationSeconds, expirationSeconds)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(apiKeyName) ^
      const DeepCollectionEquality().hash(publicKey) ^
      const DeepCollectionEquality().hash(curveType) ^
      const DeepCollectionEquality().hash(expirationSeconds) ^
      runtimeType.hashCode;
}

extension $ApiKeyParamsV2Extension on ApiKeyParamsV2 {
  ApiKeyParamsV2 copyWith(
      {String? apiKeyName,
      String? publicKey,
      enums.ApiKeyCurve? curveType,
      String? expirationSeconds}) {
    return ApiKeyParamsV2(
        apiKeyName: apiKeyName ?? this.apiKeyName,
        publicKey: publicKey ?? this.publicKey,
        curveType: curveType ?? this.curveType,
        expirationSeconds: expirationSeconds ?? this.expirationSeconds);
  }

  ApiKeyParamsV2 copyWithWrapped(
      {Wrapped<String>? apiKeyName,
      Wrapped<String>? publicKey,
      Wrapped<enums.ApiKeyCurve>? curveType,
      Wrapped<String?>? expirationSeconds}) {
    return ApiKeyParamsV2(
        apiKeyName: (apiKeyName != null ? apiKeyName.value : this.apiKeyName),
        publicKey: (publicKey != null ? publicKey.value : this.publicKey),
        curveType: (curveType != null ? curveType.value : this.curveType),
        expirationSeconds: (expirationSeconds != null
            ? expirationSeconds.value
            : this.expirationSeconds));
  }
}

@JsonSerializable(explicitToJson: true)
class ApiOnlyUserParams {
  const ApiOnlyUserParams({
    required this.userName,
    this.userEmail,
    required this.userTags,
    required this.apiKeys,
  });

  factory ApiOnlyUserParams.fromJson(Map<String, dynamic> json) =>
      _$ApiOnlyUserParamsFromJson(json);

  static const toJsonFactory = _$ApiOnlyUserParamsToJson;
  Map<String, dynamic> toJson() => _$ApiOnlyUserParamsToJson(this);

  @JsonKey(name: 'userName')
  final String userName;
  @JsonKey(name: 'userEmail')
  final String? userEmail;
  @JsonKey(name: 'userTags', defaultValue: <String>[])
  final List<String> userTags;
  @JsonKey(name: 'apiKeys', defaultValue: <ApiKeyParams>[])
  final List<ApiKeyParams> apiKeys;
  static const fromJsonFactory = _$ApiOnlyUserParamsFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ApiOnlyUserParams &&
            (identical(other.userName, userName) ||
                const DeepCollectionEquality()
                    .equals(other.userName, userName)) &&
            (identical(other.userEmail, userEmail) ||
                const DeepCollectionEquality()
                    .equals(other.userEmail, userEmail)) &&
            (identical(other.userTags, userTags) ||
                const DeepCollectionEquality()
                    .equals(other.userTags, userTags)) &&
            (identical(other.apiKeys, apiKeys) ||
                const DeepCollectionEquality().equals(other.apiKeys, apiKeys)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(userName) ^
      const DeepCollectionEquality().hash(userEmail) ^
      const DeepCollectionEquality().hash(userTags) ^
      const DeepCollectionEquality().hash(apiKeys) ^
      runtimeType.hashCode;
}

extension $ApiOnlyUserParamsExtension on ApiOnlyUserParams {
  ApiOnlyUserParams copyWith(
      {String? userName,
      String? userEmail,
      List<String>? userTags,
      List<ApiKeyParams>? apiKeys}) {
    return ApiOnlyUserParams(
        userName: userName ?? this.userName,
        userEmail: userEmail ?? this.userEmail,
        userTags: userTags ?? this.userTags,
        apiKeys: apiKeys ?? this.apiKeys);
  }

  ApiOnlyUserParams copyWithWrapped(
      {Wrapped<String>? userName,
      Wrapped<String?>? userEmail,
      Wrapped<List<String>>? userTags,
      Wrapped<List<ApiKeyParams>>? apiKeys}) {
    return ApiOnlyUserParams(
        userName: (userName != null ? userName.value : this.userName),
        userEmail: (userEmail != null ? userEmail.value : this.userEmail),
        userTags: (userTags != null ? userTags.value : this.userTags),
        apiKeys: (apiKeys != null ? apiKeys.value : this.apiKeys));
  }
}

@JsonSerializable(explicitToJson: true)
class ApproveActivityIntent {
  const ApproveActivityIntent({
    required this.fingerprint,
  });

  factory ApproveActivityIntent.fromJson(Map<String, dynamic> json) =>
      _$ApproveActivityIntentFromJson(json);

  static const toJsonFactory = _$ApproveActivityIntentToJson;
  Map<String, dynamic> toJson() => _$ApproveActivityIntentToJson(this);

  @JsonKey(name: 'fingerprint')
  final String fingerprint;
  static const fromJsonFactory = _$ApproveActivityIntentFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ApproveActivityIntent &&
            (identical(other.fingerprint, fingerprint) ||
                const DeepCollectionEquality()
                    .equals(other.fingerprint, fingerprint)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(fingerprint) ^ runtimeType.hashCode;
}

extension $ApproveActivityIntentExtension on ApproveActivityIntent {
  ApproveActivityIntent copyWith({String? fingerprint}) {
    return ApproveActivityIntent(fingerprint: fingerprint ?? this.fingerprint);
  }

  ApproveActivityIntent copyWithWrapped({Wrapped<String>? fingerprint}) {
    return ApproveActivityIntent(
        fingerprint:
            (fingerprint != null ? fingerprint.value : this.fingerprint));
  }
}

@JsonSerializable(explicitToJson: true)
class ApproveActivityRequest {
  const ApproveActivityRequest({
    required this.type,
    required this.timestampMs,
    required this.organizationId,
    required this.parameters,
  });

  factory ApproveActivityRequest.fromJson(Map<String, dynamic> json) =>
      _$ApproveActivityRequestFromJson(json);

  static const toJsonFactory = _$ApproveActivityRequestToJson;
  Map<String, dynamic> toJson() => _$ApproveActivityRequestToJson(this);

  @JsonKey(
    name: 'type',
    toJson: approveActivityRequestTypeToJson,
    fromJson: approveActivityRequestTypeFromJson,
  )
  final enums.ApproveActivityRequestType type;
  @JsonKey(name: 'timestampMs')
  final String timestampMs;
  @JsonKey(name: 'organizationId')
  final String organizationId;
  @JsonKey(name: 'parameters')
  final ApproveActivityIntent parameters;
  static const fromJsonFactory = _$ApproveActivityRequestFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ApproveActivityRequest &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.timestampMs, timestampMs) ||
                const DeepCollectionEquality()
                    .equals(other.timestampMs, timestampMs)) &&
            (identical(other.organizationId, organizationId) ||
                const DeepCollectionEquality()
                    .equals(other.organizationId, organizationId)) &&
            (identical(other.parameters, parameters) ||
                const DeepCollectionEquality()
                    .equals(other.parameters, parameters)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(timestampMs) ^
      const DeepCollectionEquality().hash(organizationId) ^
      const DeepCollectionEquality().hash(parameters) ^
      runtimeType.hashCode;
}

extension $ApproveActivityRequestExtension on ApproveActivityRequest {
  ApproveActivityRequest copyWith(
      {enums.ApproveActivityRequestType? type,
      String? timestampMs,
      String? organizationId,
      ApproveActivityIntent? parameters}) {
    return ApproveActivityRequest(
        type: type ?? this.type,
        timestampMs: timestampMs ?? this.timestampMs,
        organizationId: organizationId ?? this.organizationId,
        parameters: parameters ?? this.parameters);
  }

  ApproveActivityRequest copyWithWrapped(
      {Wrapped<enums.ApproveActivityRequestType>? type,
      Wrapped<String>? timestampMs,
      Wrapped<String>? organizationId,
      Wrapped<ApproveActivityIntent>? parameters}) {
    return ApproveActivityRequest(
        type: (type != null ? type.value : this.type),
        timestampMs:
            (timestampMs != null ? timestampMs.value : this.timestampMs),
        organizationId: (organizationId != null
            ? organizationId.value
            : this.organizationId),
        parameters: (parameters != null ? parameters.value : this.parameters));
  }
}

@JsonSerializable(explicitToJson: true)
class Attestation {
  const Attestation({
    required this.credentialId,
    required this.clientDataJson,
    required this.attestationObject,
    required this.transports,
  });

  factory Attestation.fromJson(Map<String, dynamic> json) =>
      _$AttestationFromJson(json);

  static const toJsonFactory = _$AttestationToJson;
  Map<String, dynamic> toJson() => _$AttestationToJson(this);

  @JsonKey(name: 'credentialId')
  final String credentialId;
  @JsonKey(name: 'clientDataJson')
  final String clientDataJson;
  @JsonKey(name: 'attestationObject')
  final String attestationObject;
  @JsonKey(
    name: 'transports',
    toJson: authenticatorTransportListToJson,
    fromJson: authenticatorTransportListFromJson,
  )
  final List<enums.AuthenticatorTransport> transports;
  static const fromJsonFactory = _$AttestationFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is Attestation &&
            (identical(other.credentialId, credentialId) ||
                const DeepCollectionEquality()
                    .equals(other.credentialId, credentialId)) &&
            (identical(other.clientDataJson, clientDataJson) ||
                const DeepCollectionEquality()
                    .equals(other.clientDataJson, clientDataJson)) &&
            (identical(other.attestationObject, attestationObject) ||
                const DeepCollectionEquality()
                    .equals(other.attestationObject, attestationObject)) &&
            (identical(other.transports, transports) ||
                const DeepCollectionEquality()
                    .equals(other.transports, transports)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(credentialId) ^
      const DeepCollectionEquality().hash(clientDataJson) ^
      const DeepCollectionEquality().hash(attestationObject) ^
      const DeepCollectionEquality().hash(transports) ^
      runtimeType.hashCode;
}

extension $AttestationExtension on Attestation {
  Attestation copyWith(
      {String? credentialId,
      String? clientDataJson,
      String? attestationObject,
      List<enums.AuthenticatorTransport>? transports}) {
    return Attestation(
        credentialId: credentialId ?? this.credentialId,
        clientDataJson: clientDataJson ?? this.clientDataJson,
        attestationObject: attestationObject ?? this.attestationObject,
        transports: transports ?? this.transports);
  }

  Attestation copyWithWrapped(
      {Wrapped<String>? credentialId,
      Wrapped<String>? clientDataJson,
      Wrapped<String>? attestationObject,
      Wrapped<List<enums.AuthenticatorTransport>>? transports}) {
    return Attestation(
        credentialId:
            (credentialId != null ? credentialId.value : this.credentialId),
        clientDataJson: (clientDataJson != null
            ? clientDataJson.value
            : this.clientDataJson),
        attestationObject: (attestationObject != null
            ? attestationObject.value
            : this.attestationObject),
        transports: (transports != null ? transports.value : this.transports));
  }
}

@JsonSerializable(explicitToJson: true)
class Authenticator {
  const Authenticator({
    required this.transports,
    required this.attestationType,
    required this.aaguid,
    required this.credentialId,
    required this.model,
    required this.credential,
    required this.authenticatorId,
    required this.authenticatorName,
    required this.createdAt,
    required this.updatedAt,
  });

  factory Authenticator.fromJson(Map<String, dynamic> json) =>
      _$AuthenticatorFromJson(json);

  static const toJsonFactory = _$AuthenticatorToJson;
  Map<String, dynamic> toJson() => _$AuthenticatorToJson(this);

  @JsonKey(
    name: 'transports',
    toJson: authenticatorTransportListToJson,
    fromJson: authenticatorTransportListFromJson,
  )
  final List<enums.AuthenticatorTransport> transports;
  @JsonKey(name: 'attestationType')
  final String attestationType;
  @JsonKey(name: 'aaguid')
  final String aaguid;
  @JsonKey(name: 'credentialId')
  final String credentialId;
  @JsonKey(name: 'model')
  final String model;
  @JsonKey(name: 'credential')
  final ExternalDataV1Credential credential;
  @JsonKey(name: 'authenticatorId')
  final String authenticatorId;
  @JsonKey(name: 'authenticatorName')
  final String authenticatorName;
  @JsonKey(name: 'createdAt')
  final ExternalDataV1Timestamp createdAt;
  @JsonKey(name: 'updatedAt')
  final ExternalDataV1Timestamp updatedAt;
  static const fromJsonFactory = _$AuthenticatorFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is Authenticator &&
            (identical(other.transports, transports) ||
                const DeepCollectionEquality()
                    .equals(other.transports, transports)) &&
            (identical(other.attestationType, attestationType) ||
                const DeepCollectionEquality()
                    .equals(other.attestationType, attestationType)) &&
            (identical(other.aaguid, aaguid) ||
                const DeepCollectionEquality().equals(other.aaguid, aaguid)) &&
            (identical(other.credentialId, credentialId) ||
                const DeepCollectionEquality()
                    .equals(other.credentialId, credentialId)) &&
            (identical(other.model, model) ||
                const DeepCollectionEquality().equals(other.model, model)) &&
            (identical(other.credential, credential) ||
                const DeepCollectionEquality()
                    .equals(other.credential, credential)) &&
            (identical(other.authenticatorId, authenticatorId) ||
                const DeepCollectionEquality()
                    .equals(other.authenticatorId, authenticatorId)) &&
            (identical(other.authenticatorName, authenticatorName) ||
                const DeepCollectionEquality()
                    .equals(other.authenticatorName, authenticatorName)) &&
            (identical(other.createdAt, createdAt) ||
                const DeepCollectionEquality()
                    .equals(other.createdAt, createdAt)) &&
            (identical(other.updatedAt, updatedAt) ||
                const DeepCollectionEquality()
                    .equals(other.updatedAt, updatedAt)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(transports) ^
      const DeepCollectionEquality().hash(attestationType) ^
      const DeepCollectionEquality().hash(aaguid) ^
      const DeepCollectionEquality().hash(credentialId) ^
      const DeepCollectionEquality().hash(model) ^
      const DeepCollectionEquality().hash(credential) ^
      const DeepCollectionEquality().hash(authenticatorId) ^
      const DeepCollectionEquality().hash(authenticatorName) ^
      const DeepCollectionEquality().hash(createdAt) ^
      const DeepCollectionEquality().hash(updatedAt) ^
      runtimeType.hashCode;
}

extension $AuthenticatorExtension on Authenticator {
  Authenticator copyWith(
      {List<enums.AuthenticatorTransport>? transports,
      String? attestationType,
      String? aaguid,
      String? credentialId,
      String? model,
      ExternalDataV1Credential? credential,
      String? authenticatorId,
      String? authenticatorName,
      ExternalDataV1Timestamp? createdAt,
      ExternalDataV1Timestamp? updatedAt}) {
    return Authenticator(
        transports: transports ?? this.transports,
        attestationType: attestationType ?? this.attestationType,
        aaguid: aaguid ?? this.aaguid,
        credentialId: credentialId ?? this.credentialId,
        model: model ?? this.model,
        credential: credential ?? this.credential,
        authenticatorId: authenticatorId ?? this.authenticatorId,
        authenticatorName: authenticatorName ?? this.authenticatorName,
        createdAt: createdAt ?? this.createdAt,
        updatedAt: updatedAt ?? this.updatedAt);
  }

  Authenticator copyWithWrapped(
      {Wrapped<List<enums.AuthenticatorTransport>>? transports,
      Wrapped<String>? attestationType,
      Wrapped<String>? aaguid,
      Wrapped<String>? credentialId,
      Wrapped<String>? model,
      Wrapped<ExternalDataV1Credential>? credential,
      Wrapped<String>? authenticatorId,
      Wrapped<String>? authenticatorName,
      Wrapped<ExternalDataV1Timestamp>? createdAt,
      Wrapped<ExternalDataV1Timestamp>? updatedAt}) {
    return Authenticator(
        transports: (transports != null ? transports.value : this.transports),
        attestationType: (attestationType != null
            ? attestationType.value
            : this.attestationType),
        aaguid: (aaguid != null ? aaguid.value : this.aaguid),
        credentialId:
            (credentialId != null ? credentialId.value : this.credentialId),
        model: (model != null ? model.value : this.model),
        credential: (credential != null ? credential.value : this.credential),
        authenticatorId: (authenticatorId != null
            ? authenticatorId.value
            : this.authenticatorId),
        authenticatorName: (authenticatorName != null
            ? authenticatorName.value
            : this.authenticatorName),
        createdAt: (createdAt != null ? createdAt.value : this.createdAt),
        updatedAt: (updatedAt != null ? updatedAt.value : this.updatedAt));
  }
}

@JsonSerializable(explicitToJson: true)
class AuthenticatorAttestationResponse {
  const AuthenticatorAttestationResponse({
    required this.clientDataJson,
    required this.attestationObject,
    this.transports,
    this.authenticatorAttachment,
  });

  factory AuthenticatorAttestationResponse.fromJson(
          Map<String, dynamic> json) =>
      _$AuthenticatorAttestationResponseFromJson(json);

  static const toJsonFactory = _$AuthenticatorAttestationResponseToJson;
  Map<String, dynamic> toJson() =>
      _$AuthenticatorAttestationResponseToJson(this);

  @JsonKey(name: 'clientDataJson')
  final String clientDataJson;
  @JsonKey(name: 'attestationObject')
  final String attestationObject;
  @JsonKey(
    name: 'transports',
    toJson: authenticatorTransportListToJson,
    fromJson: authenticatorTransportListFromJson,
  )
  final List<enums.AuthenticatorTransport>? transports;
  @JsonKey(
    name: 'authenticatorAttachment',
    toJson:
        authenticatorAttestationResponseAuthenticatorAttachmentNullableToJson,
    fromJson:
        authenticatorAttestationResponseAuthenticatorAttachmentNullableFromJson,
  )
  final enums.AuthenticatorAttestationResponseAuthenticatorAttachment?
      authenticatorAttachment;
  static const fromJsonFactory = _$AuthenticatorAttestationResponseFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is AuthenticatorAttestationResponse &&
            (identical(other.clientDataJson, clientDataJson) ||
                const DeepCollectionEquality()
                    .equals(other.clientDataJson, clientDataJson)) &&
            (identical(other.attestationObject, attestationObject) ||
                const DeepCollectionEquality()
                    .equals(other.attestationObject, attestationObject)) &&
            (identical(other.transports, transports) ||
                const DeepCollectionEquality()
                    .equals(other.transports, transports)) &&
            (identical(
                    other.authenticatorAttachment, authenticatorAttachment) ||
                const DeepCollectionEquality().equals(
                    other.authenticatorAttachment, authenticatorAttachment)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientDataJson) ^
      const DeepCollectionEquality().hash(attestationObject) ^
      const DeepCollectionEquality().hash(transports) ^
      const DeepCollectionEquality().hash(authenticatorAttachment) ^
      runtimeType.hashCode;
}

extension $AuthenticatorAttestationResponseExtension
    on AuthenticatorAttestationResponse {
  AuthenticatorAttestationResponse copyWith(
      {String? clientDataJson,
      String? attestationObject,
      List<enums.AuthenticatorTransport>? transports,
      enums.AuthenticatorAttestationResponseAuthenticatorAttachment?
          authenticatorAttachment}) {
    return AuthenticatorAttestationResponse(
        clientDataJson: clientDataJson ?? this.clientDataJson,
        attestationObject: attestationObject ?? this.attestationObject,
        transports: transports ?? this.transports,
        authenticatorAttachment:
            authenticatorAttachment ?? this.authenticatorAttachment);
  }

  AuthenticatorAttestationResponse copyWithWrapped(
      {Wrapped<String>? clientDataJson,
      Wrapped<String>? attestationObject,
      Wrapped<List<enums.AuthenticatorTransport>?>? transports,
      Wrapped<enums.AuthenticatorAttestationResponseAuthenticatorAttachment?>?
          authenticatorAttachment}) {
    return AuthenticatorAttestationResponse(
        clientDataJson: (clientDataJson != null
            ? clientDataJson.value
            : this.clientDataJson),
        attestationObject: (attestationObject != null
            ? attestationObject.value
            : this.attestationObject),
        transports: (transports != null ? transports.value : this.transports),
        authenticatorAttachment: (authenticatorAttachment != null
            ? authenticatorAttachment.value
            : this.authenticatorAttachment));
  }
}

@JsonSerializable(explicitToJson: true)
class AuthenticatorParams {
  const AuthenticatorParams({
    required this.authenticatorName,
    required this.userId,
    required this.attestation,
    required this.challenge,
  });

  factory AuthenticatorParams.fromJson(Map<String, dynamic> json) =>
      _$AuthenticatorParamsFromJson(json);

  static const toJsonFactory = _$AuthenticatorParamsToJson;
  Map<String, dynamic> toJson() => _$AuthenticatorParamsToJson(this);

  @JsonKey(name: 'authenticatorName')
  final String authenticatorName;
  @JsonKey(name: 'userId')
  final String userId;
  @JsonKey(name: 'attestation')
  final PublicKeyCredentialWithAttestation attestation;
  @JsonKey(name: 'challenge')
  final String challenge;
  static const fromJsonFactory = _$AuthenticatorParamsFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is AuthenticatorParams &&
            (identical(other.authenticatorName, authenticatorName) ||
                const DeepCollectionEquality()
                    .equals(other.authenticatorName, authenticatorName)) &&
            (identical(other.userId, userId) ||
                const DeepCollectionEquality().equals(other.userId, userId)) &&
            (identical(other.attestation, attestation) ||
                const DeepCollectionEquality()
                    .equals(other.attestation, attestation)) &&
            (identical(other.challenge, challenge) ||
                const DeepCollectionEquality()
                    .equals(other.challenge, challenge)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(authenticatorName) ^
      const DeepCollectionEquality().hash(userId) ^
      const DeepCollectionEquality().hash(attestation) ^
      const DeepCollectionEquality().hash(challenge) ^
      runtimeType.hashCode;
}

extension $AuthenticatorParamsExtension on AuthenticatorParams {
  AuthenticatorParams copyWith(
      {String? authenticatorName,
      String? userId,
      PublicKeyCredentialWithAttestation? attestation,
      String? challenge}) {
    return AuthenticatorParams(
        authenticatorName: authenticatorName ?? this.authenticatorName,
        userId: userId ?? this.userId,
        attestation: attestation ?? this.attestation,
        challenge: challenge ?? this.challenge);
  }

  AuthenticatorParams copyWithWrapped(
      {Wrapped<String>? authenticatorName,
      Wrapped<String>? userId,
      Wrapped<PublicKeyCredentialWithAttestation>? attestation,
      Wrapped<String>? challenge}) {
    return AuthenticatorParams(
        authenticatorName: (authenticatorName != null
            ? authenticatorName.value
            : this.authenticatorName),
        userId: (userId != null ? userId.value : this.userId),
        attestation:
            (attestation != null ? attestation.value : this.attestation),
        challenge: (challenge != null ? challenge.value : this.challenge));
  }
}

@JsonSerializable(explicitToJson: true)
class AuthenticatorParamsV2 {
  const AuthenticatorParamsV2({
    required this.authenticatorName,
    required this.challenge,
    required this.attestation,
  });

  factory AuthenticatorParamsV2.fromJson(Map<String, dynamic> json) =>
      _$AuthenticatorParamsV2FromJson(json);

  static const toJsonFactory = _$AuthenticatorParamsV2ToJson;
  Map<String, dynamic> toJson() => _$AuthenticatorParamsV2ToJson(this);

  @JsonKey(name: 'authenticatorName')
  final String authenticatorName;
  @JsonKey(name: 'challenge')
  final String challenge;
  @JsonKey(name: 'attestation')
  final Attestation attestation;
  static const fromJsonFactory = _$AuthenticatorParamsV2FromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is AuthenticatorParamsV2 &&
            (identical(other.authenticatorName, authenticatorName) ||
                const DeepCollectionEquality()
                    .equals(other.authenticatorName, authenticatorName)) &&
            (identical(other.challenge, challenge) ||
                const DeepCollectionEquality()
                    .equals(other.challenge, challenge)) &&
            (identical(other.attestation, attestation) ||
                const DeepCollectionEquality()
                    .equals(other.attestation, attestation)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(authenticatorName) ^
      const DeepCollectionEquality().hash(challenge) ^
      const DeepCollectionEquality().hash(attestation) ^
      runtimeType.hashCode;
}

extension $AuthenticatorParamsV2Extension on AuthenticatorParamsV2 {
  AuthenticatorParamsV2 copyWith(
      {String? authenticatorName,
      String? challenge,
      Attestation? attestation}) {
    return AuthenticatorParamsV2(
        authenticatorName: authenticatorName ?? this.authenticatorName,
        challenge: challenge ?? this.challenge,
        attestation: attestation ?? this.attestation);
  }

  AuthenticatorParamsV2 copyWithWrapped(
      {Wrapped<String>? authenticatorName,
      Wrapped<String>? challenge,
      Wrapped<Attestation>? attestation}) {
    return AuthenticatorParamsV2(
        authenticatorName: (authenticatorName != null
            ? authenticatorName.value
            : this.authenticatorName),
        challenge: (challenge != null ? challenge.value : this.challenge),
        attestation:
            (attestation != null ? attestation.value : this.attestation));
  }
}

@JsonSerializable(explicitToJson: true)
class Config {
  const Config({
    this.features,
    this.quorum,
  });

  factory Config.fromJson(Map<String, dynamic> json) => _$ConfigFromJson(json);

  static const toJsonFactory = _$ConfigToJson;
  Map<String, dynamic> toJson() => _$ConfigToJson(this);

  @JsonKey(name: 'features', defaultValue: <Feature>[])
  final List<Feature>? features;
  @JsonKey(name: 'quorum')
  final ExternalDataV1Quorum? quorum;
  static const fromJsonFactory = _$ConfigFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is Config &&
            (identical(other.features, features) ||
                const DeepCollectionEquality()
                    .equals(other.features, features)) &&
            (identical(other.quorum, quorum) ||
                const DeepCollectionEquality().equals(other.quorum, quorum)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(features) ^
      const DeepCollectionEquality().hash(quorum) ^
      runtimeType.hashCode;
}

extension $ConfigExtension on Config {
  Config copyWith({List<Feature>? features, ExternalDataV1Quorum? quorum}) {
    return Config(
        features: features ?? this.features, quorum: quorum ?? this.quorum);
  }

  Config copyWithWrapped(
      {Wrapped<List<Feature>?>? features,
      Wrapped<ExternalDataV1Quorum?>? quorum}) {
    return Config(
        features: (features != null ? features.value : this.features),
        quorum: (quorum != null ? quorum.value : this.quorum));
  }
}

@JsonSerializable(explicitToJson: true)
class CreateApiKeysIntent {
  const CreateApiKeysIntent({
    required this.apiKeys,
    required this.userId,
  });

  factory CreateApiKeysIntent.fromJson(Map<String, dynamic> json) =>
      _$CreateApiKeysIntentFromJson(json);

  static const toJsonFactory = _$CreateApiKeysIntentToJson;
  Map<String, dynamic> toJson() => _$CreateApiKeysIntentToJson(this);

  @JsonKey(name: 'apiKeys', defaultValue: <ApiKeyParams>[])
  final List<ApiKeyParams> apiKeys;
  @JsonKey(name: 'userId')
  final String userId;
  static const fromJsonFactory = _$CreateApiKeysIntentFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is CreateApiKeysIntent &&
            (identical(other.apiKeys, apiKeys) ||
                const DeepCollectionEquality()
                    .equals(other.apiKeys, apiKeys)) &&
            (identical(other.userId, userId) ||
                const DeepCollectionEquality().equals(other.userId, userId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(apiKeys) ^
      const DeepCollectionEquality().hash(userId) ^
      runtimeType.hashCode;
}

extension $CreateApiKeysIntentExtension on CreateApiKeysIntent {
  CreateApiKeysIntent copyWith({List<ApiKeyParams>? apiKeys, String? userId}) {
    return CreateApiKeysIntent(
        apiKeys: apiKeys ?? this.apiKeys, userId: userId ?? this.userId);
  }

  CreateApiKeysIntent copyWithWrapped(
      {Wrapped<List<ApiKeyParams>>? apiKeys, Wrapped<String>? userId}) {
    return CreateApiKeysIntent(
        apiKeys: (apiKeys != null ? apiKeys.value : this.apiKeys),
        userId: (userId != null ? userId.value : this.userId));
  }
}

@JsonSerializable(explicitToJson: true)
class CreateApiKeysIntentV2 {
  const CreateApiKeysIntentV2({
    required this.apiKeys,
    required this.userId,
  });

  factory CreateApiKeysIntentV2.fromJson(Map<String, dynamic> json) =>
      _$CreateApiKeysIntentV2FromJson(json);

  static const toJsonFactory = _$CreateApiKeysIntentV2ToJson;
  Map<String, dynamic> toJson() => _$CreateApiKeysIntentV2ToJson(this);

  @JsonKey(name: 'apiKeys', defaultValue: <ApiKeyParamsV2>[])
  final List<ApiKeyParamsV2> apiKeys;
  @JsonKey(name: 'userId')
  final String userId;
  static const fromJsonFactory = _$CreateApiKeysIntentV2FromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is CreateApiKeysIntentV2 &&
            (identical(other.apiKeys, apiKeys) ||
                const DeepCollectionEquality()
                    .equals(other.apiKeys, apiKeys)) &&
            (identical(other.userId, userId) ||
                const DeepCollectionEquality().equals(other.userId, userId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(apiKeys) ^
      const DeepCollectionEquality().hash(userId) ^
      runtimeType.hashCode;
}

extension $CreateApiKeysIntentV2Extension on CreateApiKeysIntentV2 {
  CreateApiKeysIntentV2 copyWith(
      {List<ApiKeyParamsV2>? apiKeys, String? userId}) {
    return CreateApiKeysIntentV2(
        apiKeys: apiKeys ?? this.apiKeys, userId: userId ?? this.userId);
  }

  CreateApiKeysIntentV2 copyWithWrapped(
      {Wrapped<List<ApiKeyParamsV2>>? apiKeys, Wrapped<String>? userId}) {
    return CreateApiKeysIntentV2(
        apiKeys: (apiKeys != null ? apiKeys.value : this.apiKeys),
        userId: (userId != null ? userId.value : this.userId));
  }
}

@JsonSerializable(explicitToJson: true)
class CreateApiKeysRequest {
  const CreateApiKeysRequest({
    required this.type,
    required this.timestampMs,
    required this.organizationId,
    required this.parameters,
  });

  factory CreateApiKeysRequest.fromJson(Map<String, dynamic> json) =>
      _$CreateApiKeysRequestFromJson(json);

  static const toJsonFactory = _$CreateApiKeysRequestToJson;
  Map<String, dynamic> toJson() => _$CreateApiKeysRequestToJson(this);

  @JsonKey(
    name: 'type',
    toJson: createApiKeysRequestTypeToJson,
    fromJson: createApiKeysRequestTypeFromJson,
  )
  final enums.CreateApiKeysRequestType type;
  @JsonKey(name: 'timestampMs')
  final String timestampMs;
  @JsonKey(name: 'organizationId')
  final String organizationId;
  @JsonKey(name: 'parameters')
  final CreateApiKeysIntentV2 parameters;
  static const fromJsonFactory = _$CreateApiKeysRequestFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is CreateApiKeysRequest &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.timestampMs, timestampMs) ||
                const DeepCollectionEquality()
                    .equals(other.timestampMs, timestampMs)) &&
            (identical(other.organizationId, organizationId) ||
                const DeepCollectionEquality()
                    .equals(other.organizationId, organizationId)) &&
            (identical(other.parameters, parameters) ||
                const DeepCollectionEquality()
                    .equals(other.parameters, parameters)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(timestampMs) ^
      const DeepCollectionEquality().hash(organizationId) ^
      const DeepCollectionEquality().hash(parameters) ^
      runtimeType.hashCode;
}

extension $CreateApiKeysRequestExtension on CreateApiKeysRequest {
  CreateApiKeysRequest copyWith(
      {enums.CreateApiKeysRequestType? type,
      String? timestampMs,
      String? organizationId,
      CreateApiKeysIntentV2? parameters}) {
    return CreateApiKeysRequest(
        type: type ?? this.type,
        timestampMs: timestampMs ?? this.timestampMs,
        organizationId: organizationId ?? this.organizationId,
        parameters: parameters ?? this.parameters);
  }

  CreateApiKeysRequest copyWithWrapped(
      {Wrapped<enums.CreateApiKeysRequestType>? type,
      Wrapped<String>? timestampMs,
      Wrapped<String>? organizationId,
      Wrapped<CreateApiKeysIntentV2>? parameters}) {
    return CreateApiKeysRequest(
        type: (type != null ? type.value : this.type),
        timestampMs:
            (timestampMs != null ? timestampMs.value : this.timestampMs),
        organizationId: (organizationId != null
            ? organizationId.value
            : this.organizationId),
        parameters: (parameters != null ? parameters.value : this.parameters));
  }
}

@JsonSerializable(explicitToJson: true)
class CreateApiKeysResult {
  const CreateApiKeysResult({
    required this.apiKeyIds,
  });

  factory CreateApiKeysResult.fromJson(Map<String, dynamic> json) =>
      _$CreateApiKeysResultFromJson(json);

  static const toJsonFactory = _$CreateApiKeysResultToJson;
  Map<String, dynamic> toJson() => _$CreateApiKeysResultToJson(this);

  @JsonKey(name: 'apiKeyIds', defaultValue: <String>[])
  final List<String> apiKeyIds;
  static const fromJsonFactory = _$CreateApiKeysResultFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is CreateApiKeysResult &&
            (identical(other.apiKeyIds, apiKeyIds) ||
                const DeepCollectionEquality()
                    .equals(other.apiKeyIds, apiKeyIds)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(apiKeyIds) ^ runtimeType.hashCode;
}

extension $CreateApiKeysResultExtension on CreateApiKeysResult {
  CreateApiKeysResult copyWith({List<String>? apiKeyIds}) {
    return CreateApiKeysResult(apiKeyIds: apiKeyIds ?? this.apiKeyIds);
  }

  CreateApiKeysResult copyWithWrapped({Wrapped<List<String>>? apiKeyIds}) {
    return CreateApiKeysResult(
        apiKeyIds: (apiKeyIds != null ? apiKeyIds.value : this.apiKeyIds));
  }
}

@JsonSerializable(explicitToJson: true)
class CreateApiOnlyUsersIntent {
  const CreateApiOnlyUsersIntent({
    required this.apiOnlyUsers,
  });

  factory CreateApiOnlyUsersIntent.fromJson(Map<String, dynamic> json) =>
      _$CreateApiOnlyUsersIntentFromJson(json);

  static const toJsonFactory = _$CreateApiOnlyUsersIntentToJson;
  Map<String, dynamic> toJson() => _$CreateApiOnlyUsersIntentToJson(this);

  @JsonKey(name: 'apiOnlyUsers', defaultValue: <ApiOnlyUserParams>[])
  final List<ApiOnlyUserParams> apiOnlyUsers;
  static const fromJsonFactory = _$CreateApiOnlyUsersIntentFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is CreateApiOnlyUsersIntent &&
            (identical(other.apiOnlyUsers, apiOnlyUsers) ||
                const DeepCollectionEquality()
                    .equals(other.apiOnlyUsers, apiOnlyUsers)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(apiOnlyUsers) ^ runtimeType.hashCode;
}

extension $CreateApiOnlyUsersIntentExtension on CreateApiOnlyUsersIntent {
  CreateApiOnlyUsersIntent copyWith({List<ApiOnlyUserParams>? apiOnlyUsers}) {
    return CreateApiOnlyUsersIntent(
        apiOnlyUsers: apiOnlyUsers ?? this.apiOnlyUsers);
  }

  CreateApiOnlyUsersIntent copyWithWrapped(
      {Wrapped<List<ApiOnlyUserParams>>? apiOnlyUsers}) {
    return CreateApiOnlyUsersIntent(
        apiOnlyUsers:
            (apiOnlyUsers != null ? apiOnlyUsers.value : this.apiOnlyUsers));
  }
}

@JsonSerializable(explicitToJson: true)
class CreateApiOnlyUsersResult {
  const CreateApiOnlyUsersResult({
    required this.userIds,
  });

  factory CreateApiOnlyUsersResult.fromJson(Map<String, dynamic> json) =>
      _$CreateApiOnlyUsersResultFromJson(json);

  static const toJsonFactory = _$CreateApiOnlyUsersResultToJson;
  Map<String, dynamic> toJson() => _$CreateApiOnlyUsersResultToJson(this);

  @JsonKey(name: 'userIds', defaultValue: <String>[])
  final List<String> userIds;
  static const fromJsonFactory = _$CreateApiOnlyUsersResultFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is CreateApiOnlyUsersResult &&
            (identical(other.userIds, userIds) ||
                const DeepCollectionEquality().equals(other.userIds, userIds)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(userIds) ^ runtimeType.hashCode;
}

extension $CreateApiOnlyUsersResultExtension on CreateApiOnlyUsersResult {
  CreateApiOnlyUsersResult copyWith({List<String>? userIds}) {
    return CreateApiOnlyUsersResult(userIds: userIds ?? this.userIds);
  }

  CreateApiOnlyUsersResult copyWithWrapped({Wrapped<List<String>>? userIds}) {
    return CreateApiOnlyUsersResult(
        userIds: (userIds != null ? userIds.value : this.userIds));
  }
}

@JsonSerializable(explicitToJson: true)
class CreateAuthenticatorsIntent {
  const CreateAuthenticatorsIntent({
    required this.authenticators,
    required this.userId,
  });

  factory CreateAuthenticatorsIntent.fromJson(Map<String, dynamic> json) =>
      _$CreateAuthenticatorsIntentFromJson(json);

  static const toJsonFactory = _$CreateAuthenticatorsIntentToJson;
  Map<String, dynamic> toJson() => _$CreateAuthenticatorsIntentToJson(this);

  @JsonKey(name: 'authenticators', defaultValue: <AuthenticatorParams>[])
  final List<AuthenticatorParams> authenticators;
  @JsonKey(name: 'userId')
  final String userId;
  static const fromJsonFactory = _$CreateAuthenticatorsIntentFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is CreateAuthenticatorsIntent &&
            (identical(other.authenticators, authenticators) ||
                const DeepCollectionEquality()
                    .equals(other.authenticators, authenticators)) &&
            (identical(other.userId, userId) ||
                const DeepCollectionEquality().equals(other.userId, userId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(authenticators) ^
      const DeepCollectionEquality().hash(userId) ^
      runtimeType.hashCode;
}

extension $CreateAuthenticatorsIntentExtension on CreateAuthenticatorsIntent {
  CreateAuthenticatorsIntent copyWith(
      {List<AuthenticatorParams>? authenticators, String? userId}) {
    return CreateAuthenticatorsIntent(
        authenticators: authenticators ?? this.authenticators,
        userId: userId ?? this.userId);
  }

  CreateAuthenticatorsIntent copyWithWrapped(
      {Wrapped<List<AuthenticatorParams>>? authenticators,
      Wrapped<String>? userId}) {
    return CreateAuthenticatorsIntent(
        authenticators: (authenticators != null
            ? authenticators.value
            : this.authenticators),
        userId: (userId != null ? userId.value : this.userId));
  }
}

@JsonSerializable(explicitToJson: true)
class CreateAuthenticatorsIntentV2 {
  const CreateAuthenticatorsIntentV2({
    required this.authenticators,
    required this.userId,
  });

  factory CreateAuthenticatorsIntentV2.fromJson(Map<String, dynamic> json) =>
      _$CreateAuthenticatorsIntentV2FromJson(json);

  static const toJsonFactory = _$CreateAuthenticatorsIntentV2ToJson;
  Map<String, dynamic> toJson() => _$CreateAuthenticatorsIntentV2ToJson(this);

  @JsonKey(name: 'authenticators', defaultValue: <AuthenticatorParamsV2>[])
  final List<AuthenticatorParamsV2> authenticators;
  @JsonKey(name: 'userId')
  final String userId;
  static const fromJsonFactory = _$CreateAuthenticatorsIntentV2FromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is CreateAuthenticatorsIntentV2 &&
            (identical(other.authenticators, authenticators) ||
                const DeepCollectionEquality()
                    .equals(other.authenticators, authenticators)) &&
            (identical(other.userId, userId) ||
                const DeepCollectionEquality().equals(other.userId, userId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(authenticators) ^
      const DeepCollectionEquality().hash(userId) ^
      runtimeType.hashCode;
}

extension $CreateAuthenticatorsIntentV2Extension
    on CreateAuthenticatorsIntentV2 {
  CreateAuthenticatorsIntentV2 copyWith(
      {List<AuthenticatorParamsV2>? authenticators, String? userId}) {
    return CreateAuthenticatorsIntentV2(
        authenticators: authenticators ?? this.authenticators,
        userId: userId ?? this.userId);
  }

  CreateAuthenticatorsIntentV2 copyWithWrapped(
      {Wrapped<List<AuthenticatorParamsV2>>? authenticators,
      Wrapped<String>? userId}) {
    return CreateAuthenticatorsIntentV2(
        authenticators: (authenticators != null
            ? authenticators.value
            : this.authenticators),
        userId: (userId != null ? userId.value : this.userId));
  }
}

@JsonSerializable(explicitToJson: true)
class CreateAuthenticatorsRequest {
  const CreateAuthenticatorsRequest({
    required this.type,
    required this.timestampMs,
    required this.organizationId,
    required this.parameters,
  });

  factory CreateAuthenticatorsRequest.fromJson(Map<String, dynamic> json) =>
      _$CreateAuthenticatorsRequestFromJson(json);

  static const toJsonFactory = _$CreateAuthenticatorsRequestToJson;
  Map<String, dynamic> toJson() => _$CreateAuthenticatorsRequestToJson(this);

  @JsonKey(
    name: 'type',
    toJson: createAuthenticatorsRequestTypeToJson,
    fromJson: createAuthenticatorsRequestTypeFromJson,
  )
  final enums.CreateAuthenticatorsRequestType type;
  @JsonKey(name: 'timestampMs')
  final String timestampMs;
  @JsonKey(name: 'organizationId')
  final String organizationId;
  @JsonKey(name: 'parameters')
  final CreateAuthenticatorsIntentV2 parameters;
  static const fromJsonFactory = _$CreateAuthenticatorsRequestFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is CreateAuthenticatorsRequest &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.timestampMs, timestampMs) ||
                const DeepCollectionEquality()
                    .equals(other.timestampMs, timestampMs)) &&
            (identical(other.organizationId, organizationId) ||
                const DeepCollectionEquality()
                    .equals(other.organizationId, organizationId)) &&
            (identical(other.parameters, parameters) ||
                const DeepCollectionEquality()
                    .equals(other.parameters, parameters)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(timestampMs) ^
      const DeepCollectionEquality().hash(organizationId) ^
      const DeepCollectionEquality().hash(parameters) ^
      runtimeType.hashCode;
}

extension $CreateAuthenticatorsRequestExtension on CreateAuthenticatorsRequest {
  CreateAuthenticatorsRequest copyWith(
      {enums.CreateAuthenticatorsRequestType? type,
      String? timestampMs,
      String? organizationId,
      CreateAuthenticatorsIntentV2? parameters}) {
    return CreateAuthenticatorsRequest(
        type: type ?? this.type,
        timestampMs: timestampMs ?? this.timestampMs,
        organizationId: organizationId ?? this.organizationId,
        parameters: parameters ?? this.parameters);
  }

  CreateAuthenticatorsRequest copyWithWrapped(
      {Wrapped<enums.CreateAuthenticatorsRequestType>? type,
      Wrapped<String>? timestampMs,
      Wrapped<String>? organizationId,
      Wrapped<CreateAuthenticatorsIntentV2>? parameters}) {
    return CreateAuthenticatorsRequest(
        type: (type != null ? type.value : this.type),
        timestampMs:
            (timestampMs != null ? timestampMs.value : this.timestampMs),
        organizationId: (organizationId != null
            ? organizationId.value
            : this.organizationId),
        parameters: (parameters != null ? parameters.value : this.parameters));
  }
}

@JsonSerializable(explicitToJson: true)
class CreateAuthenticatorsResult {
  const CreateAuthenticatorsResult({
    required this.authenticatorIds,
  });

  factory CreateAuthenticatorsResult.fromJson(Map<String, dynamic> json) =>
      _$CreateAuthenticatorsResultFromJson(json);

  static const toJsonFactory = _$CreateAuthenticatorsResultToJson;
  Map<String, dynamic> toJson() => _$CreateAuthenticatorsResultToJson(this);

  @JsonKey(name: 'authenticatorIds', defaultValue: <String>[])
  final List<String> authenticatorIds;
  static const fromJsonFactory = _$CreateAuthenticatorsResultFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is CreateAuthenticatorsResult &&
            (identical(other.authenticatorIds, authenticatorIds) ||
                const DeepCollectionEquality()
                    .equals(other.authenticatorIds, authenticatorIds)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(authenticatorIds) ^
      runtimeType.hashCode;
}

extension $CreateAuthenticatorsResultExtension on CreateAuthenticatorsResult {
  CreateAuthenticatorsResult copyWith({List<String>? authenticatorIds}) {
    return CreateAuthenticatorsResult(
        authenticatorIds: authenticatorIds ?? this.authenticatorIds);
  }

  CreateAuthenticatorsResult copyWithWrapped(
      {Wrapped<List<String>>? authenticatorIds}) {
    return CreateAuthenticatorsResult(
        authenticatorIds: (authenticatorIds != null
            ? authenticatorIds.value
            : this.authenticatorIds));
  }
}

@JsonSerializable(explicitToJson: true)
class CreateInvitationsIntent {
  const CreateInvitationsIntent({
    required this.invitations,
  });

  factory CreateInvitationsIntent.fromJson(Map<String, dynamic> json) =>
      _$CreateInvitationsIntentFromJson(json);

  static const toJsonFactory = _$CreateInvitationsIntentToJson;
  Map<String, dynamic> toJson() => _$CreateInvitationsIntentToJson(this);

  @JsonKey(name: 'invitations', defaultValue: <InvitationParams>[])
  final List<InvitationParams> invitations;
  static const fromJsonFactory = _$CreateInvitationsIntentFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is CreateInvitationsIntent &&
            (identical(other.invitations, invitations) ||
                const DeepCollectionEquality()
                    .equals(other.invitations, invitations)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(invitations) ^ runtimeType.hashCode;
}

extension $CreateInvitationsIntentExtension on CreateInvitationsIntent {
  CreateInvitationsIntent copyWith({List<InvitationParams>? invitations}) {
    return CreateInvitationsIntent(
        invitations: invitations ?? this.invitations);
  }

  CreateInvitationsIntent copyWithWrapped(
      {Wrapped<List<InvitationParams>>? invitations}) {
    return CreateInvitationsIntent(
        invitations:
            (invitations != null ? invitations.value : this.invitations));
  }
}

@JsonSerializable(explicitToJson: true)
class CreateInvitationsRequest {
  const CreateInvitationsRequest({
    required this.type,
    required this.timestampMs,
    required this.organizationId,
    required this.parameters,
  });

  factory CreateInvitationsRequest.fromJson(Map<String, dynamic> json) =>
      _$CreateInvitationsRequestFromJson(json);

  static const toJsonFactory = _$CreateInvitationsRequestToJson;
  Map<String, dynamic> toJson() => _$CreateInvitationsRequestToJson(this);

  @JsonKey(
    name: 'type',
    toJson: createInvitationsRequestTypeToJson,
    fromJson: createInvitationsRequestTypeFromJson,
  )
  final enums.CreateInvitationsRequestType type;
  @JsonKey(name: 'timestampMs')
  final String timestampMs;
  @JsonKey(name: 'organizationId')
  final String organizationId;
  @JsonKey(name: 'parameters')
  final CreateInvitationsIntent parameters;
  static const fromJsonFactory = _$CreateInvitationsRequestFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is CreateInvitationsRequest &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.timestampMs, timestampMs) ||
                const DeepCollectionEquality()
                    .equals(other.timestampMs, timestampMs)) &&
            (identical(other.organizationId, organizationId) ||
                const DeepCollectionEquality()
                    .equals(other.organizationId, organizationId)) &&
            (identical(other.parameters, parameters) ||
                const DeepCollectionEquality()
                    .equals(other.parameters, parameters)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(timestampMs) ^
      const DeepCollectionEquality().hash(organizationId) ^
      const DeepCollectionEquality().hash(parameters) ^
      runtimeType.hashCode;
}

extension $CreateInvitationsRequestExtension on CreateInvitationsRequest {
  CreateInvitationsRequest copyWith(
      {enums.CreateInvitationsRequestType? type,
      String? timestampMs,
      String? organizationId,
      CreateInvitationsIntent? parameters}) {
    return CreateInvitationsRequest(
        type: type ?? this.type,
        timestampMs: timestampMs ?? this.timestampMs,
        organizationId: organizationId ?? this.organizationId,
        parameters: parameters ?? this.parameters);
  }

  CreateInvitationsRequest copyWithWrapped(
      {Wrapped<enums.CreateInvitationsRequestType>? type,
      Wrapped<String>? timestampMs,
      Wrapped<String>? organizationId,
      Wrapped<CreateInvitationsIntent>? parameters}) {
    return CreateInvitationsRequest(
        type: (type != null ? type.value : this.type),
        timestampMs:
            (timestampMs != null ? timestampMs.value : this.timestampMs),
        organizationId: (organizationId != null
            ? organizationId.value
            : this.organizationId),
        parameters: (parameters != null ? parameters.value : this.parameters));
  }
}

@JsonSerializable(explicitToJson: true)
class CreateInvitationsResult {
  const CreateInvitationsResult({
    required this.invitationIds,
  });

  factory CreateInvitationsResult.fromJson(Map<String, dynamic> json) =>
      _$CreateInvitationsResultFromJson(json);

  static const toJsonFactory = _$CreateInvitationsResultToJson;
  Map<String, dynamic> toJson() => _$CreateInvitationsResultToJson(this);

  @JsonKey(name: 'invitationIds', defaultValue: <String>[])
  final List<String> invitationIds;
  static const fromJsonFactory = _$CreateInvitationsResultFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is CreateInvitationsResult &&
            (identical(other.invitationIds, invitationIds) ||
                const DeepCollectionEquality()
                    .equals(other.invitationIds, invitationIds)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(invitationIds) ^ runtimeType.hashCode;
}

extension $CreateInvitationsResultExtension on CreateInvitationsResult {
  CreateInvitationsResult copyWith({List<String>? invitationIds}) {
    return CreateInvitationsResult(
        invitationIds: invitationIds ?? this.invitationIds);
  }

  CreateInvitationsResult copyWithWrapped(
      {Wrapped<List<String>>? invitationIds}) {
    return CreateInvitationsResult(
        invitationIds:
            (invitationIds != null ? invitationIds.value : this.invitationIds));
  }
}

@JsonSerializable(explicitToJson: true)
class CreateOauthProvidersIntent {
  const CreateOauthProvidersIntent({
    required this.userId,
    required this.oauthProviders,
  });

  factory CreateOauthProvidersIntent.fromJson(Map<String, dynamic> json) =>
      _$CreateOauthProvidersIntentFromJson(json);

  static const toJsonFactory = _$CreateOauthProvidersIntentToJson;
  Map<String, dynamic> toJson() => _$CreateOauthProvidersIntentToJson(this);

  @JsonKey(name: 'userId')
  final String userId;
  @JsonKey(name: 'oauthProviders', defaultValue: <OauthProviderParams>[])
  final List<OauthProviderParams> oauthProviders;
  static const fromJsonFactory = _$CreateOauthProvidersIntentFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is CreateOauthProvidersIntent &&
            (identical(other.userId, userId) ||
                const DeepCollectionEquality().equals(other.userId, userId)) &&
            (identical(other.oauthProviders, oauthProviders) ||
                const DeepCollectionEquality()
                    .equals(other.oauthProviders, oauthProviders)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(userId) ^
      const DeepCollectionEquality().hash(oauthProviders) ^
      runtimeType.hashCode;
}

extension $CreateOauthProvidersIntentExtension on CreateOauthProvidersIntent {
  CreateOauthProvidersIntent copyWith(
      {String? userId, List<OauthProviderParams>? oauthProviders}) {
    return CreateOauthProvidersIntent(
        userId: userId ?? this.userId,
        oauthProviders: oauthProviders ?? this.oauthProviders);
  }

  CreateOauthProvidersIntent copyWithWrapped(
      {Wrapped<String>? userId,
      Wrapped<List<OauthProviderParams>>? oauthProviders}) {
    return CreateOauthProvidersIntent(
        userId: (userId != null ? userId.value : this.userId),
        oauthProviders: (oauthProviders != null
            ? oauthProviders.value
            : this.oauthProviders));
  }
}

@JsonSerializable(explicitToJson: true)
class CreateOauthProvidersRequest {
  const CreateOauthProvidersRequest({
    required this.type,
    required this.timestampMs,
    required this.organizationId,
    required this.parameters,
  });

  factory CreateOauthProvidersRequest.fromJson(Map<String, dynamic> json) =>
      _$CreateOauthProvidersRequestFromJson(json);

  static const toJsonFactory = _$CreateOauthProvidersRequestToJson;
  Map<String, dynamic> toJson() => _$CreateOauthProvidersRequestToJson(this);

  @JsonKey(
    name: 'type',
    toJson: createOauthProvidersRequestTypeToJson,
    fromJson: createOauthProvidersRequestTypeFromJson,
  )
  final enums.CreateOauthProvidersRequestType type;
  @JsonKey(name: 'timestampMs')
  final String timestampMs;
  @JsonKey(name: 'organizationId')
  final String organizationId;
  @JsonKey(name: 'parameters')
  final CreateOauthProvidersIntent parameters;
  static const fromJsonFactory = _$CreateOauthProvidersRequestFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is CreateOauthProvidersRequest &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.timestampMs, timestampMs) ||
                const DeepCollectionEquality()
                    .equals(other.timestampMs, timestampMs)) &&
            (identical(other.organizationId, organizationId) ||
                const DeepCollectionEquality()
                    .equals(other.organizationId, organizationId)) &&
            (identical(other.parameters, parameters) ||
                const DeepCollectionEquality()
                    .equals(other.parameters, parameters)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(timestampMs) ^
      const DeepCollectionEquality().hash(organizationId) ^
      const DeepCollectionEquality().hash(parameters) ^
      runtimeType.hashCode;
}

extension $CreateOauthProvidersRequestExtension on CreateOauthProvidersRequest {
  CreateOauthProvidersRequest copyWith(
      {enums.CreateOauthProvidersRequestType? type,
      String? timestampMs,
      String? organizationId,
      CreateOauthProvidersIntent? parameters}) {
    return CreateOauthProvidersRequest(
        type: type ?? this.type,
        timestampMs: timestampMs ?? this.timestampMs,
        organizationId: organizationId ?? this.organizationId,
        parameters: parameters ?? this.parameters);
  }

  CreateOauthProvidersRequest copyWithWrapped(
      {Wrapped<enums.CreateOauthProvidersRequestType>? type,
      Wrapped<String>? timestampMs,
      Wrapped<String>? organizationId,
      Wrapped<CreateOauthProvidersIntent>? parameters}) {
    return CreateOauthProvidersRequest(
        type: (type != null ? type.value : this.type),
        timestampMs:
            (timestampMs != null ? timestampMs.value : this.timestampMs),
        organizationId: (organizationId != null
            ? organizationId.value
            : this.organizationId),
        parameters: (parameters != null ? parameters.value : this.parameters));
  }
}

@JsonSerializable(explicitToJson: true)
class CreateOauthProvidersResult {
  const CreateOauthProvidersResult({
    required this.providerIds,
  });

  factory CreateOauthProvidersResult.fromJson(Map<String, dynamic> json) =>
      _$CreateOauthProvidersResultFromJson(json);

  static const toJsonFactory = _$CreateOauthProvidersResultToJson;
  Map<String, dynamic> toJson() => _$CreateOauthProvidersResultToJson(this);

  @JsonKey(name: 'providerIds', defaultValue: <String>[])
  final List<String> providerIds;
  static const fromJsonFactory = _$CreateOauthProvidersResultFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is CreateOauthProvidersResult &&
            (identical(other.providerIds, providerIds) ||
                const DeepCollectionEquality()
                    .equals(other.providerIds, providerIds)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(providerIds) ^ runtimeType.hashCode;
}

extension $CreateOauthProvidersResultExtension on CreateOauthProvidersResult {
  CreateOauthProvidersResult copyWith({List<String>? providerIds}) {
    return CreateOauthProvidersResult(
        providerIds: providerIds ?? this.providerIds);
  }

  CreateOauthProvidersResult copyWithWrapped(
      {Wrapped<List<String>>? providerIds}) {
    return CreateOauthProvidersResult(
        providerIds:
            (providerIds != null ? providerIds.value : this.providerIds));
  }
}

@JsonSerializable(explicitToJson: true)
class CreateOrganizationIntent {
  const CreateOrganizationIntent({
    required this.organizationName,
    required this.rootEmail,
    required this.rootAuthenticator,
    this.rootUserId,
  });

  factory CreateOrganizationIntent.fromJson(Map<String, dynamic> json) =>
      _$CreateOrganizationIntentFromJson(json);

  static const toJsonFactory = _$CreateOrganizationIntentToJson;
  Map<String, dynamic> toJson() => _$CreateOrganizationIntentToJson(this);

  @JsonKey(name: 'organizationName')
  final String organizationName;
  @JsonKey(name: 'rootEmail')
  final String rootEmail;
  @JsonKey(name: 'rootAuthenticator')
  final AuthenticatorParams rootAuthenticator;
  @JsonKey(name: 'rootUserId')
  final String? rootUserId;
  static const fromJsonFactory = _$CreateOrganizationIntentFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is CreateOrganizationIntent &&
            (identical(other.organizationName, organizationName) ||
                const DeepCollectionEquality()
                    .equals(other.organizationName, organizationName)) &&
            (identical(other.rootEmail, rootEmail) ||
                const DeepCollectionEquality()
                    .equals(other.rootEmail, rootEmail)) &&
            (identical(other.rootAuthenticator, rootAuthenticator) ||
                const DeepCollectionEquality()
                    .equals(other.rootAuthenticator, rootAuthenticator)) &&
            (identical(other.rootUserId, rootUserId) ||
                const DeepCollectionEquality()
                    .equals(other.rootUserId, rootUserId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(organizationName) ^
      const DeepCollectionEquality().hash(rootEmail) ^
      const DeepCollectionEquality().hash(rootAuthenticator) ^
      const DeepCollectionEquality().hash(rootUserId) ^
      runtimeType.hashCode;
}

extension $CreateOrganizationIntentExtension on CreateOrganizationIntent {
  CreateOrganizationIntent copyWith(
      {String? organizationName,
      String? rootEmail,
      AuthenticatorParams? rootAuthenticator,
      String? rootUserId}) {
    return CreateOrganizationIntent(
        organizationName: organizationName ?? this.organizationName,
        rootEmail: rootEmail ?? this.rootEmail,
        rootAuthenticator: rootAuthenticator ?? this.rootAuthenticator,
        rootUserId: rootUserId ?? this.rootUserId);
  }

  CreateOrganizationIntent copyWithWrapped(
      {Wrapped<String>? organizationName,
      Wrapped<String>? rootEmail,
      Wrapped<AuthenticatorParams>? rootAuthenticator,
      Wrapped<String?>? rootUserId}) {
    return CreateOrganizationIntent(
        organizationName: (organizationName != null
            ? organizationName.value
            : this.organizationName),
        rootEmail: (rootEmail != null ? rootEmail.value : this.rootEmail),
        rootAuthenticator: (rootAuthenticator != null
            ? rootAuthenticator.value
            : this.rootAuthenticator),
        rootUserId: (rootUserId != null ? rootUserId.value : this.rootUserId));
  }
}

@JsonSerializable(explicitToJson: true)
class CreateOrganizationIntentV2 {
  const CreateOrganizationIntentV2({
    required this.organizationName,
    required this.rootEmail,
    required this.rootAuthenticator,
    this.rootUserId,
  });

  factory CreateOrganizationIntentV2.fromJson(Map<String, dynamic> json) =>
      _$CreateOrganizationIntentV2FromJson(json);

  static const toJsonFactory = _$CreateOrganizationIntentV2ToJson;
  Map<String, dynamic> toJson() => _$CreateOrganizationIntentV2ToJson(this);

  @JsonKey(name: 'organizationName')
  final String organizationName;
  @JsonKey(name: 'rootEmail')
  final String rootEmail;
  @JsonKey(name: 'rootAuthenticator')
  final AuthenticatorParamsV2 rootAuthenticator;
  @JsonKey(name: 'rootUserId')
  final String? rootUserId;
  static const fromJsonFactory = _$CreateOrganizationIntentV2FromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is CreateOrganizationIntentV2 &&
            (identical(other.organizationName, organizationName) ||
                const DeepCollectionEquality()
                    .equals(other.organizationName, organizationName)) &&
            (identical(other.rootEmail, rootEmail) ||
                const DeepCollectionEquality()
                    .equals(other.rootEmail, rootEmail)) &&
            (identical(other.rootAuthenticator, rootAuthenticator) ||
                const DeepCollectionEquality()
                    .equals(other.rootAuthenticator, rootAuthenticator)) &&
            (identical(other.rootUserId, rootUserId) ||
                const DeepCollectionEquality()
                    .equals(other.rootUserId, rootUserId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(organizationName) ^
      const DeepCollectionEquality().hash(rootEmail) ^
      const DeepCollectionEquality().hash(rootAuthenticator) ^
      const DeepCollectionEquality().hash(rootUserId) ^
      runtimeType.hashCode;
}

extension $CreateOrganizationIntentV2Extension on CreateOrganizationIntentV2 {
  CreateOrganizationIntentV2 copyWith(
      {String? organizationName,
      String? rootEmail,
      AuthenticatorParamsV2? rootAuthenticator,
      String? rootUserId}) {
    return CreateOrganizationIntentV2(
        organizationName: organizationName ?? this.organizationName,
        rootEmail: rootEmail ?? this.rootEmail,
        rootAuthenticator: rootAuthenticator ?? this.rootAuthenticator,
        rootUserId: rootUserId ?? this.rootUserId);
  }

  CreateOrganizationIntentV2 copyWithWrapped(
      {Wrapped<String>? organizationName,
      Wrapped<String>? rootEmail,
      Wrapped<AuthenticatorParamsV2>? rootAuthenticator,
      Wrapped<String?>? rootUserId}) {
    return CreateOrganizationIntentV2(
        organizationName: (organizationName != null
            ? organizationName.value
            : this.organizationName),
        rootEmail: (rootEmail != null ? rootEmail.value : this.rootEmail),
        rootAuthenticator: (rootAuthenticator != null
            ? rootAuthenticator.value
            : this.rootAuthenticator),
        rootUserId: (rootUserId != null ? rootUserId.value : this.rootUserId));
  }
}

@JsonSerializable(explicitToJson: true)
class CreateOrganizationResult {
  const CreateOrganizationResult({
    required this.organizationId,
  });

  factory CreateOrganizationResult.fromJson(Map<String, dynamic> json) =>
      _$CreateOrganizationResultFromJson(json);

  static const toJsonFactory = _$CreateOrganizationResultToJson;
  Map<String, dynamic> toJson() => _$CreateOrganizationResultToJson(this);

  @JsonKey(name: 'organizationId')
  final String organizationId;
  static const fromJsonFactory = _$CreateOrganizationResultFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is CreateOrganizationResult &&
            (identical(other.organizationId, organizationId) ||
                const DeepCollectionEquality()
                    .equals(other.organizationId, organizationId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(organizationId) ^
      runtimeType.hashCode;
}

extension $CreateOrganizationResultExtension on CreateOrganizationResult {
  CreateOrganizationResult copyWith({String? organizationId}) {
    return CreateOrganizationResult(
        organizationId: organizationId ?? this.organizationId);
  }

  CreateOrganizationResult copyWithWrapped({Wrapped<String>? organizationId}) {
    return CreateOrganizationResult(
        organizationId: (organizationId != null
            ? organizationId.value
            : this.organizationId));
  }
}

@JsonSerializable(explicitToJson: true)
class CreatePoliciesIntent {
  const CreatePoliciesIntent({
    required this.policies,
  });

  factory CreatePoliciesIntent.fromJson(Map<String, dynamic> json) =>
      _$CreatePoliciesIntentFromJson(json);

  static const toJsonFactory = _$CreatePoliciesIntentToJson;
  Map<String, dynamic> toJson() => _$CreatePoliciesIntentToJson(this);

  @JsonKey(name: 'policies', defaultValue: <CreatePolicyIntentV3>[])
  final List<CreatePolicyIntentV3> policies;
  static const fromJsonFactory = _$CreatePoliciesIntentFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is CreatePoliciesIntent &&
            (identical(other.policies, policies) ||
                const DeepCollectionEquality()
                    .equals(other.policies, policies)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(policies) ^ runtimeType.hashCode;
}

extension $CreatePoliciesIntentExtension on CreatePoliciesIntent {
  CreatePoliciesIntent copyWith({List<CreatePolicyIntentV3>? policies}) {
    return CreatePoliciesIntent(policies: policies ?? this.policies);
  }

  CreatePoliciesIntent copyWithWrapped(
      {Wrapped<List<CreatePolicyIntentV3>>? policies}) {
    return CreatePoliciesIntent(
        policies: (policies != null ? policies.value : this.policies));
  }
}

@JsonSerializable(explicitToJson: true)
class CreatePoliciesRequest {
  const CreatePoliciesRequest({
    required this.type,
    required this.timestampMs,
    required this.organizationId,
    required this.parameters,
  });

  factory CreatePoliciesRequest.fromJson(Map<String, dynamic> json) =>
      _$CreatePoliciesRequestFromJson(json);

  static const toJsonFactory = _$CreatePoliciesRequestToJson;
  Map<String, dynamic> toJson() => _$CreatePoliciesRequestToJson(this);

  @JsonKey(
    name: 'type',
    toJson: createPoliciesRequestTypeToJson,
    fromJson: createPoliciesRequestTypeFromJson,
  )
  final enums.CreatePoliciesRequestType type;
  @JsonKey(name: 'timestampMs')
  final String timestampMs;
  @JsonKey(name: 'organizationId')
  final String organizationId;
  @JsonKey(name: 'parameters')
  final CreatePoliciesIntent parameters;
  static const fromJsonFactory = _$CreatePoliciesRequestFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is CreatePoliciesRequest &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.timestampMs, timestampMs) ||
                const DeepCollectionEquality()
                    .equals(other.timestampMs, timestampMs)) &&
            (identical(other.organizationId, organizationId) ||
                const DeepCollectionEquality()
                    .equals(other.organizationId, organizationId)) &&
            (identical(other.parameters, parameters) ||
                const DeepCollectionEquality()
                    .equals(other.parameters, parameters)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(timestampMs) ^
      const DeepCollectionEquality().hash(organizationId) ^
      const DeepCollectionEquality().hash(parameters) ^
      runtimeType.hashCode;
}

extension $CreatePoliciesRequestExtension on CreatePoliciesRequest {
  CreatePoliciesRequest copyWith(
      {enums.CreatePoliciesRequestType? type,
      String? timestampMs,
      String? organizationId,
      CreatePoliciesIntent? parameters}) {
    return CreatePoliciesRequest(
        type: type ?? this.type,
        timestampMs: timestampMs ?? this.timestampMs,
        organizationId: organizationId ?? this.organizationId,
        parameters: parameters ?? this.parameters);
  }

  CreatePoliciesRequest copyWithWrapped(
      {Wrapped<enums.CreatePoliciesRequestType>? type,
      Wrapped<String>? timestampMs,
      Wrapped<String>? organizationId,
      Wrapped<CreatePoliciesIntent>? parameters}) {
    return CreatePoliciesRequest(
        type: (type != null ? type.value : this.type),
        timestampMs:
            (timestampMs != null ? timestampMs.value : this.timestampMs),
        organizationId: (organizationId != null
            ? organizationId.value
            : this.organizationId),
        parameters: (parameters != null ? parameters.value : this.parameters));
  }
}

@JsonSerializable(explicitToJson: true)
class CreatePoliciesResult {
  const CreatePoliciesResult({
    required this.policyIds,
  });

  factory CreatePoliciesResult.fromJson(Map<String, dynamic> json) =>
      _$CreatePoliciesResultFromJson(json);

  static const toJsonFactory = _$CreatePoliciesResultToJson;
  Map<String, dynamic> toJson() => _$CreatePoliciesResultToJson(this);

  @JsonKey(name: 'policyIds', defaultValue: <String>[])
  final List<String> policyIds;
  static const fromJsonFactory = _$CreatePoliciesResultFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is CreatePoliciesResult &&
            (identical(other.policyIds, policyIds) ||
                const DeepCollectionEquality()
                    .equals(other.policyIds, policyIds)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(policyIds) ^ runtimeType.hashCode;
}

extension $CreatePoliciesResultExtension on CreatePoliciesResult {
  CreatePoliciesResult copyWith({List<String>? policyIds}) {
    return CreatePoliciesResult(policyIds: policyIds ?? this.policyIds);
  }

  CreatePoliciesResult copyWithWrapped({Wrapped<List<String>>? policyIds}) {
    return CreatePoliciesResult(
        policyIds: (policyIds != null ? policyIds.value : this.policyIds));
  }
}

@JsonSerializable(explicitToJson: true)
class CreatePolicyIntent {
  const CreatePolicyIntent({
    required this.policyName,
    required this.selectors,
    required this.effect,
    this.notes,
  });

  factory CreatePolicyIntent.fromJson(Map<String, dynamic> json) =>
      _$CreatePolicyIntentFromJson(json);

  static const toJsonFactory = _$CreatePolicyIntentToJson;
  Map<String, dynamic> toJson() => _$CreatePolicyIntentToJson(this);

  @JsonKey(name: 'policyName')
  final String policyName;
  @JsonKey(name: 'selectors', defaultValue: <Selector>[])
  final List<Selector> selectors;
  @JsonKey(
    name: 'effect',
    toJson: effectToJson,
    fromJson: effectFromJson,
  )
  final enums.Effect effect;
  @JsonKey(name: 'notes')
  final String? notes;
  static const fromJsonFactory = _$CreatePolicyIntentFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is CreatePolicyIntent &&
            (identical(other.policyName, policyName) ||
                const DeepCollectionEquality()
                    .equals(other.policyName, policyName)) &&
            (identical(other.selectors, selectors) ||
                const DeepCollectionEquality()
                    .equals(other.selectors, selectors)) &&
            (identical(other.effect, effect) ||
                const DeepCollectionEquality().equals(other.effect, effect)) &&
            (identical(other.notes, notes) ||
                const DeepCollectionEquality().equals(other.notes, notes)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(policyName) ^
      const DeepCollectionEquality().hash(selectors) ^
      const DeepCollectionEquality().hash(effect) ^
      const DeepCollectionEquality().hash(notes) ^
      runtimeType.hashCode;
}

extension $CreatePolicyIntentExtension on CreatePolicyIntent {
  CreatePolicyIntent copyWith(
      {String? policyName,
      List<Selector>? selectors,
      enums.Effect? effect,
      String? notes}) {
    return CreatePolicyIntent(
        policyName: policyName ?? this.policyName,
        selectors: selectors ?? this.selectors,
        effect: effect ?? this.effect,
        notes: notes ?? this.notes);
  }

  CreatePolicyIntent copyWithWrapped(
      {Wrapped<String>? policyName,
      Wrapped<List<Selector>>? selectors,
      Wrapped<enums.Effect>? effect,
      Wrapped<String?>? notes}) {
    return CreatePolicyIntent(
        policyName: (policyName != null ? policyName.value : this.policyName),
        selectors: (selectors != null ? selectors.value : this.selectors),
        effect: (effect != null ? effect.value : this.effect),
        notes: (notes != null ? notes.value : this.notes));
  }
}

@JsonSerializable(explicitToJson: true)
class CreatePolicyIntentV2 {
  const CreatePolicyIntentV2({
    required this.policyName,
    required this.selectors,
    required this.effect,
    this.notes,
  });

  factory CreatePolicyIntentV2.fromJson(Map<String, dynamic> json) =>
      _$CreatePolicyIntentV2FromJson(json);

  static const toJsonFactory = _$CreatePolicyIntentV2ToJson;
  Map<String, dynamic> toJson() => _$CreatePolicyIntentV2ToJson(this);

  @JsonKey(name: 'policyName')
  final String policyName;
  @JsonKey(name: 'selectors', defaultValue: <SelectorV2>[])
  final List<SelectorV2> selectors;
  @JsonKey(
    name: 'effect',
    toJson: effectToJson,
    fromJson: effectFromJson,
  )
  final enums.Effect effect;
  @JsonKey(name: 'notes')
  final String? notes;
  static const fromJsonFactory = _$CreatePolicyIntentV2FromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is CreatePolicyIntentV2 &&
            (identical(other.policyName, policyName) ||
                const DeepCollectionEquality()
                    .equals(other.policyName, policyName)) &&
            (identical(other.selectors, selectors) ||
                const DeepCollectionEquality()
                    .equals(other.selectors, selectors)) &&
            (identical(other.effect, effect) ||
                const DeepCollectionEquality().equals(other.effect, effect)) &&
            (identical(other.notes, notes) ||
                const DeepCollectionEquality().equals(other.notes, notes)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(policyName) ^
      const DeepCollectionEquality().hash(selectors) ^
      const DeepCollectionEquality().hash(effect) ^
      const DeepCollectionEquality().hash(notes) ^
      runtimeType.hashCode;
}

extension $CreatePolicyIntentV2Extension on CreatePolicyIntentV2 {
  CreatePolicyIntentV2 copyWith(
      {String? policyName,
      List<SelectorV2>? selectors,
      enums.Effect? effect,
      String? notes}) {
    return CreatePolicyIntentV2(
        policyName: policyName ?? this.policyName,
        selectors: selectors ?? this.selectors,
        effect: effect ?? this.effect,
        notes: notes ?? this.notes);
  }

  CreatePolicyIntentV2 copyWithWrapped(
      {Wrapped<String>? policyName,
      Wrapped<List<SelectorV2>>? selectors,
      Wrapped<enums.Effect>? effect,
      Wrapped<String?>? notes}) {
    return CreatePolicyIntentV2(
        policyName: (policyName != null ? policyName.value : this.policyName),
        selectors: (selectors != null ? selectors.value : this.selectors),
        effect: (effect != null ? effect.value : this.effect),
        notes: (notes != null ? notes.value : this.notes));
  }
}

@JsonSerializable(explicitToJson: true)
class CreatePolicyIntentV3 {
  const CreatePolicyIntentV3({
    required this.policyName,
    required this.effect,
    this.condition,
    this.consensus,
    this.notes,
  });

  factory CreatePolicyIntentV3.fromJson(Map<String, dynamic> json) =>
      _$CreatePolicyIntentV3FromJson(json);

  static const toJsonFactory = _$CreatePolicyIntentV3ToJson;
  Map<String, dynamic> toJson() => _$CreatePolicyIntentV3ToJson(this);

  @JsonKey(name: 'policyName')
  final String policyName;
  @JsonKey(
    name: 'effect',
    toJson: effectToJson,
    fromJson: effectFromJson,
  )
  final enums.Effect effect;
  @JsonKey(name: 'condition')
  final String? condition;
  @JsonKey(name: 'consensus')
  final String? consensus;
  @JsonKey(name: 'notes')
  final String? notes;
  static const fromJsonFactory = _$CreatePolicyIntentV3FromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is CreatePolicyIntentV3 &&
            (identical(other.policyName, policyName) ||
                const DeepCollectionEquality()
                    .equals(other.policyName, policyName)) &&
            (identical(other.effect, effect) ||
                const DeepCollectionEquality().equals(other.effect, effect)) &&
            (identical(other.condition, condition) ||
                const DeepCollectionEquality()
                    .equals(other.condition, condition)) &&
            (identical(other.consensus, consensus) ||
                const DeepCollectionEquality()
                    .equals(other.consensus, consensus)) &&
            (identical(other.notes, notes) ||
                const DeepCollectionEquality().equals(other.notes, notes)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(policyName) ^
      const DeepCollectionEquality().hash(effect) ^
      const DeepCollectionEquality().hash(condition) ^
      const DeepCollectionEquality().hash(consensus) ^
      const DeepCollectionEquality().hash(notes) ^
      runtimeType.hashCode;
}

extension $CreatePolicyIntentV3Extension on CreatePolicyIntentV3 {
  CreatePolicyIntentV3 copyWith(
      {String? policyName,
      enums.Effect? effect,
      String? condition,
      String? consensus,
      String? notes}) {
    return CreatePolicyIntentV3(
        policyName: policyName ?? this.policyName,
        effect: effect ?? this.effect,
        condition: condition ?? this.condition,
        consensus: consensus ?? this.consensus,
        notes: notes ?? this.notes);
  }

  CreatePolicyIntentV3 copyWithWrapped(
      {Wrapped<String>? policyName,
      Wrapped<enums.Effect>? effect,
      Wrapped<String?>? condition,
      Wrapped<String?>? consensus,
      Wrapped<String?>? notes}) {
    return CreatePolicyIntentV3(
        policyName: (policyName != null ? policyName.value : this.policyName),
        effect: (effect != null ? effect.value : this.effect),
        condition: (condition != null ? condition.value : this.condition),
        consensus: (consensus != null ? consensus.value : this.consensus),
        notes: (notes != null ? notes.value : this.notes));
  }
}

@JsonSerializable(explicitToJson: true)
class CreatePolicyRequest {
  const CreatePolicyRequest({
    required this.type,
    required this.timestampMs,
    required this.organizationId,
    required this.parameters,
  });

  factory CreatePolicyRequest.fromJson(Map<String, dynamic> json) =>
      _$CreatePolicyRequestFromJson(json);

  static const toJsonFactory = _$CreatePolicyRequestToJson;
  Map<String, dynamic> toJson() => _$CreatePolicyRequestToJson(this);

  @JsonKey(
    name: 'type',
    toJson: createPolicyRequestTypeToJson,
    fromJson: createPolicyRequestTypeFromJson,
  )
  final enums.CreatePolicyRequestType type;
  @JsonKey(name: 'timestampMs')
  final String timestampMs;
  @JsonKey(name: 'organizationId')
  final String organizationId;
  @JsonKey(name: 'parameters')
  final CreatePolicyIntentV3 parameters;
  static const fromJsonFactory = _$CreatePolicyRequestFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is CreatePolicyRequest &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.timestampMs, timestampMs) ||
                const DeepCollectionEquality()
                    .equals(other.timestampMs, timestampMs)) &&
            (identical(other.organizationId, organizationId) ||
                const DeepCollectionEquality()
                    .equals(other.organizationId, organizationId)) &&
            (identical(other.parameters, parameters) ||
                const DeepCollectionEquality()
                    .equals(other.parameters, parameters)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(timestampMs) ^
      const DeepCollectionEquality().hash(organizationId) ^
      const DeepCollectionEquality().hash(parameters) ^
      runtimeType.hashCode;
}

extension $CreatePolicyRequestExtension on CreatePolicyRequest {
  CreatePolicyRequest copyWith(
      {enums.CreatePolicyRequestType? type,
      String? timestampMs,
      String? organizationId,
      CreatePolicyIntentV3? parameters}) {
    return CreatePolicyRequest(
        type: type ?? this.type,
        timestampMs: timestampMs ?? this.timestampMs,
        organizationId: organizationId ?? this.organizationId,
        parameters: parameters ?? this.parameters);
  }

  CreatePolicyRequest copyWithWrapped(
      {Wrapped<enums.CreatePolicyRequestType>? type,
      Wrapped<String>? timestampMs,
      Wrapped<String>? organizationId,
      Wrapped<CreatePolicyIntentV3>? parameters}) {
    return CreatePolicyRequest(
        type: (type != null ? type.value : this.type),
        timestampMs:
            (timestampMs != null ? timestampMs.value : this.timestampMs),
        organizationId: (organizationId != null
            ? organizationId.value
            : this.organizationId),
        parameters: (parameters != null ? parameters.value : this.parameters));
  }
}

@JsonSerializable(explicitToJson: true)
class CreatePolicyResult {
  const CreatePolicyResult({
    required this.policyId,
  });

  factory CreatePolicyResult.fromJson(Map<String, dynamic> json) =>
      _$CreatePolicyResultFromJson(json);

  static const toJsonFactory = _$CreatePolicyResultToJson;
  Map<String, dynamic> toJson() => _$CreatePolicyResultToJson(this);

  @JsonKey(name: 'policyId')
  final String policyId;
  static const fromJsonFactory = _$CreatePolicyResultFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is CreatePolicyResult &&
            (identical(other.policyId, policyId) ||
                const DeepCollectionEquality()
                    .equals(other.policyId, policyId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(policyId) ^ runtimeType.hashCode;
}

extension $CreatePolicyResultExtension on CreatePolicyResult {
  CreatePolicyResult copyWith({String? policyId}) {
    return CreatePolicyResult(policyId: policyId ?? this.policyId);
  }

  CreatePolicyResult copyWithWrapped({Wrapped<String>? policyId}) {
    return CreatePolicyResult(
        policyId: (policyId != null ? policyId.value : this.policyId));
  }
}

@JsonSerializable(explicitToJson: true)
class CreatePrivateKeyTagIntent {
  const CreatePrivateKeyTagIntent({
    required this.privateKeyTagName,
    required this.privateKeyIds,
  });

  factory CreatePrivateKeyTagIntent.fromJson(Map<String, dynamic> json) =>
      _$CreatePrivateKeyTagIntentFromJson(json);

  static const toJsonFactory = _$CreatePrivateKeyTagIntentToJson;
  Map<String, dynamic> toJson() => _$CreatePrivateKeyTagIntentToJson(this);

  @JsonKey(name: 'privateKeyTagName')
  final String privateKeyTagName;
  @JsonKey(name: 'privateKeyIds', defaultValue: <String>[])
  final List<String> privateKeyIds;
  static const fromJsonFactory = _$CreatePrivateKeyTagIntentFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is CreatePrivateKeyTagIntent &&
            (identical(other.privateKeyTagName, privateKeyTagName) ||
                const DeepCollectionEquality()
                    .equals(other.privateKeyTagName, privateKeyTagName)) &&
            (identical(other.privateKeyIds, privateKeyIds) ||
                const DeepCollectionEquality()
                    .equals(other.privateKeyIds, privateKeyIds)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(privateKeyTagName) ^
      const DeepCollectionEquality().hash(privateKeyIds) ^
      runtimeType.hashCode;
}

extension $CreatePrivateKeyTagIntentExtension on CreatePrivateKeyTagIntent {
  CreatePrivateKeyTagIntent copyWith(
      {String? privateKeyTagName, List<String>? privateKeyIds}) {
    return CreatePrivateKeyTagIntent(
        privateKeyTagName: privateKeyTagName ?? this.privateKeyTagName,
        privateKeyIds: privateKeyIds ?? this.privateKeyIds);
  }

  CreatePrivateKeyTagIntent copyWithWrapped(
      {Wrapped<String>? privateKeyTagName,
      Wrapped<List<String>>? privateKeyIds}) {
    return CreatePrivateKeyTagIntent(
        privateKeyTagName: (privateKeyTagName != null
            ? privateKeyTagName.value
            : this.privateKeyTagName),
        privateKeyIds:
            (privateKeyIds != null ? privateKeyIds.value : this.privateKeyIds));
  }
}

@JsonSerializable(explicitToJson: true)
class CreatePrivateKeyTagRequest {
  const CreatePrivateKeyTagRequest({
    required this.type,
    required this.timestampMs,
    required this.organizationId,
    required this.parameters,
  });

  factory CreatePrivateKeyTagRequest.fromJson(Map<String, dynamic> json) =>
      _$CreatePrivateKeyTagRequestFromJson(json);

  static const toJsonFactory = _$CreatePrivateKeyTagRequestToJson;
  Map<String, dynamic> toJson() => _$CreatePrivateKeyTagRequestToJson(this);

  @JsonKey(
    name: 'type',
    toJson: createPrivateKeyTagRequestTypeToJson,
    fromJson: createPrivateKeyTagRequestTypeFromJson,
  )
  final enums.CreatePrivateKeyTagRequestType type;
  @JsonKey(name: 'timestampMs')
  final String timestampMs;
  @JsonKey(name: 'organizationId')
  final String organizationId;
  @JsonKey(name: 'parameters')
  final CreatePrivateKeyTagIntent parameters;
  static const fromJsonFactory = _$CreatePrivateKeyTagRequestFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is CreatePrivateKeyTagRequest &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.timestampMs, timestampMs) ||
                const DeepCollectionEquality()
                    .equals(other.timestampMs, timestampMs)) &&
            (identical(other.organizationId, organizationId) ||
                const DeepCollectionEquality()
                    .equals(other.organizationId, organizationId)) &&
            (identical(other.parameters, parameters) ||
                const DeepCollectionEquality()
                    .equals(other.parameters, parameters)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(timestampMs) ^
      const DeepCollectionEquality().hash(organizationId) ^
      const DeepCollectionEquality().hash(parameters) ^
      runtimeType.hashCode;
}

extension $CreatePrivateKeyTagRequestExtension on CreatePrivateKeyTagRequest {
  CreatePrivateKeyTagRequest copyWith(
      {enums.CreatePrivateKeyTagRequestType? type,
      String? timestampMs,
      String? organizationId,
      CreatePrivateKeyTagIntent? parameters}) {
    return CreatePrivateKeyTagRequest(
        type: type ?? this.type,
        timestampMs: timestampMs ?? this.timestampMs,
        organizationId: organizationId ?? this.organizationId,
        parameters: parameters ?? this.parameters);
  }

  CreatePrivateKeyTagRequest copyWithWrapped(
      {Wrapped<enums.CreatePrivateKeyTagRequestType>? type,
      Wrapped<String>? timestampMs,
      Wrapped<String>? organizationId,
      Wrapped<CreatePrivateKeyTagIntent>? parameters}) {
    return CreatePrivateKeyTagRequest(
        type: (type != null ? type.value : this.type),
        timestampMs:
            (timestampMs != null ? timestampMs.value : this.timestampMs),
        organizationId: (organizationId != null
            ? organizationId.value
            : this.organizationId),
        parameters: (parameters != null ? parameters.value : this.parameters));
  }
}

@JsonSerializable(explicitToJson: true)
class CreatePrivateKeyTagResult {
  const CreatePrivateKeyTagResult({
    required this.privateKeyTagId,
    required this.privateKeyIds,
  });

  factory CreatePrivateKeyTagResult.fromJson(Map<String, dynamic> json) =>
      _$CreatePrivateKeyTagResultFromJson(json);

  static const toJsonFactory = _$CreatePrivateKeyTagResultToJson;
  Map<String, dynamic> toJson() => _$CreatePrivateKeyTagResultToJson(this);

  @JsonKey(name: 'privateKeyTagId')
  final String privateKeyTagId;
  @JsonKey(name: 'privateKeyIds', defaultValue: <String>[])
  final List<String> privateKeyIds;
  static const fromJsonFactory = _$CreatePrivateKeyTagResultFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is CreatePrivateKeyTagResult &&
            (identical(other.privateKeyTagId, privateKeyTagId) ||
                const DeepCollectionEquality()
                    .equals(other.privateKeyTagId, privateKeyTagId)) &&
            (identical(other.privateKeyIds, privateKeyIds) ||
                const DeepCollectionEquality()
                    .equals(other.privateKeyIds, privateKeyIds)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(privateKeyTagId) ^
      const DeepCollectionEquality().hash(privateKeyIds) ^
      runtimeType.hashCode;
}

extension $CreatePrivateKeyTagResultExtension on CreatePrivateKeyTagResult {
  CreatePrivateKeyTagResult copyWith(
      {String? privateKeyTagId, List<String>? privateKeyIds}) {
    return CreatePrivateKeyTagResult(
        privateKeyTagId: privateKeyTagId ?? this.privateKeyTagId,
        privateKeyIds: privateKeyIds ?? this.privateKeyIds);
  }

  CreatePrivateKeyTagResult copyWithWrapped(
      {Wrapped<String>? privateKeyTagId,
      Wrapped<List<String>>? privateKeyIds}) {
    return CreatePrivateKeyTagResult(
        privateKeyTagId: (privateKeyTagId != null
            ? privateKeyTagId.value
            : this.privateKeyTagId),
        privateKeyIds:
            (privateKeyIds != null ? privateKeyIds.value : this.privateKeyIds));
  }
}

@JsonSerializable(explicitToJson: true)
class CreatePrivateKeysIntent {
  const CreatePrivateKeysIntent({
    required this.privateKeys,
  });

  factory CreatePrivateKeysIntent.fromJson(Map<String, dynamic> json) =>
      _$CreatePrivateKeysIntentFromJson(json);

  static const toJsonFactory = _$CreatePrivateKeysIntentToJson;
  Map<String, dynamic> toJson() => _$CreatePrivateKeysIntentToJson(this);

  @JsonKey(name: 'privateKeys', defaultValue: <PrivateKeyParams>[])
  final List<PrivateKeyParams> privateKeys;
  static const fromJsonFactory = _$CreatePrivateKeysIntentFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is CreatePrivateKeysIntent &&
            (identical(other.privateKeys, privateKeys) ||
                const DeepCollectionEquality()
                    .equals(other.privateKeys, privateKeys)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(privateKeys) ^ runtimeType.hashCode;
}

extension $CreatePrivateKeysIntentExtension on CreatePrivateKeysIntent {
  CreatePrivateKeysIntent copyWith({List<PrivateKeyParams>? privateKeys}) {
    return CreatePrivateKeysIntent(
        privateKeys: privateKeys ?? this.privateKeys);
  }

  CreatePrivateKeysIntent copyWithWrapped(
      {Wrapped<List<PrivateKeyParams>>? privateKeys}) {
    return CreatePrivateKeysIntent(
        privateKeys:
            (privateKeys != null ? privateKeys.value : this.privateKeys));
  }
}

@JsonSerializable(explicitToJson: true)
class CreatePrivateKeysIntentV2 {
  const CreatePrivateKeysIntentV2({
    required this.privateKeys,
  });

  factory CreatePrivateKeysIntentV2.fromJson(Map<String, dynamic> json) =>
      _$CreatePrivateKeysIntentV2FromJson(json);

  static const toJsonFactory = _$CreatePrivateKeysIntentV2ToJson;
  Map<String, dynamic> toJson() => _$CreatePrivateKeysIntentV2ToJson(this);

  @JsonKey(name: 'privateKeys', defaultValue: <PrivateKeyParams>[])
  final List<PrivateKeyParams> privateKeys;
  static const fromJsonFactory = _$CreatePrivateKeysIntentV2FromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is CreatePrivateKeysIntentV2 &&
            (identical(other.privateKeys, privateKeys) ||
                const DeepCollectionEquality()
                    .equals(other.privateKeys, privateKeys)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(privateKeys) ^ runtimeType.hashCode;
}

extension $CreatePrivateKeysIntentV2Extension on CreatePrivateKeysIntentV2 {
  CreatePrivateKeysIntentV2 copyWith({List<PrivateKeyParams>? privateKeys}) {
    return CreatePrivateKeysIntentV2(
        privateKeys: privateKeys ?? this.privateKeys);
  }

  CreatePrivateKeysIntentV2 copyWithWrapped(
      {Wrapped<List<PrivateKeyParams>>? privateKeys}) {
    return CreatePrivateKeysIntentV2(
        privateKeys:
            (privateKeys != null ? privateKeys.value : this.privateKeys));
  }
}

@JsonSerializable(explicitToJson: true)
class CreatePrivateKeysRequest {
  const CreatePrivateKeysRequest({
    required this.type,
    required this.timestampMs,
    required this.organizationId,
    required this.parameters,
  });

  factory CreatePrivateKeysRequest.fromJson(Map<String, dynamic> json) =>
      _$CreatePrivateKeysRequestFromJson(json);

  static const toJsonFactory = _$CreatePrivateKeysRequestToJson;
  Map<String, dynamic> toJson() => _$CreatePrivateKeysRequestToJson(this);

  @JsonKey(
    name: 'type',
    toJson: createPrivateKeysRequestTypeToJson,
    fromJson: createPrivateKeysRequestTypeFromJson,
  )
  final enums.CreatePrivateKeysRequestType type;
  @JsonKey(name: 'timestampMs')
  final String timestampMs;
  @JsonKey(name: 'organizationId')
  final String organizationId;
  @JsonKey(name: 'parameters')
  final CreatePrivateKeysIntentV2 parameters;
  static const fromJsonFactory = _$CreatePrivateKeysRequestFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is CreatePrivateKeysRequest &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.timestampMs, timestampMs) ||
                const DeepCollectionEquality()
                    .equals(other.timestampMs, timestampMs)) &&
            (identical(other.organizationId, organizationId) ||
                const DeepCollectionEquality()
                    .equals(other.organizationId, organizationId)) &&
            (identical(other.parameters, parameters) ||
                const DeepCollectionEquality()
                    .equals(other.parameters, parameters)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(timestampMs) ^
      const DeepCollectionEquality().hash(organizationId) ^
      const DeepCollectionEquality().hash(parameters) ^
      runtimeType.hashCode;
}

extension $CreatePrivateKeysRequestExtension on CreatePrivateKeysRequest {
  CreatePrivateKeysRequest copyWith(
      {enums.CreatePrivateKeysRequestType? type,
      String? timestampMs,
      String? organizationId,
      CreatePrivateKeysIntentV2? parameters}) {
    return CreatePrivateKeysRequest(
        type: type ?? this.type,
        timestampMs: timestampMs ?? this.timestampMs,
        organizationId: organizationId ?? this.organizationId,
        parameters: parameters ?? this.parameters);
  }

  CreatePrivateKeysRequest copyWithWrapped(
      {Wrapped<enums.CreatePrivateKeysRequestType>? type,
      Wrapped<String>? timestampMs,
      Wrapped<String>? organizationId,
      Wrapped<CreatePrivateKeysIntentV2>? parameters}) {
    return CreatePrivateKeysRequest(
        type: (type != null ? type.value : this.type),
        timestampMs:
            (timestampMs != null ? timestampMs.value : this.timestampMs),
        organizationId: (organizationId != null
            ? organizationId.value
            : this.organizationId),
        parameters: (parameters != null ? parameters.value : this.parameters));
  }
}

@JsonSerializable(explicitToJson: true)
class CreatePrivateKeysResult {
  const CreatePrivateKeysResult({
    required this.privateKeyIds,
  });

  factory CreatePrivateKeysResult.fromJson(Map<String, dynamic> json) =>
      _$CreatePrivateKeysResultFromJson(json);

  static const toJsonFactory = _$CreatePrivateKeysResultToJson;
  Map<String, dynamic> toJson() => _$CreatePrivateKeysResultToJson(this);

  @JsonKey(name: 'privateKeyIds', defaultValue: <String>[])
  final List<String> privateKeyIds;
  static const fromJsonFactory = _$CreatePrivateKeysResultFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is CreatePrivateKeysResult &&
            (identical(other.privateKeyIds, privateKeyIds) ||
                const DeepCollectionEquality()
                    .equals(other.privateKeyIds, privateKeyIds)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(privateKeyIds) ^ runtimeType.hashCode;
}

extension $CreatePrivateKeysResultExtension on CreatePrivateKeysResult {
  CreatePrivateKeysResult copyWith({List<String>? privateKeyIds}) {
    return CreatePrivateKeysResult(
        privateKeyIds: privateKeyIds ?? this.privateKeyIds);
  }

  CreatePrivateKeysResult copyWithWrapped(
      {Wrapped<List<String>>? privateKeyIds}) {
    return CreatePrivateKeysResult(
        privateKeyIds:
            (privateKeyIds != null ? privateKeyIds.value : this.privateKeyIds));
  }
}

@JsonSerializable(explicitToJson: true)
class CreatePrivateKeysResultV2 {
  const CreatePrivateKeysResultV2({
    required this.privateKeys,
  });

  factory CreatePrivateKeysResultV2.fromJson(Map<String, dynamic> json) =>
      _$CreatePrivateKeysResultV2FromJson(json);

  static const toJsonFactory = _$CreatePrivateKeysResultV2ToJson;
  Map<String, dynamic> toJson() => _$CreatePrivateKeysResultV2ToJson(this);

  @JsonKey(name: 'privateKeys', defaultValue: <PrivateKeyResult>[])
  final List<PrivateKeyResult> privateKeys;
  static const fromJsonFactory = _$CreatePrivateKeysResultV2FromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is CreatePrivateKeysResultV2 &&
            (identical(other.privateKeys, privateKeys) ||
                const DeepCollectionEquality()
                    .equals(other.privateKeys, privateKeys)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(privateKeys) ^ runtimeType.hashCode;
}

extension $CreatePrivateKeysResultV2Extension on CreatePrivateKeysResultV2 {
  CreatePrivateKeysResultV2 copyWith({List<PrivateKeyResult>? privateKeys}) {
    return CreatePrivateKeysResultV2(
        privateKeys: privateKeys ?? this.privateKeys);
  }

  CreatePrivateKeysResultV2 copyWithWrapped(
      {Wrapped<List<PrivateKeyResult>>? privateKeys}) {
    return CreatePrivateKeysResultV2(
        privateKeys:
            (privateKeys != null ? privateKeys.value : this.privateKeys));
  }
}

@JsonSerializable(explicitToJson: true)
class CreateReadOnlySessionIntent {
  const CreateReadOnlySessionIntent();

  factory CreateReadOnlySessionIntent.fromJson(Map<String, dynamic> json) =>
      _$CreateReadOnlySessionIntentFromJson(json);

  static const toJsonFactory = _$CreateReadOnlySessionIntentToJson;
  Map<String, dynamic> toJson() => _$CreateReadOnlySessionIntentToJson(this);

  static const fromJsonFactory = _$CreateReadOnlySessionIntentFromJson;

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode => runtimeType.hashCode;
}

@JsonSerializable(explicitToJson: true)
class CreateReadOnlySessionRequest {
  const CreateReadOnlySessionRequest({
    required this.type,
    required this.timestampMs,
    required this.organizationId,
    required this.parameters,
  });

  factory CreateReadOnlySessionRequest.fromJson(Map<String, dynamic> json) =>
      _$CreateReadOnlySessionRequestFromJson(json);

  static const toJsonFactory = _$CreateReadOnlySessionRequestToJson;
  Map<String, dynamic> toJson() => _$CreateReadOnlySessionRequestToJson(this);

  @JsonKey(
    name: 'type',
    toJson: createReadOnlySessionRequestTypeToJson,
    fromJson: createReadOnlySessionRequestTypeFromJson,
  )
  final enums.CreateReadOnlySessionRequestType type;
  @JsonKey(name: 'timestampMs')
  final String timestampMs;
  @JsonKey(name: 'organizationId')
  final String organizationId;
  @JsonKey(name: 'parameters')
  final CreateReadOnlySessionIntent parameters;
  static const fromJsonFactory = _$CreateReadOnlySessionRequestFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is CreateReadOnlySessionRequest &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.timestampMs, timestampMs) ||
                const DeepCollectionEquality()
                    .equals(other.timestampMs, timestampMs)) &&
            (identical(other.organizationId, organizationId) ||
                const DeepCollectionEquality()
                    .equals(other.organizationId, organizationId)) &&
            (identical(other.parameters, parameters) ||
                const DeepCollectionEquality()
                    .equals(other.parameters, parameters)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(timestampMs) ^
      const DeepCollectionEquality().hash(organizationId) ^
      const DeepCollectionEquality().hash(parameters) ^
      runtimeType.hashCode;
}

extension $CreateReadOnlySessionRequestExtension
    on CreateReadOnlySessionRequest {
  CreateReadOnlySessionRequest copyWith(
      {enums.CreateReadOnlySessionRequestType? type,
      String? timestampMs,
      String? organizationId,
      CreateReadOnlySessionIntent? parameters}) {
    return CreateReadOnlySessionRequest(
        type: type ?? this.type,
        timestampMs: timestampMs ?? this.timestampMs,
        organizationId: organizationId ?? this.organizationId,
        parameters: parameters ?? this.parameters);
  }

  CreateReadOnlySessionRequest copyWithWrapped(
      {Wrapped<enums.CreateReadOnlySessionRequestType>? type,
      Wrapped<String>? timestampMs,
      Wrapped<String>? organizationId,
      Wrapped<CreateReadOnlySessionIntent>? parameters}) {
    return CreateReadOnlySessionRequest(
        type: (type != null ? type.value : this.type),
        timestampMs:
            (timestampMs != null ? timestampMs.value : this.timestampMs),
        organizationId: (organizationId != null
            ? organizationId.value
            : this.organizationId),
        parameters: (parameters != null ? parameters.value : this.parameters));
  }
}

@JsonSerializable(explicitToJson: true)
class CreateReadOnlySessionResult {
  const CreateReadOnlySessionResult({
    required this.organizationId,
    required this.organizationName,
    required this.userId,
    required this.username,
    required this.session,
    required this.sessionExpiry,
  });

  factory CreateReadOnlySessionResult.fromJson(Map<String, dynamic> json) =>
      _$CreateReadOnlySessionResultFromJson(json);

  static const toJsonFactory = _$CreateReadOnlySessionResultToJson;
  Map<String, dynamic> toJson() => _$CreateReadOnlySessionResultToJson(this);

  @JsonKey(name: 'organizationId')
  final String organizationId;
  @JsonKey(name: 'organizationName')
  final String organizationName;
  @JsonKey(name: 'userId')
  final String userId;
  @JsonKey(name: 'username')
  final String username;
  @JsonKey(name: 'session')
  final String session;
  @JsonKey(name: 'sessionExpiry')
  final String sessionExpiry;
  static const fromJsonFactory = _$CreateReadOnlySessionResultFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is CreateReadOnlySessionResult &&
            (identical(other.organizationId, organizationId) ||
                const DeepCollectionEquality()
                    .equals(other.organizationId, organizationId)) &&
            (identical(other.organizationName, organizationName) ||
                const DeepCollectionEquality()
                    .equals(other.organizationName, organizationName)) &&
            (identical(other.userId, userId) ||
                const DeepCollectionEquality().equals(other.userId, userId)) &&
            (identical(other.username, username) ||
                const DeepCollectionEquality()
                    .equals(other.username, username)) &&
            (identical(other.session, session) ||
                const DeepCollectionEquality()
                    .equals(other.session, session)) &&
            (identical(other.sessionExpiry, sessionExpiry) ||
                const DeepCollectionEquality()
                    .equals(other.sessionExpiry, sessionExpiry)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(organizationId) ^
      const DeepCollectionEquality().hash(organizationName) ^
      const DeepCollectionEquality().hash(userId) ^
      const DeepCollectionEquality().hash(username) ^
      const DeepCollectionEquality().hash(session) ^
      const DeepCollectionEquality().hash(sessionExpiry) ^
      runtimeType.hashCode;
}

extension $CreateReadOnlySessionResultExtension on CreateReadOnlySessionResult {
  CreateReadOnlySessionResult copyWith(
      {String? organizationId,
      String? organizationName,
      String? userId,
      String? username,
      String? session,
      String? sessionExpiry}) {
    return CreateReadOnlySessionResult(
        organizationId: organizationId ?? this.organizationId,
        organizationName: organizationName ?? this.organizationName,
        userId: userId ?? this.userId,
        username: username ?? this.username,
        session: session ?? this.session,
        sessionExpiry: sessionExpiry ?? this.sessionExpiry);
  }

  CreateReadOnlySessionResult copyWithWrapped(
      {Wrapped<String>? organizationId,
      Wrapped<String>? organizationName,
      Wrapped<String>? userId,
      Wrapped<String>? username,
      Wrapped<String>? session,
      Wrapped<String>? sessionExpiry}) {
    return CreateReadOnlySessionResult(
        organizationId: (organizationId != null
            ? organizationId.value
            : this.organizationId),
        organizationName: (organizationName != null
            ? organizationName.value
            : this.organizationName),
        userId: (userId != null ? userId.value : this.userId),
        username: (username != null ? username.value : this.username),
        session: (session != null ? session.value : this.session),
        sessionExpiry:
            (sessionExpiry != null ? sessionExpiry.value : this.sessionExpiry));
  }
}

@JsonSerializable(explicitToJson: true)
class CreateReadWriteSessionIntent {
  const CreateReadWriteSessionIntent({
    required this.targetPublicKey,
    required this.email,
    this.apiKeyName,
    this.expirationSeconds,
  });

  factory CreateReadWriteSessionIntent.fromJson(Map<String, dynamic> json) =>
      _$CreateReadWriteSessionIntentFromJson(json);

  static const toJsonFactory = _$CreateReadWriteSessionIntentToJson;
  Map<String, dynamic> toJson() => _$CreateReadWriteSessionIntentToJson(this);

  @JsonKey(name: 'targetPublicKey')
  final String targetPublicKey;
  @JsonKey(name: 'email')
  final String email;
  @JsonKey(name: 'apiKeyName')
  final String? apiKeyName;
  @JsonKey(name: 'expirationSeconds')
  final String? expirationSeconds;
  static const fromJsonFactory = _$CreateReadWriteSessionIntentFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is CreateReadWriteSessionIntent &&
            (identical(other.targetPublicKey, targetPublicKey) ||
                const DeepCollectionEquality()
                    .equals(other.targetPublicKey, targetPublicKey)) &&
            (identical(other.email, email) ||
                const DeepCollectionEquality().equals(other.email, email)) &&
            (identical(other.apiKeyName, apiKeyName) ||
                const DeepCollectionEquality()
                    .equals(other.apiKeyName, apiKeyName)) &&
            (identical(other.expirationSeconds, expirationSeconds) ||
                const DeepCollectionEquality()
                    .equals(other.expirationSeconds, expirationSeconds)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(targetPublicKey) ^
      const DeepCollectionEquality().hash(email) ^
      const DeepCollectionEquality().hash(apiKeyName) ^
      const DeepCollectionEquality().hash(expirationSeconds) ^
      runtimeType.hashCode;
}

extension $CreateReadWriteSessionIntentExtension
    on CreateReadWriteSessionIntent {
  CreateReadWriteSessionIntent copyWith(
      {String? targetPublicKey,
      String? email,
      String? apiKeyName,
      String? expirationSeconds}) {
    return CreateReadWriteSessionIntent(
        targetPublicKey: targetPublicKey ?? this.targetPublicKey,
        email: email ?? this.email,
        apiKeyName: apiKeyName ?? this.apiKeyName,
        expirationSeconds: expirationSeconds ?? this.expirationSeconds);
  }

  CreateReadWriteSessionIntent copyWithWrapped(
      {Wrapped<String>? targetPublicKey,
      Wrapped<String>? email,
      Wrapped<String?>? apiKeyName,
      Wrapped<String?>? expirationSeconds}) {
    return CreateReadWriteSessionIntent(
        targetPublicKey: (targetPublicKey != null
            ? targetPublicKey.value
            : this.targetPublicKey),
        email: (email != null ? email.value : this.email),
        apiKeyName: (apiKeyName != null ? apiKeyName.value : this.apiKeyName),
        expirationSeconds: (expirationSeconds != null
            ? expirationSeconds.value
            : this.expirationSeconds));
  }
}

@JsonSerializable(explicitToJson: true)
class CreateReadWriteSessionIntentV2 {
  const CreateReadWriteSessionIntentV2({
    required this.targetPublicKey,
    this.userId,
    this.apiKeyName,
    this.expirationSeconds,
    this.invalidateExisting,
  });

  factory CreateReadWriteSessionIntentV2.fromJson(Map<String, dynamic> json) =>
      _$CreateReadWriteSessionIntentV2FromJson(json);

  static const toJsonFactory = _$CreateReadWriteSessionIntentV2ToJson;
  Map<String, dynamic> toJson() => _$CreateReadWriteSessionIntentV2ToJson(this);

  @JsonKey(name: 'targetPublicKey')
  final String targetPublicKey;
  @JsonKey(name: 'userId')
  final String? userId;
  @JsonKey(name: 'apiKeyName')
  final String? apiKeyName;
  @JsonKey(name: 'expirationSeconds')
  final String? expirationSeconds;
  @JsonKey(name: 'invalidateExisting')
  final bool? invalidateExisting;
  static const fromJsonFactory = _$CreateReadWriteSessionIntentV2FromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is CreateReadWriteSessionIntentV2 &&
            (identical(other.targetPublicKey, targetPublicKey) ||
                const DeepCollectionEquality()
                    .equals(other.targetPublicKey, targetPublicKey)) &&
            (identical(other.userId, userId) ||
                const DeepCollectionEquality().equals(other.userId, userId)) &&
            (identical(other.apiKeyName, apiKeyName) ||
                const DeepCollectionEquality()
                    .equals(other.apiKeyName, apiKeyName)) &&
            (identical(other.expirationSeconds, expirationSeconds) ||
                const DeepCollectionEquality()
                    .equals(other.expirationSeconds, expirationSeconds)) &&
            (identical(other.invalidateExisting, invalidateExisting) ||
                const DeepCollectionEquality()
                    .equals(other.invalidateExisting, invalidateExisting)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(targetPublicKey) ^
      const DeepCollectionEquality().hash(userId) ^
      const DeepCollectionEquality().hash(apiKeyName) ^
      const DeepCollectionEquality().hash(expirationSeconds) ^
      const DeepCollectionEquality().hash(invalidateExisting) ^
      runtimeType.hashCode;
}

extension $CreateReadWriteSessionIntentV2Extension
    on CreateReadWriteSessionIntentV2 {
  CreateReadWriteSessionIntentV2 copyWith(
      {String? targetPublicKey,
      String? userId,
      String? apiKeyName,
      String? expirationSeconds,
      bool? invalidateExisting}) {
    return CreateReadWriteSessionIntentV2(
        targetPublicKey: targetPublicKey ?? this.targetPublicKey,
        userId: userId ?? this.userId,
        apiKeyName: apiKeyName ?? this.apiKeyName,
        expirationSeconds: expirationSeconds ?? this.expirationSeconds,
        invalidateExisting: invalidateExisting ?? this.invalidateExisting);
  }

  CreateReadWriteSessionIntentV2 copyWithWrapped(
      {Wrapped<String>? targetPublicKey,
      Wrapped<String?>? userId,
      Wrapped<String?>? apiKeyName,
      Wrapped<String?>? expirationSeconds,
      Wrapped<bool?>? invalidateExisting}) {
    return CreateReadWriteSessionIntentV2(
        targetPublicKey: (targetPublicKey != null
            ? targetPublicKey.value
            : this.targetPublicKey),
        userId: (userId != null ? userId.value : this.userId),
        apiKeyName: (apiKeyName != null ? apiKeyName.value : this.apiKeyName),
        expirationSeconds: (expirationSeconds != null
            ? expirationSeconds.value
            : this.expirationSeconds),
        invalidateExisting: (invalidateExisting != null
            ? invalidateExisting.value
            : this.invalidateExisting));
  }
}

@JsonSerializable(explicitToJson: true)
class CreateReadWriteSessionRequest {
  const CreateReadWriteSessionRequest({
    required this.type,
    required this.timestampMs,
    required this.organizationId,
    required this.parameters,
  });

  factory CreateReadWriteSessionRequest.fromJson(Map<String, dynamic> json) =>
      _$CreateReadWriteSessionRequestFromJson(json);

  static const toJsonFactory = _$CreateReadWriteSessionRequestToJson;
  Map<String, dynamic> toJson() => _$CreateReadWriteSessionRequestToJson(this);

  @JsonKey(
    name: 'type',
    toJson: createReadWriteSessionRequestTypeToJson,
    fromJson: createReadWriteSessionRequestTypeFromJson,
  )
  final enums.CreateReadWriteSessionRequestType type;
  @JsonKey(name: 'timestampMs')
  final String timestampMs;
  @JsonKey(name: 'organizationId')
  final String organizationId;
  @JsonKey(name: 'parameters')
  final CreateReadWriteSessionIntentV2 parameters;
  static const fromJsonFactory = _$CreateReadWriteSessionRequestFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is CreateReadWriteSessionRequest &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.timestampMs, timestampMs) ||
                const DeepCollectionEquality()
                    .equals(other.timestampMs, timestampMs)) &&
            (identical(other.organizationId, organizationId) ||
                const DeepCollectionEquality()
                    .equals(other.organizationId, organizationId)) &&
            (identical(other.parameters, parameters) ||
                const DeepCollectionEquality()
                    .equals(other.parameters, parameters)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(timestampMs) ^
      const DeepCollectionEquality().hash(organizationId) ^
      const DeepCollectionEquality().hash(parameters) ^
      runtimeType.hashCode;
}

extension $CreateReadWriteSessionRequestExtension
    on CreateReadWriteSessionRequest {
  CreateReadWriteSessionRequest copyWith(
      {enums.CreateReadWriteSessionRequestType? type,
      String? timestampMs,
      String? organizationId,
      CreateReadWriteSessionIntentV2? parameters}) {
    return CreateReadWriteSessionRequest(
        type: type ?? this.type,
        timestampMs: timestampMs ?? this.timestampMs,
        organizationId: organizationId ?? this.organizationId,
        parameters: parameters ?? this.parameters);
  }

  CreateReadWriteSessionRequest copyWithWrapped(
      {Wrapped<enums.CreateReadWriteSessionRequestType>? type,
      Wrapped<String>? timestampMs,
      Wrapped<String>? organizationId,
      Wrapped<CreateReadWriteSessionIntentV2>? parameters}) {
    return CreateReadWriteSessionRequest(
        type: (type != null ? type.value : this.type),
        timestampMs:
            (timestampMs != null ? timestampMs.value : this.timestampMs),
        organizationId: (organizationId != null
            ? organizationId.value
            : this.organizationId),
        parameters: (parameters != null ? parameters.value : this.parameters));
  }
}

@JsonSerializable(explicitToJson: true)
class CreateReadWriteSessionResult {
  const CreateReadWriteSessionResult({
    required this.organizationId,
    required this.organizationName,
    required this.userId,
    required this.username,
    required this.apiKeyId,
    required this.credentialBundle,
  });

  factory CreateReadWriteSessionResult.fromJson(Map<String, dynamic> json) =>
      _$CreateReadWriteSessionResultFromJson(json);

  static const toJsonFactory = _$CreateReadWriteSessionResultToJson;
  Map<String, dynamic> toJson() => _$CreateReadWriteSessionResultToJson(this);

  @JsonKey(name: 'organizationId')
  final String organizationId;
  @JsonKey(name: 'organizationName')
  final String organizationName;
  @JsonKey(name: 'userId')
  final String userId;
  @JsonKey(name: 'username')
  final String username;
  @JsonKey(name: 'apiKeyId')
  final String apiKeyId;
  @JsonKey(name: 'credentialBundle')
  final String credentialBundle;
  static const fromJsonFactory = _$CreateReadWriteSessionResultFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is CreateReadWriteSessionResult &&
            (identical(other.organizationId, organizationId) ||
                const DeepCollectionEquality()
                    .equals(other.organizationId, organizationId)) &&
            (identical(other.organizationName, organizationName) ||
                const DeepCollectionEquality()
                    .equals(other.organizationName, organizationName)) &&
            (identical(other.userId, userId) ||
                const DeepCollectionEquality().equals(other.userId, userId)) &&
            (identical(other.username, username) ||
                const DeepCollectionEquality()
                    .equals(other.username, username)) &&
            (identical(other.apiKeyId, apiKeyId) ||
                const DeepCollectionEquality()
                    .equals(other.apiKeyId, apiKeyId)) &&
            (identical(other.credentialBundle, credentialBundle) ||
                const DeepCollectionEquality()
                    .equals(other.credentialBundle, credentialBundle)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(organizationId) ^
      const DeepCollectionEquality().hash(organizationName) ^
      const DeepCollectionEquality().hash(userId) ^
      const DeepCollectionEquality().hash(username) ^
      const DeepCollectionEquality().hash(apiKeyId) ^
      const DeepCollectionEquality().hash(credentialBundle) ^
      runtimeType.hashCode;
}

extension $CreateReadWriteSessionResultExtension
    on CreateReadWriteSessionResult {
  CreateReadWriteSessionResult copyWith(
      {String? organizationId,
      String? organizationName,
      String? userId,
      String? username,
      String? apiKeyId,
      String? credentialBundle}) {
    return CreateReadWriteSessionResult(
        organizationId: organizationId ?? this.organizationId,
        organizationName: organizationName ?? this.organizationName,
        userId: userId ?? this.userId,
        username: username ?? this.username,
        apiKeyId: apiKeyId ?? this.apiKeyId,
        credentialBundle: credentialBundle ?? this.credentialBundle);
  }

  CreateReadWriteSessionResult copyWithWrapped(
      {Wrapped<String>? organizationId,
      Wrapped<String>? organizationName,
      Wrapped<String>? userId,
      Wrapped<String>? username,
      Wrapped<String>? apiKeyId,
      Wrapped<String>? credentialBundle}) {
    return CreateReadWriteSessionResult(
        organizationId: (organizationId != null
            ? organizationId.value
            : this.organizationId),
        organizationName: (organizationName != null
            ? organizationName.value
            : this.organizationName),
        userId: (userId != null ? userId.value : this.userId),
        username: (username != null ? username.value : this.username),
        apiKeyId: (apiKeyId != null ? apiKeyId.value : this.apiKeyId),
        credentialBundle: (credentialBundle != null
            ? credentialBundle.value
            : this.credentialBundle));
  }
}

@JsonSerializable(explicitToJson: true)
class CreateReadWriteSessionResultV2 {
  const CreateReadWriteSessionResultV2({
    required this.organizationId,
    required this.organizationName,
    required this.userId,
    required this.username,
    required this.apiKeyId,
    required this.credentialBundle,
  });

  factory CreateReadWriteSessionResultV2.fromJson(Map<String, dynamic> json) =>
      _$CreateReadWriteSessionResultV2FromJson(json);

  static const toJsonFactory = _$CreateReadWriteSessionResultV2ToJson;
  Map<String, dynamic> toJson() => _$CreateReadWriteSessionResultV2ToJson(this);

  @JsonKey(name: 'organizationId')
  final String organizationId;
  @JsonKey(name: 'organizationName')
  final String organizationName;
  @JsonKey(name: 'userId')
  final String userId;
  @JsonKey(name: 'username')
  final String username;
  @JsonKey(name: 'apiKeyId')
  final String apiKeyId;
  @JsonKey(name: 'credentialBundle')
  final String credentialBundle;
  static const fromJsonFactory = _$CreateReadWriteSessionResultV2FromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is CreateReadWriteSessionResultV2 &&
            (identical(other.organizationId, organizationId) ||
                const DeepCollectionEquality()
                    .equals(other.organizationId, organizationId)) &&
            (identical(other.organizationName, organizationName) ||
                const DeepCollectionEquality()
                    .equals(other.organizationName, organizationName)) &&
            (identical(other.userId, userId) ||
                const DeepCollectionEquality().equals(other.userId, userId)) &&
            (identical(other.username, username) ||
                const DeepCollectionEquality()
                    .equals(other.username, username)) &&
            (identical(other.apiKeyId, apiKeyId) ||
                const DeepCollectionEquality()
                    .equals(other.apiKeyId, apiKeyId)) &&
            (identical(other.credentialBundle, credentialBundle) ||
                const DeepCollectionEquality()
                    .equals(other.credentialBundle, credentialBundle)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(organizationId) ^
      const DeepCollectionEquality().hash(organizationName) ^
      const DeepCollectionEquality().hash(userId) ^
      const DeepCollectionEquality().hash(username) ^
      const DeepCollectionEquality().hash(apiKeyId) ^
      const DeepCollectionEquality().hash(credentialBundle) ^
      runtimeType.hashCode;
}

extension $CreateReadWriteSessionResultV2Extension
    on CreateReadWriteSessionResultV2 {
  CreateReadWriteSessionResultV2 copyWith(
      {String? organizationId,
      String? organizationName,
      String? userId,
      String? username,
      String? apiKeyId,
      String? credentialBundle}) {
    return CreateReadWriteSessionResultV2(
        organizationId: organizationId ?? this.organizationId,
        organizationName: organizationName ?? this.organizationName,
        userId: userId ?? this.userId,
        username: username ?? this.username,
        apiKeyId: apiKeyId ?? this.apiKeyId,
        credentialBundle: credentialBundle ?? this.credentialBundle);
  }

  CreateReadWriteSessionResultV2 copyWithWrapped(
      {Wrapped<String>? organizationId,
      Wrapped<String>? organizationName,
      Wrapped<String>? userId,
      Wrapped<String>? username,
      Wrapped<String>? apiKeyId,
      Wrapped<String>? credentialBundle}) {
    return CreateReadWriteSessionResultV2(
        organizationId: (organizationId != null
            ? organizationId.value
            : this.organizationId),
        organizationName: (organizationName != null
            ? organizationName.value
            : this.organizationName),
        userId: (userId != null ? userId.value : this.userId),
        username: (username != null ? username.value : this.username),
        apiKeyId: (apiKeyId != null ? apiKeyId.value : this.apiKeyId),
        credentialBundle: (credentialBundle != null
            ? credentialBundle.value
            : this.credentialBundle));
  }
}

@JsonSerializable(explicitToJson: true)
class CreateSmartContractInterfaceIntent {
  const CreateSmartContractInterfaceIntent({
    required this.smartContractAddress,
    required this.smartContractInterface,
    required this.type,
    required this.label,
    this.notes,
  });

  factory CreateSmartContractInterfaceIntent.fromJson(
          Map<String, dynamic> json) =>
      _$CreateSmartContractInterfaceIntentFromJson(json);

  static const toJsonFactory = _$CreateSmartContractInterfaceIntentToJson;
  Map<String, dynamic> toJson() =>
      _$CreateSmartContractInterfaceIntentToJson(this);

  @JsonKey(name: 'smartContractAddress')
  final String smartContractAddress;
  @JsonKey(name: 'smartContractInterface')
  final String smartContractInterface;
  @JsonKey(
    name: 'type',
    toJson: smartContractInterfaceTypeToJson,
    fromJson: smartContractInterfaceTypeFromJson,
  )
  final enums.SmartContractInterfaceType type;
  @JsonKey(name: 'label')
  final String label;
  @JsonKey(name: 'notes')
  final String? notes;
  static const fromJsonFactory = _$CreateSmartContractInterfaceIntentFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is CreateSmartContractInterfaceIntent &&
            (identical(other.smartContractAddress, smartContractAddress) ||
                const DeepCollectionEquality().equals(
                    other.smartContractAddress, smartContractAddress)) &&
            (identical(other.smartContractInterface, smartContractInterface) ||
                const DeepCollectionEquality().equals(
                    other.smartContractInterface, smartContractInterface)) &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.label, label) ||
                const DeepCollectionEquality().equals(other.label, label)) &&
            (identical(other.notes, notes) ||
                const DeepCollectionEquality().equals(other.notes, notes)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(smartContractAddress) ^
      const DeepCollectionEquality().hash(smartContractInterface) ^
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(label) ^
      const DeepCollectionEquality().hash(notes) ^
      runtimeType.hashCode;
}

extension $CreateSmartContractInterfaceIntentExtension
    on CreateSmartContractInterfaceIntent {
  CreateSmartContractInterfaceIntent copyWith(
      {String? smartContractAddress,
      String? smartContractInterface,
      enums.SmartContractInterfaceType? type,
      String? label,
      String? notes}) {
    return CreateSmartContractInterfaceIntent(
        smartContractAddress: smartContractAddress ?? this.smartContractAddress,
        smartContractInterface:
            smartContractInterface ?? this.smartContractInterface,
        type: type ?? this.type,
        label: label ?? this.label,
        notes: notes ?? this.notes);
  }

  CreateSmartContractInterfaceIntent copyWithWrapped(
      {Wrapped<String>? smartContractAddress,
      Wrapped<String>? smartContractInterface,
      Wrapped<enums.SmartContractInterfaceType>? type,
      Wrapped<String>? label,
      Wrapped<String?>? notes}) {
    return CreateSmartContractInterfaceIntent(
        smartContractAddress: (smartContractAddress != null
            ? smartContractAddress.value
            : this.smartContractAddress),
        smartContractInterface: (smartContractInterface != null
            ? smartContractInterface.value
            : this.smartContractInterface),
        type: (type != null ? type.value : this.type),
        label: (label != null ? label.value : this.label),
        notes: (notes != null ? notes.value : this.notes));
  }
}

@JsonSerializable(explicitToJson: true)
class CreateSmartContractInterfaceRequest {
  const CreateSmartContractInterfaceRequest({
    required this.type,
    required this.timestampMs,
    required this.organizationId,
    required this.parameters,
  });

  factory CreateSmartContractInterfaceRequest.fromJson(
          Map<String, dynamic> json) =>
      _$CreateSmartContractInterfaceRequestFromJson(json);

  static const toJsonFactory = _$CreateSmartContractInterfaceRequestToJson;
  Map<String, dynamic> toJson() =>
      _$CreateSmartContractInterfaceRequestToJson(this);

  @JsonKey(
    name: 'type',
    toJson: createSmartContractInterfaceRequestTypeToJson,
    fromJson: createSmartContractInterfaceRequestTypeFromJson,
  )
  final enums.CreateSmartContractInterfaceRequestType type;
  @JsonKey(name: 'timestampMs')
  final String timestampMs;
  @JsonKey(name: 'organizationId')
  final String organizationId;
  @JsonKey(name: 'parameters')
  final CreateSmartContractInterfaceIntent parameters;
  static const fromJsonFactory = _$CreateSmartContractInterfaceRequestFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is CreateSmartContractInterfaceRequest &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.timestampMs, timestampMs) ||
                const DeepCollectionEquality()
                    .equals(other.timestampMs, timestampMs)) &&
            (identical(other.organizationId, organizationId) ||
                const DeepCollectionEquality()
                    .equals(other.organizationId, organizationId)) &&
            (identical(other.parameters, parameters) ||
                const DeepCollectionEquality()
                    .equals(other.parameters, parameters)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(timestampMs) ^
      const DeepCollectionEquality().hash(organizationId) ^
      const DeepCollectionEquality().hash(parameters) ^
      runtimeType.hashCode;
}

extension $CreateSmartContractInterfaceRequestExtension
    on CreateSmartContractInterfaceRequest {
  CreateSmartContractInterfaceRequest copyWith(
      {enums.CreateSmartContractInterfaceRequestType? type,
      String? timestampMs,
      String? organizationId,
      CreateSmartContractInterfaceIntent? parameters}) {
    return CreateSmartContractInterfaceRequest(
        type: type ?? this.type,
        timestampMs: timestampMs ?? this.timestampMs,
        organizationId: organizationId ?? this.organizationId,
        parameters: parameters ?? this.parameters);
  }

  CreateSmartContractInterfaceRequest copyWithWrapped(
      {Wrapped<enums.CreateSmartContractInterfaceRequestType>? type,
      Wrapped<String>? timestampMs,
      Wrapped<String>? organizationId,
      Wrapped<CreateSmartContractInterfaceIntent>? parameters}) {
    return CreateSmartContractInterfaceRequest(
        type: (type != null ? type.value : this.type),
        timestampMs:
            (timestampMs != null ? timestampMs.value : this.timestampMs),
        organizationId: (organizationId != null
            ? organizationId.value
            : this.organizationId),
        parameters: (parameters != null ? parameters.value : this.parameters));
  }
}

@JsonSerializable(explicitToJson: true)
class CreateSmartContractInterfaceResult {
  const CreateSmartContractInterfaceResult({
    required this.smartContractInterfaceId,
  });

  factory CreateSmartContractInterfaceResult.fromJson(
          Map<String, dynamic> json) =>
      _$CreateSmartContractInterfaceResultFromJson(json);

  static const toJsonFactory = _$CreateSmartContractInterfaceResultToJson;
  Map<String, dynamic> toJson() =>
      _$CreateSmartContractInterfaceResultToJson(this);

  @JsonKey(name: 'smartContractInterfaceId')
  final String smartContractInterfaceId;
  static const fromJsonFactory = _$CreateSmartContractInterfaceResultFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is CreateSmartContractInterfaceResult &&
            (identical(
                    other.smartContractInterfaceId, smartContractInterfaceId) ||
                const DeepCollectionEquality().equals(
                    other.smartContractInterfaceId, smartContractInterfaceId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(smartContractInterfaceId) ^
      runtimeType.hashCode;
}

extension $CreateSmartContractInterfaceResultExtension
    on CreateSmartContractInterfaceResult {
  CreateSmartContractInterfaceResult copyWith(
      {String? smartContractInterfaceId}) {
    return CreateSmartContractInterfaceResult(
        smartContractInterfaceId:
            smartContractInterfaceId ?? this.smartContractInterfaceId);
  }

  CreateSmartContractInterfaceResult copyWithWrapped(
      {Wrapped<String>? smartContractInterfaceId}) {
    return CreateSmartContractInterfaceResult(
        smartContractInterfaceId: (smartContractInterfaceId != null
            ? smartContractInterfaceId.value
            : this.smartContractInterfaceId));
  }
}

@JsonSerializable(explicitToJson: true)
class CreateSubOrganizationIntent {
  const CreateSubOrganizationIntent({
    required this.name,
    required this.rootAuthenticator,
  });

  factory CreateSubOrganizationIntent.fromJson(Map<String, dynamic> json) =>
      _$CreateSubOrganizationIntentFromJson(json);

  static const toJsonFactory = _$CreateSubOrganizationIntentToJson;
  Map<String, dynamic> toJson() => _$CreateSubOrganizationIntentToJson(this);

  @JsonKey(name: 'name')
  final String name;
  @JsonKey(name: 'rootAuthenticator')
  final AuthenticatorParamsV2 rootAuthenticator;
  static const fromJsonFactory = _$CreateSubOrganizationIntentFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is CreateSubOrganizationIntent &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.rootAuthenticator, rootAuthenticator) ||
                const DeepCollectionEquality()
                    .equals(other.rootAuthenticator, rootAuthenticator)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(rootAuthenticator) ^
      runtimeType.hashCode;
}

extension $CreateSubOrganizationIntentExtension on CreateSubOrganizationIntent {
  CreateSubOrganizationIntent copyWith(
      {String? name, AuthenticatorParamsV2? rootAuthenticator}) {
    return CreateSubOrganizationIntent(
        name: name ?? this.name,
        rootAuthenticator: rootAuthenticator ?? this.rootAuthenticator);
  }

  CreateSubOrganizationIntent copyWithWrapped(
      {Wrapped<String>? name,
      Wrapped<AuthenticatorParamsV2>? rootAuthenticator}) {
    return CreateSubOrganizationIntent(
        name: (name != null ? name.value : this.name),
        rootAuthenticator: (rootAuthenticator != null
            ? rootAuthenticator.value
            : this.rootAuthenticator));
  }
}

@JsonSerializable(explicitToJson: true)
class CreateSubOrganizationIntentV2 {
  const CreateSubOrganizationIntentV2({
    required this.subOrganizationName,
    required this.rootUsers,
    required this.rootQuorumThreshold,
  });

  factory CreateSubOrganizationIntentV2.fromJson(Map<String, dynamic> json) =>
      _$CreateSubOrganizationIntentV2FromJson(json);

  static const toJsonFactory = _$CreateSubOrganizationIntentV2ToJson;
  Map<String, dynamic> toJson() => _$CreateSubOrganizationIntentV2ToJson(this);

  @JsonKey(name: 'subOrganizationName')
  final String subOrganizationName;
  @JsonKey(name: 'rootUsers', defaultValue: <RootUserParams>[])
  final List<RootUserParams> rootUsers;
  @JsonKey(name: 'rootQuorumThreshold')
  final int rootQuorumThreshold;
  static const fromJsonFactory = _$CreateSubOrganizationIntentV2FromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is CreateSubOrganizationIntentV2 &&
            (identical(other.subOrganizationName, subOrganizationName) ||
                const DeepCollectionEquality()
                    .equals(other.subOrganizationName, subOrganizationName)) &&
            (identical(other.rootUsers, rootUsers) ||
                const DeepCollectionEquality()
                    .equals(other.rootUsers, rootUsers)) &&
            (identical(other.rootQuorumThreshold, rootQuorumThreshold) ||
                const DeepCollectionEquality()
                    .equals(other.rootQuorumThreshold, rootQuorumThreshold)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(subOrganizationName) ^
      const DeepCollectionEquality().hash(rootUsers) ^
      const DeepCollectionEquality().hash(rootQuorumThreshold) ^
      runtimeType.hashCode;
}

extension $CreateSubOrganizationIntentV2Extension
    on CreateSubOrganizationIntentV2 {
  CreateSubOrganizationIntentV2 copyWith(
      {String? subOrganizationName,
      List<RootUserParams>? rootUsers,
      int? rootQuorumThreshold}) {
    return CreateSubOrganizationIntentV2(
        subOrganizationName: subOrganizationName ?? this.subOrganizationName,
        rootUsers: rootUsers ?? this.rootUsers,
        rootQuorumThreshold: rootQuorumThreshold ?? this.rootQuorumThreshold);
  }

  CreateSubOrganizationIntentV2 copyWithWrapped(
      {Wrapped<String>? subOrganizationName,
      Wrapped<List<RootUserParams>>? rootUsers,
      Wrapped<int>? rootQuorumThreshold}) {
    return CreateSubOrganizationIntentV2(
        subOrganizationName: (subOrganizationName != null
            ? subOrganizationName.value
            : this.subOrganizationName),
        rootUsers: (rootUsers != null ? rootUsers.value : this.rootUsers),
        rootQuorumThreshold: (rootQuorumThreshold != null
            ? rootQuorumThreshold.value
            : this.rootQuorumThreshold));
  }
}

@JsonSerializable(explicitToJson: true)
class CreateSubOrganizationIntentV3 {
  const CreateSubOrganizationIntentV3({
    required this.subOrganizationName,
    required this.rootUsers,
    required this.rootQuorumThreshold,
    required this.privateKeys,
  });

  factory CreateSubOrganizationIntentV3.fromJson(Map<String, dynamic> json) =>
      _$CreateSubOrganizationIntentV3FromJson(json);

  static const toJsonFactory = _$CreateSubOrganizationIntentV3ToJson;
  Map<String, dynamic> toJson() => _$CreateSubOrganizationIntentV3ToJson(this);

  @JsonKey(name: 'subOrganizationName')
  final String subOrganizationName;
  @JsonKey(name: 'rootUsers', defaultValue: <RootUserParams>[])
  final List<RootUserParams> rootUsers;
  @JsonKey(name: 'rootQuorumThreshold')
  final int rootQuorumThreshold;
  @JsonKey(name: 'privateKeys', defaultValue: <PrivateKeyParams>[])
  final List<PrivateKeyParams> privateKeys;
  static const fromJsonFactory = _$CreateSubOrganizationIntentV3FromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is CreateSubOrganizationIntentV3 &&
            (identical(other.subOrganizationName, subOrganizationName) ||
                const DeepCollectionEquality()
                    .equals(other.subOrganizationName, subOrganizationName)) &&
            (identical(other.rootUsers, rootUsers) ||
                const DeepCollectionEquality()
                    .equals(other.rootUsers, rootUsers)) &&
            (identical(other.rootQuorumThreshold, rootQuorumThreshold) ||
                const DeepCollectionEquality()
                    .equals(other.rootQuorumThreshold, rootQuorumThreshold)) &&
            (identical(other.privateKeys, privateKeys) ||
                const DeepCollectionEquality()
                    .equals(other.privateKeys, privateKeys)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(subOrganizationName) ^
      const DeepCollectionEquality().hash(rootUsers) ^
      const DeepCollectionEquality().hash(rootQuorumThreshold) ^
      const DeepCollectionEquality().hash(privateKeys) ^
      runtimeType.hashCode;
}

extension $CreateSubOrganizationIntentV3Extension
    on CreateSubOrganizationIntentV3 {
  CreateSubOrganizationIntentV3 copyWith(
      {String? subOrganizationName,
      List<RootUserParams>? rootUsers,
      int? rootQuorumThreshold,
      List<PrivateKeyParams>? privateKeys}) {
    return CreateSubOrganizationIntentV3(
        subOrganizationName: subOrganizationName ?? this.subOrganizationName,
        rootUsers: rootUsers ?? this.rootUsers,
        rootQuorumThreshold: rootQuorumThreshold ?? this.rootQuorumThreshold,
        privateKeys: privateKeys ?? this.privateKeys);
  }

  CreateSubOrganizationIntentV3 copyWithWrapped(
      {Wrapped<String>? subOrganizationName,
      Wrapped<List<RootUserParams>>? rootUsers,
      Wrapped<int>? rootQuorumThreshold,
      Wrapped<List<PrivateKeyParams>>? privateKeys}) {
    return CreateSubOrganizationIntentV3(
        subOrganizationName: (subOrganizationName != null
            ? subOrganizationName.value
            : this.subOrganizationName),
        rootUsers: (rootUsers != null ? rootUsers.value : this.rootUsers),
        rootQuorumThreshold: (rootQuorumThreshold != null
            ? rootQuorumThreshold.value
            : this.rootQuorumThreshold),
        privateKeys:
            (privateKeys != null ? privateKeys.value : this.privateKeys));
  }
}

@JsonSerializable(explicitToJson: true)
class CreateSubOrganizationIntentV4 {
  const CreateSubOrganizationIntentV4({
    required this.subOrganizationName,
    required this.rootUsers,
    required this.rootQuorumThreshold,
    this.wallet,
    this.disableEmailRecovery,
    this.disableEmailAuth,
  });

  factory CreateSubOrganizationIntentV4.fromJson(Map<String, dynamic> json) =>
      _$CreateSubOrganizationIntentV4FromJson(json);

  static const toJsonFactory = _$CreateSubOrganizationIntentV4ToJson;
  Map<String, dynamic> toJson() => _$CreateSubOrganizationIntentV4ToJson(this);

  @JsonKey(name: 'subOrganizationName')
  final String subOrganizationName;
  @JsonKey(name: 'rootUsers', defaultValue: <RootUserParams>[])
  final List<RootUserParams> rootUsers;
  @JsonKey(name: 'rootQuorumThreshold')
  final int rootQuorumThreshold;
  @JsonKey(name: 'wallet')
  final WalletParams? wallet;
  @JsonKey(name: 'disableEmailRecovery')
  final bool? disableEmailRecovery;
  @JsonKey(name: 'disableEmailAuth')
  final bool? disableEmailAuth;
  static const fromJsonFactory = _$CreateSubOrganizationIntentV4FromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is CreateSubOrganizationIntentV4 &&
            (identical(other.subOrganizationName, subOrganizationName) ||
                const DeepCollectionEquality()
                    .equals(other.subOrganizationName, subOrganizationName)) &&
            (identical(other.rootUsers, rootUsers) ||
                const DeepCollectionEquality()
                    .equals(other.rootUsers, rootUsers)) &&
            (identical(other.rootQuorumThreshold, rootQuorumThreshold) ||
                const DeepCollectionEquality()
                    .equals(other.rootQuorumThreshold, rootQuorumThreshold)) &&
            (identical(other.wallet, wallet) ||
                const DeepCollectionEquality().equals(other.wallet, wallet)) &&
            (identical(other.disableEmailRecovery, disableEmailRecovery) ||
                const DeepCollectionEquality().equals(
                    other.disableEmailRecovery, disableEmailRecovery)) &&
            (identical(other.disableEmailAuth, disableEmailAuth) ||
                const DeepCollectionEquality()
                    .equals(other.disableEmailAuth, disableEmailAuth)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(subOrganizationName) ^
      const DeepCollectionEquality().hash(rootUsers) ^
      const DeepCollectionEquality().hash(rootQuorumThreshold) ^
      const DeepCollectionEquality().hash(wallet) ^
      const DeepCollectionEquality().hash(disableEmailRecovery) ^
      const DeepCollectionEquality().hash(disableEmailAuth) ^
      runtimeType.hashCode;
}

extension $CreateSubOrganizationIntentV4Extension
    on CreateSubOrganizationIntentV4 {
  CreateSubOrganizationIntentV4 copyWith(
      {String? subOrganizationName,
      List<RootUserParams>? rootUsers,
      int? rootQuorumThreshold,
      WalletParams? wallet,
      bool? disableEmailRecovery,
      bool? disableEmailAuth}) {
    return CreateSubOrganizationIntentV4(
        subOrganizationName: subOrganizationName ?? this.subOrganizationName,
        rootUsers: rootUsers ?? this.rootUsers,
        rootQuorumThreshold: rootQuorumThreshold ?? this.rootQuorumThreshold,
        wallet: wallet ?? this.wallet,
        disableEmailRecovery: disableEmailRecovery ?? this.disableEmailRecovery,
        disableEmailAuth: disableEmailAuth ?? this.disableEmailAuth);
  }

  CreateSubOrganizationIntentV4 copyWithWrapped(
      {Wrapped<String>? subOrganizationName,
      Wrapped<List<RootUserParams>>? rootUsers,
      Wrapped<int>? rootQuorumThreshold,
      Wrapped<WalletParams?>? wallet,
      Wrapped<bool?>? disableEmailRecovery,
      Wrapped<bool?>? disableEmailAuth}) {
    return CreateSubOrganizationIntentV4(
        subOrganizationName: (subOrganizationName != null
            ? subOrganizationName.value
            : this.subOrganizationName),
        rootUsers: (rootUsers != null ? rootUsers.value : this.rootUsers),
        rootQuorumThreshold: (rootQuorumThreshold != null
            ? rootQuorumThreshold.value
            : this.rootQuorumThreshold),
        wallet: (wallet != null ? wallet.value : this.wallet),
        disableEmailRecovery: (disableEmailRecovery != null
            ? disableEmailRecovery.value
            : this.disableEmailRecovery),
        disableEmailAuth: (disableEmailAuth != null
            ? disableEmailAuth.value
            : this.disableEmailAuth));
  }
}

@JsonSerializable(explicitToJson: true)
class CreateSubOrganizationIntentV5 {
  const CreateSubOrganizationIntentV5({
    required this.subOrganizationName,
    required this.rootUsers,
    required this.rootQuorumThreshold,
    this.wallet,
    this.disableEmailRecovery,
    this.disableEmailAuth,
  });

  factory CreateSubOrganizationIntentV5.fromJson(Map<String, dynamic> json) =>
      _$CreateSubOrganizationIntentV5FromJson(json);

  static const toJsonFactory = _$CreateSubOrganizationIntentV5ToJson;
  Map<String, dynamic> toJson() => _$CreateSubOrganizationIntentV5ToJson(this);

  @JsonKey(name: 'subOrganizationName')
  final String subOrganizationName;
  @JsonKey(name: 'rootUsers', defaultValue: <RootUserParamsV2>[])
  final List<RootUserParamsV2> rootUsers;
  @JsonKey(name: 'rootQuorumThreshold')
  final int rootQuorumThreshold;
  @JsonKey(name: 'wallet')
  final WalletParams? wallet;
  @JsonKey(name: 'disableEmailRecovery')
  final bool? disableEmailRecovery;
  @JsonKey(name: 'disableEmailAuth')
  final bool? disableEmailAuth;
  static const fromJsonFactory = _$CreateSubOrganizationIntentV5FromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is CreateSubOrganizationIntentV5 &&
            (identical(other.subOrganizationName, subOrganizationName) ||
                const DeepCollectionEquality()
                    .equals(other.subOrganizationName, subOrganizationName)) &&
            (identical(other.rootUsers, rootUsers) ||
                const DeepCollectionEquality()
                    .equals(other.rootUsers, rootUsers)) &&
            (identical(other.rootQuorumThreshold, rootQuorumThreshold) ||
                const DeepCollectionEquality()
                    .equals(other.rootQuorumThreshold, rootQuorumThreshold)) &&
            (identical(other.wallet, wallet) ||
                const DeepCollectionEquality().equals(other.wallet, wallet)) &&
            (identical(other.disableEmailRecovery, disableEmailRecovery) ||
                const DeepCollectionEquality().equals(
                    other.disableEmailRecovery, disableEmailRecovery)) &&
            (identical(other.disableEmailAuth, disableEmailAuth) ||
                const DeepCollectionEquality()
                    .equals(other.disableEmailAuth, disableEmailAuth)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(subOrganizationName) ^
      const DeepCollectionEquality().hash(rootUsers) ^
      const DeepCollectionEquality().hash(rootQuorumThreshold) ^
      const DeepCollectionEquality().hash(wallet) ^
      const DeepCollectionEquality().hash(disableEmailRecovery) ^
      const DeepCollectionEquality().hash(disableEmailAuth) ^
      runtimeType.hashCode;
}

extension $CreateSubOrganizationIntentV5Extension
    on CreateSubOrganizationIntentV5 {
  CreateSubOrganizationIntentV5 copyWith(
      {String? subOrganizationName,
      List<RootUserParamsV2>? rootUsers,
      int? rootQuorumThreshold,
      WalletParams? wallet,
      bool? disableEmailRecovery,
      bool? disableEmailAuth}) {
    return CreateSubOrganizationIntentV5(
        subOrganizationName: subOrganizationName ?? this.subOrganizationName,
        rootUsers: rootUsers ?? this.rootUsers,
        rootQuorumThreshold: rootQuorumThreshold ?? this.rootQuorumThreshold,
        wallet: wallet ?? this.wallet,
        disableEmailRecovery: disableEmailRecovery ?? this.disableEmailRecovery,
        disableEmailAuth: disableEmailAuth ?? this.disableEmailAuth);
  }

  CreateSubOrganizationIntentV5 copyWithWrapped(
      {Wrapped<String>? subOrganizationName,
      Wrapped<List<RootUserParamsV2>>? rootUsers,
      Wrapped<int>? rootQuorumThreshold,
      Wrapped<WalletParams?>? wallet,
      Wrapped<bool?>? disableEmailRecovery,
      Wrapped<bool?>? disableEmailAuth}) {
    return CreateSubOrganizationIntentV5(
        subOrganizationName: (subOrganizationName != null
            ? subOrganizationName.value
            : this.subOrganizationName),
        rootUsers: (rootUsers != null ? rootUsers.value : this.rootUsers),
        rootQuorumThreshold: (rootQuorumThreshold != null
            ? rootQuorumThreshold.value
            : this.rootQuorumThreshold),
        wallet: (wallet != null ? wallet.value : this.wallet),
        disableEmailRecovery: (disableEmailRecovery != null
            ? disableEmailRecovery.value
            : this.disableEmailRecovery),
        disableEmailAuth: (disableEmailAuth != null
            ? disableEmailAuth.value
            : this.disableEmailAuth));
  }
}

@JsonSerializable(explicitToJson: true)
class CreateSubOrganizationIntentV6 {
  const CreateSubOrganizationIntentV6({
    required this.subOrganizationName,
    required this.rootUsers,
    required this.rootQuorumThreshold,
    this.wallet,
    this.disableEmailRecovery,
    this.disableEmailAuth,
  });

  factory CreateSubOrganizationIntentV6.fromJson(Map<String, dynamic> json) =>
      _$CreateSubOrganizationIntentV6FromJson(json);

  static const toJsonFactory = _$CreateSubOrganizationIntentV6ToJson;
  Map<String, dynamic> toJson() => _$CreateSubOrganizationIntentV6ToJson(this);

  @JsonKey(name: 'subOrganizationName')
  final String subOrganizationName;
  @JsonKey(name: 'rootUsers', defaultValue: <RootUserParamsV3>[])
  final List<RootUserParamsV3> rootUsers;
  @JsonKey(name: 'rootQuorumThreshold')
  final int rootQuorumThreshold;
  @JsonKey(name: 'wallet')
  final WalletParams? wallet;
  @JsonKey(name: 'disableEmailRecovery')
  final bool? disableEmailRecovery;
  @JsonKey(name: 'disableEmailAuth')
  final bool? disableEmailAuth;
  static const fromJsonFactory = _$CreateSubOrganizationIntentV6FromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is CreateSubOrganizationIntentV6 &&
            (identical(other.subOrganizationName, subOrganizationName) ||
                const DeepCollectionEquality()
                    .equals(other.subOrganizationName, subOrganizationName)) &&
            (identical(other.rootUsers, rootUsers) ||
                const DeepCollectionEquality()
                    .equals(other.rootUsers, rootUsers)) &&
            (identical(other.rootQuorumThreshold, rootQuorumThreshold) ||
                const DeepCollectionEquality()
                    .equals(other.rootQuorumThreshold, rootQuorumThreshold)) &&
            (identical(other.wallet, wallet) ||
                const DeepCollectionEquality().equals(other.wallet, wallet)) &&
            (identical(other.disableEmailRecovery, disableEmailRecovery) ||
                const DeepCollectionEquality().equals(
                    other.disableEmailRecovery, disableEmailRecovery)) &&
            (identical(other.disableEmailAuth, disableEmailAuth) ||
                const DeepCollectionEquality()
                    .equals(other.disableEmailAuth, disableEmailAuth)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(subOrganizationName) ^
      const DeepCollectionEquality().hash(rootUsers) ^
      const DeepCollectionEquality().hash(rootQuorumThreshold) ^
      const DeepCollectionEquality().hash(wallet) ^
      const DeepCollectionEquality().hash(disableEmailRecovery) ^
      const DeepCollectionEquality().hash(disableEmailAuth) ^
      runtimeType.hashCode;
}

extension $CreateSubOrganizationIntentV6Extension
    on CreateSubOrganizationIntentV6 {
  CreateSubOrganizationIntentV6 copyWith(
      {String? subOrganizationName,
      List<RootUserParamsV3>? rootUsers,
      int? rootQuorumThreshold,
      WalletParams? wallet,
      bool? disableEmailRecovery,
      bool? disableEmailAuth}) {
    return CreateSubOrganizationIntentV6(
        subOrganizationName: subOrganizationName ?? this.subOrganizationName,
        rootUsers: rootUsers ?? this.rootUsers,
        rootQuorumThreshold: rootQuorumThreshold ?? this.rootQuorumThreshold,
        wallet: wallet ?? this.wallet,
        disableEmailRecovery: disableEmailRecovery ?? this.disableEmailRecovery,
        disableEmailAuth: disableEmailAuth ?? this.disableEmailAuth);
  }

  CreateSubOrganizationIntentV6 copyWithWrapped(
      {Wrapped<String>? subOrganizationName,
      Wrapped<List<RootUserParamsV3>>? rootUsers,
      Wrapped<int>? rootQuorumThreshold,
      Wrapped<WalletParams?>? wallet,
      Wrapped<bool?>? disableEmailRecovery,
      Wrapped<bool?>? disableEmailAuth}) {
    return CreateSubOrganizationIntentV6(
        subOrganizationName: (subOrganizationName != null
            ? subOrganizationName.value
            : this.subOrganizationName),
        rootUsers: (rootUsers != null ? rootUsers.value : this.rootUsers),
        rootQuorumThreshold: (rootQuorumThreshold != null
            ? rootQuorumThreshold.value
            : this.rootQuorumThreshold),
        wallet: (wallet != null ? wallet.value : this.wallet),
        disableEmailRecovery: (disableEmailRecovery != null
            ? disableEmailRecovery.value
            : this.disableEmailRecovery),
        disableEmailAuth: (disableEmailAuth != null
            ? disableEmailAuth.value
            : this.disableEmailAuth));
  }
}

@JsonSerializable(explicitToJson: true)
class CreateSubOrganizationIntentV7 {
  const CreateSubOrganizationIntentV7({
    required this.subOrganizationName,
    required this.rootUsers,
    required this.rootQuorumThreshold,
    this.wallet,
    this.disableEmailRecovery,
    this.disableEmailAuth,
    this.disableSmsAuth,
    this.disableOtpEmailAuth,
  });

  factory CreateSubOrganizationIntentV7.fromJson(Map<String, dynamic> json) =>
      _$CreateSubOrganizationIntentV7FromJson(json);

  static const toJsonFactory = _$CreateSubOrganizationIntentV7ToJson;
  Map<String, dynamic> toJson() => _$CreateSubOrganizationIntentV7ToJson(this);

  @JsonKey(name: 'subOrganizationName')
  final String subOrganizationName;
  @JsonKey(name: 'rootUsers', defaultValue: <RootUserParamsV4>[])
  final List<RootUserParamsV4> rootUsers;
  @JsonKey(name: 'rootQuorumThreshold')
  final int rootQuorumThreshold;
  @JsonKey(name: 'wallet')
  final WalletParams? wallet;
  @JsonKey(name: 'disableEmailRecovery')
  final bool? disableEmailRecovery;
  @JsonKey(name: 'disableEmailAuth')
  final bool? disableEmailAuth;
  @JsonKey(name: 'disableSmsAuth')
  final bool? disableSmsAuth;
  @JsonKey(name: 'disableOtpEmailAuth')
  final bool? disableOtpEmailAuth;
  static const fromJsonFactory = _$CreateSubOrganizationIntentV7FromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is CreateSubOrganizationIntentV7 &&
            (identical(other.subOrganizationName, subOrganizationName) ||
                const DeepCollectionEquality()
                    .equals(other.subOrganizationName, subOrganizationName)) &&
            (identical(other.rootUsers, rootUsers) ||
                const DeepCollectionEquality()
                    .equals(other.rootUsers, rootUsers)) &&
            (identical(other.rootQuorumThreshold, rootQuorumThreshold) ||
                const DeepCollectionEquality()
                    .equals(other.rootQuorumThreshold, rootQuorumThreshold)) &&
            (identical(other.wallet, wallet) ||
                const DeepCollectionEquality().equals(other.wallet, wallet)) &&
            (identical(other.disableEmailRecovery, disableEmailRecovery) ||
                const DeepCollectionEquality().equals(
                    other.disableEmailRecovery, disableEmailRecovery)) &&
            (identical(other.disableEmailAuth, disableEmailAuth) ||
                const DeepCollectionEquality()
                    .equals(other.disableEmailAuth, disableEmailAuth)) &&
            (identical(other.disableSmsAuth, disableSmsAuth) ||
                const DeepCollectionEquality()
                    .equals(other.disableSmsAuth, disableSmsAuth)) &&
            (identical(other.disableOtpEmailAuth, disableOtpEmailAuth) ||
                const DeepCollectionEquality()
                    .equals(other.disableOtpEmailAuth, disableOtpEmailAuth)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(subOrganizationName) ^
      const DeepCollectionEquality().hash(rootUsers) ^
      const DeepCollectionEquality().hash(rootQuorumThreshold) ^
      const DeepCollectionEquality().hash(wallet) ^
      const DeepCollectionEquality().hash(disableEmailRecovery) ^
      const DeepCollectionEquality().hash(disableEmailAuth) ^
      const DeepCollectionEquality().hash(disableSmsAuth) ^
      const DeepCollectionEquality().hash(disableOtpEmailAuth) ^
      runtimeType.hashCode;
}

extension $CreateSubOrganizationIntentV7Extension
    on CreateSubOrganizationIntentV7 {
  CreateSubOrganizationIntentV7 copyWith(
      {String? subOrganizationName,
      List<RootUserParamsV4>? rootUsers,
      int? rootQuorumThreshold,
      WalletParams? wallet,
      bool? disableEmailRecovery,
      bool? disableEmailAuth,
      bool? disableSmsAuth,
      bool? disableOtpEmailAuth}) {
    return CreateSubOrganizationIntentV7(
        subOrganizationName: subOrganizationName ?? this.subOrganizationName,
        rootUsers: rootUsers ?? this.rootUsers,
        rootQuorumThreshold: rootQuorumThreshold ?? this.rootQuorumThreshold,
        wallet: wallet ?? this.wallet,
        disableEmailRecovery: disableEmailRecovery ?? this.disableEmailRecovery,
        disableEmailAuth: disableEmailAuth ?? this.disableEmailAuth,
        disableSmsAuth: disableSmsAuth ?? this.disableSmsAuth,
        disableOtpEmailAuth: disableOtpEmailAuth ?? this.disableOtpEmailAuth);
  }

  CreateSubOrganizationIntentV7 copyWithWrapped(
      {Wrapped<String>? subOrganizationName,
      Wrapped<List<RootUserParamsV4>>? rootUsers,
      Wrapped<int>? rootQuorumThreshold,
      Wrapped<WalletParams?>? wallet,
      Wrapped<bool?>? disableEmailRecovery,
      Wrapped<bool?>? disableEmailAuth,
      Wrapped<bool?>? disableSmsAuth,
      Wrapped<bool?>? disableOtpEmailAuth}) {
    return CreateSubOrganizationIntentV7(
        subOrganizationName: (subOrganizationName != null
            ? subOrganizationName.value
            : this.subOrganizationName),
        rootUsers: (rootUsers != null ? rootUsers.value : this.rootUsers),
        rootQuorumThreshold: (rootQuorumThreshold != null
            ? rootQuorumThreshold.value
            : this.rootQuorumThreshold),
        wallet: (wallet != null ? wallet.value : this.wallet),
        disableEmailRecovery: (disableEmailRecovery != null
            ? disableEmailRecovery.value
            : this.disableEmailRecovery),
        disableEmailAuth: (disableEmailAuth != null
            ? disableEmailAuth.value
            : this.disableEmailAuth),
        disableSmsAuth: (disableSmsAuth != null
            ? disableSmsAuth.value
            : this.disableSmsAuth),
        disableOtpEmailAuth: (disableOtpEmailAuth != null
            ? disableOtpEmailAuth.value
            : this.disableOtpEmailAuth));
  }
}

@JsonSerializable(explicitToJson: true)
class CreateSubOrganizationRequest {
  const CreateSubOrganizationRequest({
    required this.type,
    required this.timestampMs,
    required this.organizationId,
    required this.parameters,
  });

  factory CreateSubOrganizationRequest.fromJson(Map<String, dynamic> json) =>
      _$CreateSubOrganizationRequestFromJson(json);

  static const toJsonFactory = _$CreateSubOrganizationRequestToJson;
  Map<String, dynamic> toJson() => _$CreateSubOrganizationRequestToJson(this);

  @JsonKey(
    name: 'type',
    toJson: createSubOrganizationRequestTypeToJson,
    fromJson: createSubOrganizationRequestTypeFromJson,
  )
  final enums.CreateSubOrganizationRequestType type;
  @JsonKey(name: 'timestampMs')
  final String timestampMs;
  @JsonKey(name: 'organizationId')
  final String organizationId;
  @JsonKey(name: 'parameters')
  final CreateSubOrganizationIntentV7 parameters;
  static const fromJsonFactory = _$CreateSubOrganizationRequestFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is CreateSubOrganizationRequest &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.timestampMs, timestampMs) ||
                const DeepCollectionEquality()
                    .equals(other.timestampMs, timestampMs)) &&
            (identical(other.organizationId, organizationId) ||
                const DeepCollectionEquality()
                    .equals(other.organizationId, organizationId)) &&
            (identical(other.parameters, parameters) ||
                const DeepCollectionEquality()
                    .equals(other.parameters, parameters)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(timestampMs) ^
      const DeepCollectionEquality().hash(organizationId) ^
      const DeepCollectionEquality().hash(parameters) ^
      runtimeType.hashCode;
}

extension $CreateSubOrganizationRequestExtension
    on CreateSubOrganizationRequest {
  CreateSubOrganizationRequest copyWith(
      {enums.CreateSubOrganizationRequestType? type,
      String? timestampMs,
      String? organizationId,
      CreateSubOrganizationIntentV7? parameters}) {
    return CreateSubOrganizationRequest(
        type: type ?? this.type,
        timestampMs: timestampMs ?? this.timestampMs,
        organizationId: organizationId ?? this.organizationId,
        parameters: parameters ?? this.parameters);
  }

  CreateSubOrganizationRequest copyWithWrapped(
      {Wrapped<enums.CreateSubOrganizationRequestType>? type,
      Wrapped<String>? timestampMs,
      Wrapped<String>? organizationId,
      Wrapped<CreateSubOrganizationIntentV7>? parameters}) {
    return CreateSubOrganizationRequest(
        type: (type != null ? type.value : this.type),
        timestampMs:
            (timestampMs != null ? timestampMs.value : this.timestampMs),
        organizationId: (organizationId != null
            ? organizationId.value
            : this.organizationId),
        parameters: (parameters != null ? parameters.value : this.parameters));
  }
}

@JsonSerializable(explicitToJson: true)
class CreateSubOrganizationResult {
  const CreateSubOrganizationResult({
    required this.subOrganizationId,
    this.rootUserIds,
  });

  factory CreateSubOrganizationResult.fromJson(Map<String, dynamic> json) =>
      _$CreateSubOrganizationResultFromJson(json);

  static const toJsonFactory = _$CreateSubOrganizationResultToJson;
  Map<String, dynamic> toJson() => _$CreateSubOrganizationResultToJson(this);

  @JsonKey(name: 'subOrganizationId')
  final String subOrganizationId;
  @JsonKey(name: 'rootUserIds', defaultValue: <String>[])
  final List<String>? rootUserIds;
  static const fromJsonFactory = _$CreateSubOrganizationResultFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is CreateSubOrganizationResult &&
            (identical(other.subOrganizationId, subOrganizationId) ||
                const DeepCollectionEquality()
                    .equals(other.subOrganizationId, subOrganizationId)) &&
            (identical(other.rootUserIds, rootUserIds) ||
                const DeepCollectionEquality()
                    .equals(other.rootUserIds, rootUserIds)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(subOrganizationId) ^
      const DeepCollectionEquality().hash(rootUserIds) ^
      runtimeType.hashCode;
}

extension $CreateSubOrganizationResultExtension on CreateSubOrganizationResult {
  CreateSubOrganizationResult copyWith(
      {String? subOrganizationId, List<String>? rootUserIds}) {
    return CreateSubOrganizationResult(
        subOrganizationId: subOrganizationId ?? this.subOrganizationId,
        rootUserIds: rootUserIds ?? this.rootUserIds);
  }

  CreateSubOrganizationResult copyWithWrapped(
      {Wrapped<String>? subOrganizationId,
      Wrapped<List<String>?>? rootUserIds}) {
    return CreateSubOrganizationResult(
        subOrganizationId: (subOrganizationId != null
            ? subOrganizationId.value
            : this.subOrganizationId),
        rootUserIds:
            (rootUserIds != null ? rootUserIds.value : this.rootUserIds));
  }
}

@JsonSerializable(explicitToJson: true)
class CreateSubOrganizationResultV3 {
  const CreateSubOrganizationResultV3({
    required this.subOrganizationId,
    required this.privateKeys,
    this.rootUserIds,
  });

  factory CreateSubOrganizationResultV3.fromJson(Map<String, dynamic> json) =>
      _$CreateSubOrganizationResultV3FromJson(json);

  static const toJsonFactory = _$CreateSubOrganizationResultV3ToJson;
  Map<String, dynamic> toJson() => _$CreateSubOrganizationResultV3ToJson(this);

  @JsonKey(name: 'subOrganizationId')
  final String subOrganizationId;
  @JsonKey(name: 'privateKeys', defaultValue: <PrivateKeyResult>[])
  final List<PrivateKeyResult> privateKeys;
  @JsonKey(name: 'rootUserIds', defaultValue: <String>[])
  final List<String>? rootUserIds;
  static const fromJsonFactory = _$CreateSubOrganizationResultV3FromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is CreateSubOrganizationResultV3 &&
            (identical(other.subOrganizationId, subOrganizationId) ||
                const DeepCollectionEquality()
                    .equals(other.subOrganizationId, subOrganizationId)) &&
            (identical(other.privateKeys, privateKeys) ||
                const DeepCollectionEquality()
                    .equals(other.privateKeys, privateKeys)) &&
            (identical(other.rootUserIds, rootUserIds) ||
                const DeepCollectionEquality()
                    .equals(other.rootUserIds, rootUserIds)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(subOrganizationId) ^
      const DeepCollectionEquality().hash(privateKeys) ^
      const DeepCollectionEquality().hash(rootUserIds) ^
      runtimeType.hashCode;
}

extension $CreateSubOrganizationResultV3Extension
    on CreateSubOrganizationResultV3 {
  CreateSubOrganizationResultV3 copyWith(
      {String? subOrganizationId,
      List<PrivateKeyResult>? privateKeys,
      List<String>? rootUserIds}) {
    return CreateSubOrganizationResultV3(
        subOrganizationId: subOrganizationId ?? this.subOrganizationId,
        privateKeys: privateKeys ?? this.privateKeys,
        rootUserIds: rootUserIds ?? this.rootUserIds);
  }

  CreateSubOrganizationResultV3 copyWithWrapped(
      {Wrapped<String>? subOrganizationId,
      Wrapped<List<PrivateKeyResult>>? privateKeys,
      Wrapped<List<String>?>? rootUserIds}) {
    return CreateSubOrganizationResultV3(
        subOrganizationId: (subOrganizationId != null
            ? subOrganizationId.value
            : this.subOrganizationId),
        privateKeys:
            (privateKeys != null ? privateKeys.value : this.privateKeys),
        rootUserIds:
            (rootUserIds != null ? rootUserIds.value : this.rootUserIds));
  }
}

@JsonSerializable(explicitToJson: true)
class CreateSubOrganizationResultV4 {
  const CreateSubOrganizationResultV4({
    required this.subOrganizationId,
    this.wallet,
    this.rootUserIds,
  });

  factory CreateSubOrganizationResultV4.fromJson(Map<String, dynamic> json) =>
      _$CreateSubOrganizationResultV4FromJson(json);

  static const toJsonFactory = _$CreateSubOrganizationResultV4ToJson;
  Map<String, dynamic> toJson() => _$CreateSubOrganizationResultV4ToJson(this);

  @JsonKey(name: 'subOrganizationId')
  final String subOrganizationId;
  @JsonKey(name: 'wallet')
  final WalletResult? wallet;
  @JsonKey(name: 'rootUserIds', defaultValue: <String>[])
  final List<String>? rootUserIds;
  static const fromJsonFactory = _$CreateSubOrganizationResultV4FromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is CreateSubOrganizationResultV4 &&
            (identical(other.subOrganizationId, subOrganizationId) ||
                const DeepCollectionEquality()
                    .equals(other.subOrganizationId, subOrganizationId)) &&
            (identical(other.wallet, wallet) ||
                const DeepCollectionEquality().equals(other.wallet, wallet)) &&
            (identical(other.rootUserIds, rootUserIds) ||
                const DeepCollectionEquality()
                    .equals(other.rootUserIds, rootUserIds)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(subOrganizationId) ^
      const DeepCollectionEquality().hash(wallet) ^
      const DeepCollectionEquality().hash(rootUserIds) ^
      runtimeType.hashCode;
}

extension $CreateSubOrganizationResultV4Extension
    on CreateSubOrganizationResultV4 {
  CreateSubOrganizationResultV4 copyWith(
      {String? subOrganizationId,
      WalletResult? wallet,
      List<String>? rootUserIds}) {
    return CreateSubOrganizationResultV4(
        subOrganizationId: subOrganizationId ?? this.subOrganizationId,
        wallet: wallet ?? this.wallet,
        rootUserIds: rootUserIds ?? this.rootUserIds);
  }

  CreateSubOrganizationResultV4 copyWithWrapped(
      {Wrapped<String>? subOrganizationId,
      Wrapped<WalletResult?>? wallet,
      Wrapped<List<String>?>? rootUserIds}) {
    return CreateSubOrganizationResultV4(
        subOrganizationId: (subOrganizationId != null
            ? subOrganizationId.value
            : this.subOrganizationId),
        wallet: (wallet != null ? wallet.value : this.wallet),
        rootUserIds:
            (rootUserIds != null ? rootUserIds.value : this.rootUserIds));
  }
}

@JsonSerializable(explicitToJson: true)
class CreateSubOrganizationResultV5 {
  const CreateSubOrganizationResultV5({
    required this.subOrganizationId,
    this.wallet,
    this.rootUserIds,
  });

  factory CreateSubOrganizationResultV5.fromJson(Map<String, dynamic> json) =>
      _$CreateSubOrganizationResultV5FromJson(json);

  static const toJsonFactory = _$CreateSubOrganizationResultV5ToJson;
  Map<String, dynamic> toJson() => _$CreateSubOrganizationResultV5ToJson(this);

  @JsonKey(name: 'subOrganizationId')
  final String subOrganizationId;
  @JsonKey(name: 'wallet')
  final WalletResult? wallet;
  @JsonKey(name: 'rootUserIds', defaultValue: <String>[])
  final List<String>? rootUserIds;
  static const fromJsonFactory = _$CreateSubOrganizationResultV5FromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is CreateSubOrganizationResultV5 &&
            (identical(other.subOrganizationId, subOrganizationId) ||
                const DeepCollectionEquality()
                    .equals(other.subOrganizationId, subOrganizationId)) &&
            (identical(other.wallet, wallet) ||
                const DeepCollectionEquality().equals(other.wallet, wallet)) &&
            (identical(other.rootUserIds, rootUserIds) ||
                const DeepCollectionEquality()
                    .equals(other.rootUserIds, rootUserIds)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(subOrganizationId) ^
      const DeepCollectionEquality().hash(wallet) ^
      const DeepCollectionEquality().hash(rootUserIds) ^
      runtimeType.hashCode;
}

extension $CreateSubOrganizationResultV5Extension
    on CreateSubOrganizationResultV5 {
  CreateSubOrganizationResultV5 copyWith(
      {String? subOrganizationId,
      WalletResult? wallet,
      List<String>? rootUserIds}) {
    return CreateSubOrganizationResultV5(
        subOrganizationId: subOrganizationId ?? this.subOrganizationId,
        wallet: wallet ?? this.wallet,
        rootUserIds: rootUserIds ?? this.rootUserIds);
  }

  CreateSubOrganizationResultV5 copyWithWrapped(
      {Wrapped<String>? subOrganizationId,
      Wrapped<WalletResult?>? wallet,
      Wrapped<List<String>?>? rootUserIds}) {
    return CreateSubOrganizationResultV5(
        subOrganizationId: (subOrganizationId != null
            ? subOrganizationId.value
            : this.subOrganizationId),
        wallet: (wallet != null ? wallet.value : this.wallet),
        rootUserIds:
            (rootUserIds != null ? rootUserIds.value : this.rootUserIds));
  }
}

@JsonSerializable(explicitToJson: true)
class CreateSubOrganizationResultV6 {
  const CreateSubOrganizationResultV6({
    required this.subOrganizationId,
    this.wallet,
    this.rootUserIds,
  });

  factory CreateSubOrganizationResultV6.fromJson(Map<String, dynamic> json) =>
      _$CreateSubOrganizationResultV6FromJson(json);

  static const toJsonFactory = _$CreateSubOrganizationResultV6ToJson;
  Map<String, dynamic> toJson() => _$CreateSubOrganizationResultV6ToJson(this);

  @JsonKey(name: 'subOrganizationId')
  final String subOrganizationId;
  @JsonKey(name: 'wallet')
  final WalletResult? wallet;
  @JsonKey(name: 'rootUserIds', defaultValue: <String>[])
  final List<String>? rootUserIds;
  static const fromJsonFactory = _$CreateSubOrganizationResultV6FromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is CreateSubOrganizationResultV6 &&
            (identical(other.subOrganizationId, subOrganizationId) ||
                const DeepCollectionEquality()
                    .equals(other.subOrganizationId, subOrganizationId)) &&
            (identical(other.wallet, wallet) ||
                const DeepCollectionEquality().equals(other.wallet, wallet)) &&
            (identical(other.rootUserIds, rootUserIds) ||
                const DeepCollectionEquality()
                    .equals(other.rootUserIds, rootUserIds)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(subOrganizationId) ^
      const DeepCollectionEquality().hash(wallet) ^
      const DeepCollectionEquality().hash(rootUserIds) ^
      runtimeType.hashCode;
}

extension $CreateSubOrganizationResultV6Extension
    on CreateSubOrganizationResultV6 {
  CreateSubOrganizationResultV6 copyWith(
      {String? subOrganizationId,
      WalletResult? wallet,
      List<String>? rootUserIds}) {
    return CreateSubOrganizationResultV6(
        subOrganizationId: subOrganizationId ?? this.subOrganizationId,
        wallet: wallet ?? this.wallet,
        rootUserIds: rootUserIds ?? this.rootUserIds);
  }

  CreateSubOrganizationResultV6 copyWithWrapped(
      {Wrapped<String>? subOrganizationId,
      Wrapped<WalletResult?>? wallet,
      Wrapped<List<String>?>? rootUserIds}) {
    return CreateSubOrganizationResultV6(
        subOrganizationId: (subOrganizationId != null
            ? subOrganizationId.value
            : this.subOrganizationId),
        wallet: (wallet != null ? wallet.value : this.wallet),
        rootUserIds:
            (rootUserIds != null ? rootUserIds.value : this.rootUserIds));
  }
}

@JsonSerializable(explicitToJson: true)
class CreateSubOrganizationResultV7 {
  const CreateSubOrganizationResultV7({
    required this.subOrganizationId,
    this.wallet,
    this.rootUserIds,
  });

  factory CreateSubOrganizationResultV7.fromJson(Map<String, dynamic> json) =>
      _$CreateSubOrganizationResultV7FromJson(json);

  static const toJsonFactory = _$CreateSubOrganizationResultV7ToJson;
  Map<String, dynamic> toJson() => _$CreateSubOrganizationResultV7ToJson(this);

  @JsonKey(name: 'subOrganizationId')
  final String subOrganizationId;
  @JsonKey(name: 'wallet')
  final WalletResult? wallet;
  @JsonKey(name: 'rootUserIds', defaultValue: <String>[])
  final List<String>? rootUserIds;
  static const fromJsonFactory = _$CreateSubOrganizationResultV7FromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is CreateSubOrganizationResultV7 &&
            (identical(other.subOrganizationId, subOrganizationId) ||
                const DeepCollectionEquality()
                    .equals(other.subOrganizationId, subOrganizationId)) &&
            (identical(other.wallet, wallet) ||
                const DeepCollectionEquality().equals(other.wallet, wallet)) &&
            (identical(other.rootUserIds, rootUserIds) ||
                const DeepCollectionEquality()
                    .equals(other.rootUserIds, rootUserIds)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(subOrganizationId) ^
      const DeepCollectionEquality().hash(wallet) ^
      const DeepCollectionEquality().hash(rootUserIds) ^
      runtimeType.hashCode;
}

extension $CreateSubOrganizationResultV7Extension
    on CreateSubOrganizationResultV7 {
  CreateSubOrganizationResultV7 copyWith(
      {String? subOrganizationId,
      WalletResult? wallet,
      List<String>? rootUserIds}) {
    return CreateSubOrganizationResultV7(
        subOrganizationId: subOrganizationId ?? this.subOrganizationId,
        wallet: wallet ?? this.wallet,
        rootUserIds: rootUserIds ?? this.rootUserIds);
  }

  CreateSubOrganizationResultV7 copyWithWrapped(
      {Wrapped<String>? subOrganizationId,
      Wrapped<WalletResult?>? wallet,
      Wrapped<List<String>?>? rootUserIds}) {
    return CreateSubOrganizationResultV7(
        subOrganizationId: (subOrganizationId != null
            ? subOrganizationId.value
            : this.subOrganizationId),
        wallet: (wallet != null ? wallet.value : this.wallet),
        rootUserIds:
            (rootUserIds != null ? rootUserIds.value : this.rootUserIds));
  }
}

@JsonSerializable(explicitToJson: true)
class CreateUserTagIntent {
  const CreateUserTagIntent({
    required this.userTagName,
    required this.userIds,
  });

  factory CreateUserTagIntent.fromJson(Map<String, dynamic> json) =>
      _$CreateUserTagIntentFromJson(json);

  static const toJsonFactory = _$CreateUserTagIntentToJson;
  Map<String, dynamic> toJson() => _$CreateUserTagIntentToJson(this);

  @JsonKey(name: 'userTagName')
  final String userTagName;
  @JsonKey(name: 'userIds', defaultValue: <String>[])
  final List<String> userIds;
  static const fromJsonFactory = _$CreateUserTagIntentFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is CreateUserTagIntent &&
            (identical(other.userTagName, userTagName) ||
                const DeepCollectionEquality()
                    .equals(other.userTagName, userTagName)) &&
            (identical(other.userIds, userIds) ||
                const DeepCollectionEquality().equals(other.userIds, userIds)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(userTagName) ^
      const DeepCollectionEquality().hash(userIds) ^
      runtimeType.hashCode;
}

extension $CreateUserTagIntentExtension on CreateUserTagIntent {
  CreateUserTagIntent copyWith({String? userTagName, List<String>? userIds}) {
    return CreateUserTagIntent(
        userTagName: userTagName ?? this.userTagName,
        userIds: userIds ?? this.userIds);
  }

  CreateUserTagIntent copyWithWrapped(
      {Wrapped<String>? userTagName, Wrapped<List<String>>? userIds}) {
    return CreateUserTagIntent(
        userTagName:
            (userTagName != null ? userTagName.value : this.userTagName),
        userIds: (userIds != null ? userIds.value : this.userIds));
  }
}

@JsonSerializable(explicitToJson: true)
class CreateUserTagRequest {
  const CreateUserTagRequest({
    required this.type,
    required this.timestampMs,
    required this.organizationId,
    required this.parameters,
  });

  factory CreateUserTagRequest.fromJson(Map<String, dynamic> json) =>
      _$CreateUserTagRequestFromJson(json);

  static const toJsonFactory = _$CreateUserTagRequestToJson;
  Map<String, dynamic> toJson() => _$CreateUserTagRequestToJson(this);

  @JsonKey(
    name: 'type',
    toJson: createUserTagRequestTypeToJson,
    fromJson: createUserTagRequestTypeFromJson,
  )
  final enums.CreateUserTagRequestType type;
  @JsonKey(name: 'timestampMs')
  final String timestampMs;
  @JsonKey(name: 'organizationId')
  final String organizationId;
  @JsonKey(name: 'parameters')
  final CreateUserTagIntent parameters;
  static const fromJsonFactory = _$CreateUserTagRequestFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is CreateUserTagRequest &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.timestampMs, timestampMs) ||
                const DeepCollectionEquality()
                    .equals(other.timestampMs, timestampMs)) &&
            (identical(other.organizationId, organizationId) ||
                const DeepCollectionEquality()
                    .equals(other.organizationId, organizationId)) &&
            (identical(other.parameters, parameters) ||
                const DeepCollectionEquality()
                    .equals(other.parameters, parameters)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(timestampMs) ^
      const DeepCollectionEquality().hash(organizationId) ^
      const DeepCollectionEquality().hash(parameters) ^
      runtimeType.hashCode;
}

extension $CreateUserTagRequestExtension on CreateUserTagRequest {
  CreateUserTagRequest copyWith(
      {enums.CreateUserTagRequestType? type,
      String? timestampMs,
      String? organizationId,
      CreateUserTagIntent? parameters}) {
    return CreateUserTagRequest(
        type: type ?? this.type,
        timestampMs: timestampMs ?? this.timestampMs,
        organizationId: organizationId ?? this.organizationId,
        parameters: parameters ?? this.parameters);
  }

  CreateUserTagRequest copyWithWrapped(
      {Wrapped<enums.CreateUserTagRequestType>? type,
      Wrapped<String>? timestampMs,
      Wrapped<String>? organizationId,
      Wrapped<CreateUserTagIntent>? parameters}) {
    return CreateUserTagRequest(
        type: (type != null ? type.value : this.type),
        timestampMs:
            (timestampMs != null ? timestampMs.value : this.timestampMs),
        organizationId: (organizationId != null
            ? organizationId.value
            : this.organizationId),
        parameters: (parameters != null ? parameters.value : this.parameters));
  }
}

@JsonSerializable(explicitToJson: true)
class CreateUserTagResult {
  const CreateUserTagResult({
    required this.userTagId,
    required this.userIds,
  });

  factory CreateUserTagResult.fromJson(Map<String, dynamic> json) =>
      _$CreateUserTagResultFromJson(json);

  static const toJsonFactory = _$CreateUserTagResultToJson;
  Map<String, dynamic> toJson() => _$CreateUserTagResultToJson(this);

  @JsonKey(name: 'userTagId')
  final String userTagId;
  @JsonKey(name: 'userIds', defaultValue: <String>[])
  final List<String> userIds;
  static const fromJsonFactory = _$CreateUserTagResultFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is CreateUserTagResult &&
            (identical(other.userTagId, userTagId) ||
                const DeepCollectionEquality()
                    .equals(other.userTagId, userTagId)) &&
            (identical(other.userIds, userIds) ||
                const DeepCollectionEquality().equals(other.userIds, userIds)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(userTagId) ^
      const DeepCollectionEquality().hash(userIds) ^
      runtimeType.hashCode;
}

extension $CreateUserTagResultExtension on CreateUserTagResult {
  CreateUserTagResult copyWith({String? userTagId, List<String>? userIds}) {
    return CreateUserTagResult(
        userTagId: userTagId ?? this.userTagId,
        userIds: userIds ?? this.userIds);
  }

  CreateUserTagResult copyWithWrapped(
      {Wrapped<String>? userTagId, Wrapped<List<String>>? userIds}) {
    return CreateUserTagResult(
        userTagId: (userTagId != null ? userTagId.value : this.userTagId),
        userIds: (userIds != null ? userIds.value : this.userIds));
  }
}

@JsonSerializable(explicitToJson: true)
class CreateUsersIntent {
  const CreateUsersIntent({
    required this.users,
  });

  factory CreateUsersIntent.fromJson(Map<String, dynamic> json) =>
      _$CreateUsersIntentFromJson(json);

  static const toJsonFactory = _$CreateUsersIntentToJson;
  Map<String, dynamic> toJson() => _$CreateUsersIntentToJson(this);

  @JsonKey(name: 'users', defaultValue: <UserParams>[])
  final List<UserParams> users;
  static const fromJsonFactory = _$CreateUsersIntentFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is CreateUsersIntent &&
            (identical(other.users, users) ||
                const DeepCollectionEquality().equals(other.users, users)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(users) ^ runtimeType.hashCode;
}

extension $CreateUsersIntentExtension on CreateUsersIntent {
  CreateUsersIntent copyWith({List<UserParams>? users}) {
    return CreateUsersIntent(users: users ?? this.users);
  }

  CreateUsersIntent copyWithWrapped({Wrapped<List<UserParams>>? users}) {
    return CreateUsersIntent(users: (users != null ? users.value : this.users));
  }
}

@JsonSerializable(explicitToJson: true)
class CreateUsersIntentV2 {
  const CreateUsersIntentV2({
    required this.users,
  });

  factory CreateUsersIntentV2.fromJson(Map<String, dynamic> json) =>
      _$CreateUsersIntentV2FromJson(json);

  static const toJsonFactory = _$CreateUsersIntentV2ToJson;
  Map<String, dynamic> toJson() => _$CreateUsersIntentV2ToJson(this);

  @JsonKey(name: 'users', defaultValue: <UserParamsV2>[])
  final List<UserParamsV2> users;
  static const fromJsonFactory = _$CreateUsersIntentV2FromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is CreateUsersIntentV2 &&
            (identical(other.users, users) ||
                const DeepCollectionEquality().equals(other.users, users)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(users) ^ runtimeType.hashCode;
}

extension $CreateUsersIntentV2Extension on CreateUsersIntentV2 {
  CreateUsersIntentV2 copyWith({List<UserParamsV2>? users}) {
    return CreateUsersIntentV2(users: users ?? this.users);
  }

  CreateUsersIntentV2 copyWithWrapped({Wrapped<List<UserParamsV2>>? users}) {
    return CreateUsersIntentV2(
        users: (users != null ? users.value : this.users));
  }
}

@JsonSerializable(explicitToJson: true)
class CreateUsersIntentV3 {
  const CreateUsersIntentV3({
    required this.users,
  });

  factory CreateUsersIntentV3.fromJson(Map<String, dynamic> json) =>
      _$CreateUsersIntentV3FromJson(json);

  static const toJsonFactory = _$CreateUsersIntentV3ToJson;
  Map<String, dynamic> toJson() => _$CreateUsersIntentV3ToJson(this);

  @JsonKey(name: 'users', defaultValue: <UserParamsV3>[])
  final List<UserParamsV3> users;
  static const fromJsonFactory = _$CreateUsersIntentV3FromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is CreateUsersIntentV3 &&
            (identical(other.users, users) ||
                const DeepCollectionEquality().equals(other.users, users)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(users) ^ runtimeType.hashCode;
}

extension $CreateUsersIntentV3Extension on CreateUsersIntentV3 {
  CreateUsersIntentV3 copyWith({List<UserParamsV3>? users}) {
    return CreateUsersIntentV3(users: users ?? this.users);
  }

  CreateUsersIntentV3 copyWithWrapped({Wrapped<List<UserParamsV3>>? users}) {
    return CreateUsersIntentV3(
        users: (users != null ? users.value : this.users));
  }
}

@JsonSerializable(explicitToJson: true)
class CreateUsersRequest {
  const CreateUsersRequest({
    required this.type,
    required this.timestampMs,
    required this.organizationId,
    required this.parameters,
  });

  factory CreateUsersRequest.fromJson(Map<String, dynamic> json) =>
      _$CreateUsersRequestFromJson(json);

  static const toJsonFactory = _$CreateUsersRequestToJson;
  Map<String, dynamic> toJson() => _$CreateUsersRequestToJson(this);

  @JsonKey(
    name: 'type',
    toJson: createUsersRequestTypeToJson,
    fromJson: createUsersRequestTypeFromJson,
  )
  final enums.CreateUsersRequestType type;
  @JsonKey(name: 'timestampMs')
  final String timestampMs;
  @JsonKey(name: 'organizationId')
  final String organizationId;
  @JsonKey(name: 'parameters')
  final CreateUsersIntentV3 parameters;
  static const fromJsonFactory = _$CreateUsersRequestFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is CreateUsersRequest &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.timestampMs, timestampMs) ||
                const DeepCollectionEquality()
                    .equals(other.timestampMs, timestampMs)) &&
            (identical(other.organizationId, organizationId) ||
                const DeepCollectionEquality()
                    .equals(other.organizationId, organizationId)) &&
            (identical(other.parameters, parameters) ||
                const DeepCollectionEquality()
                    .equals(other.parameters, parameters)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(timestampMs) ^
      const DeepCollectionEquality().hash(organizationId) ^
      const DeepCollectionEquality().hash(parameters) ^
      runtimeType.hashCode;
}

extension $CreateUsersRequestExtension on CreateUsersRequest {
  CreateUsersRequest copyWith(
      {enums.CreateUsersRequestType? type,
      String? timestampMs,
      String? organizationId,
      CreateUsersIntentV3? parameters}) {
    return CreateUsersRequest(
        type: type ?? this.type,
        timestampMs: timestampMs ?? this.timestampMs,
        organizationId: organizationId ?? this.organizationId,
        parameters: parameters ?? this.parameters);
  }

  CreateUsersRequest copyWithWrapped(
      {Wrapped<enums.CreateUsersRequestType>? type,
      Wrapped<String>? timestampMs,
      Wrapped<String>? organizationId,
      Wrapped<CreateUsersIntentV3>? parameters}) {
    return CreateUsersRequest(
        type: (type != null ? type.value : this.type),
        timestampMs:
            (timestampMs != null ? timestampMs.value : this.timestampMs),
        organizationId: (organizationId != null
            ? organizationId.value
            : this.organizationId),
        parameters: (parameters != null ? parameters.value : this.parameters));
  }
}

@JsonSerializable(explicitToJson: true)
class CreateUsersResult {
  const CreateUsersResult({
    required this.userIds,
  });

  factory CreateUsersResult.fromJson(Map<String, dynamic> json) =>
      _$CreateUsersResultFromJson(json);

  static const toJsonFactory = _$CreateUsersResultToJson;
  Map<String, dynamic> toJson() => _$CreateUsersResultToJson(this);

  @JsonKey(name: 'userIds', defaultValue: <String>[])
  final List<String> userIds;
  static const fromJsonFactory = _$CreateUsersResultFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is CreateUsersResult &&
            (identical(other.userIds, userIds) ||
                const DeepCollectionEquality().equals(other.userIds, userIds)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(userIds) ^ runtimeType.hashCode;
}

extension $CreateUsersResultExtension on CreateUsersResult {
  CreateUsersResult copyWith({List<String>? userIds}) {
    return CreateUsersResult(userIds: userIds ?? this.userIds);
  }

  CreateUsersResult copyWithWrapped({Wrapped<List<String>>? userIds}) {
    return CreateUsersResult(
        userIds: (userIds != null ? userIds.value : this.userIds));
  }
}

@JsonSerializable(explicitToJson: true)
class CreateWalletAccountsIntent {
  const CreateWalletAccountsIntent({
    required this.walletId,
    required this.accounts,
  });

  factory CreateWalletAccountsIntent.fromJson(Map<String, dynamic> json) =>
      _$CreateWalletAccountsIntentFromJson(json);

  static const toJsonFactory = _$CreateWalletAccountsIntentToJson;
  Map<String, dynamic> toJson() => _$CreateWalletAccountsIntentToJson(this);

  @JsonKey(name: 'walletId')
  final String walletId;
  @JsonKey(name: 'accounts', defaultValue: <WalletAccountParams>[])
  final List<WalletAccountParams> accounts;
  static const fromJsonFactory = _$CreateWalletAccountsIntentFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is CreateWalletAccountsIntent &&
            (identical(other.walletId, walletId) ||
                const DeepCollectionEquality()
                    .equals(other.walletId, walletId)) &&
            (identical(other.accounts, accounts) ||
                const DeepCollectionEquality()
                    .equals(other.accounts, accounts)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(walletId) ^
      const DeepCollectionEquality().hash(accounts) ^
      runtimeType.hashCode;
}

extension $CreateWalletAccountsIntentExtension on CreateWalletAccountsIntent {
  CreateWalletAccountsIntent copyWith(
      {String? walletId, List<WalletAccountParams>? accounts}) {
    return CreateWalletAccountsIntent(
        walletId: walletId ?? this.walletId,
        accounts: accounts ?? this.accounts);
  }

  CreateWalletAccountsIntent copyWithWrapped(
      {Wrapped<String>? walletId,
      Wrapped<List<WalletAccountParams>>? accounts}) {
    return CreateWalletAccountsIntent(
        walletId: (walletId != null ? walletId.value : this.walletId),
        accounts: (accounts != null ? accounts.value : this.accounts));
  }
}

@JsonSerializable(explicitToJson: true)
class CreateWalletAccountsRequest {
  const CreateWalletAccountsRequest({
    required this.type,
    required this.timestampMs,
    required this.organizationId,
    required this.parameters,
  });

  factory CreateWalletAccountsRequest.fromJson(Map<String, dynamic> json) =>
      _$CreateWalletAccountsRequestFromJson(json);

  static const toJsonFactory = _$CreateWalletAccountsRequestToJson;
  Map<String, dynamic> toJson() => _$CreateWalletAccountsRequestToJson(this);

  @JsonKey(
    name: 'type',
    toJson: createWalletAccountsRequestTypeToJson,
    fromJson: createWalletAccountsRequestTypeFromJson,
  )
  final enums.CreateWalletAccountsRequestType type;
  @JsonKey(name: 'timestampMs')
  final String timestampMs;
  @JsonKey(name: 'organizationId')
  final String organizationId;
  @JsonKey(name: 'parameters')
  final CreateWalletAccountsIntent parameters;
  static const fromJsonFactory = _$CreateWalletAccountsRequestFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is CreateWalletAccountsRequest &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.timestampMs, timestampMs) ||
                const DeepCollectionEquality()
                    .equals(other.timestampMs, timestampMs)) &&
            (identical(other.organizationId, organizationId) ||
                const DeepCollectionEquality()
                    .equals(other.organizationId, organizationId)) &&
            (identical(other.parameters, parameters) ||
                const DeepCollectionEquality()
                    .equals(other.parameters, parameters)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(timestampMs) ^
      const DeepCollectionEquality().hash(organizationId) ^
      const DeepCollectionEquality().hash(parameters) ^
      runtimeType.hashCode;
}

extension $CreateWalletAccountsRequestExtension on CreateWalletAccountsRequest {
  CreateWalletAccountsRequest copyWith(
      {enums.CreateWalletAccountsRequestType? type,
      String? timestampMs,
      String? organizationId,
      CreateWalletAccountsIntent? parameters}) {
    return CreateWalletAccountsRequest(
        type: type ?? this.type,
        timestampMs: timestampMs ?? this.timestampMs,
        organizationId: organizationId ?? this.organizationId,
        parameters: parameters ?? this.parameters);
  }

  CreateWalletAccountsRequest copyWithWrapped(
      {Wrapped<enums.CreateWalletAccountsRequestType>? type,
      Wrapped<String>? timestampMs,
      Wrapped<String>? organizationId,
      Wrapped<CreateWalletAccountsIntent>? parameters}) {
    return CreateWalletAccountsRequest(
        type: (type != null ? type.value : this.type),
        timestampMs:
            (timestampMs != null ? timestampMs.value : this.timestampMs),
        organizationId: (organizationId != null
            ? organizationId.value
            : this.organizationId),
        parameters: (parameters != null ? parameters.value : this.parameters));
  }
}

@JsonSerializable(explicitToJson: true)
class CreateWalletAccountsResult {
  const CreateWalletAccountsResult({
    required this.addresses,
  });

  factory CreateWalletAccountsResult.fromJson(Map<String, dynamic> json) =>
      _$CreateWalletAccountsResultFromJson(json);

  static const toJsonFactory = _$CreateWalletAccountsResultToJson;
  Map<String, dynamic> toJson() => _$CreateWalletAccountsResultToJson(this);

  @JsonKey(name: 'addresses', defaultValue: <String>[])
  final List<String> addresses;
  static const fromJsonFactory = _$CreateWalletAccountsResultFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is CreateWalletAccountsResult &&
            (identical(other.addresses, addresses) ||
                const DeepCollectionEquality()
                    .equals(other.addresses, addresses)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(addresses) ^ runtimeType.hashCode;
}

extension $CreateWalletAccountsResultExtension on CreateWalletAccountsResult {
  CreateWalletAccountsResult copyWith({List<String>? addresses}) {
    return CreateWalletAccountsResult(addresses: addresses ?? this.addresses);
  }

  CreateWalletAccountsResult copyWithWrapped(
      {Wrapped<List<String>>? addresses}) {
    return CreateWalletAccountsResult(
        addresses: (addresses != null ? addresses.value : this.addresses));
  }
}

@JsonSerializable(explicitToJson: true)
class CreateWalletIntent {
  const CreateWalletIntent({
    required this.walletName,
    required this.accounts,
    this.mnemonicLength,
  });

  factory CreateWalletIntent.fromJson(Map<String, dynamic> json) =>
      _$CreateWalletIntentFromJson(json);

  static const toJsonFactory = _$CreateWalletIntentToJson;
  Map<String, dynamic> toJson() => _$CreateWalletIntentToJson(this);

  @JsonKey(name: 'walletName')
  final String walletName;
  @JsonKey(name: 'accounts', defaultValue: <WalletAccountParams>[])
  final List<WalletAccountParams> accounts;
  @JsonKey(name: 'mnemonicLength')
  final int? mnemonicLength;
  static const fromJsonFactory = _$CreateWalletIntentFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is CreateWalletIntent &&
            (identical(other.walletName, walletName) ||
                const DeepCollectionEquality()
                    .equals(other.walletName, walletName)) &&
            (identical(other.accounts, accounts) ||
                const DeepCollectionEquality()
                    .equals(other.accounts, accounts)) &&
            (identical(other.mnemonicLength, mnemonicLength) ||
                const DeepCollectionEquality()
                    .equals(other.mnemonicLength, mnemonicLength)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(walletName) ^
      const DeepCollectionEquality().hash(accounts) ^
      const DeepCollectionEquality().hash(mnemonicLength) ^
      runtimeType.hashCode;
}

extension $CreateWalletIntentExtension on CreateWalletIntent {
  CreateWalletIntent copyWith(
      {String? walletName,
      List<WalletAccountParams>? accounts,
      int? mnemonicLength}) {
    return CreateWalletIntent(
        walletName: walletName ?? this.walletName,
        accounts: accounts ?? this.accounts,
        mnemonicLength: mnemonicLength ?? this.mnemonicLength);
  }

  CreateWalletIntent copyWithWrapped(
      {Wrapped<String>? walletName,
      Wrapped<List<WalletAccountParams>>? accounts,
      Wrapped<int?>? mnemonicLength}) {
    return CreateWalletIntent(
        walletName: (walletName != null ? walletName.value : this.walletName),
        accounts: (accounts != null ? accounts.value : this.accounts),
        mnemonicLength: (mnemonicLength != null
            ? mnemonicLength.value
            : this.mnemonicLength));
  }
}

@JsonSerializable(explicitToJson: true)
class CreateWalletRequest {
  const CreateWalletRequest({
    required this.type,
    required this.timestampMs,
    required this.organizationId,
    required this.parameters,
  });

  factory CreateWalletRequest.fromJson(Map<String, dynamic> json) =>
      _$CreateWalletRequestFromJson(json);

  static const toJsonFactory = _$CreateWalletRequestToJson;
  Map<String, dynamic> toJson() => _$CreateWalletRequestToJson(this);

  @JsonKey(
    name: 'type',
    toJson: createWalletRequestTypeToJson,
    fromJson: createWalletRequestTypeFromJson,
  )
  final enums.CreateWalletRequestType type;
  @JsonKey(name: 'timestampMs')
  final String timestampMs;
  @JsonKey(name: 'organizationId')
  final String organizationId;
  @JsonKey(name: 'parameters')
  final CreateWalletIntent parameters;
  static const fromJsonFactory = _$CreateWalletRequestFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is CreateWalletRequest &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.timestampMs, timestampMs) ||
                const DeepCollectionEquality()
                    .equals(other.timestampMs, timestampMs)) &&
            (identical(other.organizationId, organizationId) ||
                const DeepCollectionEquality()
                    .equals(other.organizationId, organizationId)) &&
            (identical(other.parameters, parameters) ||
                const DeepCollectionEquality()
                    .equals(other.parameters, parameters)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(timestampMs) ^
      const DeepCollectionEquality().hash(organizationId) ^
      const DeepCollectionEquality().hash(parameters) ^
      runtimeType.hashCode;
}

extension $CreateWalletRequestExtension on CreateWalletRequest {
  CreateWalletRequest copyWith(
      {enums.CreateWalletRequestType? type,
      String? timestampMs,
      String? organizationId,
      CreateWalletIntent? parameters}) {
    return CreateWalletRequest(
        type: type ?? this.type,
        timestampMs: timestampMs ?? this.timestampMs,
        organizationId: organizationId ?? this.organizationId,
        parameters: parameters ?? this.parameters);
  }

  CreateWalletRequest copyWithWrapped(
      {Wrapped<enums.CreateWalletRequestType>? type,
      Wrapped<String>? timestampMs,
      Wrapped<String>? organizationId,
      Wrapped<CreateWalletIntent>? parameters}) {
    return CreateWalletRequest(
        type: (type != null ? type.value : this.type),
        timestampMs:
            (timestampMs != null ? timestampMs.value : this.timestampMs),
        organizationId: (organizationId != null
            ? organizationId.value
            : this.organizationId),
        parameters: (parameters != null ? parameters.value : this.parameters));
  }
}

@JsonSerializable(explicitToJson: true)
class CreateWalletResult {
  const CreateWalletResult({
    required this.walletId,
    required this.addresses,
  });

  factory CreateWalletResult.fromJson(Map<String, dynamic> json) =>
      _$CreateWalletResultFromJson(json);

  static const toJsonFactory = _$CreateWalletResultToJson;
  Map<String, dynamic> toJson() => _$CreateWalletResultToJson(this);

  @JsonKey(name: 'walletId')
  final String walletId;
  @JsonKey(name: 'addresses', defaultValue: <String>[])
  final List<String> addresses;
  static const fromJsonFactory = _$CreateWalletResultFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is CreateWalletResult &&
            (identical(other.walletId, walletId) ||
                const DeepCollectionEquality()
                    .equals(other.walletId, walletId)) &&
            (identical(other.addresses, addresses) ||
                const DeepCollectionEquality()
                    .equals(other.addresses, addresses)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(walletId) ^
      const DeepCollectionEquality().hash(addresses) ^
      runtimeType.hashCode;
}

extension $CreateWalletResultExtension on CreateWalletResult {
  CreateWalletResult copyWith({String? walletId, List<String>? addresses}) {
    return CreateWalletResult(
        walletId: walletId ?? this.walletId,
        addresses: addresses ?? this.addresses);
  }

  CreateWalletResult copyWithWrapped(
      {Wrapped<String>? walletId, Wrapped<List<String>>? addresses}) {
    return CreateWalletResult(
        walletId: (walletId != null ? walletId.value : this.walletId),
        addresses: (addresses != null ? addresses.value : this.addresses));
  }
}

@JsonSerializable(explicitToJson: true)
class CredPropsAuthenticationExtensionsClientOutputs {
  const CredPropsAuthenticationExtensionsClientOutputs({
    required this.rk,
  });

  factory CredPropsAuthenticationExtensionsClientOutputs.fromJson(
          Map<String, dynamic> json) =>
      _$CredPropsAuthenticationExtensionsClientOutputsFromJson(json);

  static const toJsonFactory =
      _$CredPropsAuthenticationExtensionsClientOutputsToJson;
  Map<String, dynamic> toJson() =>
      _$CredPropsAuthenticationExtensionsClientOutputsToJson(this);

  @JsonKey(name: 'rk')
  final bool rk;
  static const fromJsonFactory =
      _$CredPropsAuthenticationExtensionsClientOutputsFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is CredPropsAuthenticationExtensionsClientOutputs &&
            (identical(other.rk, rk) ||
                const DeepCollectionEquality().equals(other.rk, rk)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(rk) ^ runtimeType.hashCode;
}

extension $CredPropsAuthenticationExtensionsClientOutputsExtension
    on CredPropsAuthenticationExtensionsClientOutputs {
  CredPropsAuthenticationExtensionsClientOutputs copyWith({bool? rk}) {
    return CredPropsAuthenticationExtensionsClientOutputs(rk: rk ?? this.rk);
  }

  CredPropsAuthenticationExtensionsClientOutputs copyWithWrapped(
      {Wrapped<bool>? rk}) {
    return CredPropsAuthenticationExtensionsClientOutputs(
        rk: (rk != null ? rk.value : this.rk));
  }
}

@JsonSerializable(explicitToJson: true)
class DeleteApiKeysIntent {
  const DeleteApiKeysIntent({
    required this.userId,
    required this.apiKeyIds,
  });

  factory DeleteApiKeysIntent.fromJson(Map<String, dynamic> json) =>
      _$DeleteApiKeysIntentFromJson(json);

  static const toJsonFactory = _$DeleteApiKeysIntentToJson;
  Map<String, dynamic> toJson() => _$DeleteApiKeysIntentToJson(this);

  @JsonKey(name: 'userId')
  final String userId;
  @JsonKey(name: 'apiKeyIds', defaultValue: <String>[])
  final List<String> apiKeyIds;
  static const fromJsonFactory = _$DeleteApiKeysIntentFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is DeleteApiKeysIntent &&
            (identical(other.userId, userId) ||
                const DeepCollectionEquality().equals(other.userId, userId)) &&
            (identical(other.apiKeyIds, apiKeyIds) ||
                const DeepCollectionEquality()
                    .equals(other.apiKeyIds, apiKeyIds)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(userId) ^
      const DeepCollectionEquality().hash(apiKeyIds) ^
      runtimeType.hashCode;
}

extension $DeleteApiKeysIntentExtension on DeleteApiKeysIntent {
  DeleteApiKeysIntent copyWith({String? userId, List<String>? apiKeyIds}) {
    return DeleteApiKeysIntent(
        userId: userId ?? this.userId, apiKeyIds: apiKeyIds ?? this.apiKeyIds);
  }

  DeleteApiKeysIntent copyWithWrapped(
      {Wrapped<String>? userId, Wrapped<List<String>>? apiKeyIds}) {
    return DeleteApiKeysIntent(
        userId: (userId != null ? userId.value : this.userId),
        apiKeyIds: (apiKeyIds != null ? apiKeyIds.value : this.apiKeyIds));
  }
}

@JsonSerializable(explicitToJson: true)
class DeleteApiKeysRequest {
  const DeleteApiKeysRequest({
    required this.type,
    required this.timestampMs,
    required this.organizationId,
    required this.parameters,
  });

  factory DeleteApiKeysRequest.fromJson(Map<String, dynamic> json) =>
      _$DeleteApiKeysRequestFromJson(json);

  static const toJsonFactory = _$DeleteApiKeysRequestToJson;
  Map<String, dynamic> toJson() => _$DeleteApiKeysRequestToJson(this);

  @JsonKey(
    name: 'type',
    toJson: deleteApiKeysRequestTypeToJson,
    fromJson: deleteApiKeysRequestTypeFromJson,
  )
  final enums.DeleteApiKeysRequestType type;
  @JsonKey(name: 'timestampMs')
  final String timestampMs;
  @JsonKey(name: 'organizationId')
  final String organizationId;
  @JsonKey(name: 'parameters')
  final DeleteApiKeysIntent parameters;
  static const fromJsonFactory = _$DeleteApiKeysRequestFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is DeleteApiKeysRequest &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.timestampMs, timestampMs) ||
                const DeepCollectionEquality()
                    .equals(other.timestampMs, timestampMs)) &&
            (identical(other.organizationId, organizationId) ||
                const DeepCollectionEquality()
                    .equals(other.organizationId, organizationId)) &&
            (identical(other.parameters, parameters) ||
                const DeepCollectionEquality()
                    .equals(other.parameters, parameters)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(timestampMs) ^
      const DeepCollectionEquality().hash(organizationId) ^
      const DeepCollectionEquality().hash(parameters) ^
      runtimeType.hashCode;
}

extension $DeleteApiKeysRequestExtension on DeleteApiKeysRequest {
  DeleteApiKeysRequest copyWith(
      {enums.DeleteApiKeysRequestType? type,
      String? timestampMs,
      String? organizationId,
      DeleteApiKeysIntent? parameters}) {
    return DeleteApiKeysRequest(
        type: type ?? this.type,
        timestampMs: timestampMs ?? this.timestampMs,
        organizationId: organizationId ?? this.organizationId,
        parameters: parameters ?? this.parameters);
  }

  DeleteApiKeysRequest copyWithWrapped(
      {Wrapped<enums.DeleteApiKeysRequestType>? type,
      Wrapped<String>? timestampMs,
      Wrapped<String>? organizationId,
      Wrapped<DeleteApiKeysIntent>? parameters}) {
    return DeleteApiKeysRequest(
        type: (type != null ? type.value : this.type),
        timestampMs:
            (timestampMs != null ? timestampMs.value : this.timestampMs),
        organizationId: (organizationId != null
            ? organizationId.value
            : this.organizationId),
        parameters: (parameters != null ? parameters.value : this.parameters));
  }
}

@JsonSerializable(explicitToJson: true)
class DeleteApiKeysResult {
  const DeleteApiKeysResult({
    required this.apiKeyIds,
  });

  factory DeleteApiKeysResult.fromJson(Map<String, dynamic> json) =>
      _$DeleteApiKeysResultFromJson(json);

  static const toJsonFactory = _$DeleteApiKeysResultToJson;
  Map<String, dynamic> toJson() => _$DeleteApiKeysResultToJson(this);

  @JsonKey(name: 'apiKeyIds', defaultValue: <String>[])
  final List<String> apiKeyIds;
  static const fromJsonFactory = _$DeleteApiKeysResultFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is DeleteApiKeysResult &&
            (identical(other.apiKeyIds, apiKeyIds) ||
                const DeepCollectionEquality()
                    .equals(other.apiKeyIds, apiKeyIds)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(apiKeyIds) ^ runtimeType.hashCode;
}

extension $DeleteApiKeysResultExtension on DeleteApiKeysResult {
  DeleteApiKeysResult copyWith({List<String>? apiKeyIds}) {
    return DeleteApiKeysResult(apiKeyIds: apiKeyIds ?? this.apiKeyIds);
  }

  DeleteApiKeysResult copyWithWrapped({Wrapped<List<String>>? apiKeyIds}) {
    return DeleteApiKeysResult(
        apiKeyIds: (apiKeyIds != null ? apiKeyIds.value : this.apiKeyIds));
  }
}

@JsonSerializable(explicitToJson: true)
class DeleteAuthenticatorsIntent {
  const DeleteAuthenticatorsIntent({
    required this.userId,
    required this.authenticatorIds,
  });

  factory DeleteAuthenticatorsIntent.fromJson(Map<String, dynamic> json) =>
      _$DeleteAuthenticatorsIntentFromJson(json);

  static const toJsonFactory = _$DeleteAuthenticatorsIntentToJson;
  Map<String, dynamic> toJson() => _$DeleteAuthenticatorsIntentToJson(this);

  @JsonKey(name: 'userId')
  final String userId;
  @JsonKey(name: 'authenticatorIds', defaultValue: <String>[])
  final List<String> authenticatorIds;
  static const fromJsonFactory = _$DeleteAuthenticatorsIntentFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is DeleteAuthenticatorsIntent &&
            (identical(other.userId, userId) ||
                const DeepCollectionEquality().equals(other.userId, userId)) &&
            (identical(other.authenticatorIds, authenticatorIds) ||
                const DeepCollectionEquality()
                    .equals(other.authenticatorIds, authenticatorIds)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(userId) ^
      const DeepCollectionEquality().hash(authenticatorIds) ^
      runtimeType.hashCode;
}

extension $DeleteAuthenticatorsIntentExtension on DeleteAuthenticatorsIntent {
  DeleteAuthenticatorsIntent copyWith(
      {String? userId, List<String>? authenticatorIds}) {
    return DeleteAuthenticatorsIntent(
        userId: userId ?? this.userId,
        authenticatorIds: authenticatorIds ?? this.authenticatorIds);
  }

  DeleteAuthenticatorsIntent copyWithWrapped(
      {Wrapped<String>? userId, Wrapped<List<String>>? authenticatorIds}) {
    return DeleteAuthenticatorsIntent(
        userId: (userId != null ? userId.value : this.userId),
        authenticatorIds: (authenticatorIds != null
            ? authenticatorIds.value
            : this.authenticatorIds));
  }
}

@JsonSerializable(explicitToJson: true)
class DeleteAuthenticatorsRequest {
  const DeleteAuthenticatorsRequest({
    required this.type,
    required this.timestampMs,
    required this.organizationId,
    required this.parameters,
  });

  factory DeleteAuthenticatorsRequest.fromJson(Map<String, dynamic> json) =>
      _$DeleteAuthenticatorsRequestFromJson(json);

  static const toJsonFactory = _$DeleteAuthenticatorsRequestToJson;
  Map<String, dynamic> toJson() => _$DeleteAuthenticatorsRequestToJson(this);

  @JsonKey(
    name: 'type',
    toJson: deleteAuthenticatorsRequestTypeToJson,
    fromJson: deleteAuthenticatorsRequestTypeFromJson,
  )
  final enums.DeleteAuthenticatorsRequestType type;
  @JsonKey(name: 'timestampMs')
  final String timestampMs;
  @JsonKey(name: 'organizationId')
  final String organizationId;
  @JsonKey(name: 'parameters')
  final DeleteAuthenticatorsIntent parameters;
  static const fromJsonFactory = _$DeleteAuthenticatorsRequestFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is DeleteAuthenticatorsRequest &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.timestampMs, timestampMs) ||
                const DeepCollectionEquality()
                    .equals(other.timestampMs, timestampMs)) &&
            (identical(other.organizationId, organizationId) ||
                const DeepCollectionEquality()
                    .equals(other.organizationId, organizationId)) &&
            (identical(other.parameters, parameters) ||
                const DeepCollectionEquality()
                    .equals(other.parameters, parameters)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(timestampMs) ^
      const DeepCollectionEquality().hash(organizationId) ^
      const DeepCollectionEquality().hash(parameters) ^
      runtimeType.hashCode;
}

extension $DeleteAuthenticatorsRequestExtension on DeleteAuthenticatorsRequest {
  DeleteAuthenticatorsRequest copyWith(
      {enums.DeleteAuthenticatorsRequestType? type,
      String? timestampMs,
      String? organizationId,
      DeleteAuthenticatorsIntent? parameters}) {
    return DeleteAuthenticatorsRequest(
        type: type ?? this.type,
        timestampMs: timestampMs ?? this.timestampMs,
        organizationId: organizationId ?? this.organizationId,
        parameters: parameters ?? this.parameters);
  }

  DeleteAuthenticatorsRequest copyWithWrapped(
      {Wrapped<enums.DeleteAuthenticatorsRequestType>? type,
      Wrapped<String>? timestampMs,
      Wrapped<String>? organizationId,
      Wrapped<DeleteAuthenticatorsIntent>? parameters}) {
    return DeleteAuthenticatorsRequest(
        type: (type != null ? type.value : this.type),
        timestampMs:
            (timestampMs != null ? timestampMs.value : this.timestampMs),
        organizationId: (organizationId != null
            ? organizationId.value
            : this.organizationId),
        parameters: (parameters != null ? parameters.value : this.parameters));
  }
}

@JsonSerializable(explicitToJson: true)
class DeleteAuthenticatorsResult {
  const DeleteAuthenticatorsResult({
    required this.authenticatorIds,
  });

  factory DeleteAuthenticatorsResult.fromJson(Map<String, dynamic> json) =>
      _$DeleteAuthenticatorsResultFromJson(json);

  static const toJsonFactory = _$DeleteAuthenticatorsResultToJson;
  Map<String, dynamic> toJson() => _$DeleteAuthenticatorsResultToJson(this);

  @JsonKey(name: 'authenticatorIds', defaultValue: <String>[])
  final List<String> authenticatorIds;
  static const fromJsonFactory = _$DeleteAuthenticatorsResultFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is DeleteAuthenticatorsResult &&
            (identical(other.authenticatorIds, authenticatorIds) ||
                const DeepCollectionEquality()
                    .equals(other.authenticatorIds, authenticatorIds)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(authenticatorIds) ^
      runtimeType.hashCode;
}

extension $DeleteAuthenticatorsResultExtension on DeleteAuthenticatorsResult {
  DeleteAuthenticatorsResult copyWith({List<String>? authenticatorIds}) {
    return DeleteAuthenticatorsResult(
        authenticatorIds: authenticatorIds ?? this.authenticatorIds);
  }

  DeleteAuthenticatorsResult copyWithWrapped(
      {Wrapped<List<String>>? authenticatorIds}) {
    return DeleteAuthenticatorsResult(
        authenticatorIds: (authenticatorIds != null
            ? authenticatorIds.value
            : this.authenticatorIds));
  }
}

@JsonSerializable(explicitToJson: true)
class DeleteInvitationIntent {
  const DeleteInvitationIntent({
    required this.invitationId,
  });

  factory DeleteInvitationIntent.fromJson(Map<String, dynamic> json) =>
      _$DeleteInvitationIntentFromJson(json);

  static const toJsonFactory = _$DeleteInvitationIntentToJson;
  Map<String, dynamic> toJson() => _$DeleteInvitationIntentToJson(this);

  @JsonKey(name: 'invitationId')
  final String invitationId;
  static const fromJsonFactory = _$DeleteInvitationIntentFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is DeleteInvitationIntent &&
            (identical(other.invitationId, invitationId) ||
                const DeepCollectionEquality()
                    .equals(other.invitationId, invitationId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(invitationId) ^ runtimeType.hashCode;
}

extension $DeleteInvitationIntentExtension on DeleteInvitationIntent {
  DeleteInvitationIntent copyWith({String? invitationId}) {
    return DeleteInvitationIntent(
        invitationId: invitationId ?? this.invitationId);
  }

  DeleteInvitationIntent copyWithWrapped({Wrapped<String>? invitationId}) {
    return DeleteInvitationIntent(
        invitationId:
            (invitationId != null ? invitationId.value : this.invitationId));
  }
}

@JsonSerializable(explicitToJson: true)
class DeleteInvitationRequest {
  const DeleteInvitationRequest({
    required this.type,
    required this.timestampMs,
    required this.organizationId,
    required this.parameters,
  });

  factory DeleteInvitationRequest.fromJson(Map<String, dynamic> json) =>
      _$DeleteInvitationRequestFromJson(json);

  static const toJsonFactory = _$DeleteInvitationRequestToJson;
  Map<String, dynamic> toJson() => _$DeleteInvitationRequestToJson(this);

  @JsonKey(
    name: 'type',
    toJson: deleteInvitationRequestTypeToJson,
    fromJson: deleteInvitationRequestTypeFromJson,
  )
  final enums.DeleteInvitationRequestType type;
  @JsonKey(name: 'timestampMs')
  final String timestampMs;
  @JsonKey(name: 'organizationId')
  final String organizationId;
  @JsonKey(name: 'parameters')
  final DeleteInvitationIntent parameters;
  static const fromJsonFactory = _$DeleteInvitationRequestFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is DeleteInvitationRequest &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.timestampMs, timestampMs) ||
                const DeepCollectionEquality()
                    .equals(other.timestampMs, timestampMs)) &&
            (identical(other.organizationId, organizationId) ||
                const DeepCollectionEquality()
                    .equals(other.organizationId, organizationId)) &&
            (identical(other.parameters, parameters) ||
                const DeepCollectionEquality()
                    .equals(other.parameters, parameters)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(timestampMs) ^
      const DeepCollectionEquality().hash(organizationId) ^
      const DeepCollectionEquality().hash(parameters) ^
      runtimeType.hashCode;
}

extension $DeleteInvitationRequestExtension on DeleteInvitationRequest {
  DeleteInvitationRequest copyWith(
      {enums.DeleteInvitationRequestType? type,
      String? timestampMs,
      String? organizationId,
      DeleteInvitationIntent? parameters}) {
    return DeleteInvitationRequest(
        type: type ?? this.type,
        timestampMs: timestampMs ?? this.timestampMs,
        organizationId: organizationId ?? this.organizationId,
        parameters: parameters ?? this.parameters);
  }

  DeleteInvitationRequest copyWithWrapped(
      {Wrapped<enums.DeleteInvitationRequestType>? type,
      Wrapped<String>? timestampMs,
      Wrapped<String>? organizationId,
      Wrapped<DeleteInvitationIntent>? parameters}) {
    return DeleteInvitationRequest(
        type: (type != null ? type.value : this.type),
        timestampMs:
            (timestampMs != null ? timestampMs.value : this.timestampMs),
        organizationId: (organizationId != null
            ? organizationId.value
            : this.organizationId),
        parameters: (parameters != null ? parameters.value : this.parameters));
  }
}

@JsonSerializable(explicitToJson: true)
class DeleteInvitationResult {
  const DeleteInvitationResult({
    required this.invitationId,
  });

  factory DeleteInvitationResult.fromJson(Map<String, dynamic> json) =>
      _$DeleteInvitationResultFromJson(json);

  static const toJsonFactory = _$DeleteInvitationResultToJson;
  Map<String, dynamic> toJson() => _$DeleteInvitationResultToJson(this);

  @JsonKey(name: 'invitationId')
  final String invitationId;
  static const fromJsonFactory = _$DeleteInvitationResultFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is DeleteInvitationResult &&
            (identical(other.invitationId, invitationId) ||
                const DeepCollectionEquality()
                    .equals(other.invitationId, invitationId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(invitationId) ^ runtimeType.hashCode;
}

extension $DeleteInvitationResultExtension on DeleteInvitationResult {
  DeleteInvitationResult copyWith({String? invitationId}) {
    return DeleteInvitationResult(
        invitationId: invitationId ?? this.invitationId);
  }

  DeleteInvitationResult copyWithWrapped({Wrapped<String>? invitationId}) {
    return DeleteInvitationResult(
        invitationId:
            (invitationId != null ? invitationId.value : this.invitationId));
  }
}

@JsonSerializable(explicitToJson: true)
class DeleteOauthProvidersIntent {
  const DeleteOauthProvidersIntent({
    required this.userId,
    required this.providerIds,
  });

  factory DeleteOauthProvidersIntent.fromJson(Map<String, dynamic> json) =>
      _$DeleteOauthProvidersIntentFromJson(json);

  static const toJsonFactory = _$DeleteOauthProvidersIntentToJson;
  Map<String, dynamic> toJson() => _$DeleteOauthProvidersIntentToJson(this);

  @JsonKey(name: 'userId')
  final String userId;
  @JsonKey(name: 'providerIds', defaultValue: <String>[])
  final List<String> providerIds;
  static const fromJsonFactory = _$DeleteOauthProvidersIntentFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is DeleteOauthProvidersIntent &&
            (identical(other.userId, userId) ||
                const DeepCollectionEquality().equals(other.userId, userId)) &&
            (identical(other.providerIds, providerIds) ||
                const DeepCollectionEquality()
                    .equals(other.providerIds, providerIds)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(userId) ^
      const DeepCollectionEquality().hash(providerIds) ^
      runtimeType.hashCode;
}

extension $DeleteOauthProvidersIntentExtension on DeleteOauthProvidersIntent {
  DeleteOauthProvidersIntent copyWith(
      {String? userId, List<String>? providerIds}) {
    return DeleteOauthProvidersIntent(
        userId: userId ?? this.userId,
        providerIds: providerIds ?? this.providerIds);
  }

  DeleteOauthProvidersIntent copyWithWrapped(
      {Wrapped<String>? userId, Wrapped<List<String>>? providerIds}) {
    return DeleteOauthProvidersIntent(
        userId: (userId != null ? userId.value : this.userId),
        providerIds:
            (providerIds != null ? providerIds.value : this.providerIds));
  }
}

@JsonSerializable(explicitToJson: true)
class DeleteOauthProvidersRequest {
  const DeleteOauthProvidersRequest({
    required this.type,
    required this.timestampMs,
    required this.organizationId,
    required this.parameters,
  });

  factory DeleteOauthProvidersRequest.fromJson(Map<String, dynamic> json) =>
      _$DeleteOauthProvidersRequestFromJson(json);

  static const toJsonFactory = _$DeleteOauthProvidersRequestToJson;
  Map<String, dynamic> toJson() => _$DeleteOauthProvidersRequestToJson(this);

  @JsonKey(
    name: 'type',
    toJson: deleteOauthProvidersRequestTypeToJson,
    fromJson: deleteOauthProvidersRequestTypeFromJson,
  )
  final enums.DeleteOauthProvidersRequestType type;
  @JsonKey(name: 'timestampMs')
  final String timestampMs;
  @JsonKey(name: 'organizationId')
  final String organizationId;
  @JsonKey(name: 'parameters')
  final DeleteOauthProvidersIntent parameters;
  static const fromJsonFactory = _$DeleteOauthProvidersRequestFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is DeleteOauthProvidersRequest &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.timestampMs, timestampMs) ||
                const DeepCollectionEquality()
                    .equals(other.timestampMs, timestampMs)) &&
            (identical(other.organizationId, organizationId) ||
                const DeepCollectionEquality()
                    .equals(other.organizationId, organizationId)) &&
            (identical(other.parameters, parameters) ||
                const DeepCollectionEquality()
                    .equals(other.parameters, parameters)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(timestampMs) ^
      const DeepCollectionEquality().hash(organizationId) ^
      const DeepCollectionEquality().hash(parameters) ^
      runtimeType.hashCode;
}

extension $DeleteOauthProvidersRequestExtension on DeleteOauthProvidersRequest {
  DeleteOauthProvidersRequest copyWith(
      {enums.DeleteOauthProvidersRequestType? type,
      String? timestampMs,
      String? organizationId,
      DeleteOauthProvidersIntent? parameters}) {
    return DeleteOauthProvidersRequest(
        type: type ?? this.type,
        timestampMs: timestampMs ?? this.timestampMs,
        organizationId: organizationId ?? this.organizationId,
        parameters: parameters ?? this.parameters);
  }

  DeleteOauthProvidersRequest copyWithWrapped(
      {Wrapped<enums.DeleteOauthProvidersRequestType>? type,
      Wrapped<String>? timestampMs,
      Wrapped<String>? organizationId,
      Wrapped<DeleteOauthProvidersIntent>? parameters}) {
    return DeleteOauthProvidersRequest(
        type: (type != null ? type.value : this.type),
        timestampMs:
            (timestampMs != null ? timestampMs.value : this.timestampMs),
        organizationId: (organizationId != null
            ? organizationId.value
            : this.organizationId),
        parameters: (parameters != null ? parameters.value : this.parameters));
  }
}

@JsonSerializable(explicitToJson: true)
class DeleteOauthProvidersResult {
  const DeleteOauthProvidersResult({
    required this.providerIds,
  });

  factory DeleteOauthProvidersResult.fromJson(Map<String, dynamic> json) =>
      _$DeleteOauthProvidersResultFromJson(json);

  static const toJsonFactory = _$DeleteOauthProvidersResultToJson;
  Map<String, dynamic> toJson() => _$DeleteOauthProvidersResultToJson(this);

  @JsonKey(name: 'providerIds', defaultValue: <String>[])
  final List<String> providerIds;
  static const fromJsonFactory = _$DeleteOauthProvidersResultFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is DeleteOauthProvidersResult &&
            (identical(other.providerIds, providerIds) ||
                const DeepCollectionEquality()
                    .equals(other.providerIds, providerIds)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(providerIds) ^ runtimeType.hashCode;
}

extension $DeleteOauthProvidersResultExtension on DeleteOauthProvidersResult {
  DeleteOauthProvidersResult copyWith({List<String>? providerIds}) {
    return DeleteOauthProvidersResult(
        providerIds: providerIds ?? this.providerIds);
  }

  DeleteOauthProvidersResult copyWithWrapped(
      {Wrapped<List<String>>? providerIds}) {
    return DeleteOauthProvidersResult(
        providerIds:
            (providerIds != null ? providerIds.value : this.providerIds));
  }
}

@JsonSerializable(explicitToJson: true)
class DeleteOrganizationIntent {
  const DeleteOrganizationIntent({
    required this.organizationId,
  });

  factory DeleteOrganizationIntent.fromJson(Map<String, dynamic> json) =>
      _$DeleteOrganizationIntentFromJson(json);

  static const toJsonFactory = _$DeleteOrganizationIntentToJson;
  Map<String, dynamic> toJson() => _$DeleteOrganizationIntentToJson(this);

  @JsonKey(name: 'organizationId')
  final String organizationId;
  static const fromJsonFactory = _$DeleteOrganizationIntentFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is DeleteOrganizationIntent &&
            (identical(other.organizationId, organizationId) ||
                const DeepCollectionEquality()
                    .equals(other.organizationId, organizationId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(organizationId) ^
      runtimeType.hashCode;
}

extension $DeleteOrganizationIntentExtension on DeleteOrganizationIntent {
  DeleteOrganizationIntent copyWith({String? organizationId}) {
    return DeleteOrganizationIntent(
        organizationId: organizationId ?? this.organizationId);
  }

  DeleteOrganizationIntent copyWithWrapped({Wrapped<String>? organizationId}) {
    return DeleteOrganizationIntent(
        organizationId: (organizationId != null
            ? organizationId.value
            : this.organizationId));
  }
}

@JsonSerializable(explicitToJson: true)
class DeleteOrganizationResult {
  const DeleteOrganizationResult({
    required this.organizationId,
  });

  factory DeleteOrganizationResult.fromJson(Map<String, dynamic> json) =>
      _$DeleteOrganizationResultFromJson(json);

  static const toJsonFactory = _$DeleteOrganizationResultToJson;
  Map<String, dynamic> toJson() => _$DeleteOrganizationResultToJson(this);

  @JsonKey(name: 'organizationId')
  final String organizationId;
  static const fromJsonFactory = _$DeleteOrganizationResultFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is DeleteOrganizationResult &&
            (identical(other.organizationId, organizationId) ||
                const DeepCollectionEquality()
                    .equals(other.organizationId, organizationId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(organizationId) ^
      runtimeType.hashCode;
}

extension $DeleteOrganizationResultExtension on DeleteOrganizationResult {
  DeleteOrganizationResult copyWith({String? organizationId}) {
    return DeleteOrganizationResult(
        organizationId: organizationId ?? this.organizationId);
  }

  DeleteOrganizationResult copyWithWrapped({Wrapped<String>? organizationId}) {
    return DeleteOrganizationResult(
        organizationId: (organizationId != null
            ? organizationId.value
            : this.organizationId));
  }
}

@JsonSerializable(explicitToJson: true)
class DeletePaymentMethodIntent {
  const DeletePaymentMethodIntent({
    this.paymentMethodId,
  });

  factory DeletePaymentMethodIntent.fromJson(Map<String, dynamic> json) =>
      _$DeletePaymentMethodIntentFromJson(json);

  static const toJsonFactory = _$DeletePaymentMethodIntentToJson;
  Map<String, dynamic> toJson() => _$DeletePaymentMethodIntentToJson(this);

  @JsonKey(name: 'paymentMethodId')
  final String? paymentMethodId;
  static const fromJsonFactory = _$DeletePaymentMethodIntentFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is DeletePaymentMethodIntent &&
            (identical(other.paymentMethodId, paymentMethodId) ||
                const DeepCollectionEquality()
                    .equals(other.paymentMethodId, paymentMethodId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(paymentMethodId) ^
      runtimeType.hashCode;
}

extension $DeletePaymentMethodIntentExtension on DeletePaymentMethodIntent {
  DeletePaymentMethodIntent copyWith({String? paymentMethodId}) {
    return DeletePaymentMethodIntent(
        paymentMethodId: paymentMethodId ?? this.paymentMethodId);
  }

  DeletePaymentMethodIntent copyWithWrapped(
      {Wrapped<String?>? paymentMethodId}) {
    return DeletePaymentMethodIntent(
        paymentMethodId: (paymentMethodId != null
            ? paymentMethodId.value
            : this.paymentMethodId));
  }
}

@JsonSerializable(explicitToJson: true)
class DeletePaymentMethodResult {
  const DeletePaymentMethodResult({
    required this.paymentMethodId,
  });

  factory DeletePaymentMethodResult.fromJson(Map<String, dynamic> json) =>
      _$DeletePaymentMethodResultFromJson(json);

  static const toJsonFactory = _$DeletePaymentMethodResultToJson;
  Map<String, dynamic> toJson() => _$DeletePaymentMethodResultToJson(this);

  @JsonKey(name: 'paymentMethodId')
  final String paymentMethodId;
  static const fromJsonFactory = _$DeletePaymentMethodResultFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is DeletePaymentMethodResult &&
            (identical(other.paymentMethodId, paymentMethodId) ||
                const DeepCollectionEquality()
                    .equals(other.paymentMethodId, paymentMethodId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(paymentMethodId) ^
      runtimeType.hashCode;
}

extension $DeletePaymentMethodResultExtension on DeletePaymentMethodResult {
  DeletePaymentMethodResult copyWith({String? paymentMethodId}) {
    return DeletePaymentMethodResult(
        paymentMethodId: paymentMethodId ?? this.paymentMethodId);
  }

  DeletePaymentMethodResult copyWithWrapped(
      {Wrapped<String>? paymentMethodId}) {
    return DeletePaymentMethodResult(
        paymentMethodId: (paymentMethodId != null
            ? paymentMethodId.value
            : this.paymentMethodId));
  }
}

@JsonSerializable(explicitToJson: true)
class DeletePolicyIntent {
  const DeletePolicyIntent({
    required this.policyId,
  });

  factory DeletePolicyIntent.fromJson(Map<String, dynamic> json) =>
      _$DeletePolicyIntentFromJson(json);

  static const toJsonFactory = _$DeletePolicyIntentToJson;
  Map<String, dynamic> toJson() => _$DeletePolicyIntentToJson(this);

  @JsonKey(name: 'policyId')
  final String policyId;
  static const fromJsonFactory = _$DeletePolicyIntentFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is DeletePolicyIntent &&
            (identical(other.policyId, policyId) ||
                const DeepCollectionEquality()
                    .equals(other.policyId, policyId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(policyId) ^ runtimeType.hashCode;
}

extension $DeletePolicyIntentExtension on DeletePolicyIntent {
  DeletePolicyIntent copyWith({String? policyId}) {
    return DeletePolicyIntent(policyId: policyId ?? this.policyId);
  }

  DeletePolicyIntent copyWithWrapped({Wrapped<String>? policyId}) {
    return DeletePolicyIntent(
        policyId: (policyId != null ? policyId.value : this.policyId));
  }
}

@JsonSerializable(explicitToJson: true)
class DeletePolicyRequest {
  const DeletePolicyRequest({
    required this.type,
    required this.timestampMs,
    required this.organizationId,
    required this.parameters,
  });

  factory DeletePolicyRequest.fromJson(Map<String, dynamic> json) =>
      _$DeletePolicyRequestFromJson(json);

  static const toJsonFactory = _$DeletePolicyRequestToJson;
  Map<String, dynamic> toJson() => _$DeletePolicyRequestToJson(this);

  @JsonKey(
    name: 'type',
    toJson: deletePolicyRequestTypeToJson,
    fromJson: deletePolicyRequestTypeFromJson,
  )
  final enums.DeletePolicyRequestType type;
  @JsonKey(name: 'timestampMs')
  final String timestampMs;
  @JsonKey(name: 'organizationId')
  final String organizationId;
  @JsonKey(name: 'parameters')
  final DeletePolicyIntent parameters;
  static const fromJsonFactory = _$DeletePolicyRequestFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is DeletePolicyRequest &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.timestampMs, timestampMs) ||
                const DeepCollectionEquality()
                    .equals(other.timestampMs, timestampMs)) &&
            (identical(other.organizationId, organizationId) ||
                const DeepCollectionEquality()
                    .equals(other.organizationId, organizationId)) &&
            (identical(other.parameters, parameters) ||
                const DeepCollectionEquality()
                    .equals(other.parameters, parameters)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(timestampMs) ^
      const DeepCollectionEquality().hash(organizationId) ^
      const DeepCollectionEquality().hash(parameters) ^
      runtimeType.hashCode;
}

extension $DeletePolicyRequestExtension on DeletePolicyRequest {
  DeletePolicyRequest copyWith(
      {enums.DeletePolicyRequestType? type,
      String? timestampMs,
      String? organizationId,
      DeletePolicyIntent? parameters}) {
    return DeletePolicyRequest(
        type: type ?? this.type,
        timestampMs: timestampMs ?? this.timestampMs,
        organizationId: organizationId ?? this.organizationId,
        parameters: parameters ?? this.parameters);
  }

  DeletePolicyRequest copyWithWrapped(
      {Wrapped<enums.DeletePolicyRequestType>? type,
      Wrapped<String>? timestampMs,
      Wrapped<String>? organizationId,
      Wrapped<DeletePolicyIntent>? parameters}) {
    return DeletePolicyRequest(
        type: (type != null ? type.value : this.type),
        timestampMs:
            (timestampMs != null ? timestampMs.value : this.timestampMs),
        organizationId: (organizationId != null
            ? organizationId.value
            : this.organizationId),
        parameters: (parameters != null ? parameters.value : this.parameters));
  }
}

@JsonSerializable(explicitToJson: true)
class DeletePolicyResult {
  const DeletePolicyResult({
    required this.policyId,
  });

  factory DeletePolicyResult.fromJson(Map<String, dynamic> json) =>
      _$DeletePolicyResultFromJson(json);

  static const toJsonFactory = _$DeletePolicyResultToJson;
  Map<String, dynamic> toJson() => _$DeletePolicyResultToJson(this);

  @JsonKey(name: 'policyId')
  final String policyId;
  static const fromJsonFactory = _$DeletePolicyResultFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is DeletePolicyResult &&
            (identical(other.policyId, policyId) ||
                const DeepCollectionEquality()
                    .equals(other.policyId, policyId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(policyId) ^ runtimeType.hashCode;
}

extension $DeletePolicyResultExtension on DeletePolicyResult {
  DeletePolicyResult copyWith({String? policyId}) {
    return DeletePolicyResult(policyId: policyId ?? this.policyId);
  }

  DeletePolicyResult copyWithWrapped({Wrapped<String>? policyId}) {
    return DeletePolicyResult(
        policyId: (policyId != null ? policyId.value : this.policyId));
  }
}

@JsonSerializable(explicitToJson: true)
class DeletePrivateKeyTagsIntent {
  const DeletePrivateKeyTagsIntent({
    required this.privateKeyTagIds,
  });

  factory DeletePrivateKeyTagsIntent.fromJson(Map<String, dynamic> json) =>
      _$DeletePrivateKeyTagsIntentFromJson(json);

  static const toJsonFactory = _$DeletePrivateKeyTagsIntentToJson;
  Map<String, dynamic> toJson() => _$DeletePrivateKeyTagsIntentToJson(this);

  @JsonKey(name: 'privateKeyTagIds', defaultValue: <String>[])
  final List<String> privateKeyTagIds;
  static const fromJsonFactory = _$DeletePrivateKeyTagsIntentFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is DeletePrivateKeyTagsIntent &&
            (identical(other.privateKeyTagIds, privateKeyTagIds) ||
                const DeepCollectionEquality()
                    .equals(other.privateKeyTagIds, privateKeyTagIds)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(privateKeyTagIds) ^
      runtimeType.hashCode;
}

extension $DeletePrivateKeyTagsIntentExtension on DeletePrivateKeyTagsIntent {
  DeletePrivateKeyTagsIntent copyWith({List<String>? privateKeyTagIds}) {
    return DeletePrivateKeyTagsIntent(
        privateKeyTagIds: privateKeyTagIds ?? this.privateKeyTagIds);
  }

  DeletePrivateKeyTagsIntent copyWithWrapped(
      {Wrapped<List<String>>? privateKeyTagIds}) {
    return DeletePrivateKeyTagsIntent(
        privateKeyTagIds: (privateKeyTagIds != null
            ? privateKeyTagIds.value
            : this.privateKeyTagIds));
  }
}

@JsonSerializable(explicitToJson: true)
class DeletePrivateKeyTagsRequest {
  const DeletePrivateKeyTagsRequest({
    required this.type,
    required this.timestampMs,
    required this.organizationId,
    required this.parameters,
  });

  factory DeletePrivateKeyTagsRequest.fromJson(Map<String, dynamic> json) =>
      _$DeletePrivateKeyTagsRequestFromJson(json);

  static const toJsonFactory = _$DeletePrivateKeyTagsRequestToJson;
  Map<String, dynamic> toJson() => _$DeletePrivateKeyTagsRequestToJson(this);

  @JsonKey(
    name: 'type',
    toJson: deletePrivateKeyTagsRequestTypeToJson,
    fromJson: deletePrivateKeyTagsRequestTypeFromJson,
  )
  final enums.DeletePrivateKeyTagsRequestType type;
  @JsonKey(name: 'timestampMs')
  final String timestampMs;
  @JsonKey(name: 'organizationId')
  final String organizationId;
  @JsonKey(name: 'parameters')
  final DeletePrivateKeyTagsIntent parameters;
  static const fromJsonFactory = _$DeletePrivateKeyTagsRequestFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is DeletePrivateKeyTagsRequest &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.timestampMs, timestampMs) ||
                const DeepCollectionEquality()
                    .equals(other.timestampMs, timestampMs)) &&
            (identical(other.organizationId, organizationId) ||
                const DeepCollectionEquality()
                    .equals(other.organizationId, organizationId)) &&
            (identical(other.parameters, parameters) ||
                const DeepCollectionEquality()
                    .equals(other.parameters, parameters)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(timestampMs) ^
      const DeepCollectionEquality().hash(organizationId) ^
      const DeepCollectionEquality().hash(parameters) ^
      runtimeType.hashCode;
}

extension $DeletePrivateKeyTagsRequestExtension on DeletePrivateKeyTagsRequest {
  DeletePrivateKeyTagsRequest copyWith(
      {enums.DeletePrivateKeyTagsRequestType? type,
      String? timestampMs,
      String? organizationId,
      DeletePrivateKeyTagsIntent? parameters}) {
    return DeletePrivateKeyTagsRequest(
        type: type ?? this.type,
        timestampMs: timestampMs ?? this.timestampMs,
        organizationId: organizationId ?? this.organizationId,
        parameters: parameters ?? this.parameters);
  }

  DeletePrivateKeyTagsRequest copyWithWrapped(
      {Wrapped<enums.DeletePrivateKeyTagsRequestType>? type,
      Wrapped<String>? timestampMs,
      Wrapped<String>? organizationId,
      Wrapped<DeletePrivateKeyTagsIntent>? parameters}) {
    return DeletePrivateKeyTagsRequest(
        type: (type != null ? type.value : this.type),
        timestampMs:
            (timestampMs != null ? timestampMs.value : this.timestampMs),
        organizationId: (organizationId != null
            ? organizationId.value
            : this.organizationId),
        parameters: (parameters != null ? parameters.value : this.parameters));
  }
}

@JsonSerializable(explicitToJson: true)
class DeletePrivateKeyTagsResult {
  const DeletePrivateKeyTagsResult({
    required this.privateKeyTagIds,
    required this.privateKeyIds,
  });

  factory DeletePrivateKeyTagsResult.fromJson(Map<String, dynamic> json) =>
      _$DeletePrivateKeyTagsResultFromJson(json);

  static const toJsonFactory = _$DeletePrivateKeyTagsResultToJson;
  Map<String, dynamic> toJson() => _$DeletePrivateKeyTagsResultToJson(this);

  @JsonKey(name: 'privateKeyTagIds', defaultValue: <String>[])
  final List<String> privateKeyTagIds;
  @JsonKey(name: 'privateKeyIds', defaultValue: <String>[])
  final List<String> privateKeyIds;
  static const fromJsonFactory = _$DeletePrivateKeyTagsResultFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is DeletePrivateKeyTagsResult &&
            (identical(other.privateKeyTagIds, privateKeyTagIds) ||
                const DeepCollectionEquality()
                    .equals(other.privateKeyTagIds, privateKeyTagIds)) &&
            (identical(other.privateKeyIds, privateKeyIds) ||
                const DeepCollectionEquality()
                    .equals(other.privateKeyIds, privateKeyIds)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(privateKeyTagIds) ^
      const DeepCollectionEquality().hash(privateKeyIds) ^
      runtimeType.hashCode;
}

extension $DeletePrivateKeyTagsResultExtension on DeletePrivateKeyTagsResult {
  DeletePrivateKeyTagsResult copyWith(
      {List<String>? privateKeyTagIds, List<String>? privateKeyIds}) {
    return DeletePrivateKeyTagsResult(
        privateKeyTagIds: privateKeyTagIds ?? this.privateKeyTagIds,
        privateKeyIds: privateKeyIds ?? this.privateKeyIds);
  }

  DeletePrivateKeyTagsResult copyWithWrapped(
      {Wrapped<List<String>>? privateKeyTagIds,
      Wrapped<List<String>>? privateKeyIds}) {
    return DeletePrivateKeyTagsResult(
        privateKeyTagIds: (privateKeyTagIds != null
            ? privateKeyTagIds.value
            : this.privateKeyTagIds),
        privateKeyIds:
            (privateKeyIds != null ? privateKeyIds.value : this.privateKeyIds));
  }
}

@JsonSerializable(explicitToJson: true)
class DeletePrivateKeysIntent {
  const DeletePrivateKeysIntent({
    required this.privateKeyIds,
    this.deleteWithoutExport,
  });

  factory DeletePrivateKeysIntent.fromJson(Map<String, dynamic> json) =>
      _$DeletePrivateKeysIntentFromJson(json);

  static const toJsonFactory = _$DeletePrivateKeysIntentToJson;
  Map<String, dynamic> toJson() => _$DeletePrivateKeysIntentToJson(this);

  @JsonKey(name: 'privateKeyIds', defaultValue: <String>[])
  final List<String> privateKeyIds;
  @JsonKey(name: 'deleteWithoutExport')
  final bool? deleteWithoutExport;
  static const fromJsonFactory = _$DeletePrivateKeysIntentFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is DeletePrivateKeysIntent &&
            (identical(other.privateKeyIds, privateKeyIds) ||
                const DeepCollectionEquality()
                    .equals(other.privateKeyIds, privateKeyIds)) &&
            (identical(other.deleteWithoutExport, deleteWithoutExport) ||
                const DeepCollectionEquality()
                    .equals(other.deleteWithoutExport, deleteWithoutExport)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(privateKeyIds) ^
      const DeepCollectionEquality().hash(deleteWithoutExport) ^
      runtimeType.hashCode;
}

extension $DeletePrivateKeysIntentExtension on DeletePrivateKeysIntent {
  DeletePrivateKeysIntent copyWith(
      {List<String>? privateKeyIds, bool? deleteWithoutExport}) {
    return DeletePrivateKeysIntent(
        privateKeyIds: privateKeyIds ?? this.privateKeyIds,
        deleteWithoutExport: deleteWithoutExport ?? this.deleteWithoutExport);
  }

  DeletePrivateKeysIntent copyWithWrapped(
      {Wrapped<List<String>>? privateKeyIds,
      Wrapped<bool?>? deleteWithoutExport}) {
    return DeletePrivateKeysIntent(
        privateKeyIds:
            (privateKeyIds != null ? privateKeyIds.value : this.privateKeyIds),
        deleteWithoutExport: (deleteWithoutExport != null
            ? deleteWithoutExport.value
            : this.deleteWithoutExport));
  }
}

@JsonSerializable(explicitToJson: true)
class DeletePrivateKeysRequest {
  const DeletePrivateKeysRequest({
    required this.type,
    required this.timestampMs,
    required this.organizationId,
    required this.parameters,
  });

  factory DeletePrivateKeysRequest.fromJson(Map<String, dynamic> json) =>
      _$DeletePrivateKeysRequestFromJson(json);

  static const toJsonFactory = _$DeletePrivateKeysRequestToJson;
  Map<String, dynamic> toJson() => _$DeletePrivateKeysRequestToJson(this);

  @JsonKey(
    name: 'type',
    toJson: deletePrivateKeysRequestTypeToJson,
    fromJson: deletePrivateKeysRequestTypeFromJson,
  )
  final enums.DeletePrivateKeysRequestType type;
  @JsonKey(name: 'timestampMs')
  final String timestampMs;
  @JsonKey(name: 'organizationId')
  final String organizationId;
  @JsonKey(name: 'parameters')
  final DeletePrivateKeysIntent parameters;
  static const fromJsonFactory = _$DeletePrivateKeysRequestFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is DeletePrivateKeysRequest &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.timestampMs, timestampMs) ||
                const DeepCollectionEquality()
                    .equals(other.timestampMs, timestampMs)) &&
            (identical(other.organizationId, organizationId) ||
                const DeepCollectionEquality()
                    .equals(other.organizationId, organizationId)) &&
            (identical(other.parameters, parameters) ||
                const DeepCollectionEquality()
                    .equals(other.parameters, parameters)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(timestampMs) ^
      const DeepCollectionEquality().hash(organizationId) ^
      const DeepCollectionEquality().hash(parameters) ^
      runtimeType.hashCode;
}

extension $DeletePrivateKeysRequestExtension on DeletePrivateKeysRequest {
  DeletePrivateKeysRequest copyWith(
      {enums.DeletePrivateKeysRequestType? type,
      String? timestampMs,
      String? organizationId,
      DeletePrivateKeysIntent? parameters}) {
    return DeletePrivateKeysRequest(
        type: type ?? this.type,
        timestampMs: timestampMs ?? this.timestampMs,
        organizationId: organizationId ?? this.organizationId,
        parameters: parameters ?? this.parameters);
  }

  DeletePrivateKeysRequest copyWithWrapped(
      {Wrapped<enums.DeletePrivateKeysRequestType>? type,
      Wrapped<String>? timestampMs,
      Wrapped<String>? organizationId,
      Wrapped<DeletePrivateKeysIntent>? parameters}) {
    return DeletePrivateKeysRequest(
        type: (type != null ? type.value : this.type),
        timestampMs:
            (timestampMs != null ? timestampMs.value : this.timestampMs),
        organizationId: (organizationId != null
            ? organizationId.value
            : this.organizationId),
        parameters: (parameters != null ? parameters.value : this.parameters));
  }
}

@JsonSerializable(explicitToJson: true)
class DeletePrivateKeysResult {
  const DeletePrivateKeysResult({
    required this.privateKeyIds,
  });

  factory DeletePrivateKeysResult.fromJson(Map<String, dynamic> json) =>
      _$DeletePrivateKeysResultFromJson(json);

  static const toJsonFactory = _$DeletePrivateKeysResultToJson;
  Map<String, dynamic> toJson() => _$DeletePrivateKeysResultToJson(this);

  @JsonKey(name: 'privateKeyIds', defaultValue: <String>[])
  final List<String> privateKeyIds;
  static const fromJsonFactory = _$DeletePrivateKeysResultFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is DeletePrivateKeysResult &&
            (identical(other.privateKeyIds, privateKeyIds) ||
                const DeepCollectionEquality()
                    .equals(other.privateKeyIds, privateKeyIds)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(privateKeyIds) ^ runtimeType.hashCode;
}

extension $DeletePrivateKeysResultExtension on DeletePrivateKeysResult {
  DeletePrivateKeysResult copyWith({List<String>? privateKeyIds}) {
    return DeletePrivateKeysResult(
        privateKeyIds: privateKeyIds ?? this.privateKeyIds);
  }

  DeletePrivateKeysResult copyWithWrapped(
      {Wrapped<List<String>>? privateKeyIds}) {
    return DeletePrivateKeysResult(
        privateKeyIds:
            (privateKeyIds != null ? privateKeyIds.value : this.privateKeyIds));
  }
}

@JsonSerializable(explicitToJson: true)
class DeleteSmartContractInterfaceIntent {
  const DeleteSmartContractInterfaceIntent({
    required this.smartContractInterfaceId,
  });

  factory DeleteSmartContractInterfaceIntent.fromJson(
          Map<String, dynamic> json) =>
      _$DeleteSmartContractInterfaceIntentFromJson(json);

  static const toJsonFactory = _$DeleteSmartContractInterfaceIntentToJson;
  Map<String, dynamic> toJson() =>
      _$DeleteSmartContractInterfaceIntentToJson(this);

  @JsonKey(name: 'smartContractInterfaceId')
  final String smartContractInterfaceId;
  static const fromJsonFactory = _$DeleteSmartContractInterfaceIntentFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is DeleteSmartContractInterfaceIntent &&
            (identical(
                    other.smartContractInterfaceId, smartContractInterfaceId) ||
                const DeepCollectionEquality().equals(
                    other.smartContractInterfaceId, smartContractInterfaceId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(smartContractInterfaceId) ^
      runtimeType.hashCode;
}

extension $DeleteSmartContractInterfaceIntentExtension
    on DeleteSmartContractInterfaceIntent {
  DeleteSmartContractInterfaceIntent copyWith(
      {String? smartContractInterfaceId}) {
    return DeleteSmartContractInterfaceIntent(
        smartContractInterfaceId:
            smartContractInterfaceId ?? this.smartContractInterfaceId);
  }

  DeleteSmartContractInterfaceIntent copyWithWrapped(
      {Wrapped<String>? smartContractInterfaceId}) {
    return DeleteSmartContractInterfaceIntent(
        smartContractInterfaceId: (smartContractInterfaceId != null
            ? smartContractInterfaceId.value
            : this.smartContractInterfaceId));
  }
}

@JsonSerializable(explicitToJson: true)
class DeleteSmartContractInterfaceRequest {
  const DeleteSmartContractInterfaceRequest({
    required this.type,
    required this.timestampMs,
    required this.organizationId,
    required this.parameters,
  });

  factory DeleteSmartContractInterfaceRequest.fromJson(
          Map<String, dynamic> json) =>
      _$DeleteSmartContractInterfaceRequestFromJson(json);

  static const toJsonFactory = _$DeleteSmartContractInterfaceRequestToJson;
  Map<String, dynamic> toJson() =>
      _$DeleteSmartContractInterfaceRequestToJson(this);

  @JsonKey(
    name: 'type',
    toJson: deleteSmartContractInterfaceRequestTypeToJson,
    fromJson: deleteSmartContractInterfaceRequestTypeFromJson,
  )
  final enums.DeleteSmartContractInterfaceRequestType type;
  @JsonKey(name: 'timestampMs')
  final String timestampMs;
  @JsonKey(name: 'organizationId')
  final String organizationId;
  @JsonKey(name: 'parameters')
  final DeleteSmartContractInterfaceIntent parameters;
  static const fromJsonFactory = _$DeleteSmartContractInterfaceRequestFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is DeleteSmartContractInterfaceRequest &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.timestampMs, timestampMs) ||
                const DeepCollectionEquality()
                    .equals(other.timestampMs, timestampMs)) &&
            (identical(other.organizationId, organizationId) ||
                const DeepCollectionEquality()
                    .equals(other.organizationId, organizationId)) &&
            (identical(other.parameters, parameters) ||
                const DeepCollectionEquality()
                    .equals(other.parameters, parameters)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(timestampMs) ^
      const DeepCollectionEquality().hash(organizationId) ^
      const DeepCollectionEquality().hash(parameters) ^
      runtimeType.hashCode;
}

extension $DeleteSmartContractInterfaceRequestExtension
    on DeleteSmartContractInterfaceRequest {
  DeleteSmartContractInterfaceRequest copyWith(
      {enums.DeleteSmartContractInterfaceRequestType? type,
      String? timestampMs,
      String? organizationId,
      DeleteSmartContractInterfaceIntent? parameters}) {
    return DeleteSmartContractInterfaceRequest(
        type: type ?? this.type,
        timestampMs: timestampMs ?? this.timestampMs,
        organizationId: organizationId ?? this.organizationId,
        parameters: parameters ?? this.parameters);
  }

  DeleteSmartContractInterfaceRequest copyWithWrapped(
      {Wrapped<enums.DeleteSmartContractInterfaceRequestType>? type,
      Wrapped<String>? timestampMs,
      Wrapped<String>? organizationId,
      Wrapped<DeleteSmartContractInterfaceIntent>? parameters}) {
    return DeleteSmartContractInterfaceRequest(
        type: (type != null ? type.value : this.type),
        timestampMs:
            (timestampMs != null ? timestampMs.value : this.timestampMs),
        organizationId: (organizationId != null
            ? organizationId.value
            : this.organizationId),
        parameters: (parameters != null ? parameters.value : this.parameters));
  }
}

@JsonSerializable(explicitToJson: true)
class DeleteSmartContractInterfaceResult {
  const DeleteSmartContractInterfaceResult({
    required this.smartContractInterfaceId,
  });

  factory DeleteSmartContractInterfaceResult.fromJson(
          Map<String, dynamic> json) =>
      _$DeleteSmartContractInterfaceResultFromJson(json);

  static const toJsonFactory = _$DeleteSmartContractInterfaceResultToJson;
  Map<String, dynamic> toJson() =>
      _$DeleteSmartContractInterfaceResultToJson(this);

  @JsonKey(name: 'smartContractInterfaceId')
  final String smartContractInterfaceId;
  static const fromJsonFactory = _$DeleteSmartContractInterfaceResultFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is DeleteSmartContractInterfaceResult &&
            (identical(
                    other.smartContractInterfaceId, smartContractInterfaceId) ||
                const DeepCollectionEquality().equals(
                    other.smartContractInterfaceId, smartContractInterfaceId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(smartContractInterfaceId) ^
      runtimeType.hashCode;
}

extension $DeleteSmartContractInterfaceResultExtension
    on DeleteSmartContractInterfaceResult {
  DeleteSmartContractInterfaceResult copyWith(
      {String? smartContractInterfaceId}) {
    return DeleteSmartContractInterfaceResult(
        smartContractInterfaceId:
            smartContractInterfaceId ?? this.smartContractInterfaceId);
  }

  DeleteSmartContractInterfaceResult copyWithWrapped(
      {Wrapped<String>? smartContractInterfaceId}) {
    return DeleteSmartContractInterfaceResult(
        smartContractInterfaceId: (smartContractInterfaceId != null
            ? smartContractInterfaceId.value
            : this.smartContractInterfaceId));
  }
}

@JsonSerializable(explicitToJson: true)
class DeleteSubOrganizationIntent {
  const DeleteSubOrganizationIntent({
    this.deleteWithoutExport,
  });

  factory DeleteSubOrganizationIntent.fromJson(Map<String, dynamic> json) =>
      _$DeleteSubOrganizationIntentFromJson(json);

  static const toJsonFactory = _$DeleteSubOrganizationIntentToJson;
  Map<String, dynamic> toJson() => _$DeleteSubOrganizationIntentToJson(this);

  @JsonKey(name: 'deleteWithoutExport')
  final bool? deleteWithoutExport;
  static const fromJsonFactory = _$DeleteSubOrganizationIntentFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is DeleteSubOrganizationIntent &&
            (identical(other.deleteWithoutExport, deleteWithoutExport) ||
                const DeepCollectionEquality()
                    .equals(other.deleteWithoutExport, deleteWithoutExport)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(deleteWithoutExport) ^
      runtimeType.hashCode;
}

extension $DeleteSubOrganizationIntentExtension on DeleteSubOrganizationIntent {
  DeleteSubOrganizationIntent copyWith({bool? deleteWithoutExport}) {
    return DeleteSubOrganizationIntent(
        deleteWithoutExport: deleteWithoutExport ?? this.deleteWithoutExport);
  }

  DeleteSubOrganizationIntent copyWithWrapped(
      {Wrapped<bool?>? deleteWithoutExport}) {
    return DeleteSubOrganizationIntent(
        deleteWithoutExport: (deleteWithoutExport != null
            ? deleteWithoutExport.value
            : this.deleteWithoutExport));
  }
}

@JsonSerializable(explicitToJson: true)
class DeleteSubOrganizationRequest {
  const DeleteSubOrganizationRequest({
    required this.type,
    required this.timestampMs,
    required this.organizationId,
    required this.parameters,
  });

  factory DeleteSubOrganizationRequest.fromJson(Map<String, dynamic> json) =>
      _$DeleteSubOrganizationRequestFromJson(json);

  static const toJsonFactory = _$DeleteSubOrganizationRequestToJson;
  Map<String, dynamic> toJson() => _$DeleteSubOrganizationRequestToJson(this);

  @JsonKey(
    name: 'type',
    toJson: deleteSubOrganizationRequestTypeToJson,
    fromJson: deleteSubOrganizationRequestTypeFromJson,
  )
  final enums.DeleteSubOrganizationRequestType type;
  @JsonKey(name: 'timestampMs')
  final String timestampMs;
  @JsonKey(name: 'organizationId')
  final String organizationId;
  @JsonKey(name: 'parameters')
  final DeleteSubOrganizationIntent parameters;
  static const fromJsonFactory = _$DeleteSubOrganizationRequestFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is DeleteSubOrganizationRequest &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.timestampMs, timestampMs) ||
                const DeepCollectionEquality()
                    .equals(other.timestampMs, timestampMs)) &&
            (identical(other.organizationId, organizationId) ||
                const DeepCollectionEquality()
                    .equals(other.organizationId, organizationId)) &&
            (identical(other.parameters, parameters) ||
                const DeepCollectionEquality()
                    .equals(other.parameters, parameters)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(timestampMs) ^
      const DeepCollectionEquality().hash(organizationId) ^
      const DeepCollectionEquality().hash(parameters) ^
      runtimeType.hashCode;
}

extension $DeleteSubOrganizationRequestExtension
    on DeleteSubOrganizationRequest {
  DeleteSubOrganizationRequest copyWith(
      {enums.DeleteSubOrganizationRequestType? type,
      String? timestampMs,
      String? organizationId,
      DeleteSubOrganizationIntent? parameters}) {
    return DeleteSubOrganizationRequest(
        type: type ?? this.type,
        timestampMs: timestampMs ?? this.timestampMs,
        organizationId: organizationId ?? this.organizationId,
        parameters: parameters ?? this.parameters);
  }

  DeleteSubOrganizationRequest copyWithWrapped(
      {Wrapped<enums.DeleteSubOrganizationRequestType>? type,
      Wrapped<String>? timestampMs,
      Wrapped<String>? organizationId,
      Wrapped<DeleteSubOrganizationIntent>? parameters}) {
    return DeleteSubOrganizationRequest(
        type: (type != null ? type.value : this.type),
        timestampMs:
            (timestampMs != null ? timestampMs.value : this.timestampMs),
        organizationId: (organizationId != null
            ? organizationId.value
            : this.organizationId),
        parameters: (parameters != null ? parameters.value : this.parameters));
  }
}

@JsonSerializable(explicitToJson: true)
class DeleteSubOrganizationResult {
  const DeleteSubOrganizationResult({
    required this.subOrganizationUuid,
  });

  factory DeleteSubOrganizationResult.fromJson(Map<String, dynamic> json) =>
      _$DeleteSubOrganizationResultFromJson(json);

  static const toJsonFactory = _$DeleteSubOrganizationResultToJson;
  Map<String, dynamic> toJson() => _$DeleteSubOrganizationResultToJson(this);

  @JsonKey(name: 'subOrganizationUuid')
  final String subOrganizationUuid;
  static const fromJsonFactory = _$DeleteSubOrganizationResultFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is DeleteSubOrganizationResult &&
            (identical(other.subOrganizationUuid, subOrganizationUuid) ||
                const DeepCollectionEquality()
                    .equals(other.subOrganizationUuid, subOrganizationUuid)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(subOrganizationUuid) ^
      runtimeType.hashCode;
}

extension $DeleteSubOrganizationResultExtension on DeleteSubOrganizationResult {
  DeleteSubOrganizationResult copyWith({String? subOrganizationUuid}) {
    return DeleteSubOrganizationResult(
        subOrganizationUuid: subOrganizationUuid ?? this.subOrganizationUuid);
  }

  DeleteSubOrganizationResult copyWithWrapped(
      {Wrapped<String>? subOrganizationUuid}) {
    return DeleteSubOrganizationResult(
        subOrganizationUuid: (subOrganizationUuid != null
            ? subOrganizationUuid.value
            : this.subOrganizationUuid));
  }
}

@JsonSerializable(explicitToJson: true)
class DeleteUserTagsIntent {
  const DeleteUserTagsIntent({
    required this.userTagIds,
  });

  factory DeleteUserTagsIntent.fromJson(Map<String, dynamic> json) =>
      _$DeleteUserTagsIntentFromJson(json);

  static const toJsonFactory = _$DeleteUserTagsIntentToJson;
  Map<String, dynamic> toJson() => _$DeleteUserTagsIntentToJson(this);

  @JsonKey(name: 'userTagIds', defaultValue: <String>[])
  final List<String> userTagIds;
  static const fromJsonFactory = _$DeleteUserTagsIntentFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is DeleteUserTagsIntent &&
            (identical(other.userTagIds, userTagIds) ||
                const DeepCollectionEquality()
                    .equals(other.userTagIds, userTagIds)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(userTagIds) ^ runtimeType.hashCode;
}

extension $DeleteUserTagsIntentExtension on DeleteUserTagsIntent {
  DeleteUserTagsIntent copyWith({List<String>? userTagIds}) {
    return DeleteUserTagsIntent(userTagIds: userTagIds ?? this.userTagIds);
  }

  DeleteUserTagsIntent copyWithWrapped({Wrapped<List<String>>? userTagIds}) {
    return DeleteUserTagsIntent(
        userTagIds: (userTagIds != null ? userTagIds.value : this.userTagIds));
  }
}

@JsonSerializable(explicitToJson: true)
class DeleteUserTagsRequest {
  const DeleteUserTagsRequest({
    required this.type,
    required this.timestampMs,
    required this.organizationId,
    required this.parameters,
  });

  factory DeleteUserTagsRequest.fromJson(Map<String, dynamic> json) =>
      _$DeleteUserTagsRequestFromJson(json);

  static const toJsonFactory = _$DeleteUserTagsRequestToJson;
  Map<String, dynamic> toJson() => _$DeleteUserTagsRequestToJson(this);

  @JsonKey(
    name: 'type',
    toJson: deleteUserTagsRequestTypeToJson,
    fromJson: deleteUserTagsRequestTypeFromJson,
  )
  final enums.DeleteUserTagsRequestType type;
  @JsonKey(name: 'timestampMs')
  final String timestampMs;
  @JsonKey(name: 'organizationId')
  final String organizationId;
  @JsonKey(name: 'parameters')
  final DeleteUserTagsIntent parameters;
  static const fromJsonFactory = _$DeleteUserTagsRequestFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is DeleteUserTagsRequest &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.timestampMs, timestampMs) ||
                const DeepCollectionEquality()
                    .equals(other.timestampMs, timestampMs)) &&
            (identical(other.organizationId, organizationId) ||
                const DeepCollectionEquality()
                    .equals(other.organizationId, organizationId)) &&
            (identical(other.parameters, parameters) ||
                const DeepCollectionEquality()
                    .equals(other.parameters, parameters)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(timestampMs) ^
      const DeepCollectionEquality().hash(organizationId) ^
      const DeepCollectionEquality().hash(parameters) ^
      runtimeType.hashCode;
}

extension $DeleteUserTagsRequestExtension on DeleteUserTagsRequest {
  DeleteUserTagsRequest copyWith(
      {enums.DeleteUserTagsRequestType? type,
      String? timestampMs,
      String? organizationId,
      DeleteUserTagsIntent? parameters}) {
    return DeleteUserTagsRequest(
        type: type ?? this.type,
        timestampMs: timestampMs ?? this.timestampMs,
        organizationId: organizationId ?? this.organizationId,
        parameters: parameters ?? this.parameters);
  }

  DeleteUserTagsRequest copyWithWrapped(
      {Wrapped<enums.DeleteUserTagsRequestType>? type,
      Wrapped<String>? timestampMs,
      Wrapped<String>? organizationId,
      Wrapped<DeleteUserTagsIntent>? parameters}) {
    return DeleteUserTagsRequest(
        type: (type != null ? type.value : this.type),
        timestampMs:
            (timestampMs != null ? timestampMs.value : this.timestampMs),
        organizationId: (organizationId != null
            ? organizationId.value
            : this.organizationId),
        parameters: (parameters != null ? parameters.value : this.parameters));
  }
}

@JsonSerializable(explicitToJson: true)
class DeleteUserTagsResult {
  const DeleteUserTagsResult({
    required this.userTagIds,
    required this.userIds,
  });

  factory DeleteUserTagsResult.fromJson(Map<String, dynamic> json) =>
      _$DeleteUserTagsResultFromJson(json);

  static const toJsonFactory = _$DeleteUserTagsResultToJson;
  Map<String, dynamic> toJson() => _$DeleteUserTagsResultToJson(this);

  @JsonKey(name: 'userTagIds', defaultValue: <String>[])
  final List<String> userTagIds;
  @JsonKey(name: 'userIds', defaultValue: <String>[])
  final List<String> userIds;
  static const fromJsonFactory = _$DeleteUserTagsResultFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is DeleteUserTagsResult &&
            (identical(other.userTagIds, userTagIds) ||
                const DeepCollectionEquality()
                    .equals(other.userTagIds, userTagIds)) &&
            (identical(other.userIds, userIds) ||
                const DeepCollectionEquality().equals(other.userIds, userIds)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(userTagIds) ^
      const DeepCollectionEquality().hash(userIds) ^
      runtimeType.hashCode;
}

extension $DeleteUserTagsResultExtension on DeleteUserTagsResult {
  DeleteUserTagsResult copyWith(
      {List<String>? userTagIds, List<String>? userIds}) {
    return DeleteUserTagsResult(
        userTagIds: userTagIds ?? this.userTagIds,
        userIds: userIds ?? this.userIds);
  }

  DeleteUserTagsResult copyWithWrapped(
      {Wrapped<List<String>>? userTagIds, Wrapped<List<String>>? userIds}) {
    return DeleteUserTagsResult(
        userTagIds: (userTagIds != null ? userTagIds.value : this.userTagIds),
        userIds: (userIds != null ? userIds.value : this.userIds));
  }
}

@JsonSerializable(explicitToJson: true)
class DeleteUsersIntent {
  const DeleteUsersIntent({
    required this.userIds,
  });

  factory DeleteUsersIntent.fromJson(Map<String, dynamic> json) =>
      _$DeleteUsersIntentFromJson(json);

  static const toJsonFactory = _$DeleteUsersIntentToJson;
  Map<String, dynamic> toJson() => _$DeleteUsersIntentToJson(this);

  @JsonKey(name: 'userIds', defaultValue: <String>[])
  final List<String> userIds;
  static const fromJsonFactory = _$DeleteUsersIntentFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is DeleteUsersIntent &&
            (identical(other.userIds, userIds) ||
                const DeepCollectionEquality().equals(other.userIds, userIds)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(userIds) ^ runtimeType.hashCode;
}

extension $DeleteUsersIntentExtension on DeleteUsersIntent {
  DeleteUsersIntent copyWith({List<String>? userIds}) {
    return DeleteUsersIntent(userIds: userIds ?? this.userIds);
  }

  DeleteUsersIntent copyWithWrapped({Wrapped<List<String>>? userIds}) {
    return DeleteUsersIntent(
        userIds: (userIds != null ? userIds.value : this.userIds));
  }
}

@JsonSerializable(explicitToJson: true)
class DeleteUsersRequest {
  const DeleteUsersRequest({
    required this.type,
    required this.timestampMs,
    required this.organizationId,
    required this.parameters,
  });

  factory DeleteUsersRequest.fromJson(Map<String, dynamic> json) =>
      _$DeleteUsersRequestFromJson(json);

  static const toJsonFactory = _$DeleteUsersRequestToJson;
  Map<String, dynamic> toJson() => _$DeleteUsersRequestToJson(this);

  @JsonKey(
    name: 'type',
    toJson: deleteUsersRequestTypeToJson,
    fromJson: deleteUsersRequestTypeFromJson,
  )
  final enums.DeleteUsersRequestType type;
  @JsonKey(name: 'timestampMs')
  final String timestampMs;
  @JsonKey(name: 'organizationId')
  final String organizationId;
  @JsonKey(name: 'parameters')
  final DeleteUsersIntent parameters;
  static const fromJsonFactory = _$DeleteUsersRequestFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is DeleteUsersRequest &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.timestampMs, timestampMs) ||
                const DeepCollectionEquality()
                    .equals(other.timestampMs, timestampMs)) &&
            (identical(other.organizationId, organizationId) ||
                const DeepCollectionEquality()
                    .equals(other.organizationId, organizationId)) &&
            (identical(other.parameters, parameters) ||
                const DeepCollectionEquality()
                    .equals(other.parameters, parameters)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(timestampMs) ^
      const DeepCollectionEquality().hash(organizationId) ^
      const DeepCollectionEquality().hash(parameters) ^
      runtimeType.hashCode;
}

extension $DeleteUsersRequestExtension on DeleteUsersRequest {
  DeleteUsersRequest copyWith(
      {enums.DeleteUsersRequestType? type,
      String? timestampMs,
      String? organizationId,
      DeleteUsersIntent? parameters}) {
    return DeleteUsersRequest(
        type: type ?? this.type,
        timestampMs: timestampMs ?? this.timestampMs,
        organizationId: organizationId ?? this.organizationId,
        parameters: parameters ?? this.parameters);
  }

  DeleteUsersRequest copyWithWrapped(
      {Wrapped<enums.DeleteUsersRequestType>? type,
      Wrapped<String>? timestampMs,
      Wrapped<String>? organizationId,
      Wrapped<DeleteUsersIntent>? parameters}) {
    return DeleteUsersRequest(
        type: (type != null ? type.value : this.type),
        timestampMs:
            (timestampMs != null ? timestampMs.value : this.timestampMs),
        organizationId: (organizationId != null
            ? organizationId.value
            : this.organizationId),
        parameters: (parameters != null ? parameters.value : this.parameters));
  }
}

@JsonSerializable(explicitToJson: true)
class DeleteUsersResult {
  const DeleteUsersResult({
    required this.userIds,
  });

  factory DeleteUsersResult.fromJson(Map<String, dynamic> json) =>
      _$DeleteUsersResultFromJson(json);

  static const toJsonFactory = _$DeleteUsersResultToJson;
  Map<String, dynamic> toJson() => _$DeleteUsersResultToJson(this);

  @JsonKey(name: 'userIds', defaultValue: <String>[])
  final List<String> userIds;
  static const fromJsonFactory = _$DeleteUsersResultFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is DeleteUsersResult &&
            (identical(other.userIds, userIds) ||
                const DeepCollectionEquality().equals(other.userIds, userIds)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(userIds) ^ runtimeType.hashCode;
}

extension $DeleteUsersResultExtension on DeleteUsersResult {
  DeleteUsersResult copyWith({List<String>? userIds}) {
    return DeleteUsersResult(userIds: userIds ?? this.userIds);
  }

  DeleteUsersResult copyWithWrapped({Wrapped<List<String>>? userIds}) {
    return DeleteUsersResult(
        userIds: (userIds != null ? userIds.value : this.userIds));
  }
}

@JsonSerializable(explicitToJson: true)
class DeleteWalletsIntent {
  const DeleteWalletsIntent({
    required this.walletIds,
    this.deleteWithoutExport,
  });

  factory DeleteWalletsIntent.fromJson(Map<String, dynamic> json) =>
      _$DeleteWalletsIntentFromJson(json);

  static const toJsonFactory = _$DeleteWalletsIntentToJson;
  Map<String, dynamic> toJson() => _$DeleteWalletsIntentToJson(this);

  @JsonKey(name: 'walletIds', defaultValue: <String>[])
  final List<String> walletIds;
  @JsonKey(name: 'deleteWithoutExport')
  final bool? deleteWithoutExport;
  static const fromJsonFactory = _$DeleteWalletsIntentFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is DeleteWalletsIntent &&
            (identical(other.walletIds, walletIds) ||
                const DeepCollectionEquality()
                    .equals(other.walletIds, walletIds)) &&
            (identical(other.deleteWithoutExport, deleteWithoutExport) ||
                const DeepCollectionEquality()
                    .equals(other.deleteWithoutExport, deleteWithoutExport)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(walletIds) ^
      const DeepCollectionEquality().hash(deleteWithoutExport) ^
      runtimeType.hashCode;
}

extension $DeleteWalletsIntentExtension on DeleteWalletsIntent {
  DeleteWalletsIntent copyWith(
      {List<String>? walletIds, bool? deleteWithoutExport}) {
    return DeleteWalletsIntent(
        walletIds: walletIds ?? this.walletIds,
        deleteWithoutExport: deleteWithoutExport ?? this.deleteWithoutExport);
  }

  DeleteWalletsIntent copyWithWrapped(
      {Wrapped<List<String>>? walletIds, Wrapped<bool?>? deleteWithoutExport}) {
    return DeleteWalletsIntent(
        walletIds: (walletIds != null ? walletIds.value : this.walletIds),
        deleteWithoutExport: (deleteWithoutExport != null
            ? deleteWithoutExport.value
            : this.deleteWithoutExport));
  }
}

@JsonSerializable(explicitToJson: true)
class DeleteWalletsRequest {
  const DeleteWalletsRequest({
    required this.type,
    required this.timestampMs,
    required this.organizationId,
    required this.parameters,
  });

  factory DeleteWalletsRequest.fromJson(Map<String, dynamic> json) =>
      _$DeleteWalletsRequestFromJson(json);

  static const toJsonFactory = _$DeleteWalletsRequestToJson;
  Map<String, dynamic> toJson() => _$DeleteWalletsRequestToJson(this);

  @JsonKey(
    name: 'type',
    toJson: deleteWalletsRequestTypeToJson,
    fromJson: deleteWalletsRequestTypeFromJson,
  )
  final enums.DeleteWalletsRequestType type;
  @JsonKey(name: 'timestampMs')
  final String timestampMs;
  @JsonKey(name: 'organizationId')
  final String organizationId;
  @JsonKey(name: 'parameters')
  final DeleteWalletsIntent parameters;
  static const fromJsonFactory = _$DeleteWalletsRequestFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is DeleteWalletsRequest &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.timestampMs, timestampMs) ||
                const DeepCollectionEquality()
                    .equals(other.timestampMs, timestampMs)) &&
            (identical(other.organizationId, organizationId) ||
                const DeepCollectionEquality()
                    .equals(other.organizationId, organizationId)) &&
            (identical(other.parameters, parameters) ||
                const DeepCollectionEquality()
                    .equals(other.parameters, parameters)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(timestampMs) ^
      const DeepCollectionEquality().hash(organizationId) ^
      const DeepCollectionEquality().hash(parameters) ^
      runtimeType.hashCode;
}

extension $DeleteWalletsRequestExtension on DeleteWalletsRequest {
  DeleteWalletsRequest copyWith(
      {enums.DeleteWalletsRequestType? type,
      String? timestampMs,
      String? organizationId,
      DeleteWalletsIntent? parameters}) {
    return DeleteWalletsRequest(
        type: type ?? this.type,
        timestampMs: timestampMs ?? this.timestampMs,
        organizationId: organizationId ?? this.organizationId,
        parameters: parameters ?? this.parameters);
  }

  DeleteWalletsRequest copyWithWrapped(
      {Wrapped<enums.DeleteWalletsRequestType>? type,
      Wrapped<String>? timestampMs,
      Wrapped<String>? organizationId,
      Wrapped<DeleteWalletsIntent>? parameters}) {
    return DeleteWalletsRequest(
        type: (type != null ? type.value : this.type),
        timestampMs:
            (timestampMs != null ? timestampMs.value : this.timestampMs),
        organizationId: (organizationId != null
            ? organizationId.value
            : this.organizationId),
        parameters: (parameters != null ? parameters.value : this.parameters));
  }
}

@JsonSerializable(explicitToJson: true)
class DeleteWalletsResult {
  const DeleteWalletsResult({
    required this.walletIds,
  });

  factory DeleteWalletsResult.fromJson(Map<String, dynamic> json) =>
      _$DeleteWalletsResultFromJson(json);

  static const toJsonFactory = _$DeleteWalletsResultToJson;
  Map<String, dynamic> toJson() => _$DeleteWalletsResultToJson(this);

  @JsonKey(name: 'walletIds', defaultValue: <String>[])
  final List<String> walletIds;
  static const fromJsonFactory = _$DeleteWalletsResultFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is DeleteWalletsResult &&
            (identical(other.walletIds, walletIds) ||
                const DeepCollectionEquality()
                    .equals(other.walletIds, walletIds)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(walletIds) ^ runtimeType.hashCode;
}

extension $DeleteWalletsResultExtension on DeleteWalletsResult {
  DeleteWalletsResult copyWith({List<String>? walletIds}) {
    return DeleteWalletsResult(walletIds: walletIds ?? this.walletIds);
  }

  DeleteWalletsResult copyWithWrapped({Wrapped<List<String>>? walletIds}) {
    return DeleteWalletsResult(
        walletIds: (walletIds != null ? walletIds.value : this.walletIds));
  }
}

@JsonSerializable(explicitToJson: true)
class DisablePrivateKeyIntent {
  const DisablePrivateKeyIntent({
    required this.privateKeyId,
  });

  factory DisablePrivateKeyIntent.fromJson(Map<String, dynamic> json) =>
      _$DisablePrivateKeyIntentFromJson(json);

  static const toJsonFactory = _$DisablePrivateKeyIntentToJson;
  Map<String, dynamic> toJson() => _$DisablePrivateKeyIntentToJson(this);

  @JsonKey(name: 'privateKeyId')
  final String privateKeyId;
  static const fromJsonFactory = _$DisablePrivateKeyIntentFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is DisablePrivateKeyIntent &&
            (identical(other.privateKeyId, privateKeyId) ||
                const DeepCollectionEquality()
                    .equals(other.privateKeyId, privateKeyId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(privateKeyId) ^ runtimeType.hashCode;
}

extension $DisablePrivateKeyIntentExtension on DisablePrivateKeyIntent {
  DisablePrivateKeyIntent copyWith({String? privateKeyId}) {
    return DisablePrivateKeyIntent(
        privateKeyId: privateKeyId ?? this.privateKeyId);
  }

  DisablePrivateKeyIntent copyWithWrapped({Wrapped<String>? privateKeyId}) {
    return DisablePrivateKeyIntent(
        privateKeyId:
            (privateKeyId != null ? privateKeyId.value : this.privateKeyId));
  }
}

@JsonSerializable(explicitToJson: true)
class DisablePrivateKeyResult {
  const DisablePrivateKeyResult({
    required this.privateKeyId,
  });

  factory DisablePrivateKeyResult.fromJson(Map<String, dynamic> json) =>
      _$DisablePrivateKeyResultFromJson(json);

  static const toJsonFactory = _$DisablePrivateKeyResultToJson;
  Map<String, dynamic> toJson() => _$DisablePrivateKeyResultToJson(this);

  @JsonKey(name: 'privateKeyId')
  final String privateKeyId;
  static const fromJsonFactory = _$DisablePrivateKeyResultFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is DisablePrivateKeyResult &&
            (identical(other.privateKeyId, privateKeyId) ||
                const DeepCollectionEquality()
                    .equals(other.privateKeyId, privateKeyId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(privateKeyId) ^ runtimeType.hashCode;
}

extension $DisablePrivateKeyResultExtension on DisablePrivateKeyResult {
  DisablePrivateKeyResult copyWith({String? privateKeyId}) {
    return DisablePrivateKeyResult(
        privateKeyId: privateKeyId ?? this.privateKeyId);
  }

  DisablePrivateKeyResult copyWithWrapped({Wrapped<String>? privateKeyId}) {
    return DisablePrivateKeyResult(
        privateKeyId:
            (privateKeyId != null ? privateKeyId.value : this.privateKeyId));
  }
}

@JsonSerializable(explicitToJson: true)
class EmailAuthIntent {
  const EmailAuthIntent({
    required this.email,
    required this.targetPublicKey,
    this.apiKeyName,
    this.expirationSeconds,
    this.emailCustomization,
    this.invalidateExisting,
    this.sendFromEmailAddress,
    this.sendFromEmailSenderName,
    this.replyToEmailAddress,
  });

  factory EmailAuthIntent.fromJson(Map<String, dynamic> json) =>
      _$EmailAuthIntentFromJson(json);

  static const toJsonFactory = _$EmailAuthIntentToJson;
  Map<String, dynamic> toJson() => _$EmailAuthIntentToJson(this);

  @JsonKey(name: 'email')
  final String email;
  @JsonKey(name: 'targetPublicKey')
  final String targetPublicKey;
  @JsonKey(name: 'apiKeyName')
  final String? apiKeyName;
  @JsonKey(name: 'expirationSeconds')
  final String? expirationSeconds;
  @JsonKey(name: 'emailCustomization')
  final EmailCustomizationParams? emailCustomization;
  @JsonKey(name: 'invalidateExisting')
  final bool? invalidateExisting;
  @JsonKey(name: 'sendFromEmailAddress')
  final String? sendFromEmailAddress;
  @JsonKey(name: 'sendFromEmailSenderName')
  final String? sendFromEmailSenderName;
  @JsonKey(name: 'replyToEmailAddress')
  final String? replyToEmailAddress;
  static const fromJsonFactory = _$EmailAuthIntentFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is EmailAuthIntent &&
            (identical(other.email, email) ||
                const DeepCollectionEquality().equals(other.email, email)) &&
            (identical(other.targetPublicKey, targetPublicKey) ||
                const DeepCollectionEquality()
                    .equals(other.targetPublicKey, targetPublicKey)) &&
            (identical(other.apiKeyName, apiKeyName) ||
                const DeepCollectionEquality()
                    .equals(other.apiKeyName, apiKeyName)) &&
            (identical(other.expirationSeconds, expirationSeconds) ||
                const DeepCollectionEquality()
                    .equals(other.expirationSeconds, expirationSeconds)) &&
            (identical(other.emailCustomization, emailCustomization) ||
                const DeepCollectionEquality()
                    .equals(other.emailCustomization, emailCustomization)) &&
            (identical(other.invalidateExisting, invalidateExisting) ||
                const DeepCollectionEquality()
                    .equals(other.invalidateExisting, invalidateExisting)) &&
            (identical(other.sendFromEmailAddress, sendFromEmailAddress) ||
                const DeepCollectionEquality().equals(
                    other.sendFromEmailAddress, sendFromEmailAddress)) &&
            (identical(
                    other.sendFromEmailSenderName, sendFromEmailSenderName) ||
                const DeepCollectionEquality().equals(
                    other.sendFromEmailSenderName, sendFromEmailSenderName)) &&
            (identical(other.replyToEmailAddress, replyToEmailAddress) ||
                const DeepCollectionEquality()
                    .equals(other.replyToEmailAddress, replyToEmailAddress)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(email) ^
      const DeepCollectionEquality().hash(targetPublicKey) ^
      const DeepCollectionEquality().hash(apiKeyName) ^
      const DeepCollectionEquality().hash(expirationSeconds) ^
      const DeepCollectionEquality().hash(emailCustomization) ^
      const DeepCollectionEquality().hash(invalidateExisting) ^
      const DeepCollectionEquality().hash(sendFromEmailAddress) ^
      const DeepCollectionEquality().hash(sendFromEmailSenderName) ^
      const DeepCollectionEquality().hash(replyToEmailAddress) ^
      runtimeType.hashCode;
}

extension $EmailAuthIntentExtension on EmailAuthIntent {
  EmailAuthIntent copyWith(
      {String? email,
      String? targetPublicKey,
      String? apiKeyName,
      String? expirationSeconds,
      EmailCustomizationParams? emailCustomization,
      bool? invalidateExisting,
      String? sendFromEmailAddress,
      String? sendFromEmailSenderName,
      String? replyToEmailAddress}) {
    return EmailAuthIntent(
        email: email ?? this.email,
        targetPublicKey: targetPublicKey ?? this.targetPublicKey,
        apiKeyName: apiKeyName ?? this.apiKeyName,
        expirationSeconds: expirationSeconds ?? this.expirationSeconds,
        emailCustomization: emailCustomization ?? this.emailCustomization,
        invalidateExisting: invalidateExisting ?? this.invalidateExisting,
        sendFromEmailAddress: sendFromEmailAddress ?? this.sendFromEmailAddress,
        sendFromEmailSenderName:
            sendFromEmailSenderName ?? this.sendFromEmailSenderName,
        replyToEmailAddress: replyToEmailAddress ?? this.replyToEmailAddress);
  }

  EmailAuthIntent copyWithWrapped(
      {Wrapped<String>? email,
      Wrapped<String>? targetPublicKey,
      Wrapped<String?>? apiKeyName,
      Wrapped<String?>? expirationSeconds,
      Wrapped<EmailCustomizationParams?>? emailCustomization,
      Wrapped<bool?>? invalidateExisting,
      Wrapped<String?>? sendFromEmailAddress,
      Wrapped<String?>? sendFromEmailSenderName,
      Wrapped<String?>? replyToEmailAddress}) {
    return EmailAuthIntent(
        email: (email != null ? email.value : this.email),
        targetPublicKey: (targetPublicKey != null
            ? targetPublicKey.value
            : this.targetPublicKey),
        apiKeyName: (apiKeyName != null ? apiKeyName.value : this.apiKeyName),
        expirationSeconds: (expirationSeconds != null
            ? expirationSeconds.value
            : this.expirationSeconds),
        emailCustomization: (emailCustomization != null
            ? emailCustomization.value
            : this.emailCustomization),
        invalidateExisting: (invalidateExisting != null
            ? invalidateExisting.value
            : this.invalidateExisting),
        sendFromEmailAddress: (sendFromEmailAddress != null
            ? sendFromEmailAddress.value
            : this.sendFromEmailAddress),
        sendFromEmailSenderName: (sendFromEmailSenderName != null
            ? sendFromEmailSenderName.value
            : this.sendFromEmailSenderName),
        replyToEmailAddress: (replyToEmailAddress != null
            ? replyToEmailAddress.value
            : this.replyToEmailAddress));
  }
}

@JsonSerializable(explicitToJson: true)
class EmailAuthIntentV2 {
  const EmailAuthIntentV2({
    required this.email,
    required this.targetPublicKey,
    this.apiKeyName,
    this.expirationSeconds,
    this.emailCustomization,
    this.invalidateExisting,
    this.sendFromEmailAddress,
    this.sendFromEmailSenderName,
    this.replyToEmailAddress,
  });

  factory EmailAuthIntentV2.fromJson(Map<String, dynamic> json) =>
      _$EmailAuthIntentV2FromJson(json);

  static const toJsonFactory = _$EmailAuthIntentV2ToJson;
  Map<String, dynamic> toJson() => _$EmailAuthIntentV2ToJson(this);

  @JsonKey(name: 'email')
  final String email;
  @JsonKey(name: 'targetPublicKey')
  final String targetPublicKey;
  @JsonKey(name: 'apiKeyName')
  final String? apiKeyName;
  @JsonKey(name: 'expirationSeconds')
  final String? expirationSeconds;
  @JsonKey(name: 'emailCustomization')
  final EmailCustomizationParams? emailCustomization;
  @JsonKey(name: 'invalidateExisting')
  final bool? invalidateExisting;
  @JsonKey(name: 'sendFromEmailAddress')
  final String? sendFromEmailAddress;
  @JsonKey(name: 'sendFromEmailSenderName')
  final String? sendFromEmailSenderName;
  @JsonKey(name: 'replyToEmailAddress')
  final String? replyToEmailAddress;
  static const fromJsonFactory = _$EmailAuthIntentV2FromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is EmailAuthIntentV2 &&
            (identical(other.email, email) ||
                const DeepCollectionEquality().equals(other.email, email)) &&
            (identical(other.targetPublicKey, targetPublicKey) ||
                const DeepCollectionEquality()
                    .equals(other.targetPublicKey, targetPublicKey)) &&
            (identical(other.apiKeyName, apiKeyName) ||
                const DeepCollectionEquality()
                    .equals(other.apiKeyName, apiKeyName)) &&
            (identical(other.expirationSeconds, expirationSeconds) ||
                const DeepCollectionEquality()
                    .equals(other.expirationSeconds, expirationSeconds)) &&
            (identical(other.emailCustomization, emailCustomization) ||
                const DeepCollectionEquality()
                    .equals(other.emailCustomization, emailCustomization)) &&
            (identical(other.invalidateExisting, invalidateExisting) ||
                const DeepCollectionEquality()
                    .equals(other.invalidateExisting, invalidateExisting)) &&
            (identical(other.sendFromEmailAddress, sendFromEmailAddress) ||
                const DeepCollectionEquality().equals(
                    other.sendFromEmailAddress, sendFromEmailAddress)) &&
            (identical(
                    other.sendFromEmailSenderName, sendFromEmailSenderName) ||
                const DeepCollectionEquality().equals(
                    other.sendFromEmailSenderName, sendFromEmailSenderName)) &&
            (identical(other.replyToEmailAddress, replyToEmailAddress) ||
                const DeepCollectionEquality()
                    .equals(other.replyToEmailAddress, replyToEmailAddress)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(email) ^
      const DeepCollectionEquality().hash(targetPublicKey) ^
      const DeepCollectionEquality().hash(apiKeyName) ^
      const DeepCollectionEquality().hash(expirationSeconds) ^
      const DeepCollectionEquality().hash(emailCustomization) ^
      const DeepCollectionEquality().hash(invalidateExisting) ^
      const DeepCollectionEquality().hash(sendFromEmailAddress) ^
      const DeepCollectionEquality().hash(sendFromEmailSenderName) ^
      const DeepCollectionEquality().hash(replyToEmailAddress) ^
      runtimeType.hashCode;
}

extension $EmailAuthIntentV2Extension on EmailAuthIntentV2 {
  EmailAuthIntentV2 copyWith(
      {String? email,
      String? targetPublicKey,
      String? apiKeyName,
      String? expirationSeconds,
      EmailCustomizationParams? emailCustomization,
      bool? invalidateExisting,
      String? sendFromEmailAddress,
      String? sendFromEmailSenderName,
      String? replyToEmailAddress}) {
    return EmailAuthIntentV2(
        email: email ?? this.email,
        targetPublicKey: targetPublicKey ?? this.targetPublicKey,
        apiKeyName: apiKeyName ?? this.apiKeyName,
        expirationSeconds: expirationSeconds ?? this.expirationSeconds,
        emailCustomization: emailCustomization ?? this.emailCustomization,
        invalidateExisting: invalidateExisting ?? this.invalidateExisting,
        sendFromEmailAddress: sendFromEmailAddress ?? this.sendFromEmailAddress,
        sendFromEmailSenderName:
            sendFromEmailSenderName ?? this.sendFromEmailSenderName,
        replyToEmailAddress: replyToEmailAddress ?? this.replyToEmailAddress);
  }

  EmailAuthIntentV2 copyWithWrapped(
      {Wrapped<String>? email,
      Wrapped<String>? targetPublicKey,
      Wrapped<String?>? apiKeyName,
      Wrapped<String?>? expirationSeconds,
      Wrapped<EmailCustomizationParams?>? emailCustomization,
      Wrapped<bool?>? invalidateExisting,
      Wrapped<String?>? sendFromEmailAddress,
      Wrapped<String?>? sendFromEmailSenderName,
      Wrapped<String?>? replyToEmailAddress}) {
    return EmailAuthIntentV2(
        email: (email != null ? email.value : this.email),
        targetPublicKey: (targetPublicKey != null
            ? targetPublicKey.value
            : this.targetPublicKey),
        apiKeyName: (apiKeyName != null ? apiKeyName.value : this.apiKeyName),
        expirationSeconds: (expirationSeconds != null
            ? expirationSeconds.value
            : this.expirationSeconds),
        emailCustomization: (emailCustomization != null
            ? emailCustomization.value
            : this.emailCustomization),
        invalidateExisting: (invalidateExisting != null
            ? invalidateExisting.value
            : this.invalidateExisting),
        sendFromEmailAddress: (sendFromEmailAddress != null
            ? sendFromEmailAddress.value
            : this.sendFromEmailAddress),
        sendFromEmailSenderName: (sendFromEmailSenderName != null
            ? sendFromEmailSenderName.value
            : this.sendFromEmailSenderName),
        replyToEmailAddress: (replyToEmailAddress != null
            ? replyToEmailAddress.value
            : this.replyToEmailAddress));
  }
}

@JsonSerializable(explicitToJson: true)
class EmailAuthRequest {
  const EmailAuthRequest({
    required this.type,
    required this.timestampMs,
    required this.organizationId,
    required this.parameters,
  });

  factory EmailAuthRequest.fromJson(Map<String, dynamic> json) =>
      _$EmailAuthRequestFromJson(json);

  static const toJsonFactory = _$EmailAuthRequestToJson;
  Map<String, dynamic> toJson() => _$EmailAuthRequestToJson(this);

  @JsonKey(
    name: 'type',
    toJson: emailAuthRequestTypeToJson,
    fromJson: emailAuthRequestTypeFromJson,
  )
  final enums.EmailAuthRequestType type;
  @JsonKey(name: 'timestampMs')
  final String timestampMs;
  @JsonKey(name: 'organizationId')
  final String organizationId;
  @JsonKey(name: 'parameters')
  final EmailAuthIntentV2 parameters;
  static const fromJsonFactory = _$EmailAuthRequestFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is EmailAuthRequest &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.timestampMs, timestampMs) ||
                const DeepCollectionEquality()
                    .equals(other.timestampMs, timestampMs)) &&
            (identical(other.organizationId, organizationId) ||
                const DeepCollectionEquality()
                    .equals(other.organizationId, organizationId)) &&
            (identical(other.parameters, parameters) ||
                const DeepCollectionEquality()
                    .equals(other.parameters, parameters)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(timestampMs) ^
      const DeepCollectionEquality().hash(organizationId) ^
      const DeepCollectionEquality().hash(parameters) ^
      runtimeType.hashCode;
}

extension $EmailAuthRequestExtension on EmailAuthRequest {
  EmailAuthRequest copyWith(
      {enums.EmailAuthRequestType? type,
      String? timestampMs,
      String? organizationId,
      EmailAuthIntentV2? parameters}) {
    return EmailAuthRequest(
        type: type ?? this.type,
        timestampMs: timestampMs ?? this.timestampMs,
        organizationId: organizationId ?? this.organizationId,
        parameters: parameters ?? this.parameters);
  }

  EmailAuthRequest copyWithWrapped(
      {Wrapped<enums.EmailAuthRequestType>? type,
      Wrapped<String>? timestampMs,
      Wrapped<String>? organizationId,
      Wrapped<EmailAuthIntentV2>? parameters}) {
    return EmailAuthRequest(
        type: (type != null ? type.value : this.type),
        timestampMs:
            (timestampMs != null ? timestampMs.value : this.timestampMs),
        organizationId: (organizationId != null
            ? organizationId.value
            : this.organizationId),
        parameters: (parameters != null ? parameters.value : this.parameters));
  }
}

@JsonSerializable(explicitToJson: true)
class EmailAuthResult {
  const EmailAuthResult({
    required this.userId,
    required this.apiKeyId,
  });

  factory EmailAuthResult.fromJson(Map<String, dynamic> json) =>
      _$EmailAuthResultFromJson(json);

  static const toJsonFactory = _$EmailAuthResultToJson;
  Map<String, dynamic> toJson() => _$EmailAuthResultToJson(this);

  @JsonKey(name: 'userId')
  final String userId;
  @JsonKey(name: 'apiKeyId')
  final String apiKeyId;
  static const fromJsonFactory = _$EmailAuthResultFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is EmailAuthResult &&
            (identical(other.userId, userId) ||
                const DeepCollectionEquality().equals(other.userId, userId)) &&
            (identical(other.apiKeyId, apiKeyId) ||
                const DeepCollectionEquality()
                    .equals(other.apiKeyId, apiKeyId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(userId) ^
      const DeepCollectionEquality().hash(apiKeyId) ^
      runtimeType.hashCode;
}

extension $EmailAuthResultExtension on EmailAuthResult {
  EmailAuthResult copyWith({String? userId, String? apiKeyId}) {
    return EmailAuthResult(
        userId: userId ?? this.userId, apiKeyId: apiKeyId ?? this.apiKeyId);
  }

  EmailAuthResult copyWithWrapped(
      {Wrapped<String>? userId, Wrapped<String>? apiKeyId}) {
    return EmailAuthResult(
        userId: (userId != null ? userId.value : this.userId),
        apiKeyId: (apiKeyId != null ? apiKeyId.value : this.apiKeyId));
  }
}

@JsonSerializable(explicitToJson: true)
class EmailCustomizationParams {
  const EmailCustomizationParams({
    this.appName,
    this.logoUrl,
    this.magicLinkTemplate,
    this.templateVariables,
    this.templateId,
  });

  factory EmailCustomizationParams.fromJson(Map<String, dynamic> json) =>
      _$EmailCustomizationParamsFromJson(json);

  static const toJsonFactory = _$EmailCustomizationParamsToJson;
  Map<String, dynamic> toJson() => _$EmailCustomizationParamsToJson(this);

  @JsonKey(name: 'appName')
  final String? appName;
  @JsonKey(name: 'logoUrl')
  final String? logoUrl;
  @JsonKey(name: 'magicLinkTemplate')
  final String? magicLinkTemplate;
  @JsonKey(name: 'templateVariables')
  final String? templateVariables;
  @JsonKey(name: 'templateId')
  final String? templateId;
  static const fromJsonFactory = _$EmailCustomizationParamsFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is EmailCustomizationParams &&
            (identical(other.appName, appName) ||
                const DeepCollectionEquality()
                    .equals(other.appName, appName)) &&
            (identical(other.logoUrl, logoUrl) ||
                const DeepCollectionEquality()
                    .equals(other.logoUrl, logoUrl)) &&
            (identical(other.magicLinkTemplate, magicLinkTemplate) ||
                const DeepCollectionEquality()
                    .equals(other.magicLinkTemplate, magicLinkTemplate)) &&
            (identical(other.templateVariables, templateVariables) ||
                const DeepCollectionEquality()
                    .equals(other.templateVariables, templateVariables)) &&
            (identical(other.templateId, templateId) ||
                const DeepCollectionEquality()
                    .equals(other.templateId, templateId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(appName) ^
      const DeepCollectionEquality().hash(logoUrl) ^
      const DeepCollectionEquality().hash(magicLinkTemplate) ^
      const DeepCollectionEquality().hash(templateVariables) ^
      const DeepCollectionEquality().hash(templateId) ^
      runtimeType.hashCode;
}

extension $EmailCustomizationParamsExtension on EmailCustomizationParams {
  EmailCustomizationParams copyWith(
      {String? appName,
      String? logoUrl,
      String? magicLinkTemplate,
      String? templateVariables,
      String? templateId}) {
    return EmailCustomizationParams(
        appName: appName ?? this.appName,
        logoUrl: logoUrl ?? this.logoUrl,
        magicLinkTemplate: magicLinkTemplate ?? this.magicLinkTemplate,
        templateVariables: templateVariables ?? this.templateVariables,
        templateId: templateId ?? this.templateId);
  }

  EmailCustomizationParams copyWithWrapped(
      {Wrapped<String?>? appName,
      Wrapped<String?>? logoUrl,
      Wrapped<String?>? magicLinkTemplate,
      Wrapped<String?>? templateVariables,
      Wrapped<String?>? templateId}) {
    return EmailCustomizationParams(
        appName: (appName != null ? appName.value : this.appName),
        logoUrl: (logoUrl != null ? logoUrl.value : this.logoUrl),
        magicLinkTemplate: (magicLinkTemplate != null
            ? magicLinkTemplate.value
            : this.magicLinkTemplate),
        templateVariables: (templateVariables != null
            ? templateVariables.value
            : this.templateVariables),
        templateId: (templateId != null ? templateId.value : this.templateId));
  }
}

@JsonSerializable(explicitToJson: true)
class ExportPrivateKeyIntent {
  const ExportPrivateKeyIntent({
    required this.privateKeyId,
    required this.targetPublicKey,
  });

  factory ExportPrivateKeyIntent.fromJson(Map<String, dynamic> json) =>
      _$ExportPrivateKeyIntentFromJson(json);

  static const toJsonFactory = _$ExportPrivateKeyIntentToJson;
  Map<String, dynamic> toJson() => _$ExportPrivateKeyIntentToJson(this);

  @JsonKey(name: 'privateKeyId')
  final String privateKeyId;
  @JsonKey(name: 'targetPublicKey')
  final String targetPublicKey;
  static const fromJsonFactory = _$ExportPrivateKeyIntentFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ExportPrivateKeyIntent &&
            (identical(other.privateKeyId, privateKeyId) ||
                const DeepCollectionEquality()
                    .equals(other.privateKeyId, privateKeyId)) &&
            (identical(other.targetPublicKey, targetPublicKey) ||
                const DeepCollectionEquality()
                    .equals(other.targetPublicKey, targetPublicKey)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(privateKeyId) ^
      const DeepCollectionEquality().hash(targetPublicKey) ^
      runtimeType.hashCode;
}

extension $ExportPrivateKeyIntentExtension on ExportPrivateKeyIntent {
  ExportPrivateKeyIntent copyWith(
      {String? privateKeyId, String? targetPublicKey}) {
    return ExportPrivateKeyIntent(
        privateKeyId: privateKeyId ?? this.privateKeyId,
        targetPublicKey: targetPublicKey ?? this.targetPublicKey);
  }

  ExportPrivateKeyIntent copyWithWrapped(
      {Wrapped<String>? privateKeyId, Wrapped<String>? targetPublicKey}) {
    return ExportPrivateKeyIntent(
        privateKeyId:
            (privateKeyId != null ? privateKeyId.value : this.privateKeyId),
        targetPublicKey: (targetPublicKey != null
            ? targetPublicKey.value
            : this.targetPublicKey));
  }
}

@JsonSerializable(explicitToJson: true)
class ExportPrivateKeyRequest {
  const ExportPrivateKeyRequest({
    required this.type,
    required this.timestampMs,
    required this.organizationId,
    required this.parameters,
  });

  factory ExportPrivateKeyRequest.fromJson(Map<String, dynamic> json) =>
      _$ExportPrivateKeyRequestFromJson(json);

  static const toJsonFactory = _$ExportPrivateKeyRequestToJson;
  Map<String, dynamic> toJson() => _$ExportPrivateKeyRequestToJson(this);

  @JsonKey(
    name: 'type',
    toJson: exportPrivateKeyRequestTypeToJson,
    fromJson: exportPrivateKeyRequestTypeFromJson,
  )
  final enums.ExportPrivateKeyRequestType type;
  @JsonKey(name: 'timestampMs')
  final String timestampMs;
  @JsonKey(name: 'organizationId')
  final String organizationId;
  @JsonKey(name: 'parameters')
  final ExportPrivateKeyIntent parameters;
  static const fromJsonFactory = _$ExportPrivateKeyRequestFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ExportPrivateKeyRequest &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.timestampMs, timestampMs) ||
                const DeepCollectionEquality()
                    .equals(other.timestampMs, timestampMs)) &&
            (identical(other.organizationId, organizationId) ||
                const DeepCollectionEquality()
                    .equals(other.organizationId, organizationId)) &&
            (identical(other.parameters, parameters) ||
                const DeepCollectionEquality()
                    .equals(other.parameters, parameters)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(timestampMs) ^
      const DeepCollectionEquality().hash(organizationId) ^
      const DeepCollectionEquality().hash(parameters) ^
      runtimeType.hashCode;
}

extension $ExportPrivateKeyRequestExtension on ExportPrivateKeyRequest {
  ExportPrivateKeyRequest copyWith(
      {enums.ExportPrivateKeyRequestType? type,
      String? timestampMs,
      String? organizationId,
      ExportPrivateKeyIntent? parameters}) {
    return ExportPrivateKeyRequest(
        type: type ?? this.type,
        timestampMs: timestampMs ?? this.timestampMs,
        organizationId: organizationId ?? this.organizationId,
        parameters: parameters ?? this.parameters);
  }

  ExportPrivateKeyRequest copyWithWrapped(
      {Wrapped<enums.ExportPrivateKeyRequestType>? type,
      Wrapped<String>? timestampMs,
      Wrapped<String>? organizationId,
      Wrapped<ExportPrivateKeyIntent>? parameters}) {
    return ExportPrivateKeyRequest(
        type: (type != null ? type.value : this.type),
        timestampMs:
            (timestampMs != null ? timestampMs.value : this.timestampMs),
        organizationId: (organizationId != null
            ? organizationId.value
            : this.organizationId),
        parameters: (parameters != null ? parameters.value : this.parameters));
  }
}

@JsonSerializable(explicitToJson: true)
class ExportPrivateKeyResult {
  const ExportPrivateKeyResult({
    required this.privateKeyId,
    required this.exportBundle,
  });

  factory ExportPrivateKeyResult.fromJson(Map<String, dynamic> json) =>
      _$ExportPrivateKeyResultFromJson(json);

  static const toJsonFactory = _$ExportPrivateKeyResultToJson;
  Map<String, dynamic> toJson() => _$ExportPrivateKeyResultToJson(this);

  @JsonKey(name: 'privateKeyId')
  final String privateKeyId;
  @JsonKey(name: 'exportBundle')
  final String exportBundle;
  static const fromJsonFactory = _$ExportPrivateKeyResultFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ExportPrivateKeyResult &&
            (identical(other.privateKeyId, privateKeyId) ||
                const DeepCollectionEquality()
                    .equals(other.privateKeyId, privateKeyId)) &&
            (identical(other.exportBundle, exportBundle) ||
                const DeepCollectionEquality()
                    .equals(other.exportBundle, exportBundle)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(privateKeyId) ^
      const DeepCollectionEquality().hash(exportBundle) ^
      runtimeType.hashCode;
}

extension $ExportPrivateKeyResultExtension on ExportPrivateKeyResult {
  ExportPrivateKeyResult copyWith(
      {String? privateKeyId, String? exportBundle}) {
    return ExportPrivateKeyResult(
        privateKeyId: privateKeyId ?? this.privateKeyId,
        exportBundle: exportBundle ?? this.exportBundle);
  }

  ExportPrivateKeyResult copyWithWrapped(
      {Wrapped<String>? privateKeyId, Wrapped<String>? exportBundle}) {
    return ExportPrivateKeyResult(
        privateKeyId:
            (privateKeyId != null ? privateKeyId.value : this.privateKeyId),
        exportBundle:
            (exportBundle != null ? exportBundle.value : this.exportBundle));
  }
}

@JsonSerializable(explicitToJson: true)
class ExportWalletAccountIntent {
  const ExportWalletAccountIntent({
    required this.address,
    required this.targetPublicKey,
  });

  factory ExportWalletAccountIntent.fromJson(Map<String, dynamic> json) =>
      _$ExportWalletAccountIntentFromJson(json);

  static const toJsonFactory = _$ExportWalletAccountIntentToJson;
  Map<String, dynamic> toJson() => _$ExportWalletAccountIntentToJson(this);

  @JsonKey(name: 'address')
  final String address;
  @JsonKey(name: 'targetPublicKey')
  final String targetPublicKey;
  static const fromJsonFactory = _$ExportWalletAccountIntentFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ExportWalletAccountIntent &&
            (identical(other.address, address) ||
                const DeepCollectionEquality()
                    .equals(other.address, address)) &&
            (identical(other.targetPublicKey, targetPublicKey) ||
                const DeepCollectionEquality()
                    .equals(other.targetPublicKey, targetPublicKey)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(address) ^
      const DeepCollectionEquality().hash(targetPublicKey) ^
      runtimeType.hashCode;
}

extension $ExportWalletAccountIntentExtension on ExportWalletAccountIntent {
  ExportWalletAccountIntent copyWith(
      {String? address, String? targetPublicKey}) {
    return ExportWalletAccountIntent(
        address: address ?? this.address,
        targetPublicKey: targetPublicKey ?? this.targetPublicKey);
  }

  ExportWalletAccountIntent copyWithWrapped(
      {Wrapped<String>? address, Wrapped<String>? targetPublicKey}) {
    return ExportWalletAccountIntent(
        address: (address != null ? address.value : this.address),
        targetPublicKey: (targetPublicKey != null
            ? targetPublicKey.value
            : this.targetPublicKey));
  }
}

@JsonSerializable(explicitToJson: true)
class ExportWalletAccountRequest {
  const ExportWalletAccountRequest({
    required this.type,
    required this.timestampMs,
    required this.organizationId,
    required this.parameters,
  });

  factory ExportWalletAccountRequest.fromJson(Map<String, dynamic> json) =>
      _$ExportWalletAccountRequestFromJson(json);

  static const toJsonFactory = _$ExportWalletAccountRequestToJson;
  Map<String, dynamic> toJson() => _$ExportWalletAccountRequestToJson(this);

  @JsonKey(
    name: 'type',
    toJson: exportWalletAccountRequestTypeToJson,
    fromJson: exportWalletAccountRequestTypeFromJson,
  )
  final enums.ExportWalletAccountRequestType type;
  @JsonKey(name: 'timestampMs')
  final String timestampMs;
  @JsonKey(name: 'organizationId')
  final String organizationId;
  @JsonKey(name: 'parameters')
  final ExportWalletAccountIntent parameters;
  static const fromJsonFactory = _$ExportWalletAccountRequestFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ExportWalletAccountRequest &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.timestampMs, timestampMs) ||
                const DeepCollectionEquality()
                    .equals(other.timestampMs, timestampMs)) &&
            (identical(other.organizationId, organizationId) ||
                const DeepCollectionEquality()
                    .equals(other.organizationId, organizationId)) &&
            (identical(other.parameters, parameters) ||
                const DeepCollectionEquality()
                    .equals(other.parameters, parameters)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(timestampMs) ^
      const DeepCollectionEquality().hash(organizationId) ^
      const DeepCollectionEquality().hash(parameters) ^
      runtimeType.hashCode;
}

extension $ExportWalletAccountRequestExtension on ExportWalletAccountRequest {
  ExportWalletAccountRequest copyWith(
      {enums.ExportWalletAccountRequestType? type,
      String? timestampMs,
      String? organizationId,
      ExportWalletAccountIntent? parameters}) {
    return ExportWalletAccountRequest(
        type: type ?? this.type,
        timestampMs: timestampMs ?? this.timestampMs,
        organizationId: organizationId ?? this.organizationId,
        parameters: parameters ?? this.parameters);
  }

  ExportWalletAccountRequest copyWithWrapped(
      {Wrapped<enums.ExportWalletAccountRequestType>? type,
      Wrapped<String>? timestampMs,
      Wrapped<String>? organizationId,
      Wrapped<ExportWalletAccountIntent>? parameters}) {
    return ExportWalletAccountRequest(
        type: (type != null ? type.value : this.type),
        timestampMs:
            (timestampMs != null ? timestampMs.value : this.timestampMs),
        organizationId: (organizationId != null
            ? organizationId.value
            : this.organizationId),
        parameters: (parameters != null ? parameters.value : this.parameters));
  }
}

@JsonSerializable(explicitToJson: true)
class ExportWalletAccountResult {
  const ExportWalletAccountResult({
    required this.address,
    required this.exportBundle,
  });

  factory ExportWalletAccountResult.fromJson(Map<String, dynamic> json) =>
      _$ExportWalletAccountResultFromJson(json);

  static const toJsonFactory = _$ExportWalletAccountResultToJson;
  Map<String, dynamic> toJson() => _$ExportWalletAccountResultToJson(this);

  @JsonKey(name: 'address')
  final String address;
  @JsonKey(name: 'exportBundle')
  final String exportBundle;
  static const fromJsonFactory = _$ExportWalletAccountResultFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ExportWalletAccountResult &&
            (identical(other.address, address) ||
                const DeepCollectionEquality()
                    .equals(other.address, address)) &&
            (identical(other.exportBundle, exportBundle) ||
                const DeepCollectionEquality()
                    .equals(other.exportBundle, exportBundle)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(address) ^
      const DeepCollectionEquality().hash(exportBundle) ^
      runtimeType.hashCode;
}

extension $ExportWalletAccountResultExtension on ExportWalletAccountResult {
  ExportWalletAccountResult copyWith({String? address, String? exportBundle}) {
    return ExportWalletAccountResult(
        address: address ?? this.address,
        exportBundle: exportBundle ?? this.exportBundle);
  }

  ExportWalletAccountResult copyWithWrapped(
      {Wrapped<String>? address, Wrapped<String>? exportBundle}) {
    return ExportWalletAccountResult(
        address: (address != null ? address.value : this.address),
        exportBundle:
            (exportBundle != null ? exportBundle.value : this.exportBundle));
  }
}

@JsonSerializable(explicitToJson: true)
class ExportWalletIntent {
  const ExportWalletIntent({
    required this.walletId,
    required this.targetPublicKey,
    this.language,
  });

  factory ExportWalletIntent.fromJson(Map<String, dynamic> json) =>
      _$ExportWalletIntentFromJson(json);

  static const toJsonFactory = _$ExportWalletIntentToJson;
  Map<String, dynamic> toJson() => _$ExportWalletIntentToJson(this);

  @JsonKey(name: 'walletId')
  final String walletId;
  @JsonKey(name: 'targetPublicKey')
  final String targetPublicKey;
  @JsonKey(
    name: 'language',
    toJson: mnemonicLanguageNullableToJson,
    fromJson: mnemonicLanguageNullableFromJson,
  )
  final enums.MnemonicLanguage? language;
  static const fromJsonFactory = _$ExportWalletIntentFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ExportWalletIntent &&
            (identical(other.walletId, walletId) ||
                const DeepCollectionEquality()
                    .equals(other.walletId, walletId)) &&
            (identical(other.targetPublicKey, targetPublicKey) ||
                const DeepCollectionEquality()
                    .equals(other.targetPublicKey, targetPublicKey)) &&
            (identical(other.language, language) ||
                const DeepCollectionEquality()
                    .equals(other.language, language)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(walletId) ^
      const DeepCollectionEquality().hash(targetPublicKey) ^
      const DeepCollectionEquality().hash(language) ^
      runtimeType.hashCode;
}

extension $ExportWalletIntentExtension on ExportWalletIntent {
  ExportWalletIntent copyWith(
      {String? walletId,
      String? targetPublicKey,
      enums.MnemonicLanguage? language}) {
    return ExportWalletIntent(
        walletId: walletId ?? this.walletId,
        targetPublicKey: targetPublicKey ?? this.targetPublicKey,
        language: language ?? this.language);
  }

  ExportWalletIntent copyWithWrapped(
      {Wrapped<String>? walletId,
      Wrapped<String>? targetPublicKey,
      Wrapped<enums.MnemonicLanguage?>? language}) {
    return ExportWalletIntent(
        walletId: (walletId != null ? walletId.value : this.walletId),
        targetPublicKey: (targetPublicKey != null
            ? targetPublicKey.value
            : this.targetPublicKey),
        language: (language != null ? language.value : this.language));
  }
}

@JsonSerializable(explicitToJson: true)
class ExportWalletRequest {
  const ExportWalletRequest({
    required this.type,
    required this.timestampMs,
    required this.organizationId,
    required this.parameters,
  });

  factory ExportWalletRequest.fromJson(Map<String, dynamic> json) =>
      _$ExportWalletRequestFromJson(json);

  static const toJsonFactory = _$ExportWalletRequestToJson;
  Map<String, dynamic> toJson() => _$ExportWalletRequestToJson(this);

  @JsonKey(
    name: 'type',
    toJson: exportWalletRequestTypeToJson,
    fromJson: exportWalletRequestTypeFromJson,
  )
  final enums.ExportWalletRequestType type;
  @JsonKey(name: 'timestampMs')
  final String timestampMs;
  @JsonKey(name: 'organizationId')
  final String organizationId;
  @JsonKey(name: 'parameters')
  final ExportWalletIntent parameters;
  static const fromJsonFactory = _$ExportWalletRequestFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ExportWalletRequest &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.timestampMs, timestampMs) ||
                const DeepCollectionEquality()
                    .equals(other.timestampMs, timestampMs)) &&
            (identical(other.organizationId, organizationId) ||
                const DeepCollectionEquality()
                    .equals(other.organizationId, organizationId)) &&
            (identical(other.parameters, parameters) ||
                const DeepCollectionEquality()
                    .equals(other.parameters, parameters)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(timestampMs) ^
      const DeepCollectionEquality().hash(organizationId) ^
      const DeepCollectionEquality().hash(parameters) ^
      runtimeType.hashCode;
}

extension $ExportWalletRequestExtension on ExportWalletRequest {
  ExportWalletRequest copyWith(
      {enums.ExportWalletRequestType? type,
      String? timestampMs,
      String? organizationId,
      ExportWalletIntent? parameters}) {
    return ExportWalletRequest(
        type: type ?? this.type,
        timestampMs: timestampMs ?? this.timestampMs,
        organizationId: organizationId ?? this.organizationId,
        parameters: parameters ?? this.parameters);
  }

  ExportWalletRequest copyWithWrapped(
      {Wrapped<enums.ExportWalletRequestType>? type,
      Wrapped<String>? timestampMs,
      Wrapped<String>? organizationId,
      Wrapped<ExportWalletIntent>? parameters}) {
    return ExportWalletRequest(
        type: (type != null ? type.value : this.type),
        timestampMs:
            (timestampMs != null ? timestampMs.value : this.timestampMs),
        organizationId: (organizationId != null
            ? organizationId.value
            : this.organizationId),
        parameters: (parameters != null ? parameters.value : this.parameters));
  }
}

@JsonSerializable(explicitToJson: true)
class ExportWalletResult {
  const ExportWalletResult({
    required this.walletId,
    required this.exportBundle,
  });

  factory ExportWalletResult.fromJson(Map<String, dynamic> json) =>
      _$ExportWalletResultFromJson(json);

  static const toJsonFactory = _$ExportWalletResultToJson;
  Map<String, dynamic> toJson() => _$ExportWalletResultToJson(this);

  @JsonKey(name: 'walletId')
  final String walletId;
  @JsonKey(name: 'exportBundle')
  final String exportBundle;
  static const fromJsonFactory = _$ExportWalletResultFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ExportWalletResult &&
            (identical(other.walletId, walletId) ||
                const DeepCollectionEquality()
                    .equals(other.walletId, walletId)) &&
            (identical(other.exportBundle, exportBundle) ||
                const DeepCollectionEquality()
                    .equals(other.exportBundle, exportBundle)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(walletId) ^
      const DeepCollectionEquality().hash(exportBundle) ^
      runtimeType.hashCode;
}

extension $ExportWalletResultExtension on ExportWalletResult {
  ExportWalletResult copyWith({String? walletId, String? exportBundle}) {
    return ExportWalletResult(
        walletId: walletId ?? this.walletId,
        exportBundle: exportBundle ?? this.exportBundle);
  }

  ExportWalletResult copyWithWrapped(
      {Wrapped<String>? walletId, Wrapped<String>? exportBundle}) {
    return ExportWalletResult(
        walletId: (walletId != null ? walletId.value : this.walletId),
        exportBundle:
            (exportBundle != null ? exportBundle.value : this.exportBundle));
  }
}

@JsonSerializable(explicitToJson: true)
class Feature {
  const Feature({
    this.name,
    this.$value,
  });

  factory Feature.fromJson(Map<String, dynamic> json) =>
      _$FeatureFromJson(json);

  static const toJsonFactory = _$FeatureToJson;
  Map<String, dynamic> toJson() => _$FeatureToJson(this);

  @JsonKey(
    name: 'name',
    toJson: featureNameNullableToJson,
    fromJson: featureNameNullableFromJson,
  )
  final enums.FeatureName? name;
  @JsonKey(name: 'value')
  final String? $value;
  static const fromJsonFactory = _$FeatureFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is Feature &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.$value, $value) ||
                const DeepCollectionEquality().equals(other.$value, $value)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash($value) ^
      runtimeType.hashCode;
}

extension $FeatureExtension on Feature {
  Feature copyWith({enums.FeatureName? name, String? $value}) {
    return Feature(name: name ?? this.name, $value: $value ?? this.$value);
  }

  Feature copyWithWrapped(
      {Wrapped<enums.FeatureName?>? name, Wrapped<String?>? $value}) {
    return Feature(
        name: (name != null ? name.value : this.name),
        $value: ($value != null ? $value.value : this.$value));
  }
}

@JsonSerializable(explicitToJson: true)
class GetActivitiesRequest {
  const GetActivitiesRequest({
    required this.organizationId,
    this.filterByStatus,
    this.paginationOptions,
    this.filterByType,
  });

  factory GetActivitiesRequest.fromJson(Map<String, dynamic> json) =>
      _$GetActivitiesRequestFromJson(json);

  static const toJsonFactory = _$GetActivitiesRequestToJson;
  Map<String, dynamic> toJson() => _$GetActivitiesRequestToJson(this);

  @JsonKey(name: 'organizationId')
  final String organizationId;
  @JsonKey(
    name: 'filterByStatus',
    toJson: activityStatusListToJson,
    fromJson: activityStatusListFromJson,
  )
  final List<enums.ActivityStatus>? filterByStatus;
  @JsonKey(name: 'paginationOptions')
  final Pagination? paginationOptions;
  @JsonKey(
    name: 'filterByType',
    toJson: activityTypeListToJson,
    fromJson: activityTypeListFromJson,
  )
  final List<enums.ActivityType>? filterByType;
  static const fromJsonFactory = _$GetActivitiesRequestFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is GetActivitiesRequest &&
            (identical(other.organizationId, organizationId) ||
                const DeepCollectionEquality()
                    .equals(other.organizationId, organizationId)) &&
            (identical(other.filterByStatus, filterByStatus) ||
                const DeepCollectionEquality()
                    .equals(other.filterByStatus, filterByStatus)) &&
            (identical(other.paginationOptions, paginationOptions) ||
                const DeepCollectionEquality()
                    .equals(other.paginationOptions, paginationOptions)) &&
            (identical(other.filterByType, filterByType) ||
                const DeepCollectionEquality()
                    .equals(other.filterByType, filterByType)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(organizationId) ^
      const DeepCollectionEquality().hash(filterByStatus) ^
      const DeepCollectionEquality().hash(paginationOptions) ^
      const DeepCollectionEquality().hash(filterByType) ^
      runtimeType.hashCode;
}

extension $GetActivitiesRequestExtension on GetActivitiesRequest {
  GetActivitiesRequest copyWith(
      {String? organizationId,
      List<enums.ActivityStatus>? filterByStatus,
      Pagination? paginationOptions,
      List<enums.ActivityType>? filterByType}) {
    return GetActivitiesRequest(
        organizationId: organizationId ?? this.organizationId,
        filterByStatus: filterByStatus ?? this.filterByStatus,
        paginationOptions: paginationOptions ?? this.paginationOptions,
        filterByType: filterByType ?? this.filterByType);
  }

  GetActivitiesRequest copyWithWrapped(
      {Wrapped<String>? organizationId,
      Wrapped<List<enums.ActivityStatus>?>? filterByStatus,
      Wrapped<Pagination?>? paginationOptions,
      Wrapped<List<enums.ActivityType>?>? filterByType}) {
    return GetActivitiesRequest(
        organizationId: (organizationId != null
            ? organizationId.value
            : this.organizationId),
        filterByStatus: (filterByStatus != null
            ? filterByStatus.value
            : this.filterByStatus),
        paginationOptions: (paginationOptions != null
            ? paginationOptions.value
            : this.paginationOptions),
        filterByType:
            (filterByType != null ? filterByType.value : this.filterByType));
  }
}

@JsonSerializable(explicitToJson: true)
class GetActivitiesResponse {
  const GetActivitiesResponse({
    required this.activities,
  });

  factory GetActivitiesResponse.fromJson(Map<String, dynamic> json) =>
      _$GetActivitiesResponseFromJson(json);

  static const toJsonFactory = _$GetActivitiesResponseToJson;
  Map<String, dynamic> toJson() => _$GetActivitiesResponseToJson(this);

  @JsonKey(name: 'activities', defaultValue: <Activity>[])
  final List<Activity> activities;
  static const fromJsonFactory = _$GetActivitiesResponseFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is GetActivitiesResponse &&
            (identical(other.activities, activities) ||
                const DeepCollectionEquality()
                    .equals(other.activities, activities)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(activities) ^ runtimeType.hashCode;
}

extension $GetActivitiesResponseExtension on GetActivitiesResponse {
  GetActivitiesResponse copyWith({List<Activity>? activities}) {
    return GetActivitiesResponse(activities: activities ?? this.activities);
  }

  GetActivitiesResponse copyWithWrapped({Wrapped<List<Activity>>? activities}) {
    return GetActivitiesResponse(
        activities: (activities != null ? activities.value : this.activities));
  }
}

@JsonSerializable(explicitToJson: true)
class GetActivityRequest {
  const GetActivityRequest({
    required this.organizationId,
    required this.activityId,
  });

  factory GetActivityRequest.fromJson(Map<String, dynamic> json) =>
      _$GetActivityRequestFromJson(json);

  static const toJsonFactory = _$GetActivityRequestToJson;
  Map<String, dynamic> toJson() => _$GetActivityRequestToJson(this);

  @JsonKey(name: 'organizationId')
  final String organizationId;
  @JsonKey(name: 'activityId')
  final String activityId;
  static const fromJsonFactory = _$GetActivityRequestFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is GetActivityRequest &&
            (identical(other.organizationId, organizationId) ||
                const DeepCollectionEquality()
                    .equals(other.organizationId, organizationId)) &&
            (identical(other.activityId, activityId) ||
                const DeepCollectionEquality()
                    .equals(other.activityId, activityId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(organizationId) ^
      const DeepCollectionEquality().hash(activityId) ^
      runtimeType.hashCode;
}

extension $GetActivityRequestExtension on GetActivityRequest {
  GetActivityRequest copyWith({String? organizationId, String? activityId}) {
    return GetActivityRequest(
        organizationId: organizationId ?? this.organizationId,
        activityId: activityId ?? this.activityId);
  }

  GetActivityRequest copyWithWrapped(
      {Wrapped<String>? organizationId, Wrapped<String>? activityId}) {
    return GetActivityRequest(
        organizationId: (organizationId != null
            ? organizationId.value
            : this.organizationId),
        activityId: (activityId != null ? activityId.value : this.activityId));
  }
}

@JsonSerializable(explicitToJson: true)
class GetApiKeyRequest {
  const GetApiKeyRequest({
    required this.organizationId,
    required this.apiKeyId,
  });

  factory GetApiKeyRequest.fromJson(Map<String, dynamic> json) =>
      _$GetApiKeyRequestFromJson(json);

  static const toJsonFactory = _$GetApiKeyRequestToJson;
  Map<String, dynamic> toJson() => _$GetApiKeyRequestToJson(this);

  @JsonKey(name: 'organizationId')
  final String organizationId;
  @JsonKey(name: 'apiKeyId')
  final String apiKeyId;
  static const fromJsonFactory = _$GetApiKeyRequestFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is GetApiKeyRequest &&
            (identical(other.organizationId, organizationId) ||
                const DeepCollectionEquality()
                    .equals(other.organizationId, organizationId)) &&
            (identical(other.apiKeyId, apiKeyId) ||
                const DeepCollectionEquality()
                    .equals(other.apiKeyId, apiKeyId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(organizationId) ^
      const DeepCollectionEquality().hash(apiKeyId) ^
      runtimeType.hashCode;
}

extension $GetApiKeyRequestExtension on GetApiKeyRequest {
  GetApiKeyRequest copyWith({String? organizationId, String? apiKeyId}) {
    return GetApiKeyRequest(
        organizationId: organizationId ?? this.organizationId,
        apiKeyId: apiKeyId ?? this.apiKeyId);
  }

  GetApiKeyRequest copyWithWrapped(
      {Wrapped<String>? organizationId, Wrapped<String>? apiKeyId}) {
    return GetApiKeyRequest(
        organizationId: (organizationId != null
            ? organizationId.value
            : this.organizationId),
        apiKeyId: (apiKeyId != null ? apiKeyId.value : this.apiKeyId));
  }
}

@JsonSerializable(explicitToJson: true)
class GetApiKeyResponse {
  const GetApiKeyResponse({
    required this.apiKey,
  });

  factory GetApiKeyResponse.fromJson(Map<String, dynamic> json) =>
      _$GetApiKeyResponseFromJson(json);

  static const toJsonFactory = _$GetApiKeyResponseToJson;
  Map<String, dynamic> toJson() => _$GetApiKeyResponseToJson(this);

  @JsonKey(name: 'apiKey')
  final ApiKey apiKey;
  static const fromJsonFactory = _$GetApiKeyResponseFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is GetApiKeyResponse &&
            (identical(other.apiKey, apiKey) ||
                const DeepCollectionEquality().equals(other.apiKey, apiKey)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(apiKey) ^ runtimeType.hashCode;
}

extension $GetApiKeyResponseExtension on GetApiKeyResponse {
  GetApiKeyResponse copyWith({ApiKey? apiKey}) {
    return GetApiKeyResponse(apiKey: apiKey ?? this.apiKey);
  }

  GetApiKeyResponse copyWithWrapped({Wrapped<ApiKey>? apiKey}) {
    return GetApiKeyResponse(
        apiKey: (apiKey != null ? apiKey.value : this.apiKey));
  }
}

@JsonSerializable(explicitToJson: true)
class GetApiKeysRequest {
  const GetApiKeysRequest({
    required this.organizationId,
    this.userId,
  });

  factory GetApiKeysRequest.fromJson(Map<String, dynamic> json) =>
      _$GetApiKeysRequestFromJson(json);

  static const toJsonFactory = _$GetApiKeysRequestToJson;
  Map<String, dynamic> toJson() => _$GetApiKeysRequestToJson(this);

  @JsonKey(name: 'organizationId')
  final String organizationId;
  @JsonKey(name: 'userId')
  final String? userId;
  static const fromJsonFactory = _$GetApiKeysRequestFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is GetApiKeysRequest &&
            (identical(other.organizationId, organizationId) ||
                const DeepCollectionEquality()
                    .equals(other.organizationId, organizationId)) &&
            (identical(other.userId, userId) ||
                const DeepCollectionEquality().equals(other.userId, userId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(organizationId) ^
      const DeepCollectionEquality().hash(userId) ^
      runtimeType.hashCode;
}

extension $GetApiKeysRequestExtension on GetApiKeysRequest {
  GetApiKeysRequest copyWith({String? organizationId, String? userId}) {
    return GetApiKeysRequest(
        organizationId: organizationId ?? this.organizationId,
        userId: userId ?? this.userId);
  }

  GetApiKeysRequest copyWithWrapped(
      {Wrapped<String>? organizationId, Wrapped<String?>? userId}) {
    return GetApiKeysRequest(
        organizationId: (organizationId != null
            ? organizationId.value
            : this.organizationId),
        userId: (userId != null ? userId.value : this.userId));
  }
}

@JsonSerializable(explicitToJson: true)
class GetApiKeysResponse {
  const GetApiKeysResponse({
    required this.apiKeys,
  });

  factory GetApiKeysResponse.fromJson(Map<String, dynamic> json) =>
      _$GetApiKeysResponseFromJson(json);

  static const toJsonFactory = _$GetApiKeysResponseToJson;
  Map<String, dynamic> toJson() => _$GetApiKeysResponseToJson(this);

  @JsonKey(name: 'apiKeys', defaultValue: <ApiKey>[])
  final List<ApiKey> apiKeys;
  static const fromJsonFactory = _$GetApiKeysResponseFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is GetApiKeysResponse &&
            (identical(other.apiKeys, apiKeys) ||
                const DeepCollectionEquality().equals(other.apiKeys, apiKeys)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(apiKeys) ^ runtimeType.hashCode;
}

extension $GetApiKeysResponseExtension on GetApiKeysResponse {
  GetApiKeysResponse copyWith({List<ApiKey>? apiKeys}) {
    return GetApiKeysResponse(apiKeys: apiKeys ?? this.apiKeys);
  }

  GetApiKeysResponse copyWithWrapped({Wrapped<List<ApiKey>>? apiKeys}) {
    return GetApiKeysResponse(
        apiKeys: (apiKeys != null ? apiKeys.value : this.apiKeys));
  }
}

@JsonSerializable(explicitToJson: true)
class GetAuthenticatorRequest {
  const GetAuthenticatorRequest({
    required this.organizationId,
    required this.authenticatorId,
  });

  factory GetAuthenticatorRequest.fromJson(Map<String, dynamic> json) =>
      _$GetAuthenticatorRequestFromJson(json);

  static const toJsonFactory = _$GetAuthenticatorRequestToJson;
  Map<String, dynamic> toJson() => _$GetAuthenticatorRequestToJson(this);

  @JsonKey(name: 'organizationId')
  final String organizationId;
  @JsonKey(name: 'authenticatorId')
  final String authenticatorId;
  static const fromJsonFactory = _$GetAuthenticatorRequestFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is GetAuthenticatorRequest &&
            (identical(other.organizationId, organizationId) ||
                const DeepCollectionEquality()
                    .equals(other.organizationId, organizationId)) &&
            (identical(other.authenticatorId, authenticatorId) ||
                const DeepCollectionEquality()
                    .equals(other.authenticatorId, authenticatorId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(organizationId) ^
      const DeepCollectionEquality().hash(authenticatorId) ^
      runtimeType.hashCode;
}

extension $GetAuthenticatorRequestExtension on GetAuthenticatorRequest {
  GetAuthenticatorRequest copyWith(
      {String? organizationId, String? authenticatorId}) {
    return GetAuthenticatorRequest(
        organizationId: organizationId ?? this.organizationId,
        authenticatorId: authenticatorId ?? this.authenticatorId);
  }

  GetAuthenticatorRequest copyWithWrapped(
      {Wrapped<String>? organizationId, Wrapped<String>? authenticatorId}) {
    return GetAuthenticatorRequest(
        organizationId: (organizationId != null
            ? organizationId.value
            : this.organizationId),
        authenticatorId: (authenticatorId != null
            ? authenticatorId.value
            : this.authenticatorId));
  }
}

@JsonSerializable(explicitToJson: true)
class GetAuthenticatorResponse {
  const GetAuthenticatorResponse({
    required this.authenticator,
  });

  factory GetAuthenticatorResponse.fromJson(Map<String, dynamic> json) =>
      _$GetAuthenticatorResponseFromJson(json);

  static const toJsonFactory = _$GetAuthenticatorResponseToJson;
  Map<String, dynamic> toJson() => _$GetAuthenticatorResponseToJson(this);

  @JsonKey(name: 'authenticator')
  final Authenticator authenticator;
  static const fromJsonFactory = _$GetAuthenticatorResponseFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is GetAuthenticatorResponse &&
            (identical(other.authenticator, authenticator) ||
                const DeepCollectionEquality()
                    .equals(other.authenticator, authenticator)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(authenticator) ^ runtimeType.hashCode;
}

extension $GetAuthenticatorResponseExtension on GetAuthenticatorResponse {
  GetAuthenticatorResponse copyWith({Authenticator? authenticator}) {
    return GetAuthenticatorResponse(
        authenticator: authenticator ?? this.authenticator);
  }

  GetAuthenticatorResponse copyWithWrapped(
      {Wrapped<Authenticator>? authenticator}) {
    return GetAuthenticatorResponse(
        authenticator:
            (authenticator != null ? authenticator.value : this.authenticator));
  }
}

@JsonSerializable(explicitToJson: true)
class GetAuthenticatorsRequest {
  const GetAuthenticatorsRequest({
    required this.organizationId,
    required this.userId,
  });

  factory GetAuthenticatorsRequest.fromJson(Map<String, dynamic> json) =>
      _$GetAuthenticatorsRequestFromJson(json);

  static const toJsonFactory = _$GetAuthenticatorsRequestToJson;
  Map<String, dynamic> toJson() => _$GetAuthenticatorsRequestToJson(this);

  @JsonKey(name: 'organizationId')
  final String organizationId;
  @JsonKey(name: 'userId')
  final String userId;
  static const fromJsonFactory = _$GetAuthenticatorsRequestFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is GetAuthenticatorsRequest &&
            (identical(other.organizationId, organizationId) ||
                const DeepCollectionEquality()
                    .equals(other.organizationId, organizationId)) &&
            (identical(other.userId, userId) ||
                const DeepCollectionEquality().equals(other.userId, userId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(organizationId) ^
      const DeepCollectionEquality().hash(userId) ^
      runtimeType.hashCode;
}

extension $GetAuthenticatorsRequestExtension on GetAuthenticatorsRequest {
  GetAuthenticatorsRequest copyWith({String? organizationId, String? userId}) {
    return GetAuthenticatorsRequest(
        organizationId: organizationId ?? this.organizationId,
        userId: userId ?? this.userId);
  }

  GetAuthenticatorsRequest copyWithWrapped(
      {Wrapped<String>? organizationId, Wrapped<String>? userId}) {
    return GetAuthenticatorsRequest(
        organizationId: (organizationId != null
            ? organizationId.value
            : this.organizationId),
        userId: (userId != null ? userId.value : this.userId));
  }
}

@JsonSerializable(explicitToJson: true)
class GetAuthenticatorsResponse {
  const GetAuthenticatorsResponse({
    required this.authenticators,
  });

  factory GetAuthenticatorsResponse.fromJson(Map<String, dynamic> json) =>
      _$GetAuthenticatorsResponseFromJson(json);

  static const toJsonFactory = _$GetAuthenticatorsResponseToJson;
  Map<String, dynamic> toJson() => _$GetAuthenticatorsResponseToJson(this);

  @JsonKey(name: 'authenticators', defaultValue: <Authenticator>[])
  final List<Authenticator> authenticators;
  static const fromJsonFactory = _$GetAuthenticatorsResponseFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is GetAuthenticatorsResponse &&
            (identical(other.authenticators, authenticators) ||
                const DeepCollectionEquality()
                    .equals(other.authenticators, authenticators)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(authenticators) ^
      runtimeType.hashCode;
}

extension $GetAuthenticatorsResponseExtension on GetAuthenticatorsResponse {
  GetAuthenticatorsResponse copyWith({List<Authenticator>? authenticators}) {
    return GetAuthenticatorsResponse(
        authenticators: authenticators ?? this.authenticators);
  }

  GetAuthenticatorsResponse copyWithWrapped(
      {Wrapped<List<Authenticator>>? authenticators}) {
    return GetAuthenticatorsResponse(
        authenticators: (authenticators != null
            ? authenticators.value
            : this.authenticators));
  }
}

@JsonSerializable(explicitToJson: true)
class GetOauthProvidersRequest {
  const GetOauthProvidersRequest({
    required this.organizationId,
    this.userId,
  });

  factory GetOauthProvidersRequest.fromJson(Map<String, dynamic> json) =>
      _$GetOauthProvidersRequestFromJson(json);

  static const toJsonFactory = _$GetOauthProvidersRequestToJson;
  Map<String, dynamic> toJson() => _$GetOauthProvidersRequestToJson(this);

  @JsonKey(name: 'organizationId')
  final String organizationId;
  @JsonKey(name: 'userId')
  final String? userId;
  static const fromJsonFactory = _$GetOauthProvidersRequestFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is GetOauthProvidersRequest &&
            (identical(other.organizationId, organizationId) ||
                const DeepCollectionEquality()
                    .equals(other.organizationId, organizationId)) &&
            (identical(other.userId, userId) ||
                const DeepCollectionEquality().equals(other.userId, userId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(organizationId) ^
      const DeepCollectionEquality().hash(userId) ^
      runtimeType.hashCode;
}

extension $GetOauthProvidersRequestExtension on GetOauthProvidersRequest {
  GetOauthProvidersRequest copyWith({String? organizationId, String? userId}) {
    return GetOauthProvidersRequest(
        organizationId: organizationId ?? this.organizationId,
        userId: userId ?? this.userId);
  }

  GetOauthProvidersRequest copyWithWrapped(
      {Wrapped<String>? organizationId, Wrapped<String?>? userId}) {
    return GetOauthProvidersRequest(
        organizationId: (organizationId != null
            ? organizationId.value
            : this.organizationId),
        userId: (userId != null ? userId.value : this.userId));
  }
}

@JsonSerializable(explicitToJson: true)
class GetOauthProvidersResponse {
  const GetOauthProvidersResponse({
    required this.oauthProviders,
  });

  factory GetOauthProvidersResponse.fromJson(Map<String, dynamic> json) =>
      _$GetOauthProvidersResponseFromJson(json);

  static const toJsonFactory = _$GetOauthProvidersResponseToJson;
  Map<String, dynamic> toJson() => _$GetOauthProvidersResponseToJson(this);

  @JsonKey(name: 'oauthProviders', defaultValue: <OauthProvider>[])
  final List<OauthProvider> oauthProviders;
  static const fromJsonFactory = _$GetOauthProvidersResponseFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is GetOauthProvidersResponse &&
            (identical(other.oauthProviders, oauthProviders) ||
                const DeepCollectionEquality()
                    .equals(other.oauthProviders, oauthProviders)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(oauthProviders) ^
      runtimeType.hashCode;
}

extension $GetOauthProvidersResponseExtension on GetOauthProvidersResponse {
  GetOauthProvidersResponse copyWith({List<OauthProvider>? oauthProviders}) {
    return GetOauthProvidersResponse(
        oauthProviders: oauthProviders ?? this.oauthProviders);
  }

  GetOauthProvidersResponse copyWithWrapped(
      {Wrapped<List<OauthProvider>>? oauthProviders}) {
    return GetOauthProvidersResponse(
        oauthProviders: (oauthProviders != null
            ? oauthProviders.value
            : this.oauthProviders));
  }
}

@JsonSerializable(explicitToJson: true)
class GetOrganizationConfigsRequest {
  const GetOrganizationConfigsRequest({
    required this.organizationId,
  });

  factory GetOrganizationConfigsRequest.fromJson(Map<String, dynamic> json) =>
      _$GetOrganizationConfigsRequestFromJson(json);

  static const toJsonFactory = _$GetOrganizationConfigsRequestToJson;
  Map<String, dynamic> toJson() => _$GetOrganizationConfigsRequestToJson(this);

  @JsonKey(name: 'organizationId')
  final String organizationId;
  static const fromJsonFactory = _$GetOrganizationConfigsRequestFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is GetOrganizationConfigsRequest &&
            (identical(other.organizationId, organizationId) ||
                const DeepCollectionEquality()
                    .equals(other.organizationId, organizationId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(organizationId) ^
      runtimeType.hashCode;
}

extension $GetOrganizationConfigsRequestExtension
    on GetOrganizationConfigsRequest {
  GetOrganizationConfigsRequest copyWith({String? organizationId}) {
    return GetOrganizationConfigsRequest(
        organizationId: organizationId ?? this.organizationId);
  }

  GetOrganizationConfigsRequest copyWithWrapped(
      {Wrapped<String>? organizationId}) {
    return GetOrganizationConfigsRequest(
        organizationId: (organizationId != null
            ? organizationId.value
            : this.organizationId));
  }
}

@JsonSerializable(explicitToJson: true)
class GetOrganizationConfigsResponse {
  const GetOrganizationConfigsResponse({
    required this.configs,
  });

  factory GetOrganizationConfigsResponse.fromJson(Map<String, dynamic> json) =>
      _$GetOrganizationConfigsResponseFromJson(json);

  static const toJsonFactory = _$GetOrganizationConfigsResponseToJson;
  Map<String, dynamic> toJson() => _$GetOrganizationConfigsResponseToJson(this);

  @JsonKey(name: 'configs')
  final Config configs;
  static const fromJsonFactory = _$GetOrganizationConfigsResponseFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is GetOrganizationConfigsResponse &&
            (identical(other.configs, configs) ||
                const DeepCollectionEquality().equals(other.configs, configs)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(configs) ^ runtimeType.hashCode;
}

extension $GetOrganizationConfigsResponseExtension
    on GetOrganizationConfigsResponse {
  GetOrganizationConfigsResponse copyWith({Config? configs}) {
    return GetOrganizationConfigsResponse(configs: configs ?? this.configs);
  }

  GetOrganizationConfigsResponse copyWithWrapped({Wrapped<Config>? configs}) {
    return GetOrganizationConfigsResponse(
        configs: (configs != null ? configs.value : this.configs));
  }
}

@JsonSerializable(explicitToJson: true)
class GetPoliciesRequest {
  const GetPoliciesRequest({
    required this.organizationId,
  });

  factory GetPoliciesRequest.fromJson(Map<String, dynamic> json) =>
      _$GetPoliciesRequestFromJson(json);

  static const toJsonFactory = _$GetPoliciesRequestToJson;
  Map<String, dynamic> toJson() => _$GetPoliciesRequestToJson(this);

  @JsonKey(name: 'organizationId')
  final String organizationId;
  static const fromJsonFactory = _$GetPoliciesRequestFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is GetPoliciesRequest &&
            (identical(other.organizationId, organizationId) ||
                const DeepCollectionEquality()
                    .equals(other.organizationId, organizationId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(organizationId) ^
      runtimeType.hashCode;
}

extension $GetPoliciesRequestExtension on GetPoliciesRequest {
  GetPoliciesRequest copyWith({String? organizationId}) {
    return GetPoliciesRequest(
        organizationId: organizationId ?? this.organizationId);
  }

  GetPoliciesRequest copyWithWrapped({Wrapped<String>? organizationId}) {
    return GetPoliciesRequest(
        organizationId: (organizationId != null
            ? organizationId.value
            : this.organizationId));
  }
}

@JsonSerializable(explicitToJson: true)
class GetPoliciesResponse {
  const GetPoliciesResponse({
    required this.policies,
  });

  factory GetPoliciesResponse.fromJson(Map<String, dynamic> json) =>
      _$GetPoliciesResponseFromJson(json);

  static const toJsonFactory = _$GetPoliciesResponseToJson;
  Map<String, dynamic> toJson() => _$GetPoliciesResponseToJson(this);

  @JsonKey(name: 'policies', defaultValue: <Policy>[])
  final List<Policy> policies;
  static const fromJsonFactory = _$GetPoliciesResponseFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is GetPoliciesResponse &&
            (identical(other.policies, policies) ||
                const DeepCollectionEquality()
                    .equals(other.policies, policies)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(policies) ^ runtimeType.hashCode;
}

extension $GetPoliciesResponseExtension on GetPoliciesResponse {
  GetPoliciesResponse copyWith({List<Policy>? policies}) {
    return GetPoliciesResponse(policies: policies ?? this.policies);
  }

  GetPoliciesResponse copyWithWrapped({Wrapped<List<Policy>>? policies}) {
    return GetPoliciesResponse(
        policies: (policies != null ? policies.value : this.policies));
  }
}

@JsonSerializable(explicitToJson: true)
class GetPolicyEvaluationsRequest {
  const GetPolicyEvaluationsRequest({
    required this.organizationId,
    required this.activityId,
  });

  factory GetPolicyEvaluationsRequest.fromJson(Map<String, dynamic> json) =>
      _$GetPolicyEvaluationsRequestFromJson(json);

  static const toJsonFactory = _$GetPolicyEvaluationsRequestToJson;
  Map<String, dynamic> toJson() => _$GetPolicyEvaluationsRequestToJson(this);

  @JsonKey(name: 'organizationId')
  final String organizationId;
  @JsonKey(name: 'activityId')
  final String activityId;
  static const fromJsonFactory = _$GetPolicyEvaluationsRequestFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is GetPolicyEvaluationsRequest &&
            (identical(other.organizationId, organizationId) ||
                const DeepCollectionEquality()
                    .equals(other.organizationId, organizationId)) &&
            (identical(other.activityId, activityId) ||
                const DeepCollectionEquality()
                    .equals(other.activityId, activityId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(organizationId) ^
      const DeepCollectionEquality().hash(activityId) ^
      runtimeType.hashCode;
}

extension $GetPolicyEvaluationsRequestExtension on GetPolicyEvaluationsRequest {
  GetPolicyEvaluationsRequest copyWith(
      {String? organizationId, String? activityId}) {
    return GetPolicyEvaluationsRequest(
        organizationId: organizationId ?? this.organizationId,
        activityId: activityId ?? this.activityId);
  }

  GetPolicyEvaluationsRequest copyWithWrapped(
      {Wrapped<String>? organizationId, Wrapped<String>? activityId}) {
    return GetPolicyEvaluationsRequest(
        organizationId: (organizationId != null
            ? organizationId.value
            : this.organizationId),
        activityId: (activityId != null ? activityId.value : this.activityId));
  }
}

@JsonSerializable(explicitToJson: true)
class GetPolicyEvaluationsResponse {
  const GetPolicyEvaluationsResponse({
    required this.policyEvaluations,
  });

  factory GetPolicyEvaluationsResponse.fromJson(Map<String, dynamic> json) =>
      _$GetPolicyEvaluationsResponseFromJson(json);

  static const toJsonFactory = _$GetPolicyEvaluationsResponseToJson;
  Map<String, dynamic> toJson() => _$GetPolicyEvaluationsResponseToJson(this);

  @JsonKey(
      name: 'policyEvaluations', defaultValue: <ActivityV1PolicyEvaluation>[])
  final List<ActivityV1PolicyEvaluation> policyEvaluations;
  static const fromJsonFactory = _$GetPolicyEvaluationsResponseFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is GetPolicyEvaluationsResponse &&
            (identical(other.policyEvaluations, policyEvaluations) ||
                const DeepCollectionEquality()
                    .equals(other.policyEvaluations, policyEvaluations)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(policyEvaluations) ^
      runtimeType.hashCode;
}

extension $GetPolicyEvaluationsResponseExtension
    on GetPolicyEvaluationsResponse {
  GetPolicyEvaluationsResponse copyWith(
      {List<ActivityV1PolicyEvaluation>? policyEvaluations}) {
    return GetPolicyEvaluationsResponse(
        policyEvaluations: policyEvaluations ?? this.policyEvaluations);
  }

  GetPolicyEvaluationsResponse copyWithWrapped(
      {Wrapped<List<ActivityV1PolicyEvaluation>>? policyEvaluations}) {
    return GetPolicyEvaluationsResponse(
        policyEvaluations: (policyEvaluations != null
            ? policyEvaluations.value
            : this.policyEvaluations));
  }
}

@JsonSerializable(explicitToJson: true)
class GetPolicyRequest {
  const GetPolicyRequest({
    required this.organizationId,
    required this.policyId,
  });

  factory GetPolicyRequest.fromJson(Map<String, dynamic> json) =>
      _$GetPolicyRequestFromJson(json);

  static const toJsonFactory = _$GetPolicyRequestToJson;
  Map<String, dynamic> toJson() => _$GetPolicyRequestToJson(this);

  @JsonKey(name: 'organizationId')
  final String organizationId;
  @JsonKey(name: 'policyId')
  final String policyId;
  static const fromJsonFactory = _$GetPolicyRequestFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is GetPolicyRequest &&
            (identical(other.organizationId, organizationId) ||
                const DeepCollectionEquality()
                    .equals(other.organizationId, organizationId)) &&
            (identical(other.policyId, policyId) ||
                const DeepCollectionEquality()
                    .equals(other.policyId, policyId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(organizationId) ^
      const DeepCollectionEquality().hash(policyId) ^
      runtimeType.hashCode;
}

extension $GetPolicyRequestExtension on GetPolicyRequest {
  GetPolicyRequest copyWith({String? organizationId, String? policyId}) {
    return GetPolicyRequest(
        organizationId: organizationId ?? this.organizationId,
        policyId: policyId ?? this.policyId);
  }

  GetPolicyRequest copyWithWrapped(
      {Wrapped<String>? organizationId, Wrapped<String>? policyId}) {
    return GetPolicyRequest(
        organizationId: (organizationId != null
            ? organizationId.value
            : this.organizationId),
        policyId: (policyId != null ? policyId.value : this.policyId));
  }
}

@JsonSerializable(explicitToJson: true)
class GetPolicyResponse {
  const GetPolicyResponse({
    required this.policy,
  });

  factory GetPolicyResponse.fromJson(Map<String, dynamic> json) =>
      _$GetPolicyResponseFromJson(json);

  static const toJsonFactory = _$GetPolicyResponseToJson;
  Map<String, dynamic> toJson() => _$GetPolicyResponseToJson(this);

  @JsonKey(name: 'policy')
  final Policy policy;
  static const fromJsonFactory = _$GetPolicyResponseFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is GetPolicyResponse &&
            (identical(other.policy, policy) ||
                const DeepCollectionEquality().equals(other.policy, policy)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(policy) ^ runtimeType.hashCode;
}

extension $GetPolicyResponseExtension on GetPolicyResponse {
  GetPolicyResponse copyWith({Policy? policy}) {
    return GetPolicyResponse(policy: policy ?? this.policy);
  }

  GetPolicyResponse copyWithWrapped({Wrapped<Policy>? policy}) {
    return GetPolicyResponse(
        policy: (policy != null ? policy.value : this.policy));
  }
}

@JsonSerializable(explicitToJson: true)
class GetPrivateKeyRequest {
  const GetPrivateKeyRequest({
    required this.organizationId,
    required this.privateKeyId,
  });

  factory GetPrivateKeyRequest.fromJson(Map<String, dynamic> json) =>
      _$GetPrivateKeyRequestFromJson(json);

  static const toJsonFactory = _$GetPrivateKeyRequestToJson;
  Map<String, dynamic> toJson() => _$GetPrivateKeyRequestToJson(this);

  @JsonKey(name: 'organizationId')
  final String organizationId;
  @JsonKey(name: 'privateKeyId')
  final String privateKeyId;
  static const fromJsonFactory = _$GetPrivateKeyRequestFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is GetPrivateKeyRequest &&
            (identical(other.organizationId, organizationId) ||
                const DeepCollectionEquality()
                    .equals(other.organizationId, organizationId)) &&
            (identical(other.privateKeyId, privateKeyId) ||
                const DeepCollectionEquality()
                    .equals(other.privateKeyId, privateKeyId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(organizationId) ^
      const DeepCollectionEquality().hash(privateKeyId) ^
      runtimeType.hashCode;
}

extension $GetPrivateKeyRequestExtension on GetPrivateKeyRequest {
  GetPrivateKeyRequest copyWith(
      {String? organizationId, String? privateKeyId}) {
    return GetPrivateKeyRequest(
        organizationId: organizationId ?? this.organizationId,
        privateKeyId: privateKeyId ?? this.privateKeyId);
  }

  GetPrivateKeyRequest copyWithWrapped(
      {Wrapped<String>? organizationId, Wrapped<String>? privateKeyId}) {
    return GetPrivateKeyRequest(
        organizationId: (organizationId != null
            ? organizationId.value
            : this.organizationId),
        privateKeyId:
            (privateKeyId != null ? privateKeyId.value : this.privateKeyId));
  }
}

@JsonSerializable(explicitToJson: true)
class GetPrivateKeyResponse {
  const GetPrivateKeyResponse({
    required this.privateKey,
  });

  factory GetPrivateKeyResponse.fromJson(Map<String, dynamic> json) =>
      _$GetPrivateKeyResponseFromJson(json);

  static const toJsonFactory = _$GetPrivateKeyResponseToJson;
  Map<String, dynamic> toJson() => _$GetPrivateKeyResponseToJson(this);

  @JsonKey(name: 'privateKey')
  final PrivateKey privateKey;
  static const fromJsonFactory = _$GetPrivateKeyResponseFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is GetPrivateKeyResponse &&
            (identical(other.privateKey, privateKey) ||
                const DeepCollectionEquality()
                    .equals(other.privateKey, privateKey)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(privateKey) ^ runtimeType.hashCode;
}

extension $GetPrivateKeyResponseExtension on GetPrivateKeyResponse {
  GetPrivateKeyResponse copyWith({PrivateKey? privateKey}) {
    return GetPrivateKeyResponse(privateKey: privateKey ?? this.privateKey);
  }

  GetPrivateKeyResponse copyWithWrapped({Wrapped<PrivateKey>? privateKey}) {
    return GetPrivateKeyResponse(
        privateKey: (privateKey != null ? privateKey.value : this.privateKey));
  }
}

@JsonSerializable(explicitToJson: true)
class GetPrivateKeysRequest {
  const GetPrivateKeysRequest({
    required this.organizationId,
  });

  factory GetPrivateKeysRequest.fromJson(Map<String, dynamic> json) =>
      _$GetPrivateKeysRequestFromJson(json);

  static const toJsonFactory = _$GetPrivateKeysRequestToJson;
  Map<String, dynamic> toJson() => _$GetPrivateKeysRequestToJson(this);

  @JsonKey(name: 'organizationId')
  final String organizationId;
  static const fromJsonFactory = _$GetPrivateKeysRequestFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is GetPrivateKeysRequest &&
            (identical(other.organizationId, organizationId) ||
                const DeepCollectionEquality()
                    .equals(other.organizationId, organizationId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(organizationId) ^
      runtimeType.hashCode;
}

extension $GetPrivateKeysRequestExtension on GetPrivateKeysRequest {
  GetPrivateKeysRequest copyWith({String? organizationId}) {
    return GetPrivateKeysRequest(
        organizationId: organizationId ?? this.organizationId);
  }

  GetPrivateKeysRequest copyWithWrapped({Wrapped<String>? organizationId}) {
    return GetPrivateKeysRequest(
        organizationId: (organizationId != null
            ? organizationId.value
            : this.organizationId));
  }
}

@JsonSerializable(explicitToJson: true)
class GetPrivateKeysResponse {
  const GetPrivateKeysResponse({
    required this.privateKeys,
  });

  factory GetPrivateKeysResponse.fromJson(Map<String, dynamic> json) =>
      _$GetPrivateKeysResponseFromJson(json);

  static const toJsonFactory = _$GetPrivateKeysResponseToJson;
  Map<String, dynamic> toJson() => _$GetPrivateKeysResponseToJson(this);

  @JsonKey(name: 'privateKeys', defaultValue: <PrivateKey>[])
  final List<PrivateKey> privateKeys;
  static const fromJsonFactory = _$GetPrivateKeysResponseFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is GetPrivateKeysResponse &&
            (identical(other.privateKeys, privateKeys) ||
                const DeepCollectionEquality()
                    .equals(other.privateKeys, privateKeys)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(privateKeys) ^ runtimeType.hashCode;
}

extension $GetPrivateKeysResponseExtension on GetPrivateKeysResponse {
  GetPrivateKeysResponse copyWith({List<PrivateKey>? privateKeys}) {
    return GetPrivateKeysResponse(privateKeys: privateKeys ?? this.privateKeys);
  }

  GetPrivateKeysResponse copyWithWrapped(
      {Wrapped<List<PrivateKey>>? privateKeys}) {
    return GetPrivateKeysResponse(
        privateKeys:
            (privateKeys != null ? privateKeys.value : this.privateKeys));
  }
}

@JsonSerializable(explicitToJson: true)
class GetSmartContractInterfaceRequest {
  const GetSmartContractInterfaceRequest({
    required this.organizationId,
    required this.smartContractInterfaceId,
  });

  factory GetSmartContractInterfaceRequest.fromJson(
          Map<String, dynamic> json) =>
      _$GetSmartContractInterfaceRequestFromJson(json);

  static const toJsonFactory = _$GetSmartContractInterfaceRequestToJson;
  Map<String, dynamic> toJson() =>
      _$GetSmartContractInterfaceRequestToJson(this);

  @JsonKey(name: 'organizationId')
  final String organizationId;
  @JsonKey(name: 'smartContractInterfaceId')
  final String smartContractInterfaceId;
  static const fromJsonFactory = _$GetSmartContractInterfaceRequestFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is GetSmartContractInterfaceRequest &&
            (identical(other.organizationId, organizationId) ||
                const DeepCollectionEquality()
                    .equals(other.organizationId, organizationId)) &&
            (identical(
                    other.smartContractInterfaceId, smartContractInterfaceId) ||
                const DeepCollectionEquality().equals(
                    other.smartContractInterfaceId, smartContractInterfaceId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(organizationId) ^
      const DeepCollectionEquality().hash(smartContractInterfaceId) ^
      runtimeType.hashCode;
}

extension $GetSmartContractInterfaceRequestExtension
    on GetSmartContractInterfaceRequest {
  GetSmartContractInterfaceRequest copyWith(
      {String? organizationId, String? smartContractInterfaceId}) {
    return GetSmartContractInterfaceRequest(
        organizationId: organizationId ?? this.organizationId,
        smartContractInterfaceId:
            smartContractInterfaceId ?? this.smartContractInterfaceId);
  }

  GetSmartContractInterfaceRequest copyWithWrapped(
      {Wrapped<String>? organizationId,
      Wrapped<String>? smartContractInterfaceId}) {
    return GetSmartContractInterfaceRequest(
        organizationId: (organizationId != null
            ? organizationId.value
            : this.organizationId),
        smartContractInterfaceId: (smartContractInterfaceId != null
            ? smartContractInterfaceId.value
            : this.smartContractInterfaceId));
  }
}

@JsonSerializable(explicitToJson: true)
class GetSmartContractInterfaceResponse {
  const GetSmartContractInterfaceResponse({
    required this.smartContractInterface,
  });

  factory GetSmartContractInterfaceResponse.fromJson(
          Map<String, dynamic> json) =>
      _$GetSmartContractInterfaceResponseFromJson(json);

  static const toJsonFactory = _$GetSmartContractInterfaceResponseToJson;
  Map<String, dynamic> toJson() =>
      _$GetSmartContractInterfaceResponseToJson(this);

  @JsonKey(name: 'smartContractInterface')
  final DataV1SmartContractInterface smartContractInterface;
  static const fromJsonFactory = _$GetSmartContractInterfaceResponseFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is GetSmartContractInterfaceResponse &&
            (identical(other.smartContractInterface, smartContractInterface) ||
                const DeepCollectionEquality().equals(
                    other.smartContractInterface, smartContractInterface)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(smartContractInterface) ^
      runtimeType.hashCode;
}

extension $GetSmartContractInterfaceResponseExtension
    on GetSmartContractInterfaceResponse {
  GetSmartContractInterfaceResponse copyWith(
      {DataV1SmartContractInterface? smartContractInterface}) {
    return GetSmartContractInterfaceResponse(
        smartContractInterface:
            smartContractInterface ?? this.smartContractInterface);
  }

  GetSmartContractInterfaceResponse copyWithWrapped(
      {Wrapped<DataV1SmartContractInterface>? smartContractInterface}) {
    return GetSmartContractInterfaceResponse(
        smartContractInterface: (smartContractInterface != null
            ? smartContractInterface.value
            : this.smartContractInterface));
  }
}

@JsonSerializable(explicitToJson: true)
class GetSmartContractInterfacesRequest {
  const GetSmartContractInterfacesRequest({
    required this.organizationId,
  });

  factory GetSmartContractInterfacesRequest.fromJson(
          Map<String, dynamic> json) =>
      _$GetSmartContractInterfacesRequestFromJson(json);

  static const toJsonFactory = _$GetSmartContractInterfacesRequestToJson;
  Map<String, dynamic> toJson() =>
      _$GetSmartContractInterfacesRequestToJson(this);

  @JsonKey(name: 'organizationId')
  final String organizationId;
  static const fromJsonFactory = _$GetSmartContractInterfacesRequestFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is GetSmartContractInterfacesRequest &&
            (identical(other.organizationId, organizationId) ||
                const DeepCollectionEquality()
                    .equals(other.organizationId, organizationId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(organizationId) ^
      runtimeType.hashCode;
}

extension $GetSmartContractInterfacesRequestExtension
    on GetSmartContractInterfacesRequest {
  GetSmartContractInterfacesRequest copyWith({String? organizationId}) {
    return GetSmartContractInterfacesRequest(
        organizationId: organizationId ?? this.organizationId);
  }

  GetSmartContractInterfacesRequest copyWithWrapped(
      {Wrapped<String>? organizationId}) {
    return GetSmartContractInterfacesRequest(
        organizationId: (organizationId != null
            ? organizationId.value
            : this.organizationId));
  }
}

@JsonSerializable(explicitToJson: true)
class GetSmartContractInterfacesResponse {
  const GetSmartContractInterfacesResponse({
    required this.smartContractInterfaces,
  });

  factory GetSmartContractInterfacesResponse.fromJson(
          Map<String, dynamic> json) =>
      _$GetSmartContractInterfacesResponseFromJson(json);

  static const toJsonFactory = _$GetSmartContractInterfacesResponseToJson;
  Map<String, dynamic> toJson() =>
      _$GetSmartContractInterfacesResponseToJson(this);

  @JsonKey(
      name: 'smartContractInterfaces',
      defaultValue: <DataV1SmartContractInterface>[])
  final List<DataV1SmartContractInterface> smartContractInterfaces;
  static const fromJsonFactory = _$GetSmartContractInterfacesResponseFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is GetSmartContractInterfacesResponse &&
            (identical(
                    other.smartContractInterfaces, smartContractInterfaces) ||
                const DeepCollectionEquality().equals(
                    other.smartContractInterfaces, smartContractInterfaces)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(smartContractInterfaces) ^
      runtimeType.hashCode;
}

extension $GetSmartContractInterfacesResponseExtension
    on GetSmartContractInterfacesResponse {
  GetSmartContractInterfacesResponse copyWith(
      {List<DataV1SmartContractInterface>? smartContractInterfaces}) {
    return GetSmartContractInterfacesResponse(
        smartContractInterfaces:
            smartContractInterfaces ?? this.smartContractInterfaces);
  }

  GetSmartContractInterfacesResponse copyWithWrapped(
      {Wrapped<List<DataV1SmartContractInterface>>? smartContractInterfaces}) {
    return GetSmartContractInterfacesResponse(
        smartContractInterfaces: (smartContractInterfaces != null
            ? smartContractInterfaces.value
            : this.smartContractInterfaces));
  }
}

@JsonSerializable(explicitToJson: true)
class GetSubOrgIdsRequest {
  const GetSubOrgIdsRequest({
    required this.organizationId,
    this.filterType,
    this.filterValue,
    this.paginationOptions,
  });

  factory GetSubOrgIdsRequest.fromJson(Map<String, dynamic> json) =>
      _$GetSubOrgIdsRequestFromJson(json);

  static const toJsonFactory = _$GetSubOrgIdsRequestToJson;
  Map<String, dynamic> toJson() => _$GetSubOrgIdsRequestToJson(this);

  @JsonKey(name: 'organizationId')
  final String organizationId;
  @JsonKey(name: 'filterType')
  final String? filterType;
  @JsonKey(name: 'filterValue')
  final String? filterValue;
  @JsonKey(name: 'paginationOptions')
  final Pagination? paginationOptions;
  static const fromJsonFactory = _$GetSubOrgIdsRequestFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is GetSubOrgIdsRequest &&
            (identical(other.organizationId, organizationId) ||
                const DeepCollectionEquality()
                    .equals(other.organizationId, organizationId)) &&
            (identical(other.filterType, filterType) ||
                const DeepCollectionEquality()
                    .equals(other.filterType, filterType)) &&
            (identical(other.filterValue, filterValue) ||
                const DeepCollectionEquality()
                    .equals(other.filterValue, filterValue)) &&
            (identical(other.paginationOptions, paginationOptions) ||
                const DeepCollectionEquality()
                    .equals(other.paginationOptions, paginationOptions)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(organizationId) ^
      const DeepCollectionEquality().hash(filterType) ^
      const DeepCollectionEquality().hash(filterValue) ^
      const DeepCollectionEquality().hash(paginationOptions) ^
      runtimeType.hashCode;
}

extension $GetSubOrgIdsRequestExtension on GetSubOrgIdsRequest {
  GetSubOrgIdsRequest copyWith(
      {String? organizationId,
      String? filterType,
      String? filterValue,
      Pagination? paginationOptions}) {
    return GetSubOrgIdsRequest(
        organizationId: organizationId ?? this.organizationId,
        filterType: filterType ?? this.filterType,
        filterValue: filterValue ?? this.filterValue,
        paginationOptions: paginationOptions ?? this.paginationOptions);
  }

  GetSubOrgIdsRequest copyWithWrapped(
      {Wrapped<String>? organizationId,
      Wrapped<String?>? filterType,
      Wrapped<String?>? filterValue,
      Wrapped<Pagination?>? paginationOptions}) {
    return GetSubOrgIdsRequest(
        organizationId: (organizationId != null
            ? organizationId.value
            : this.organizationId),
        filterType: (filterType != null ? filterType.value : this.filterType),
        filterValue:
            (filterValue != null ? filterValue.value : this.filterValue),
        paginationOptions: (paginationOptions != null
            ? paginationOptions.value
            : this.paginationOptions));
  }
}

@JsonSerializable(explicitToJson: true)
class GetSubOrgIdsResponse {
  const GetSubOrgIdsResponse({
    required this.organizationIds,
  });

  factory GetSubOrgIdsResponse.fromJson(Map<String, dynamic> json) =>
      _$GetSubOrgIdsResponseFromJson(json);

  static const toJsonFactory = _$GetSubOrgIdsResponseToJson;
  Map<String, dynamic> toJson() => _$GetSubOrgIdsResponseToJson(this);

  @JsonKey(name: 'organizationIds', defaultValue: <String>[])
  final List<String> organizationIds;
  static const fromJsonFactory = _$GetSubOrgIdsResponseFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is GetSubOrgIdsResponse &&
            (identical(other.organizationIds, organizationIds) ||
                const DeepCollectionEquality()
                    .equals(other.organizationIds, organizationIds)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(organizationIds) ^
      runtimeType.hashCode;
}

extension $GetSubOrgIdsResponseExtension on GetSubOrgIdsResponse {
  GetSubOrgIdsResponse copyWith({List<String>? organizationIds}) {
    return GetSubOrgIdsResponse(
        organizationIds: organizationIds ?? this.organizationIds);
  }

  GetSubOrgIdsResponse copyWithWrapped(
      {Wrapped<List<String>>? organizationIds}) {
    return GetSubOrgIdsResponse(
        organizationIds: (organizationIds != null
            ? organizationIds.value
            : this.organizationIds));
  }
}

@JsonSerializable(explicitToJson: true)
class GetUserRequest {
  const GetUserRequest({
    required this.organizationId,
    required this.userId,
  });

  factory GetUserRequest.fromJson(Map<String, dynamic> json) =>
      _$GetUserRequestFromJson(json);

  static const toJsonFactory = _$GetUserRequestToJson;
  Map<String, dynamic> toJson() => _$GetUserRequestToJson(this);

  @JsonKey(name: 'organizationId')
  final String organizationId;
  @JsonKey(name: 'userId')
  final String userId;
  static const fromJsonFactory = _$GetUserRequestFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is GetUserRequest &&
            (identical(other.organizationId, organizationId) ||
                const DeepCollectionEquality()
                    .equals(other.organizationId, organizationId)) &&
            (identical(other.userId, userId) ||
                const DeepCollectionEquality().equals(other.userId, userId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(organizationId) ^
      const DeepCollectionEquality().hash(userId) ^
      runtimeType.hashCode;
}

extension $GetUserRequestExtension on GetUserRequest {
  GetUserRequest copyWith({String? organizationId, String? userId}) {
    return GetUserRequest(
        organizationId: organizationId ?? this.organizationId,
        userId: userId ?? this.userId);
  }

  GetUserRequest copyWithWrapped(
      {Wrapped<String>? organizationId, Wrapped<String>? userId}) {
    return GetUserRequest(
        organizationId: (organizationId != null
            ? organizationId.value
            : this.organizationId),
        userId: (userId != null ? userId.value : this.userId));
  }
}

@JsonSerializable(explicitToJson: true)
class GetUserResponse {
  const GetUserResponse({
    required this.user,
  });

  factory GetUserResponse.fromJson(Map<String, dynamic> json) =>
      _$GetUserResponseFromJson(json);

  static const toJsonFactory = _$GetUserResponseToJson;
  Map<String, dynamic> toJson() => _$GetUserResponseToJson(this);

  @JsonKey(name: 'user')
  final User user;
  static const fromJsonFactory = _$GetUserResponseFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is GetUserResponse &&
            (identical(other.user, user) ||
                const DeepCollectionEquality().equals(other.user, user)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(user) ^ runtimeType.hashCode;
}

extension $GetUserResponseExtension on GetUserResponse {
  GetUserResponse copyWith({User? user}) {
    return GetUserResponse(user: user ?? this.user);
  }

  GetUserResponse copyWithWrapped({Wrapped<User>? user}) {
    return GetUserResponse(user: (user != null ? user.value : this.user));
  }
}

@JsonSerializable(explicitToJson: true)
class GetUsersRequest {
  const GetUsersRequest({
    required this.organizationId,
  });

  factory GetUsersRequest.fromJson(Map<String, dynamic> json) =>
      _$GetUsersRequestFromJson(json);

  static const toJsonFactory = _$GetUsersRequestToJson;
  Map<String, dynamic> toJson() => _$GetUsersRequestToJson(this);

  @JsonKey(name: 'organizationId')
  final String organizationId;
  static const fromJsonFactory = _$GetUsersRequestFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is GetUsersRequest &&
            (identical(other.organizationId, organizationId) ||
                const DeepCollectionEquality()
                    .equals(other.organizationId, organizationId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(organizationId) ^
      runtimeType.hashCode;
}

extension $GetUsersRequestExtension on GetUsersRequest {
  GetUsersRequest copyWith({String? organizationId}) {
    return GetUsersRequest(
        organizationId: organizationId ?? this.organizationId);
  }

  GetUsersRequest copyWithWrapped({Wrapped<String>? organizationId}) {
    return GetUsersRequest(
        organizationId: (organizationId != null
            ? organizationId.value
            : this.organizationId));
  }
}

@JsonSerializable(explicitToJson: true)
class GetUsersResponse {
  const GetUsersResponse({
    required this.users,
  });

  factory GetUsersResponse.fromJson(Map<String, dynamic> json) =>
      _$GetUsersResponseFromJson(json);

  static const toJsonFactory = _$GetUsersResponseToJson;
  Map<String, dynamic> toJson() => _$GetUsersResponseToJson(this);

  @JsonKey(name: 'users', defaultValue: <User>[])
  final List<User> users;
  static const fromJsonFactory = _$GetUsersResponseFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is GetUsersResponse &&
            (identical(other.users, users) ||
                const DeepCollectionEquality().equals(other.users, users)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(users) ^ runtimeType.hashCode;
}

extension $GetUsersResponseExtension on GetUsersResponse {
  GetUsersResponse copyWith({List<User>? users}) {
    return GetUsersResponse(users: users ?? this.users);
  }

  GetUsersResponse copyWithWrapped({Wrapped<List<User>>? users}) {
    return GetUsersResponse(users: (users != null ? users.value : this.users));
  }
}

@JsonSerializable(explicitToJson: true)
class GetVerifiedSubOrgIdsRequest {
  const GetVerifiedSubOrgIdsRequest({
    required this.organizationId,
    this.filterType,
    this.filterValue,
    this.paginationOptions,
  });

  factory GetVerifiedSubOrgIdsRequest.fromJson(Map<String, dynamic> json) =>
      _$GetVerifiedSubOrgIdsRequestFromJson(json);

  static const toJsonFactory = _$GetVerifiedSubOrgIdsRequestToJson;
  Map<String, dynamic> toJson() => _$GetVerifiedSubOrgIdsRequestToJson(this);

  @JsonKey(name: 'organizationId')
  final String organizationId;
  @JsonKey(name: 'filterType')
  final String? filterType;
  @JsonKey(name: 'filterValue')
  final String? filterValue;
  @JsonKey(name: 'paginationOptions')
  final Pagination? paginationOptions;
  static const fromJsonFactory = _$GetVerifiedSubOrgIdsRequestFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is GetVerifiedSubOrgIdsRequest &&
            (identical(other.organizationId, organizationId) ||
                const DeepCollectionEquality()
                    .equals(other.organizationId, organizationId)) &&
            (identical(other.filterType, filterType) ||
                const DeepCollectionEquality()
                    .equals(other.filterType, filterType)) &&
            (identical(other.filterValue, filterValue) ||
                const DeepCollectionEquality()
                    .equals(other.filterValue, filterValue)) &&
            (identical(other.paginationOptions, paginationOptions) ||
                const DeepCollectionEquality()
                    .equals(other.paginationOptions, paginationOptions)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(organizationId) ^
      const DeepCollectionEquality().hash(filterType) ^
      const DeepCollectionEquality().hash(filterValue) ^
      const DeepCollectionEquality().hash(paginationOptions) ^
      runtimeType.hashCode;
}

extension $GetVerifiedSubOrgIdsRequestExtension on GetVerifiedSubOrgIdsRequest {
  GetVerifiedSubOrgIdsRequest copyWith(
      {String? organizationId,
      String? filterType,
      String? filterValue,
      Pagination? paginationOptions}) {
    return GetVerifiedSubOrgIdsRequest(
        organizationId: organizationId ?? this.organizationId,
        filterType: filterType ?? this.filterType,
        filterValue: filterValue ?? this.filterValue,
        paginationOptions: paginationOptions ?? this.paginationOptions);
  }

  GetVerifiedSubOrgIdsRequest copyWithWrapped(
      {Wrapped<String>? organizationId,
      Wrapped<String?>? filterType,
      Wrapped<String?>? filterValue,
      Wrapped<Pagination?>? paginationOptions}) {
    return GetVerifiedSubOrgIdsRequest(
        organizationId: (organizationId != null
            ? organizationId.value
            : this.organizationId),
        filterType: (filterType != null ? filterType.value : this.filterType),
        filterValue:
            (filterValue != null ? filterValue.value : this.filterValue),
        paginationOptions: (paginationOptions != null
            ? paginationOptions.value
            : this.paginationOptions));
  }
}

@JsonSerializable(explicitToJson: true)
class GetVerifiedSubOrgIdsResponse {
  const GetVerifiedSubOrgIdsResponse({
    required this.organizationIds,
  });

  factory GetVerifiedSubOrgIdsResponse.fromJson(Map<String, dynamic> json) =>
      _$GetVerifiedSubOrgIdsResponseFromJson(json);

  static const toJsonFactory = _$GetVerifiedSubOrgIdsResponseToJson;
  Map<String, dynamic> toJson() => _$GetVerifiedSubOrgIdsResponseToJson(this);

  @JsonKey(name: 'organizationIds', defaultValue: <String>[])
  final List<String> organizationIds;
  static const fromJsonFactory = _$GetVerifiedSubOrgIdsResponseFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is GetVerifiedSubOrgIdsResponse &&
            (identical(other.organizationIds, organizationIds) ||
                const DeepCollectionEquality()
                    .equals(other.organizationIds, organizationIds)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(organizationIds) ^
      runtimeType.hashCode;
}

extension $GetVerifiedSubOrgIdsResponseExtension
    on GetVerifiedSubOrgIdsResponse {
  GetVerifiedSubOrgIdsResponse copyWith({List<String>? organizationIds}) {
    return GetVerifiedSubOrgIdsResponse(
        organizationIds: organizationIds ?? this.organizationIds);
  }

  GetVerifiedSubOrgIdsResponse copyWithWrapped(
      {Wrapped<List<String>>? organizationIds}) {
    return GetVerifiedSubOrgIdsResponse(
        organizationIds: (organizationIds != null
            ? organizationIds.value
            : this.organizationIds));
  }
}

@JsonSerializable(explicitToJson: true)
class GetWalletAccountRequest {
  const GetWalletAccountRequest({
    required this.organizationId,
    required this.walletId,
    this.address,
    this.path,
  });

  factory GetWalletAccountRequest.fromJson(Map<String, dynamic> json) =>
      _$GetWalletAccountRequestFromJson(json);

  static const toJsonFactory = _$GetWalletAccountRequestToJson;
  Map<String, dynamic> toJson() => _$GetWalletAccountRequestToJson(this);

  @JsonKey(name: 'organizationId')
  final String organizationId;
  @JsonKey(name: 'walletId')
  final String walletId;
  @JsonKey(name: 'address')
  final String? address;
  @JsonKey(name: 'path')
  final String? path;
  static const fromJsonFactory = _$GetWalletAccountRequestFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is GetWalletAccountRequest &&
            (identical(other.organizationId, organizationId) ||
                const DeepCollectionEquality()
                    .equals(other.organizationId, organizationId)) &&
            (identical(other.walletId, walletId) ||
                const DeepCollectionEquality()
                    .equals(other.walletId, walletId)) &&
            (identical(other.address, address) ||
                const DeepCollectionEquality()
                    .equals(other.address, address)) &&
            (identical(other.path, path) ||
                const DeepCollectionEquality().equals(other.path, path)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(organizationId) ^
      const DeepCollectionEquality().hash(walletId) ^
      const DeepCollectionEquality().hash(address) ^
      const DeepCollectionEquality().hash(path) ^
      runtimeType.hashCode;
}

extension $GetWalletAccountRequestExtension on GetWalletAccountRequest {
  GetWalletAccountRequest copyWith(
      {String? organizationId,
      String? walletId,
      String? address,
      String? path}) {
    return GetWalletAccountRequest(
        organizationId: organizationId ?? this.organizationId,
        walletId: walletId ?? this.walletId,
        address: address ?? this.address,
        path: path ?? this.path);
  }

  GetWalletAccountRequest copyWithWrapped(
      {Wrapped<String>? organizationId,
      Wrapped<String>? walletId,
      Wrapped<String?>? address,
      Wrapped<String?>? path}) {
    return GetWalletAccountRequest(
        organizationId: (organizationId != null
            ? organizationId.value
            : this.organizationId),
        walletId: (walletId != null ? walletId.value : this.walletId),
        address: (address != null ? address.value : this.address),
        path: (path != null ? path.value : this.path));
  }
}

@JsonSerializable(explicitToJson: true)
class GetWalletAccountResponse {
  const GetWalletAccountResponse({
    required this.account,
  });

  factory GetWalletAccountResponse.fromJson(Map<String, dynamic> json) =>
      _$GetWalletAccountResponseFromJson(json);

  static const toJsonFactory = _$GetWalletAccountResponseToJson;
  Map<String, dynamic> toJson() => _$GetWalletAccountResponseToJson(this);

  @JsonKey(name: 'account')
  final WalletAccount account;
  static const fromJsonFactory = _$GetWalletAccountResponseFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is GetWalletAccountResponse &&
            (identical(other.account, account) ||
                const DeepCollectionEquality().equals(other.account, account)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(account) ^ runtimeType.hashCode;
}

extension $GetWalletAccountResponseExtension on GetWalletAccountResponse {
  GetWalletAccountResponse copyWith({WalletAccount? account}) {
    return GetWalletAccountResponse(account: account ?? this.account);
  }

  GetWalletAccountResponse copyWithWrapped({Wrapped<WalletAccount>? account}) {
    return GetWalletAccountResponse(
        account: (account != null ? account.value : this.account));
  }
}

@JsonSerializable(explicitToJson: true)
class GetWalletAccountsRequest {
  const GetWalletAccountsRequest({
    required this.organizationId,
    this.walletId,
    this.paginationOptions,
  });

  factory GetWalletAccountsRequest.fromJson(Map<String, dynamic> json) =>
      _$GetWalletAccountsRequestFromJson(json);

  static const toJsonFactory = _$GetWalletAccountsRequestToJson;
  Map<String, dynamic> toJson() => _$GetWalletAccountsRequestToJson(this);

  @JsonKey(name: 'organizationId')
  final String organizationId;
  @JsonKey(name: 'walletId')
  final String? walletId;
  @JsonKey(name: 'paginationOptions')
  final Pagination? paginationOptions;
  static const fromJsonFactory = _$GetWalletAccountsRequestFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is GetWalletAccountsRequest &&
            (identical(other.organizationId, organizationId) ||
                const DeepCollectionEquality()
                    .equals(other.organizationId, organizationId)) &&
            (identical(other.walletId, walletId) ||
                const DeepCollectionEquality()
                    .equals(other.walletId, walletId)) &&
            (identical(other.paginationOptions, paginationOptions) ||
                const DeepCollectionEquality()
                    .equals(other.paginationOptions, paginationOptions)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(organizationId) ^
      const DeepCollectionEquality().hash(walletId) ^
      const DeepCollectionEquality().hash(paginationOptions) ^
      runtimeType.hashCode;
}

extension $GetWalletAccountsRequestExtension on GetWalletAccountsRequest {
  GetWalletAccountsRequest copyWith(
      {String? organizationId,
      String? walletId,
      Pagination? paginationOptions}) {
    return GetWalletAccountsRequest(
        organizationId: organizationId ?? this.organizationId,
        walletId: walletId ?? this.walletId,
        paginationOptions: paginationOptions ?? this.paginationOptions);
  }

  GetWalletAccountsRequest copyWithWrapped(
      {Wrapped<String>? organizationId,
      Wrapped<String?>? walletId,
      Wrapped<Pagination?>? paginationOptions}) {
    return GetWalletAccountsRequest(
        organizationId: (organizationId != null
            ? organizationId.value
            : this.organizationId),
        walletId: (walletId != null ? walletId.value : this.walletId),
        paginationOptions: (paginationOptions != null
            ? paginationOptions.value
            : this.paginationOptions));
  }
}

@JsonSerializable(explicitToJson: true)
class GetWalletAccountsResponse {
  const GetWalletAccountsResponse({
    required this.accounts,
  });

  factory GetWalletAccountsResponse.fromJson(Map<String, dynamic> json) =>
      _$GetWalletAccountsResponseFromJson(json);

  static const toJsonFactory = _$GetWalletAccountsResponseToJson;
  Map<String, dynamic> toJson() => _$GetWalletAccountsResponseToJson(this);

  @JsonKey(name: 'accounts', defaultValue: <WalletAccount>[])
  final List<WalletAccount> accounts;
  static const fromJsonFactory = _$GetWalletAccountsResponseFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is GetWalletAccountsResponse &&
            (identical(other.accounts, accounts) ||
                const DeepCollectionEquality()
                    .equals(other.accounts, accounts)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(accounts) ^ runtimeType.hashCode;
}

extension $GetWalletAccountsResponseExtension on GetWalletAccountsResponse {
  GetWalletAccountsResponse copyWith({List<WalletAccount>? accounts}) {
    return GetWalletAccountsResponse(accounts: accounts ?? this.accounts);
  }

  GetWalletAccountsResponse copyWithWrapped(
      {Wrapped<List<WalletAccount>>? accounts}) {
    return GetWalletAccountsResponse(
        accounts: (accounts != null ? accounts.value : this.accounts));
  }
}

@JsonSerializable(explicitToJson: true)
class GetWalletRequest {
  const GetWalletRequest({
    required this.organizationId,
    required this.walletId,
  });

  factory GetWalletRequest.fromJson(Map<String, dynamic> json) =>
      _$GetWalletRequestFromJson(json);

  static const toJsonFactory = _$GetWalletRequestToJson;
  Map<String, dynamic> toJson() => _$GetWalletRequestToJson(this);

  @JsonKey(name: 'organizationId')
  final String organizationId;
  @JsonKey(name: 'walletId')
  final String walletId;
  static const fromJsonFactory = _$GetWalletRequestFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is GetWalletRequest &&
            (identical(other.organizationId, organizationId) ||
                const DeepCollectionEquality()
                    .equals(other.organizationId, organizationId)) &&
            (identical(other.walletId, walletId) ||
                const DeepCollectionEquality()
                    .equals(other.walletId, walletId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(organizationId) ^
      const DeepCollectionEquality().hash(walletId) ^
      runtimeType.hashCode;
}

extension $GetWalletRequestExtension on GetWalletRequest {
  GetWalletRequest copyWith({String? organizationId, String? walletId}) {
    return GetWalletRequest(
        organizationId: organizationId ?? this.organizationId,
        walletId: walletId ?? this.walletId);
  }

  GetWalletRequest copyWithWrapped(
      {Wrapped<String>? organizationId, Wrapped<String>? walletId}) {
    return GetWalletRequest(
        organizationId: (organizationId != null
            ? organizationId.value
            : this.organizationId),
        walletId: (walletId != null ? walletId.value : this.walletId));
  }
}

@JsonSerializable(explicitToJson: true)
class GetWalletResponse {
  const GetWalletResponse({
    required this.wallet,
  });

  factory GetWalletResponse.fromJson(Map<String, dynamic> json) =>
      _$GetWalletResponseFromJson(json);

  static const toJsonFactory = _$GetWalletResponseToJson;
  Map<String, dynamic> toJson() => _$GetWalletResponseToJson(this);

  @JsonKey(name: 'wallet')
  final Wallet wallet;
  static const fromJsonFactory = _$GetWalletResponseFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is GetWalletResponse &&
            (identical(other.wallet, wallet) ||
                const DeepCollectionEquality().equals(other.wallet, wallet)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(wallet) ^ runtimeType.hashCode;
}

extension $GetWalletResponseExtension on GetWalletResponse {
  GetWalletResponse copyWith({Wallet? wallet}) {
    return GetWalletResponse(wallet: wallet ?? this.wallet);
  }

  GetWalletResponse copyWithWrapped({Wrapped<Wallet>? wallet}) {
    return GetWalletResponse(
        wallet: (wallet != null ? wallet.value : this.wallet));
  }
}

@JsonSerializable(explicitToJson: true)
class GetWalletsRequest {
  const GetWalletsRequest({
    required this.organizationId,
  });

  factory GetWalletsRequest.fromJson(Map<String, dynamic> json) =>
      _$GetWalletsRequestFromJson(json);

  static const toJsonFactory = _$GetWalletsRequestToJson;
  Map<String, dynamic> toJson() => _$GetWalletsRequestToJson(this);

  @JsonKey(name: 'organizationId')
  final String organizationId;
  static const fromJsonFactory = _$GetWalletsRequestFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is GetWalletsRequest &&
            (identical(other.organizationId, organizationId) ||
                const DeepCollectionEquality()
                    .equals(other.organizationId, organizationId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(organizationId) ^
      runtimeType.hashCode;
}

extension $GetWalletsRequestExtension on GetWalletsRequest {
  GetWalletsRequest copyWith({String? organizationId}) {
    return GetWalletsRequest(
        organizationId: organizationId ?? this.organizationId);
  }

  GetWalletsRequest copyWithWrapped({Wrapped<String>? organizationId}) {
    return GetWalletsRequest(
        organizationId: (organizationId != null
            ? organizationId.value
            : this.organizationId));
  }
}

@JsonSerializable(explicitToJson: true)
class GetWalletsResponse {
  const GetWalletsResponse({
    required this.wallets,
  });

  factory GetWalletsResponse.fromJson(Map<String, dynamic> json) =>
      _$GetWalletsResponseFromJson(json);

  static const toJsonFactory = _$GetWalletsResponseToJson;
  Map<String, dynamic> toJson() => _$GetWalletsResponseToJson(this);

  @JsonKey(name: 'wallets', defaultValue: <Wallet>[])
  final List<Wallet> wallets;
  static const fromJsonFactory = _$GetWalletsResponseFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is GetWalletsResponse &&
            (identical(other.wallets, wallets) ||
                const DeepCollectionEquality().equals(other.wallets, wallets)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(wallets) ^ runtimeType.hashCode;
}

extension $GetWalletsResponseExtension on GetWalletsResponse {
  GetWalletsResponse copyWith({List<Wallet>? wallets}) {
    return GetWalletsResponse(wallets: wallets ?? this.wallets);
  }

  GetWalletsResponse copyWithWrapped({Wrapped<List<Wallet>>? wallets}) {
    return GetWalletsResponse(
        wallets: (wallets != null ? wallets.value : this.wallets));
  }
}

@JsonSerializable(explicitToJson: true)
class GetWhoamiRequest {
  const GetWhoamiRequest({
    required this.organizationId,
  });

  factory GetWhoamiRequest.fromJson(Map<String, dynamic> json) =>
      _$GetWhoamiRequestFromJson(json);

  static const toJsonFactory = _$GetWhoamiRequestToJson;
  Map<String, dynamic> toJson() => _$GetWhoamiRequestToJson(this);

  @JsonKey(name: 'organizationId')
  final String organizationId;
  static const fromJsonFactory = _$GetWhoamiRequestFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is GetWhoamiRequest &&
            (identical(other.organizationId, organizationId) ||
                const DeepCollectionEquality()
                    .equals(other.organizationId, organizationId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(organizationId) ^
      runtimeType.hashCode;
}

extension $GetWhoamiRequestExtension on GetWhoamiRequest {
  GetWhoamiRequest copyWith({String? organizationId}) {
    return GetWhoamiRequest(
        organizationId: organizationId ?? this.organizationId);
  }

  GetWhoamiRequest copyWithWrapped({Wrapped<String>? organizationId}) {
    return GetWhoamiRequest(
        organizationId: (organizationId != null
            ? organizationId.value
            : this.organizationId));
  }
}

@JsonSerializable(explicitToJson: true)
class GetWhoamiResponse {
  const GetWhoamiResponse({
    required this.organizationId,
    required this.organizationName,
    required this.userId,
    required this.username,
  });

  factory GetWhoamiResponse.fromJson(Map<String, dynamic> json) =>
      _$GetWhoamiResponseFromJson(json);

  static const toJsonFactory = _$GetWhoamiResponseToJson;
  Map<String, dynamic> toJson() => _$GetWhoamiResponseToJson(this);

  @JsonKey(name: 'organizationId')
  final String organizationId;
  @JsonKey(name: 'organizationName')
  final String organizationName;
  @JsonKey(name: 'userId')
  final String userId;
  @JsonKey(name: 'username')
  final String username;
  static const fromJsonFactory = _$GetWhoamiResponseFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is GetWhoamiResponse &&
            (identical(other.organizationId, organizationId) ||
                const DeepCollectionEquality()
                    .equals(other.organizationId, organizationId)) &&
            (identical(other.organizationName, organizationName) ||
                const DeepCollectionEquality()
                    .equals(other.organizationName, organizationName)) &&
            (identical(other.userId, userId) ||
                const DeepCollectionEquality().equals(other.userId, userId)) &&
            (identical(other.username, username) ||
                const DeepCollectionEquality()
                    .equals(other.username, username)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(organizationId) ^
      const DeepCollectionEquality().hash(organizationName) ^
      const DeepCollectionEquality().hash(userId) ^
      const DeepCollectionEquality().hash(username) ^
      runtimeType.hashCode;
}

extension $GetWhoamiResponseExtension on GetWhoamiResponse {
  GetWhoamiResponse copyWith(
      {String? organizationId,
      String? organizationName,
      String? userId,
      String? username}) {
    return GetWhoamiResponse(
        organizationId: organizationId ?? this.organizationId,
        organizationName: organizationName ?? this.organizationName,
        userId: userId ?? this.userId,
        username: username ?? this.username);
  }

  GetWhoamiResponse copyWithWrapped(
      {Wrapped<String>? organizationId,
      Wrapped<String>? organizationName,
      Wrapped<String>? userId,
      Wrapped<String>? username}) {
    return GetWhoamiResponse(
        organizationId: (organizationId != null
            ? organizationId.value
            : this.organizationId),
        organizationName: (organizationName != null
            ? organizationName.value
            : this.organizationName),
        userId: (userId != null ? userId.value : this.userId),
        username: (username != null ? username.value : this.username));
  }
}

@JsonSerializable(explicitToJson: true)
class ImportPrivateKeyIntent {
  const ImportPrivateKeyIntent({
    required this.userId,
    required this.privateKeyName,
    required this.encryptedBundle,
    required this.curve,
    required this.addressFormats,
  });

  factory ImportPrivateKeyIntent.fromJson(Map<String, dynamic> json) =>
      _$ImportPrivateKeyIntentFromJson(json);

  static const toJsonFactory = _$ImportPrivateKeyIntentToJson;
  Map<String, dynamic> toJson() => _$ImportPrivateKeyIntentToJson(this);

  @JsonKey(name: 'userId')
  final String userId;
  @JsonKey(name: 'privateKeyName')
  final String privateKeyName;
  @JsonKey(name: 'encryptedBundle')
  final String encryptedBundle;
  @JsonKey(
    name: 'curve',
    toJson: curveToJson,
    fromJson: curveFromJson,
  )
  final enums.Curve curve;
  @JsonKey(
    name: 'addressFormats',
    toJson: addressFormatListToJson,
    fromJson: addressFormatListFromJson,
  )
  final List<enums.AddressFormat> addressFormats;
  static const fromJsonFactory = _$ImportPrivateKeyIntentFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ImportPrivateKeyIntent &&
            (identical(other.userId, userId) ||
                const DeepCollectionEquality().equals(other.userId, userId)) &&
            (identical(other.privateKeyName, privateKeyName) ||
                const DeepCollectionEquality()
                    .equals(other.privateKeyName, privateKeyName)) &&
            (identical(other.encryptedBundle, encryptedBundle) ||
                const DeepCollectionEquality()
                    .equals(other.encryptedBundle, encryptedBundle)) &&
            (identical(other.curve, curve) ||
                const DeepCollectionEquality().equals(other.curve, curve)) &&
            (identical(other.addressFormats, addressFormats) ||
                const DeepCollectionEquality()
                    .equals(other.addressFormats, addressFormats)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(userId) ^
      const DeepCollectionEquality().hash(privateKeyName) ^
      const DeepCollectionEquality().hash(encryptedBundle) ^
      const DeepCollectionEquality().hash(curve) ^
      const DeepCollectionEquality().hash(addressFormats) ^
      runtimeType.hashCode;
}

extension $ImportPrivateKeyIntentExtension on ImportPrivateKeyIntent {
  ImportPrivateKeyIntent copyWith(
      {String? userId,
      String? privateKeyName,
      String? encryptedBundle,
      enums.Curve? curve,
      List<enums.AddressFormat>? addressFormats}) {
    return ImportPrivateKeyIntent(
        userId: userId ?? this.userId,
        privateKeyName: privateKeyName ?? this.privateKeyName,
        encryptedBundle: encryptedBundle ?? this.encryptedBundle,
        curve: curve ?? this.curve,
        addressFormats: addressFormats ?? this.addressFormats);
  }

  ImportPrivateKeyIntent copyWithWrapped(
      {Wrapped<String>? userId,
      Wrapped<String>? privateKeyName,
      Wrapped<String>? encryptedBundle,
      Wrapped<enums.Curve>? curve,
      Wrapped<List<enums.AddressFormat>>? addressFormats}) {
    return ImportPrivateKeyIntent(
        userId: (userId != null ? userId.value : this.userId),
        privateKeyName: (privateKeyName != null
            ? privateKeyName.value
            : this.privateKeyName),
        encryptedBundle: (encryptedBundle != null
            ? encryptedBundle.value
            : this.encryptedBundle),
        curve: (curve != null ? curve.value : this.curve),
        addressFormats: (addressFormats != null
            ? addressFormats.value
            : this.addressFormats));
  }
}

@JsonSerializable(explicitToJson: true)
class ImportPrivateKeyRequest {
  const ImportPrivateKeyRequest({
    required this.type,
    required this.timestampMs,
    required this.organizationId,
    required this.parameters,
  });

  factory ImportPrivateKeyRequest.fromJson(Map<String, dynamic> json) =>
      _$ImportPrivateKeyRequestFromJson(json);

  static const toJsonFactory = _$ImportPrivateKeyRequestToJson;
  Map<String, dynamic> toJson() => _$ImportPrivateKeyRequestToJson(this);

  @JsonKey(
    name: 'type',
    toJson: importPrivateKeyRequestTypeToJson,
    fromJson: importPrivateKeyRequestTypeFromJson,
  )
  final enums.ImportPrivateKeyRequestType type;
  @JsonKey(name: 'timestampMs')
  final String timestampMs;
  @JsonKey(name: 'organizationId')
  final String organizationId;
  @JsonKey(name: 'parameters')
  final ImportPrivateKeyIntent parameters;
  static const fromJsonFactory = _$ImportPrivateKeyRequestFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ImportPrivateKeyRequest &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.timestampMs, timestampMs) ||
                const DeepCollectionEquality()
                    .equals(other.timestampMs, timestampMs)) &&
            (identical(other.organizationId, organizationId) ||
                const DeepCollectionEquality()
                    .equals(other.organizationId, organizationId)) &&
            (identical(other.parameters, parameters) ||
                const DeepCollectionEquality()
                    .equals(other.parameters, parameters)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(timestampMs) ^
      const DeepCollectionEquality().hash(organizationId) ^
      const DeepCollectionEquality().hash(parameters) ^
      runtimeType.hashCode;
}

extension $ImportPrivateKeyRequestExtension on ImportPrivateKeyRequest {
  ImportPrivateKeyRequest copyWith(
      {enums.ImportPrivateKeyRequestType? type,
      String? timestampMs,
      String? organizationId,
      ImportPrivateKeyIntent? parameters}) {
    return ImportPrivateKeyRequest(
        type: type ?? this.type,
        timestampMs: timestampMs ?? this.timestampMs,
        organizationId: organizationId ?? this.organizationId,
        parameters: parameters ?? this.parameters);
  }

  ImportPrivateKeyRequest copyWithWrapped(
      {Wrapped<enums.ImportPrivateKeyRequestType>? type,
      Wrapped<String>? timestampMs,
      Wrapped<String>? organizationId,
      Wrapped<ImportPrivateKeyIntent>? parameters}) {
    return ImportPrivateKeyRequest(
        type: (type != null ? type.value : this.type),
        timestampMs:
            (timestampMs != null ? timestampMs.value : this.timestampMs),
        organizationId: (organizationId != null
            ? organizationId.value
            : this.organizationId),
        parameters: (parameters != null ? parameters.value : this.parameters));
  }
}

@JsonSerializable(explicitToJson: true)
class ImportPrivateKeyResult {
  const ImportPrivateKeyResult({
    required this.privateKeyId,
    required this.addresses,
  });

  factory ImportPrivateKeyResult.fromJson(Map<String, dynamic> json) =>
      _$ImportPrivateKeyResultFromJson(json);

  static const toJsonFactory = _$ImportPrivateKeyResultToJson;
  Map<String, dynamic> toJson() => _$ImportPrivateKeyResultToJson(this);

  @JsonKey(name: 'privateKeyId')
  final String privateKeyId;
  @JsonKey(name: 'addresses', defaultValue: <ActivityV1Address>[])
  final List<ActivityV1Address> addresses;
  static const fromJsonFactory = _$ImportPrivateKeyResultFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ImportPrivateKeyResult &&
            (identical(other.privateKeyId, privateKeyId) ||
                const DeepCollectionEquality()
                    .equals(other.privateKeyId, privateKeyId)) &&
            (identical(other.addresses, addresses) ||
                const DeepCollectionEquality()
                    .equals(other.addresses, addresses)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(privateKeyId) ^
      const DeepCollectionEquality().hash(addresses) ^
      runtimeType.hashCode;
}

extension $ImportPrivateKeyResultExtension on ImportPrivateKeyResult {
  ImportPrivateKeyResult copyWith(
      {String? privateKeyId, List<ActivityV1Address>? addresses}) {
    return ImportPrivateKeyResult(
        privateKeyId: privateKeyId ?? this.privateKeyId,
        addresses: addresses ?? this.addresses);
  }

  ImportPrivateKeyResult copyWithWrapped(
      {Wrapped<String>? privateKeyId,
      Wrapped<List<ActivityV1Address>>? addresses}) {
    return ImportPrivateKeyResult(
        privateKeyId:
            (privateKeyId != null ? privateKeyId.value : this.privateKeyId),
        addresses: (addresses != null ? addresses.value : this.addresses));
  }
}

@JsonSerializable(explicitToJson: true)
class ImportWalletIntent {
  const ImportWalletIntent({
    required this.userId,
    required this.walletName,
    required this.encryptedBundle,
    required this.accounts,
  });

  factory ImportWalletIntent.fromJson(Map<String, dynamic> json) =>
      _$ImportWalletIntentFromJson(json);

  static const toJsonFactory = _$ImportWalletIntentToJson;
  Map<String, dynamic> toJson() => _$ImportWalletIntentToJson(this);

  @JsonKey(name: 'userId')
  final String userId;
  @JsonKey(name: 'walletName')
  final String walletName;
  @JsonKey(name: 'encryptedBundle')
  final String encryptedBundle;
  @JsonKey(name: 'accounts', defaultValue: <WalletAccountParams>[])
  final List<WalletAccountParams> accounts;
  static const fromJsonFactory = _$ImportWalletIntentFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ImportWalletIntent &&
            (identical(other.userId, userId) ||
                const DeepCollectionEquality().equals(other.userId, userId)) &&
            (identical(other.walletName, walletName) ||
                const DeepCollectionEquality()
                    .equals(other.walletName, walletName)) &&
            (identical(other.encryptedBundle, encryptedBundle) ||
                const DeepCollectionEquality()
                    .equals(other.encryptedBundle, encryptedBundle)) &&
            (identical(other.accounts, accounts) ||
                const DeepCollectionEquality()
                    .equals(other.accounts, accounts)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(userId) ^
      const DeepCollectionEquality().hash(walletName) ^
      const DeepCollectionEquality().hash(encryptedBundle) ^
      const DeepCollectionEquality().hash(accounts) ^
      runtimeType.hashCode;
}

extension $ImportWalletIntentExtension on ImportWalletIntent {
  ImportWalletIntent copyWith(
      {String? userId,
      String? walletName,
      String? encryptedBundle,
      List<WalletAccountParams>? accounts}) {
    return ImportWalletIntent(
        userId: userId ?? this.userId,
        walletName: walletName ?? this.walletName,
        encryptedBundle: encryptedBundle ?? this.encryptedBundle,
        accounts: accounts ?? this.accounts);
  }

  ImportWalletIntent copyWithWrapped(
      {Wrapped<String>? userId,
      Wrapped<String>? walletName,
      Wrapped<String>? encryptedBundle,
      Wrapped<List<WalletAccountParams>>? accounts}) {
    return ImportWalletIntent(
        userId: (userId != null ? userId.value : this.userId),
        walletName: (walletName != null ? walletName.value : this.walletName),
        encryptedBundle: (encryptedBundle != null
            ? encryptedBundle.value
            : this.encryptedBundle),
        accounts: (accounts != null ? accounts.value : this.accounts));
  }
}

@JsonSerializable(explicitToJson: true)
class ImportWalletRequest {
  const ImportWalletRequest({
    required this.type,
    required this.timestampMs,
    required this.organizationId,
    required this.parameters,
  });

  factory ImportWalletRequest.fromJson(Map<String, dynamic> json) =>
      _$ImportWalletRequestFromJson(json);

  static const toJsonFactory = _$ImportWalletRequestToJson;
  Map<String, dynamic> toJson() => _$ImportWalletRequestToJson(this);

  @JsonKey(
    name: 'type',
    toJson: importWalletRequestTypeToJson,
    fromJson: importWalletRequestTypeFromJson,
  )
  final enums.ImportWalletRequestType type;
  @JsonKey(name: 'timestampMs')
  final String timestampMs;
  @JsonKey(name: 'organizationId')
  final String organizationId;
  @JsonKey(name: 'parameters')
  final ImportWalletIntent parameters;
  static const fromJsonFactory = _$ImportWalletRequestFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ImportWalletRequest &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.timestampMs, timestampMs) ||
                const DeepCollectionEquality()
                    .equals(other.timestampMs, timestampMs)) &&
            (identical(other.organizationId, organizationId) ||
                const DeepCollectionEquality()
                    .equals(other.organizationId, organizationId)) &&
            (identical(other.parameters, parameters) ||
                const DeepCollectionEquality()
                    .equals(other.parameters, parameters)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(timestampMs) ^
      const DeepCollectionEquality().hash(organizationId) ^
      const DeepCollectionEquality().hash(parameters) ^
      runtimeType.hashCode;
}

extension $ImportWalletRequestExtension on ImportWalletRequest {
  ImportWalletRequest copyWith(
      {enums.ImportWalletRequestType? type,
      String? timestampMs,
      String? organizationId,
      ImportWalletIntent? parameters}) {
    return ImportWalletRequest(
        type: type ?? this.type,
        timestampMs: timestampMs ?? this.timestampMs,
        organizationId: organizationId ?? this.organizationId,
        parameters: parameters ?? this.parameters);
  }

  ImportWalletRequest copyWithWrapped(
      {Wrapped<enums.ImportWalletRequestType>? type,
      Wrapped<String>? timestampMs,
      Wrapped<String>? organizationId,
      Wrapped<ImportWalletIntent>? parameters}) {
    return ImportWalletRequest(
        type: (type != null ? type.value : this.type),
        timestampMs:
            (timestampMs != null ? timestampMs.value : this.timestampMs),
        organizationId: (organizationId != null
            ? organizationId.value
            : this.organizationId),
        parameters: (parameters != null ? parameters.value : this.parameters));
  }
}

@JsonSerializable(explicitToJson: true)
class ImportWalletResult {
  const ImportWalletResult({
    required this.walletId,
    required this.addresses,
  });

  factory ImportWalletResult.fromJson(Map<String, dynamic> json) =>
      _$ImportWalletResultFromJson(json);

  static const toJsonFactory = _$ImportWalletResultToJson;
  Map<String, dynamic> toJson() => _$ImportWalletResultToJson(this);

  @JsonKey(name: 'walletId')
  final String walletId;
  @JsonKey(name: 'addresses', defaultValue: <String>[])
  final List<String> addresses;
  static const fromJsonFactory = _$ImportWalletResultFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ImportWalletResult &&
            (identical(other.walletId, walletId) ||
                const DeepCollectionEquality()
                    .equals(other.walletId, walletId)) &&
            (identical(other.addresses, addresses) ||
                const DeepCollectionEquality()
                    .equals(other.addresses, addresses)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(walletId) ^
      const DeepCollectionEquality().hash(addresses) ^
      runtimeType.hashCode;
}

extension $ImportWalletResultExtension on ImportWalletResult {
  ImportWalletResult copyWith({String? walletId, List<String>? addresses}) {
    return ImportWalletResult(
        walletId: walletId ?? this.walletId,
        addresses: addresses ?? this.addresses);
  }

  ImportWalletResult copyWithWrapped(
      {Wrapped<String>? walletId, Wrapped<List<String>>? addresses}) {
    return ImportWalletResult(
        walletId: (walletId != null ? walletId.value : this.walletId),
        addresses: (addresses != null ? addresses.value : this.addresses));
  }
}

@JsonSerializable(explicitToJson: true)
class InitFiatOnRampIntent {
  const InitFiatOnRampIntent({
    required this.onrampProvider,
    required this.walletAddress,
    required this.network,
    required this.cryptoCurrencyCode,
    this.fiatCurrencyCode,
    this.fiatCurrencyAmount,
    this.paymentMethod,
    this.countryCode,
    this.countrySubdivisionCode,
    this.sandboxMode,
  });

  factory InitFiatOnRampIntent.fromJson(Map<String, dynamic> json) =>
      _$InitFiatOnRampIntentFromJson(json);

  static const toJsonFactory = _$InitFiatOnRampIntentToJson;
  Map<String, dynamic> toJson() => _$InitFiatOnRampIntentToJson(this);

  @JsonKey(
    name: 'onrampProvider',
    toJson: fiatOnRampProviderToJson,
    fromJson: fiatOnRampProviderFromJson,
  )
  final enums.FiatOnRampProvider onrampProvider;
  @JsonKey(name: 'walletAddress')
  final String walletAddress;
  @JsonKey(
    name: 'network',
    toJson: fiatOnRampBlockchainNetworkToJson,
    fromJson: fiatOnRampBlockchainNetworkFromJson,
  )
  final enums.FiatOnRampBlockchainNetwork network;
  @JsonKey(
    name: 'cryptoCurrencyCode',
    toJson: fiatOnRampCryptoCurrencyToJson,
    fromJson: fiatOnRampCryptoCurrencyFromJson,
  )
  final enums.FiatOnRampCryptoCurrency cryptoCurrencyCode;
  @JsonKey(
    name: 'fiatCurrencyCode',
    toJson: fiatOnRampCurrencyNullableToJson,
    fromJson: fiatOnRampCurrencyNullableFromJson,
  )
  final enums.FiatOnRampCurrency? fiatCurrencyCode;
  @JsonKey(name: 'fiatCurrencyAmount')
  final String? fiatCurrencyAmount;
  @JsonKey(
    name: 'paymentMethod',
    toJson: fiatOnRampPaymentMethodNullableToJson,
    fromJson: fiatOnRampPaymentMethodNullableFromJson,
  )
  final enums.FiatOnRampPaymentMethod? paymentMethod;
  @JsonKey(name: 'countryCode')
  final String? countryCode;
  @JsonKey(name: 'countrySubdivisionCode')
  final String? countrySubdivisionCode;
  @JsonKey(name: 'sandboxMode')
  final bool? sandboxMode;
  static const fromJsonFactory = _$InitFiatOnRampIntentFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is InitFiatOnRampIntent &&
            (identical(other.onrampProvider, onrampProvider) ||
                const DeepCollectionEquality()
                    .equals(other.onrampProvider, onrampProvider)) &&
            (identical(other.walletAddress, walletAddress) ||
                const DeepCollectionEquality()
                    .equals(other.walletAddress, walletAddress)) &&
            (identical(other.network, network) ||
                const DeepCollectionEquality()
                    .equals(other.network, network)) &&
            (identical(other.cryptoCurrencyCode, cryptoCurrencyCode) ||
                const DeepCollectionEquality()
                    .equals(other.cryptoCurrencyCode, cryptoCurrencyCode)) &&
            (identical(other.fiatCurrencyCode, fiatCurrencyCode) ||
                const DeepCollectionEquality()
                    .equals(other.fiatCurrencyCode, fiatCurrencyCode)) &&
            (identical(other.fiatCurrencyAmount, fiatCurrencyAmount) ||
                const DeepCollectionEquality()
                    .equals(other.fiatCurrencyAmount, fiatCurrencyAmount)) &&
            (identical(other.paymentMethod, paymentMethod) ||
                const DeepCollectionEquality()
                    .equals(other.paymentMethod, paymentMethod)) &&
            (identical(other.countryCode, countryCode) ||
                const DeepCollectionEquality()
                    .equals(other.countryCode, countryCode)) &&
            (identical(other.countrySubdivisionCode, countrySubdivisionCode) ||
                const DeepCollectionEquality().equals(
                    other.countrySubdivisionCode, countrySubdivisionCode)) &&
            (identical(other.sandboxMode, sandboxMode) ||
                const DeepCollectionEquality()
                    .equals(other.sandboxMode, sandboxMode)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(onrampProvider) ^
      const DeepCollectionEquality().hash(walletAddress) ^
      const DeepCollectionEquality().hash(network) ^
      const DeepCollectionEquality().hash(cryptoCurrencyCode) ^
      const DeepCollectionEquality().hash(fiatCurrencyCode) ^
      const DeepCollectionEquality().hash(fiatCurrencyAmount) ^
      const DeepCollectionEquality().hash(paymentMethod) ^
      const DeepCollectionEquality().hash(countryCode) ^
      const DeepCollectionEquality().hash(countrySubdivisionCode) ^
      const DeepCollectionEquality().hash(sandboxMode) ^
      runtimeType.hashCode;
}

extension $InitFiatOnRampIntentExtension on InitFiatOnRampIntent {
  InitFiatOnRampIntent copyWith(
      {enums.FiatOnRampProvider? onrampProvider,
      String? walletAddress,
      enums.FiatOnRampBlockchainNetwork? network,
      enums.FiatOnRampCryptoCurrency? cryptoCurrencyCode,
      enums.FiatOnRampCurrency? fiatCurrencyCode,
      String? fiatCurrencyAmount,
      enums.FiatOnRampPaymentMethod? paymentMethod,
      String? countryCode,
      String? countrySubdivisionCode,
      bool? sandboxMode}) {
    return InitFiatOnRampIntent(
        onrampProvider: onrampProvider ?? this.onrampProvider,
        walletAddress: walletAddress ?? this.walletAddress,
        network: network ?? this.network,
        cryptoCurrencyCode: cryptoCurrencyCode ?? this.cryptoCurrencyCode,
        fiatCurrencyCode: fiatCurrencyCode ?? this.fiatCurrencyCode,
        fiatCurrencyAmount: fiatCurrencyAmount ?? this.fiatCurrencyAmount,
        paymentMethod: paymentMethod ?? this.paymentMethod,
        countryCode: countryCode ?? this.countryCode,
        countrySubdivisionCode:
            countrySubdivisionCode ?? this.countrySubdivisionCode,
        sandboxMode: sandboxMode ?? this.sandboxMode);
  }

  InitFiatOnRampIntent copyWithWrapped(
      {Wrapped<enums.FiatOnRampProvider>? onrampProvider,
      Wrapped<String>? walletAddress,
      Wrapped<enums.FiatOnRampBlockchainNetwork>? network,
      Wrapped<enums.FiatOnRampCryptoCurrency>? cryptoCurrencyCode,
      Wrapped<enums.FiatOnRampCurrency?>? fiatCurrencyCode,
      Wrapped<String?>? fiatCurrencyAmount,
      Wrapped<enums.FiatOnRampPaymentMethod?>? paymentMethod,
      Wrapped<String?>? countryCode,
      Wrapped<String?>? countrySubdivisionCode,
      Wrapped<bool?>? sandboxMode}) {
    return InitFiatOnRampIntent(
        onrampProvider: (onrampProvider != null
            ? onrampProvider.value
            : this.onrampProvider),
        walletAddress:
            (walletAddress != null ? walletAddress.value : this.walletAddress),
        network: (network != null ? network.value : this.network),
        cryptoCurrencyCode: (cryptoCurrencyCode != null
            ? cryptoCurrencyCode.value
            : this.cryptoCurrencyCode),
        fiatCurrencyCode: (fiatCurrencyCode != null
            ? fiatCurrencyCode.value
            : this.fiatCurrencyCode),
        fiatCurrencyAmount: (fiatCurrencyAmount != null
            ? fiatCurrencyAmount.value
            : this.fiatCurrencyAmount),
        paymentMethod:
            (paymentMethod != null ? paymentMethod.value : this.paymentMethod),
        countryCode:
            (countryCode != null ? countryCode.value : this.countryCode),
        countrySubdivisionCode: (countrySubdivisionCode != null
            ? countrySubdivisionCode.value
            : this.countrySubdivisionCode),
        sandboxMode:
            (sandboxMode != null ? sandboxMode.value : this.sandboxMode));
  }
}

@JsonSerializable(explicitToJson: true)
class InitFiatOnRampRequest {
  const InitFiatOnRampRequest({
    required this.type,
    required this.timestampMs,
    required this.organizationId,
    required this.parameters,
  });

  factory InitFiatOnRampRequest.fromJson(Map<String, dynamic> json) =>
      _$InitFiatOnRampRequestFromJson(json);

  static const toJsonFactory = _$InitFiatOnRampRequestToJson;
  Map<String, dynamic> toJson() => _$InitFiatOnRampRequestToJson(this);

  @JsonKey(
    name: 'type',
    toJson: initFiatOnRampRequestTypeToJson,
    fromJson: initFiatOnRampRequestTypeFromJson,
  )
  final enums.InitFiatOnRampRequestType type;
  @JsonKey(name: 'timestampMs')
  final String timestampMs;
  @JsonKey(name: 'organizationId')
  final String organizationId;
  @JsonKey(name: 'parameters')
  final InitFiatOnRampIntent parameters;
  static const fromJsonFactory = _$InitFiatOnRampRequestFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is InitFiatOnRampRequest &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.timestampMs, timestampMs) ||
                const DeepCollectionEquality()
                    .equals(other.timestampMs, timestampMs)) &&
            (identical(other.organizationId, organizationId) ||
                const DeepCollectionEquality()
                    .equals(other.organizationId, organizationId)) &&
            (identical(other.parameters, parameters) ||
                const DeepCollectionEquality()
                    .equals(other.parameters, parameters)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(timestampMs) ^
      const DeepCollectionEquality().hash(organizationId) ^
      const DeepCollectionEquality().hash(parameters) ^
      runtimeType.hashCode;
}

extension $InitFiatOnRampRequestExtension on InitFiatOnRampRequest {
  InitFiatOnRampRequest copyWith(
      {enums.InitFiatOnRampRequestType? type,
      String? timestampMs,
      String? organizationId,
      InitFiatOnRampIntent? parameters}) {
    return InitFiatOnRampRequest(
        type: type ?? this.type,
        timestampMs: timestampMs ?? this.timestampMs,
        organizationId: organizationId ?? this.organizationId,
        parameters: parameters ?? this.parameters);
  }

  InitFiatOnRampRequest copyWithWrapped(
      {Wrapped<enums.InitFiatOnRampRequestType>? type,
      Wrapped<String>? timestampMs,
      Wrapped<String>? organizationId,
      Wrapped<InitFiatOnRampIntent>? parameters}) {
    return InitFiatOnRampRequest(
        type: (type != null ? type.value : this.type),
        timestampMs:
            (timestampMs != null ? timestampMs.value : this.timestampMs),
        organizationId: (organizationId != null
            ? organizationId.value
            : this.organizationId),
        parameters: (parameters != null ? parameters.value : this.parameters));
  }
}

@JsonSerializable(explicitToJson: true)
class InitFiatOnRampResult {
  const InitFiatOnRampResult({
    required this.onRampUrl,
    required this.onRampTransactionId,
  });

  factory InitFiatOnRampResult.fromJson(Map<String, dynamic> json) =>
      _$InitFiatOnRampResultFromJson(json);

  static const toJsonFactory = _$InitFiatOnRampResultToJson;
  Map<String, dynamic> toJson() => _$InitFiatOnRampResultToJson(this);

  @JsonKey(name: 'onRampUrl')
  final String onRampUrl;
  @JsonKey(name: 'onRampTransactionId')
  final String onRampTransactionId;
  static const fromJsonFactory = _$InitFiatOnRampResultFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is InitFiatOnRampResult &&
            (identical(other.onRampUrl, onRampUrl) ||
                const DeepCollectionEquality()
                    .equals(other.onRampUrl, onRampUrl)) &&
            (identical(other.onRampTransactionId, onRampTransactionId) ||
                const DeepCollectionEquality()
                    .equals(other.onRampTransactionId, onRampTransactionId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(onRampUrl) ^
      const DeepCollectionEquality().hash(onRampTransactionId) ^
      runtimeType.hashCode;
}

extension $InitFiatOnRampResultExtension on InitFiatOnRampResult {
  InitFiatOnRampResult copyWith(
      {String? onRampUrl, String? onRampTransactionId}) {
    return InitFiatOnRampResult(
        onRampUrl: onRampUrl ?? this.onRampUrl,
        onRampTransactionId: onRampTransactionId ?? this.onRampTransactionId);
  }

  InitFiatOnRampResult copyWithWrapped(
      {Wrapped<String>? onRampUrl, Wrapped<String>? onRampTransactionId}) {
    return InitFiatOnRampResult(
        onRampUrl: (onRampUrl != null ? onRampUrl.value : this.onRampUrl),
        onRampTransactionId: (onRampTransactionId != null
            ? onRampTransactionId.value
            : this.onRampTransactionId));
  }
}

@JsonSerializable(explicitToJson: true)
class InitImportPrivateKeyIntent {
  const InitImportPrivateKeyIntent({
    required this.userId,
  });

  factory InitImportPrivateKeyIntent.fromJson(Map<String, dynamic> json) =>
      _$InitImportPrivateKeyIntentFromJson(json);

  static const toJsonFactory = _$InitImportPrivateKeyIntentToJson;
  Map<String, dynamic> toJson() => _$InitImportPrivateKeyIntentToJson(this);

  @JsonKey(name: 'userId')
  final String userId;
  static const fromJsonFactory = _$InitImportPrivateKeyIntentFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is InitImportPrivateKeyIntent &&
            (identical(other.userId, userId) ||
                const DeepCollectionEquality().equals(other.userId, userId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(userId) ^ runtimeType.hashCode;
}

extension $InitImportPrivateKeyIntentExtension on InitImportPrivateKeyIntent {
  InitImportPrivateKeyIntent copyWith({String? userId}) {
    return InitImportPrivateKeyIntent(userId: userId ?? this.userId);
  }

  InitImportPrivateKeyIntent copyWithWrapped({Wrapped<String>? userId}) {
    return InitImportPrivateKeyIntent(
        userId: (userId != null ? userId.value : this.userId));
  }
}

@JsonSerializable(explicitToJson: true)
class InitImportPrivateKeyRequest {
  const InitImportPrivateKeyRequest({
    required this.type,
    required this.timestampMs,
    required this.organizationId,
    required this.parameters,
  });

  factory InitImportPrivateKeyRequest.fromJson(Map<String, dynamic> json) =>
      _$InitImportPrivateKeyRequestFromJson(json);

  static const toJsonFactory = _$InitImportPrivateKeyRequestToJson;
  Map<String, dynamic> toJson() => _$InitImportPrivateKeyRequestToJson(this);

  @JsonKey(
    name: 'type',
    toJson: initImportPrivateKeyRequestTypeToJson,
    fromJson: initImportPrivateKeyRequestTypeFromJson,
  )
  final enums.InitImportPrivateKeyRequestType type;
  @JsonKey(name: 'timestampMs')
  final String timestampMs;
  @JsonKey(name: 'organizationId')
  final String organizationId;
  @JsonKey(name: 'parameters')
  final InitImportPrivateKeyIntent parameters;
  static const fromJsonFactory = _$InitImportPrivateKeyRequestFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is InitImportPrivateKeyRequest &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.timestampMs, timestampMs) ||
                const DeepCollectionEquality()
                    .equals(other.timestampMs, timestampMs)) &&
            (identical(other.organizationId, organizationId) ||
                const DeepCollectionEquality()
                    .equals(other.organizationId, organizationId)) &&
            (identical(other.parameters, parameters) ||
                const DeepCollectionEquality()
                    .equals(other.parameters, parameters)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(timestampMs) ^
      const DeepCollectionEquality().hash(organizationId) ^
      const DeepCollectionEquality().hash(parameters) ^
      runtimeType.hashCode;
}

extension $InitImportPrivateKeyRequestExtension on InitImportPrivateKeyRequest {
  InitImportPrivateKeyRequest copyWith(
      {enums.InitImportPrivateKeyRequestType? type,
      String? timestampMs,
      String? organizationId,
      InitImportPrivateKeyIntent? parameters}) {
    return InitImportPrivateKeyRequest(
        type: type ?? this.type,
        timestampMs: timestampMs ?? this.timestampMs,
        organizationId: organizationId ?? this.organizationId,
        parameters: parameters ?? this.parameters);
  }

  InitImportPrivateKeyRequest copyWithWrapped(
      {Wrapped<enums.InitImportPrivateKeyRequestType>? type,
      Wrapped<String>? timestampMs,
      Wrapped<String>? organizationId,
      Wrapped<InitImportPrivateKeyIntent>? parameters}) {
    return InitImportPrivateKeyRequest(
        type: (type != null ? type.value : this.type),
        timestampMs:
            (timestampMs != null ? timestampMs.value : this.timestampMs),
        organizationId: (organizationId != null
            ? organizationId.value
            : this.organizationId),
        parameters: (parameters != null ? parameters.value : this.parameters));
  }
}

@JsonSerializable(explicitToJson: true)
class InitImportPrivateKeyResult {
  const InitImportPrivateKeyResult({
    required this.importBundle,
  });

  factory InitImportPrivateKeyResult.fromJson(Map<String, dynamic> json) =>
      _$InitImportPrivateKeyResultFromJson(json);

  static const toJsonFactory = _$InitImportPrivateKeyResultToJson;
  Map<String, dynamic> toJson() => _$InitImportPrivateKeyResultToJson(this);

  @JsonKey(name: 'importBundle')
  final String importBundle;
  static const fromJsonFactory = _$InitImportPrivateKeyResultFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is InitImportPrivateKeyResult &&
            (identical(other.importBundle, importBundle) ||
                const DeepCollectionEquality()
                    .equals(other.importBundle, importBundle)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(importBundle) ^ runtimeType.hashCode;
}

extension $InitImportPrivateKeyResultExtension on InitImportPrivateKeyResult {
  InitImportPrivateKeyResult copyWith({String? importBundle}) {
    return InitImportPrivateKeyResult(
        importBundle: importBundle ?? this.importBundle);
  }

  InitImportPrivateKeyResult copyWithWrapped({Wrapped<String>? importBundle}) {
    return InitImportPrivateKeyResult(
        importBundle:
            (importBundle != null ? importBundle.value : this.importBundle));
  }
}

@JsonSerializable(explicitToJson: true)
class InitImportWalletIntent {
  const InitImportWalletIntent({
    required this.userId,
  });

  factory InitImportWalletIntent.fromJson(Map<String, dynamic> json) =>
      _$InitImportWalletIntentFromJson(json);

  static const toJsonFactory = _$InitImportWalletIntentToJson;
  Map<String, dynamic> toJson() => _$InitImportWalletIntentToJson(this);

  @JsonKey(name: 'userId')
  final String userId;
  static const fromJsonFactory = _$InitImportWalletIntentFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is InitImportWalletIntent &&
            (identical(other.userId, userId) ||
                const DeepCollectionEquality().equals(other.userId, userId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(userId) ^ runtimeType.hashCode;
}

extension $InitImportWalletIntentExtension on InitImportWalletIntent {
  InitImportWalletIntent copyWith({String? userId}) {
    return InitImportWalletIntent(userId: userId ?? this.userId);
  }

  InitImportWalletIntent copyWithWrapped({Wrapped<String>? userId}) {
    return InitImportWalletIntent(
        userId: (userId != null ? userId.value : this.userId));
  }
}

@JsonSerializable(explicitToJson: true)
class InitImportWalletRequest {
  const InitImportWalletRequest({
    required this.type,
    required this.timestampMs,
    required this.organizationId,
    required this.parameters,
  });

  factory InitImportWalletRequest.fromJson(Map<String, dynamic> json) =>
      _$InitImportWalletRequestFromJson(json);

  static const toJsonFactory = _$InitImportWalletRequestToJson;
  Map<String, dynamic> toJson() => _$InitImportWalletRequestToJson(this);

  @JsonKey(
    name: 'type',
    toJson: initImportWalletRequestTypeToJson,
    fromJson: initImportWalletRequestTypeFromJson,
  )
  final enums.InitImportWalletRequestType type;
  @JsonKey(name: 'timestampMs')
  final String timestampMs;
  @JsonKey(name: 'organizationId')
  final String organizationId;
  @JsonKey(name: 'parameters')
  final InitImportWalletIntent parameters;
  static const fromJsonFactory = _$InitImportWalletRequestFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is InitImportWalletRequest &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.timestampMs, timestampMs) ||
                const DeepCollectionEquality()
                    .equals(other.timestampMs, timestampMs)) &&
            (identical(other.organizationId, organizationId) ||
                const DeepCollectionEquality()
                    .equals(other.organizationId, organizationId)) &&
            (identical(other.parameters, parameters) ||
                const DeepCollectionEquality()
                    .equals(other.parameters, parameters)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(timestampMs) ^
      const DeepCollectionEquality().hash(organizationId) ^
      const DeepCollectionEquality().hash(parameters) ^
      runtimeType.hashCode;
}

extension $InitImportWalletRequestExtension on InitImportWalletRequest {
  InitImportWalletRequest copyWith(
      {enums.InitImportWalletRequestType? type,
      String? timestampMs,
      String? organizationId,
      InitImportWalletIntent? parameters}) {
    return InitImportWalletRequest(
        type: type ?? this.type,
        timestampMs: timestampMs ?? this.timestampMs,
        organizationId: organizationId ?? this.organizationId,
        parameters: parameters ?? this.parameters);
  }

  InitImportWalletRequest copyWithWrapped(
      {Wrapped<enums.InitImportWalletRequestType>? type,
      Wrapped<String>? timestampMs,
      Wrapped<String>? organizationId,
      Wrapped<InitImportWalletIntent>? parameters}) {
    return InitImportWalletRequest(
        type: (type != null ? type.value : this.type),
        timestampMs:
            (timestampMs != null ? timestampMs.value : this.timestampMs),
        organizationId: (organizationId != null
            ? organizationId.value
            : this.organizationId),
        parameters: (parameters != null ? parameters.value : this.parameters));
  }
}

@JsonSerializable(explicitToJson: true)
class InitImportWalletResult {
  const InitImportWalletResult({
    required this.importBundle,
  });

  factory InitImportWalletResult.fromJson(Map<String, dynamic> json) =>
      _$InitImportWalletResultFromJson(json);

  static const toJsonFactory = _$InitImportWalletResultToJson;
  Map<String, dynamic> toJson() => _$InitImportWalletResultToJson(this);

  @JsonKey(name: 'importBundle')
  final String importBundle;
  static const fromJsonFactory = _$InitImportWalletResultFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is InitImportWalletResult &&
            (identical(other.importBundle, importBundle) ||
                const DeepCollectionEquality()
                    .equals(other.importBundle, importBundle)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(importBundle) ^ runtimeType.hashCode;
}

extension $InitImportWalletResultExtension on InitImportWalletResult {
  InitImportWalletResult copyWith({String? importBundle}) {
    return InitImportWalletResult(
        importBundle: importBundle ?? this.importBundle);
  }

  InitImportWalletResult copyWithWrapped({Wrapped<String>? importBundle}) {
    return InitImportWalletResult(
        importBundle:
            (importBundle != null ? importBundle.value : this.importBundle));
  }
}

@JsonSerializable(explicitToJson: true)
class InitOtpAuthIntent {
  const InitOtpAuthIntent({
    required this.otpType,
    required this.contact,
    this.emailCustomization,
    this.smsCustomization,
    this.userIdentifier,
    this.sendFromEmailAddress,
    this.sendFromEmailSenderName,
    this.replyToEmailAddress,
  });

  factory InitOtpAuthIntent.fromJson(Map<String, dynamic> json) =>
      _$InitOtpAuthIntentFromJson(json);

  static const toJsonFactory = _$InitOtpAuthIntentToJson;
  Map<String, dynamic> toJson() => _$InitOtpAuthIntentToJson(this);

  @JsonKey(name: 'otpType')
  final String otpType;
  @JsonKey(name: 'contact')
  final String contact;
  @JsonKey(name: 'emailCustomization')
  final EmailCustomizationParams? emailCustomization;
  @JsonKey(name: 'smsCustomization')
  final SmsCustomizationParams? smsCustomization;
  @JsonKey(name: 'userIdentifier')
  final String? userIdentifier;
  @JsonKey(name: 'sendFromEmailAddress')
  final String? sendFromEmailAddress;
  @JsonKey(name: 'sendFromEmailSenderName')
  final String? sendFromEmailSenderName;
  @JsonKey(name: 'replyToEmailAddress')
  final String? replyToEmailAddress;
  static const fromJsonFactory = _$InitOtpAuthIntentFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is InitOtpAuthIntent &&
            (identical(other.otpType, otpType) ||
                const DeepCollectionEquality()
                    .equals(other.otpType, otpType)) &&
            (identical(other.contact, contact) ||
                const DeepCollectionEquality()
                    .equals(other.contact, contact)) &&
            (identical(other.emailCustomization, emailCustomization) ||
                const DeepCollectionEquality()
                    .equals(other.emailCustomization, emailCustomization)) &&
            (identical(other.smsCustomization, smsCustomization) ||
                const DeepCollectionEquality()
                    .equals(other.smsCustomization, smsCustomization)) &&
            (identical(other.userIdentifier, userIdentifier) ||
                const DeepCollectionEquality()
                    .equals(other.userIdentifier, userIdentifier)) &&
            (identical(other.sendFromEmailAddress, sendFromEmailAddress) ||
                const DeepCollectionEquality().equals(
                    other.sendFromEmailAddress, sendFromEmailAddress)) &&
            (identical(
                    other.sendFromEmailSenderName, sendFromEmailSenderName) ||
                const DeepCollectionEquality().equals(
                    other.sendFromEmailSenderName, sendFromEmailSenderName)) &&
            (identical(other.replyToEmailAddress, replyToEmailAddress) ||
                const DeepCollectionEquality()
                    .equals(other.replyToEmailAddress, replyToEmailAddress)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(otpType) ^
      const DeepCollectionEquality().hash(contact) ^
      const DeepCollectionEquality().hash(emailCustomization) ^
      const DeepCollectionEquality().hash(smsCustomization) ^
      const DeepCollectionEquality().hash(userIdentifier) ^
      const DeepCollectionEquality().hash(sendFromEmailAddress) ^
      const DeepCollectionEquality().hash(sendFromEmailSenderName) ^
      const DeepCollectionEquality().hash(replyToEmailAddress) ^
      runtimeType.hashCode;
}

extension $InitOtpAuthIntentExtension on InitOtpAuthIntent {
  InitOtpAuthIntent copyWith(
      {String? otpType,
      String? contact,
      EmailCustomizationParams? emailCustomization,
      SmsCustomizationParams? smsCustomization,
      String? userIdentifier,
      String? sendFromEmailAddress,
      String? sendFromEmailSenderName,
      String? replyToEmailAddress}) {
    return InitOtpAuthIntent(
        otpType: otpType ?? this.otpType,
        contact: contact ?? this.contact,
        emailCustomization: emailCustomization ?? this.emailCustomization,
        smsCustomization: smsCustomization ?? this.smsCustomization,
        userIdentifier: userIdentifier ?? this.userIdentifier,
        sendFromEmailAddress: sendFromEmailAddress ?? this.sendFromEmailAddress,
        sendFromEmailSenderName:
            sendFromEmailSenderName ?? this.sendFromEmailSenderName,
        replyToEmailAddress: replyToEmailAddress ?? this.replyToEmailAddress);
  }

  InitOtpAuthIntent copyWithWrapped(
      {Wrapped<String>? otpType,
      Wrapped<String>? contact,
      Wrapped<EmailCustomizationParams?>? emailCustomization,
      Wrapped<SmsCustomizationParams?>? smsCustomization,
      Wrapped<String?>? userIdentifier,
      Wrapped<String?>? sendFromEmailAddress,
      Wrapped<String?>? sendFromEmailSenderName,
      Wrapped<String?>? replyToEmailAddress}) {
    return InitOtpAuthIntent(
        otpType: (otpType != null ? otpType.value : this.otpType),
        contact: (contact != null ? contact.value : this.contact),
        emailCustomization: (emailCustomization != null
            ? emailCustomization.value
            : this.emailCustomization),
        smsCustomization: (smsCustomization != null
            ? smsCustomization.value
            : this.smsCustomization),
        userIdentifier: (userIdentifier != null
            ? userIdentifier.value
            : this.userIdentifier),
        sendFromEmailAddress: (sendFromEmailAddress != null
            ? sendFromEmailAddress.value
            : this.sendFromEmailAddress),
        sendFromEmailSenderName: (sendFromEmailSenderName != null
            ? sendFromEmailSenderName.value
            : this.sendFromEmailSenderName),
        replyToEmailAddress: (replyToEmailAddress != null
            ? replyToEmailAddress.value
            : this.replyToEmailAddress));
  }
}

@JsonSerializable(explicitToJson: true)
class InitOtpAuthIntentV2 {
  const InitOtpAuthIntentV2({
    required this.otpType,
    required this.contact,
    this.otpLength,
    this.emailCustomization,
    this.smsCustomization,
    this.userIdentifier,
    this.sendFromEmailAddress,
    this.alphanumeric,
    this.sendFromEmailSenderName,
    this.replyToEmailAddress,
  });

  factory InitOtpAuthIntentV2.fromJson(Map<String, dynamic> json) =>
      _$InitOtpAuthIntentV2FromJson(json);

  static const toJsonFactory = _$InitOtpAuthIntentV2ToJson;
  Map<String, dynamic> toJson() => _$InitOtpAuthIntentV2ToJson(this);

  @JsonKey(name: 'otpType')
  final String otpType;
  @JsonKey(name: 'contact')
  final String contact;
  @JsonKey(name: 'otpLength')
  final int? otpLength;
  @JsonKey(name: 'emailCustomization')
  final EmailCustomizationParams? emailCustomization;
  @JsonKey(name: 'smsCustomization')
  final SmsCustomizationParams? smsCustomization;
  @JsonKey(name: 'userIdentifier')
  final String? userIdentifier;
  @JsonKey(name: 'sendFromEmailAddress')
  final String? sendFromEmailAddress;
  @JsonKey(name: 'alphanumeric')
  final bool? alphanumeric;
  @JsonKey(name: 'sendFromEmailSenderName')
  final String? sendFromEmailSenderName;
  @JsonKey(name: 'replyToEmailAddress')
  final String? replyToEmailAddress;
  static const fromJsonFactory = _$InitOtpAuthIntentV2FromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is InitOtpAuthIntentV2 &&
            (identical(other.otpType, otpType) ||
                const DeepCollectionEquality()
                    .equals(other.otpType, otpType)) &&
            (identical(other.contact, contact) ||
                const DeepCollectionEquality()
                    .equals(other.contact, contact)) &&
            (identical(other.otpLength, otpLength) ||
                const DeepCollectionEquality()
                    .equals(other.otpLength, otpLength)) &&
            (identical(other.emailCustomization, emailCustomization) ||
                const DeepCollectionEquality()
                    .equals(other.emailCustomization, emailCustomization)) &&
            (identical(other.smsCustomization, smsCustomization) ||
                const DeepCollectionEquality()
                    .equals(other.smsCustomization, smsCustomization)) &&
            (identical(other.userIdentifier, userIdentifier) ||
                const DeepCollectionEquality()
                    .equals(other.userIdentifier, userIdentifier)) &&
            (identical(other.sendFromEmailAddress, sendFromEmailAddress) ||
                const DeepCollectionEquality().equals(
                    other.sendFromEmailAddress, sendFromEmailAddress)) &&
            (identical(other.alphanumeric, alphanumeric) ||
                const DeepCollectionEquality()
                    .equals(other.alphanumeric, alphanumeric)) &&
            (identical(
                    other.sendFromEmailSenderName, sendFromEmailSenderName) ||
                const DeepCollectionEquality().equals(
                    other.sendFromEmailSenderName, sendFromEmailSenderName)) &&
            (identical(other.replyToEmailAddress, replyToEmailAddress) ||
                const DeepCollectionEquality()
                    .equals(other.replyToEmailAddress, replyToEmailAddress)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(otpType) ^
      const DeepCollectionEquality().hash(contact) ^
      const DeepCollectionEquality().hash(otpLength) ^
      const DeepCollectionEquality().hash(emailCustomization) ^
      const DeepCollectionEquality().hash(smsCustomization) ^
      const DeepCollectionEquality().hash(userIdentifier) ^
      const DeepCollectionEquality().hash(sendFromEmailAddress) ^
      const DeepCollectionEquality().hash(alphanumeric) ^
      const DeepCollectionEquality().hash(sendFromEmailSenderName) ^
      const DeepCollectionEquality().hash(replyToEmailAddress) ^
      runtimeType.hashCode;
}

extension $InitOtpAuthIntentV2Extension on InitOtpAuthIntentV2 {
  InitOtpAuthIntentV2 copyWith(
      {String? otpType,
      String? contact,
      int? otpLength,
      EmailCustomizationParams? emailCustomization,
      SmsCustomizationParams? smsCustomization,
      String? userIdentifier,
      String? sendFromEmailAddress,
      bool? alphanumeric,
      String? sendFromEmailSenderName,
      String? replyToEmailAddress}) {
    return InitOtpAuthIntentV2(
        otpType: otpType ?? this.otpType,
        contact: contact ?? this.contact,
        otpLength: otpLength ?? this.otpLength,
        emailCustomization: emailCustomization ?? this.emailCustomization,
        smsCustomization: smsCustomization ?? this.smsCustomization,
        userIdentifier: userIdentifier ?? this.userIdentifier,
        sendFromEmailAddress: sendFromEmailAddress ?? this.sendFromEmailAddress,
        alphanumeric: alphanumeric ?? this.alphanumeric,
        sendFromEmailSenderName:
            sendFromEmailSenderName ?? this.sendFromEmailSenderName,
        replyToEmailAddress: replyToEmailAddress ?? this.replyToEmailAddress);
  }

  InitOtpAuthIntentV2 copyWithWrapped(
      {Wrapped<String>? otpType,
      Wrapped<String>? contact,
      Wrapped<int?>? otpLength,
      Wrapped<EmailCustomizationParams?>? emailCustomization,
      Wrapped<SmsCustomizationParams?>? smsCustomization,
      Wrapped<String?>? userIdentifier,
      Wrapped<String?>? sendFromEmailAddress,
      Wrapped<bool?>? alphanumeric,
      Wrapped<String?>? sendFromEmailSenderName,
      Wrapped<String?>? replyToEmailAddress}) {
    return InitOtpAuthIntentV2(
        otpType: (otpType != null ? otpType.value : this.otpType),
        contact: (contact != null ? contact.value : this.contact),
        otpLength: (otpLength != null ? otpLength.value : this.otpLength),
        emailCustomization: (emailCustomization != null
            ? emailCustomization.value
            : this.emailCustomization),
        smsCustomization: (smsCustomization != null
            ? smsCustomization.value
            : this.smsCustomization),
        userIdentifier: (userIdentifier != null
            ? userIdentifier.value
            : this.userIdentifier),
        sendFromEmailAddress: (sendFromEmailAddress != null
            ? sendFromEmailAddress.value
            : this.sendFromEmailAddress),
        alphanumeric:
            (alphanumeric != null ? alphanumeric.value : this.alphanumeric),
        sendFromEmailSenderName: (sendFromEmailSenderName != null
            ? sendFromEmailSenderName.value
            : this.sendFromEmailSenderName),
        replyToEmailAddress: (replyToEmailAddress != null
            ? replyToEmailAddress.value
            : this.replyToEmailAddress));
  }
}

@JsonSerializable(explicitToJson: true)
class InitOtpAuthRequest {
  const InitOtpAuthRequest({
    required this.type,
    required this.timestampMs,
    required this.organizationId,
    required this.parameters,
  });

  factory InitOtpAuthRequest.fromJson(Map<String, dynamic> json) =>
      _$InitOtpAuthRequestFromJson(json);

  static const toJsonFactory = _$InitOtpAuthRequestToJson;
  Map<String, dynamic> toJson() => _$InitOtpAuthRequestToJson(this);

  @JsonKey(
    name: 'type',
    toJson: initOtpAuthRequestTypeToJson,
    fromJson: initOtpAuthRequestTypeFromJson,
  )
  final enums.InitOtpAuthRequestType type;
  @JsonKey(name: 'timestampMs')
  final String timestampMs;
  @JsonKey(name: 'organizationId')
  final String organizationId;
  @JsonKey(name: 'parameters')
  final InitOtpAuthIntentV2 parameters;
  static const fromJsonFactory = _$InitOtpAuthRequestFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is InitOtpAuthRequest &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.timestampMs, timestampMs) ||
                const DeepCollectionEquality()
                    .equals(other.timestampMs, timestampMs)) &&
            (identical(other.organizationId, organizationId) ||
                const DeepCollectionEquality()
                    .equals(other.organizationId, organizationId)) &&
            (identical(other.parameters, parameters) ||
                const DeepCollectionEquality()
                    .equals(other.parameters, parameters)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(timestampMs) ^
      const DeepCollectionEquality().hash(organizationId) ^
      const DeepCollectionEquality().hash(parameters) ^
      runtimeType.hashCode;
}

extension $InitOtpAuthRequestExtension on InitOtpAuthRequest {
  InitOtpAuthRequest copyWith(
      {enums.InitOtpAuthRequestType? type,
      String? timestampMs,
      String? organizationId,
      InitOtpAuthIntentV2? parameters}) {
    return InitOtpAuthRequest(
        type: type ?? this.type,
        timestampMs: timestampMs ?? this.timestampMs,
        organizationId: organizationId ?? this.organizationId,
        parameters: parameters ?? this.parameters);
  }

  InitOtpAuthRequest copyWithWrapped(
      {Wrapped<enums.InitOtpAuthRequestType>? type,
      Wrapped<String>? timestampMs,
      Wrapped<String>? organizationId,
      Wrapped<InitOtpAuthIntentV2>? parameters}) {
    return InitOtpAuthRequest(
        type: (type != null ? type.value : this.type),
        timestampMs:
            (timestampMs != null ? timestampMs.value : this.timestampMs),
        organizationId: (organizationId != null
            ? organizationId.value
            : this.organizationId),
        parameters: (parameters != null ? parameters.value : this.parameters));
  }
}

@JsonSerializable(explicitToJson: true)
class InitOtpAuthResult {
  const InitOtpAuthResult({
    required this.otpId,
  });

  factory InitOtpAuthResult.fromJson(Map<String, dynamic> json) =>
      _$InitOtpAuthResultFromJson(json);

  static const toJsonFactory = _$InitOtpAuthResultToJson;
  Map<String, dynamic> toJson() => _$InitOtpAuthResultToJson(this);

  @JsonKey(name: 'otpId')
  final String otpId;
  static const fromJsonFactory = _$InitOtpAuthResultFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is InitOtpAuthResult &&
            (identical(other.otpId, otpId) ||
                const DeepCollectionEquality().equals(other.otpId, otpId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(otpId) ^ runtimeType.hashCode;
}

extension $InitOtpAuthResultExtension on InitOtpAuthResult {
  InitOtpAuthResult copyWith({String? otpId}) {
    return InitOtpAuthResult(otpId: otpId ?? this.otpId);
  }

  InitOtpAuthResult copyWithWrapped({Wrapped<String>? otpId}) {
    return InitOtpAuthResult(otpId: (otpId != null ? otpId.value : this.otpId));
  }
}

@JsonSerializable(explicitToJson: true)
class InitOtpAuthResultV2 {
  const InitOtpAuthResultV2({
    required this.otpId,
  });

  factory InitOtpAuthResultV2.fromJson(Map<String, dynamic> json) =>
      _$InitOtpAuthResultV2FromJson(json);

  static const toJsonFactory = _$InitOtpAuthResultV2ToJson;
  Map<String, dynamic> toJson() => _$InitOtpAuthResultV2ToJson(this);

  @JsonKey(name: 'otpId')
  final String otpId;
  static const fromJsonFactory = _$InitOtpAuthResultV2FromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is InitOtpAuthResultV2 &&
            (identical(other.otpId, otpId) ||
                const DeepCollectionEquality().equals(other.otpId, otpId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(otpId) ^ runtimeType.hashCode;
}

extension $InitOtpAuthResultV2Extension on InitOtpAuthResultV2 {
  InitOtpAuthResultV2 copyWith({String? otpId}) {
    return InitOtpAuthResultV2(otpId: otpId ?? this.otpId);
  }

  InitOtpAuthResultV2 copyWithWrapped({Wrapped<String>? otpId}) {
    return InitOtpAuthResultV2(
        otpId: (otpId != null ? otpId.value : this.otpId));
  }
}

@JsonSerializable(explicitToJson: true)
class InitOtpIntent {
  const InitOtpIntent({
    required this.otpType,
    required this.contact,
    this.otpLength,
    this.emailCustomization,
    this.smsCustomization,
    this.userIdentifier,
    this.sendFromEmailAddress,
    this.alphanumeric,
    this.sendFromEmailSenderName,
    this.expirationSeconds,
    this.replyToEmailAddress,
  });

  factory InitOtpIntent.fromJson(Map<String, dynamic> json) =>
      _$InitOtpIntentFromJson(json);

  static const toJsonFactory = _$InitOtpIntentToJson;
  Map<String, dynamic> toJson() => _$InitOtpIntentToJson(this);

  @JsonKey(name: 'otpType')
  final String otpType;
  @JsonKey(name: 'contact')
  final String contact;
  @JsonKey(name: 'otpLength')
  final int? otpLength;
  @JsonKey(name: 'emailCustomization')
  final EmailCustomizationParams? emailCustomization;
  @JsonKey(name: 'smsCustomization')
  final SmsCustomizationParams? smsCustomization;
  @JsonKey(name: 'userIdentifier')
  final String? userIdentifier;
  @JsonKey(name: 'sendFromEmailAddress')
  final String? sendFromEmailAddress;
  @JsonKey(name: 'alphanumeric')
  final bool? alphanumeric;
  @JsonKey(name: 'sendFromEmailSenderName')
  final String? sendFromEmailSenderName;
  @JsonKey(name: 'expirationSeconds')
  final String? expirationSeconds;
  @JsonKey(name: 'replyToEmailAddress')
  final String? replyToEmailAddress;
  static const fromJsonFactory = _$InitOtpIntentFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is InitOtpIntent &&
            (identical(other.otpType, otpType) ||
                const DeepCollectionEquality()
                    .equals(other.otpType, otpType)) &&
            (identical(other.contact, contact) ||
                const DeepCollectionEquality()
                    .equals(other.contact, contact)) &&
            (identical(other.otpLength, otpLength) ||
                const DeepCollectionEquality()
                    .equals(other.otpLength, otpLength)) &&
            (identical(other.emailCustomization, emailCustomization) ||
                const DeepCollectionEquality()
                    .equals(other.emailCustomization, emailCustomization)) &&
            (identical(other.smsCustomization, smsCustomization) ||
                const DeepCollectionEquality()
                    .equals(other.smsCustomization, smsCustomization)) &&
            (identical(other.userIdentifier, userIdentifier) ||
                const DeepCollectionEquality()
                    .equals(other.userIdentifier, userIdentifier)) &&
            (identical(other.sendFromEmailAddress, sendFromEmailAddress) ||
                const DeepCollectionEquality().equals(
                    other.sendFromEmailAddress, sendFromEmailAddress)) &&
            (identical(other.alphanumeric, alphanumeric) ||
                const DeepCollectionEquality()
                    .equals(other.alphanumeric, alphanumeric)) &&
            (identical(
                    other.sendFromEmailSenderName, sendFromEmailSenderName) ||
                const DeepCollectionEquality().equals(
                    other.sendFromEmailSenderName, sendFromEmailSenderName)) &&
            (identical(other.expirationSeconds, expirationSeconds) ||
                const DeepCollectionEquality()
                    .equals(other.expirationSeconds, expirationSeconds)) &&
            (identical(other.replyToEmailAddress, replyToEmailAddress) ||
                const DeepCollectionEquality()
                    .equals(other.replyToEmailAddress, replyToEmailAddress)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(otpType) ^
      const DeepCollectionEquality().hash(contact) ^
      const DeepCollectionEquality().hash(otpLength) ^
      const DeepCollectionEquality().hash(emailCustomization) ^
      const DeepCollectionEquality().hash(smsCustomization) ^
      const DeepCollectionEquality().hash(userIdentifier) ^
      const DeepCollectionEquality().hash(sendFromEmailAddress) ^
      const DeepCollectionEquality().hash(alphanumeric) ^
      const DeepCollectionEquality().hash(sendFromEmailSenderName) ^
      const DeepCollectionEquality().hash(expirationSeconds) ^
      const DeepCollectionEquality().hash(replyToEmailAddress) ^
      runtimeType.hashCode;
}

extension $InitOtpIntentExtension on InitOtpIntent {
  InitOtpIntent copyWith(
      {String? otpType,
      String? contact,
      int? otpLength,
      EmailCustomizationParams? emailCustomization,
      SmsCustomizationParams? smsCustomization,
      String? userIdentifier,
      String? sendFromEmailAddress,
      bool? alphanumeric,
      String? sendFromEmailSenderName,
      String? expirationSeconds,
      String? replyToEmailAddress}) {
    return InitOtpIntent(
        otpType: otpType ?? this.otpType,
        contact: contact ?? this.contact,
        otpLength: otpLength ?? this.otpLength,
        emailCustomization: emailCustomization ?? this.emailCustomization,
        smsCustomization: smsCustomization ?? this.smsCustomization,
        userIdentifier: userIdentifier ?? this.userIdentifier,
        sendFromEmailAddress: sendFromEmailAddress ?? this.sendFromEmailAddress,
        alphanumeric: alphanumeric ?? this.alphanumeric,
        sendFromEmailSenderName:
            sendFromEmailSenderName ?? this.sendFromEmailSenderName,
        expirationSeconds: expirationSeconds ?? this.expirationSeconds,
        replyToEmailAddress: replyToEmailAddress ?? this.replyToEmailAddress);
  }

  InitOtpIntent copyWithWrapped(
      {Wrapped<String>? otpType,
      Wrapped<String>? contact,
      Wrapped<int?>? otpLength,
      Wrapped<EmailCustomizationParams?>? emailCustomization,
      Wrapped<SmsCustomizationParams?>? smsCustomization,
      Wrapped<String?>? userIdentifier,
      Wrapped<String?>? sendFromEmailAddress,
      Wrapped<bool?>? alphanumeric,
      Wrapped<String?>? sendFromEmailSenderName,
      Wrapped<String?>? expirationSeconds,
      Wrapped<String?>? replyToEmailAddress}) {
    return InitOtpIntent(
        otpType: (otpType != null ? otpType.value : this.otpType),
        contact: (contact != null ? contact.value : this.contact),
        otpLength: (otpLength != null ? otpLength.value : this.otpLength),
        emailCustomization: (emailCustomization != null
            ? emailCustomization.value
            : this.emailCustomization),
        smsCustomization: (smsCustomization != null
            ? smsCustomization.value
            : this.smsCustomization),
        userIdentifier: (userIdentifier != null
            ? userIdentifier.value
            : this.userIdentifier),
        sendFromEmailAddress: (sendFromEmailAddress != null
            ? sendFromEmailAddress.value
            : this.sendFromEmailAddress),
        alphanumeric:
            (alphanumeric != null ? alphanumeric.value : this.alphanumeric),
        sendFromEmailSenderName: (sendFromEmailSenderName != null
            ? sendFromEmailSenderName.value
            : this.sendFromEmailSenderName),
        expirationSeconds: (expirationSeconds != null
            ? expirationSeconds.value
            : this.expirationSeconds),
        replyToEmailAddress: (replyToEmailAddress != null
            ? replyToEmailAddress.value
            : this.replyToEmailAddress));
  }
}

@JsonSerializable(explicitToJson: true)
class InitOtpRequest {
  const InitOtpRequest({
    required this.type,
    required this.timestampMs,
    required this.organizationId,
    required this.parameters,
  });

  factory InitOtpRequest.fromJson(Map<String, dynamic> json) =>
      _$InitOtpRequestFromJson(json);

  static const toJsonFactory = _$InitOtpRequestToJson;
  Map<String, dynamic> toJson() => _$InitOtpRequestToJson(this);

  @JsonKey(
    name: 'type',
    toJson: initOtpRequestTypeToJson,
    fromJson: initOtpRequestTypeFromJson,
  )
  final enums.InitOtpRequestType type;
  @JsonKey(name: 'timestampMs')
  final String timestampMs;
  @JsonKey(name: 'organizationId')
  final String organizationId;
  @JsonKey(name: 'parameters')
  final InitOtpIntent parameters;
  static const fromJsonFactory = _$InitOtpRequestFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is InitOtpRequest &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.timestampMs, timestampMs) ||
                const DeepCollectionEquality()
                    .equals(other.timestampMs, timestampMs)) &&
            (identical(other.organizationId, organizationId) ||
                const DeepCollectionEquality()
                    .equals(other.organizationId, organizationId)) &&
            (identical(other.parameters, parameters) ||
                const DeepCollectionEquality()
                    .equals(other.parameters, parameters)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(timestampMs) ^
      const DeepCollectionEquality().hash(organizationId) ^
      const DeepCollectionEquality().hash(parameters) ^
      runtimeType.hashCode;
}

extension $InitOtpRequestExtension on InitOtpRequest {
  InitOtpRequest copyWith(
      {enums.InitOtpRequestType? type,
      String? timestampMs,
      String? organizationId,
      InitOtpIntent? parameters}) {
    return InitOtpRequest(
        type: type ?? this.type,
        timestampMs: timestampMs ?? this.timestampMs,
        organizationId: organizationId ?? this.organizationId,
        parameters: parameters ?? this.parameters);
  }

  InitOtpRequest copyWithWrapped(
      {Wrapped<enums.InitOtpRequestType>? type,
      Wrapped<String>? timestampMs,
      Wrapped<String>? organizationId,
      Wrapped<InitOtpIntent>? parameters}) {
    return InitOtpRequest(
        type: (type != null ? type.value : this.type),
        timestampMs:
            (timestampMs != null ? timestampMs.value : this.timestampMs),
        organizationId: (organizationId != null
            ? organizationId.value
            : this.organizationId),
        parameters: (parameters != null ? parameters.value : this.parameters));
  }
}

@JsonSerializable(explicitToJson: true)
class InitOtpResult {
  const InitOtpResult({
    required this.otpId,
  });

  factory InitOtpResult.fromJson(Map<String, dynamic> json) =>
      _$InitOtpResultFromJson(json);

  static const toJsonFactory = _$InitOtpResultToJson;
  Map<String, dynamic> toJson() => _$InitOtpResultToJson(this);

  @JsonKey(name: 'otpId')
  final String otpId;
  static const fromJsonFactory = _$InitOtpResultFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is InitOtpResult &&
            (identical(other.otpId, otpId) ||
                const DeepCollectionEquality().equals(other.otpId, otpId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(otpId) ^ runtimeType.hashCode;
}

extension $InitOtpResultExtension on InitOtpResult {
  InitOtpResult copyWith({String? otpId}) {
    return InitOtpResult(otpId: otpId ?? this.otpId);
  }

  InitOtpResult copyWithWrapped({Wrapped<String>? otpId}) {
    return InitOtpResult(otpId: (otpId != null ? otpId.value : this.otpId));
  }
}

@JsonSerializable(explicitToJson: true)
class InitUserEmailRecoveryIntent {
  const InitUserEmailRecoveryIntent({
    required this.email,
    required this.targetPublicKey,
    this.expirationSeconds,
    this.emailCustomization,
  });

  factory InitUserEmailRecoveryIntent.fromJson(Map<String, dynamic> json) =>
      _$InitUserEmailRecoveryIntentFromJson(json);

  static const toJsonFactory = _$InitUserEmailRecoveryIntentToJson;
  Map<String, dynamic> toJson() => _$InitUserEmailRecoveryIntentToJson(this);

  @JsonKey(name: 'email')
  final String email;
  @JsonKey(name: 'targetPublicKey')
  final String targetPublicKey;
  @JsonKey(name: 'expirationSeconds')
  final String? expirationSeconds;
  @JsonKey(name: 'emailCustomization')
  final EmailCustomizationParams? emailCustomization;
  static const fromJsonFactory = _$InitUserEmailRecoveryIntentFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is InitUserEmailRecoveryIntent &&
            (identical(other.email, email) ||
                const DeepCollectionEquality().equals(other.email, email)) &&
            (identical(other.targetPublicKey, targetPublicKey) ||
                const DeepCollectionEquality()
                    .equals(other.targetPublicKey, targetPublicKey)) &&
            (identical(other.expirationSeconds, expirationSeconds) ||
                const DeepCollectionEquality()
                    .equals(other.expirationSeconds, expirationSeconds)) &&
            (identical(other.emailCustomization, emailCustomization) ||
                const DeepCollectionEquality()
                    .equals(other.emailCustomization, emailCustomization)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(email) ^
      const DeepCollectionEquality().hash(targetPublicKey) ^
      const DeepCollectionEquality().hash(expirationSeconds) ^
      const DeepCollectionEquality().hash(emailCustomization) ^
      runtimeType.hashCode;
}

extension $InitUserEmailRecoveryIntentExtension on InitUserEmailRecoveryIntent {
  InitUserEmailRecoveryIntent copyWith(
      {String? email,
      String? targetPublicKey,
      String? expirationSeconds,
      EmailCustomizationParams? emailCustomization}) {
    return InitUserEmailRecoveryIntent(
        email: email ?? this.email,
        targetPublicKey: targetPublicKey ?? this.targetPublicKey,
        expirationSeconds: expirationSeconds ?? this.expirationSeconds,
        emailCustomization: emailCustomization ?? this.emailCustomization);
  }

  InitUserEmailRecoveryIntent copyWithWrapped(
      {Wrapped<String>? email,
      Wrapped<String>? targetPublicKey,
      Wrapped<String?>? expirationSeconds,
      Wrapped<EmailCustomizationParams?>? emailCustomization}) {
    return InitUserEmailRecoveryIntent(
        email: (email != null ? email.value : this.email),
        targetPublicKey: (targetPublicKey != null
            ? targetPublicKey.value
            : this.targetPublicKey),
        expirationSeconds: (expirationSeconds != null
            ? expirationSeconds.value
            : this.expirationSeconds),
        emailCustomization: (emailCustomization != null
            ? emailCustomization.value
            : this.emailCustomization));
  }
}

@JsonSerializable(explicitToJson: true)
class InitUserEmailRecoveryRequest {
  const InitUserEmailRecoveryRequest({
    required this.type,
    required this.timestampMs,
    required this.organizationId,
    required this.parameters,
  });

  factory InitUserEmailRecoveryRequest.fromJson(Map<String, dynamic> json) =>
      _$InitUserEmailRecoveryRequestFromJson(json);

  static const toJsonFactory = _$InitUserEmailRecoveryRequestToJson;
  Map<String, dynamic> toJson() => _$InitUserEmailRecoveryRequestToJson(this);

  @JsonKey(
    name: 'type',
    toJson: initUserEmailRecoveryRequestTypeToJson,
    fromJson: initUserEmailRecoveryRequestTypeFromJson,
  )
  final enums.InitUserEmailRecoveryRequestType type;
  @JsonKey(name: 'timestampMs')
  final String timestampMs;
  @JsonKey(name: 'organizationId')
  final String organizationId;
  @JsonKey(name: 'parameters')
  final InitUserEmailRecoveryIntent parameters;
  static const fromJsonFactory = _$InitUserEmailRecoveryRequestFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is InitUserEmailRecoveryRequest &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.timestampMs, timestampMs) ||
                const DeepCollectionEquality()
                    .equals(other.timestampMs, timestampMs)) &&
            (identical(other.organizationId, organizationId) ||
                const DeepCollectionEquality()
                    .equals(other.organizationId, organizationId)) &&
            (identical(other.parameters, parameters) ||
                const DeepCollectionEquality()
                    .equals(other.parameters, parameters)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(timestampMs) ^
      const DeepCollectionEquality().hash(organizationId) ^
      const DeepCollectionEquality().hash(parameters) ^
      runtimeType.hashCode;
}

extension $InitUserEmailRecoveryRequestExtension
    on InitUserEmailRecoveryRequest {
  InitUserEmailRecoveryRequest copyWith(
      {enums.InitUserEmailRecoveryRequestType? type,
      String? timestampMs,
      String? organizationId,
      InitUserEmailRecoveryIntent? parameters}) {
    return InitUserEmailRecoveryRequest(
        type: type ?? this.type,
        timestampMs: timestampMs ?? this.timestampMs,
        organizationId: organizationId ?? this.organizationId,
        parameters: parameters ?? this.parameters);
  }

  InitUserEmailRecoveryRequest copyWithWrapped(
      {Wrapped<enums.InitUserEmailRecoveryRequestType>? type,
      Wrapped<String>? timestampMs,
      Wrapped<String>? organizationId,
      Wrapped<InitUserEmailRecoveryIntent>? parameters}) {
    return InitUserEmailRecoveryRequest(
        type: (type != null ? type.value : this.type),
        timestampMs:
            (timestampMs != null ? timestampMs.value : this.timestampMs),
        organizationId: (organizationId != null
            ? organizationId.value
            : this.organizationId),
        parameters: (parameters != null ? parameters.value : this.parameters));
  }
}

@JsonSerializable(explicitToJson: true)
class InitUserEmailRecoveryResult {
  const InitUserEmailRecoveryResult({
    required this.userId,
  });

  factory InitUserEmailRecoveryResult.fromJson(Map<String, dynamic> json) =>
      _$InitUserEmailRecoveryResultFromJson(json);

  static const toJsonFactory = _$InitUserEmailRecoveryResultToJson;
  Map<String, dynamic> toJson() => _$InitUserEmailRecoveryResultToJson(this);

  @JsonKey(name: 'userId')
  final String userId;
  static const fromJsonFactory = _$InitUserEmailRecoveryResultFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is InitUserEmailRecoveryResult &&
            (identical(other.userId, userId) ||
                const DeepCollectionEquality().equals(other.userId, userId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(userId) ^ runtimeType.hashCode;
}

extension $InitUserEmailRecoveryResultExtension on InitUserEmailRecoveryResult {
  InitUserEmailRecoveryResult copyWith({String? userId}) {
    return InitUserEmailRecoveryResult(userId: userId ?? this.userId);
  }

  InitUserEmailRecoveryResult copyWithWrapped({Wrapped<String>? userId}) {
    return InitUserEmailRecoveryResult(
        userId: (userId != null ? userId.value : this.userId));
  }
}

@JsonSerializable(explicitToJson: true)
class Intent {
  const Intent({
    this.createOrganizationIntent,
    this.createAuthenticatorsIntent,
    this.createUsersIntent,
    this.createPrivateKeysIntent,
    this.signRawPayloadIntent,
    this.createInvitationsIntent,
    this.acceptInvitationIntent,
    this.createPolicyIntent,
    this.disablePrivateKeyIntent,
    this.deleteUsersIntent,
    this.deleteAuthenticatorsIntent,
    this.deleteInvitationIntent,
    this.deleteOrganizationIntent,
    this.deletePolicyIntent,
    this.createUserTagIntent,
    this.deleteUserTagsIntent,
    this.signTransactionIntent,
    this.createApiKeysIntent,
    this.deleteApiKeysIntent,
    this.approveActivityIntent,
    this.rejectActivityIntent,
    this.createPrivateKeyTagIntent,
    this.deletePrivateKeyTagsIntent,
    this.createPolicyIntentV2,
    this.setPaymentMethodIntent,
    this.activateBillingTierIntent,
    this.deletePaymentMethodIntent,
    this.createPolicyIntentV3,
    this.createApiOnlyUsersIntent,
    this.updateRootQuorumIntent,
    this.updateUserTagIntent,
    this.updatePrivateKeyTagIntent,
    this.createAuthenticatorsIntentV2,
    this.acceptInvitationIntentV2,
    this.createOrganizationIntentV2,
    this.createUsersIntentV2,
    this.createSubOrganizationIntent,
    this.createSubOrganizationIntentV2,
    this.updateAllowedOriginsIntent,
    this.createPrivateKeysIntentV2,
    this.updateUserIntent,
    this.updatePolicyIntent,
    this.setPaymentMethodIntentV2,
    this.createSubOrganizationIntentV3,
    this.createWalletIntent,
    this.createWalletAccountsIntent,
    this.initUserEmailRecoveryIntent,
    this.recoverUserIntent,
    this.setOrganizationFeatureIntent,
    this.removeOrganizationFeatureIntent,
    this.signRawPayloadIntentV2,
    this.signTransactionIntentV2,
    this.exportPrivateKeyIntent,
    this.exportWalletIntent,
    this.createSubOrganizationIntentV4,
    this.emailAuthIntent,
    this.exportWalletAccountIntent,
    this.initImportWalletIntent,
    this.importWalletIntent,
    this.initImportPrivateKeyIntent,
    this.importPrivateKeyIntent,
    this.createPoliciesIntent,
    this.signRawPayloadsIntent,
    this.createReadOnlySessionIntent,
    this.createOauthProvidersIntent,
    this.deleteOauthProvidersIntent,
    this.createSubOrganizationIntentV5,
    this.oauthIntent,
    this.createApiKeysIntentV2,
    this.createReadWriteSessionIntent,
    this.emailAuthIntentV2,
    this.createSubOrganizationIntentV6,
    this.deletePrivateKeysIntent,
    this.deleteWalletsIntent,
    this.createReadWriteSessionIntentV2,
    this.deleteSubOrganizationIntent,
    this.initOtpAuthIntent,
    this.otpAuthIntent,
    this.createSubOrganizationIntentV7,
    this.updateWalletIntent,
    this.updatePolicyIntentV2,
    this.createUsersIntentV3,
    this.initOtpAuthIntentV2,
    this.initOtpIntent,
    this.verifyOtpIntent,
    this.otpLoginIntent,
    this.stampLoginIntent,
    this.oauthLoginIntent,
    this.updateUserNameIntent,
    this.updateUserEmailIntent,
    this.updateUserPhoneNumberIntent,
    this.initFiatOnRampIntent,
    this.createSmartContractInterfaceIntent,
    this.deleteSmartContractInterfaceIntent,
  });

  factory Intent.fromJson(Map<String, dynamic> json) => _$IntentFromJson(json);

  static const toJsonFactory = _$IntentToJson;
  Map<String, dynamic> toJson() => _$IntentToJson(this);

  @JsonKey(name: 'createOrganizationIntent')
  final CreateOrganizationIntent? createOrganizationIntent;
  @JsonKey(name: 'createAuthenticatorsIntent')
  final CreateAuthenticatorsIntent? createAuthenticatorsIntent;
  @JsonKey(name: 'createUsersIntent')
  final CreateUsersIntent? createUsersIntent;
  @JsonKey(name: 'createPrivateKeysIntent')
  final CreatePrivateKeysIntent? createPrivateKeysIntent;
  @JsonKey(name: 'signRawPayloadIntent')
  final SignRawPayloadIntent? signRawPayloadIntent;
  @JsonKey(name: 'createInvitationsIntent')
  final CreateInvitationsIntent? createInvitationsIntent;
  @JsonKey(name: 'acceptInvitationIntent')
  final AcceptInvitationIntent? acceptInvitationIntent;
  @JsonKey(name: 'createPolicyIntent')
  final CreatePolicyIntent? createPolicyIntent;
  @JsonKey(name: 'disablePrivateKeyIntent')
  final DisablePrivateKeyIntent? disablePrivateKeyIntent;
  @JsonKey(name: 'deleteUsersIntent')
  final DeleteUsersIntent? deleteUsersIntent;
  @JsonKey(name: 'deleteAuthenticatorsIntent')
  final DeleteAuthenticatorsIntent? deleteAuthenticatorsIntent;
  @JsonKey(name: 'deleteInvitationIntent')
  final DeleteInvitationIntent? deleteInvitationIntent;
  @JsonKey(name: 'deleteOrganizationIntent')
  final DeleteOrganizationIntent? deleteOrganizationIntent;
  @JsonKey(name: 'deletePolicyIntent')
  final DeletePolicyIntent? deletePolicyIntent;
  @JsonKey(name: 'createUserTagIntent')
  final CreateUserTagIntent? createUserTagIntent;
  @JsonKey(name: 'deleteUserTagsIntent')
  final DeleteUserTagsIntent? deleteUserTagsIntent;
  @JsonKey(name: 'signTransactionIntent')
  final SignTransactionIntent? signTransactionIntent;
  @JsonKey(name: 'createApiKeysIntent')
  final CreateApiKeysIntent? createApiKeysIntent;
  @JsonKey(name: 'deleteApiKeysIntent')
  final DeleteApiKeysIntent? deleteApiKeysIntent;
  @JsonKey(name: 'approveActivityIntent')
  final ApproveActivityIntent? approveActivityIntent;
  @JsonKey(name: 'rejectActivityIntent')
  final RejectActivityIntent? rejectActivityIntent;
  @JsonKey(name: 'createPrivateKeyTagIntent')
  final CreatePrivateKeyTagIntent? createPrivateKeyTagIntent;
  @JsonKey(name: 'deletePrivateKeyTagsIntent')
  final DeletePrivateKeyTagsIntent? deletePrivateKeyTagsIntent;
  @JsonKey(name: 'createPolicyIntentV2')
  final CreatePolicyIntentV2? createPolicyIntentV2;
  @JsonKey(name: 'setPaymentMethodIntent')
  final SetPaymentMethodIntent? setPaymentMethodIntent;
  @JsonKey(name: 'activateBillingTierIntent')
  final ActivateBillingTierIntent? activateBillingTierIntent;
  @JsonKey(name: 'deletePaymentMethodIntent')
  final DeletePaymentMethodIntent? deletePaymentMethodIntent;
  @JsonKey(name: 'createPolicyIntentV3')
  final CreatePolicyIntentV3? createPolicyIntentV3;
  @JsonKey(name: 'createApiOnlyUsersIntent')
  final CreateApiOnlyUsersIntent? createApiOnlyUsersIntent;
  @JsonKey(name: 'updateRootQuorumIntent')
  final UpdateRootQuorumIntent? updateRootQuorumIntent;
  @JsonKey(name: 'updateUserTagIntent')
  final UpdateUserTagIntent? updateUserTagIntent;
  @JsonKey(name: 'updatePrivateKeyTagIntent')
  final UpdatePrivateKeyTagIntent? updatePrivateKeyTagIntent;
  @JsonKey(name: 'createAuthenticatorsIntentV2')
  final CreateAuthenticatorsIntentV2? createAuthenticatorsIntentV2;
  @JsonKey(name: 'acceptInvitationIntentV2')
  final AcceptInvitationIntentV2? acceptInvitationIntentV2;
  @JsonKey(name: 'createOrganizationIntentV2')
  final CreateOrganizationIntentV2? createOrganizationIntentV2;
  @JsonKey(name: 'createUsersIntentV2')
  final CreateUsersIntentV2? createUsersIntentV2;
  @JsonKey(name: 'createSubOrganizationIntent')
  final CreateSubOrganizationIntent? createSubOrganizationIntent;
  @JsonKey(name: 'createSubOrganizationIntentV2')
  final CreateSubOrganizationIntentV2? createSubOrganizationIntentV2;
  @JsonKey(name: 'updateAllowedOriginsIntent')
  final UpdateAllowedOriginsIntent? updateAllowedOriginsIntent;
  @JsonKey(name: 'createPrivateKeysIntentV2')
  final CreatePrivateKeysIntentV2? createPrivateKeysIntentV2;
  @JsonKey(name: 'updateUserIntent')
  final UpdateUserIntent? updateUserIntent;
  @JsonKey(name: 'updatePolicyIntent')
  final UpdatePolicyIntent? updatePolicyIntent;
  @JsonKey(name: 'setPaymentMethodIntentV2')
  final SetPaymentMethodIntentV2? setPaymentMethodIntentV2;
  @JsonKey(name: 'createSubOrganizationIntentV3')
  final CreateSubOrganizationIntentV3? createSubOrganizationIntentV3;
  @JsonKey(name: 'createWalletIntent')
  final CreateWalletIntent? createWalletIntent;
  @JsonKey(name: 'createWalletAccountsIntent')
  final CreateWalletAccountsIntent? createWalletAccountsIntent;
  @JsonKey(name: 'initUserEmailRecoveryIntent')
  final InitUserEmailRecoveryIntent? initUserEmailRecoveryIntent;
  @JsonKey(name: 'recoverUserIntent')
  final RecoverUserIntent? recoverUserIntent;
  @JsonKey(name: 'setOrganizationFeatureIntent')
  final SetOrganizationFeatureIntent? setOrganizationFeatureIntent;
  @JsonKey(name: 'removeOrganizationFeatureIntent')
  final RemoveOrganizationFeatureIntent? removeOrganizationFeatureIntent;
  @JsonKey(name: 'signRawPayloadIntentV2')
  final SignRawPayloadIntentV2? signRawPayloadIntentV2;
  @JsonKey(name: 'signTransactionIntentV2')
  final SignTransactionIntentV2? signTransactionIntentV2;
  @JsonKey(name: 'exportPrivateKeyIntent')
  final ExportPrivateKeyIntent? exportPrivateKeyIntent;
  @JsonKey(name: 'exportWalletIntent')
  final ExportWalletIntent? exportWalletIntent;
  @JsonKey(name: 'createSubOrganizationIntentV4')
  final CreateSubOrganizationIntentV4? createSubOrganizationIntentV4;
  @JsonKey(name: 'emailAuthIntent')
  final EmailAuthIntent? emailAuthIntent;
  @JsonKey(name: 'exportWalletAccountIntent')
  final ExportWalletAccountIntent? exportWalletAccountIntent;
  @JsonKey(name: 'initImportWalletIntent')
  final InitImportWalletIntent? initImportWalletIntent;
  @JsonKey(name: 'importWalletIntent')
  final ImportWalletIntent? importWalletIntent;
  @JsonKey(name: 'initImportPrivateKeyIntent')
  final InitImportPrivateKeyIntent? initImportPrivateKeyIntent;
  @JsonKey(name: 'importPrivateKeyIntent')
  final ImportPrivateKeyIntent? importPrivateKeyIntent;
  @JsonKey(name: 'createPoliciesIntent')
  final CreatePoliciesIntent? createPoliciesIntent;
  @JsonKey(name: 'signRawPayloadsIntent')
  final SignRawPayloadsIntent? signRawPayloadsIntent;
  @JsonKey(name: 'createReadOnlySessionIntent')
  final CreateReadOnlySessionIntent? createReadOnlySessionIntent;
  @JsonKey(name: 'createOauthProvidersIntent')
  final CreateOauthProvidersIntent? createOauthProvidersIntent;
  @JsonKey(name: 'deleteOauthProvidersIntent')
  final DeleteOauthProvidersIntent? deleteOauthProvidersIntent;
  @JsonKey(name: 'createSubOrganizationIntentV5')
  final CreateSubOrganizationIntentV5? createSubOrganizationIntentV5;
  @JsonKey(name: 'oauthIntent')
  final OauthIntent? oauthIntent;
  @JsonKey(name: 'createApiKeysIntentV2')
  final CreateApiKeysIntentV2? createApiKeysIntentV2;
  @JsonKey(name: 'createReadWriteSessionIntent')
  final CreateReadWriteSessionIntent? createReadWriteSessionIntent;
  @JsonKey(name: 'emailAuthIntentV2')
  final EmailAuthIntentV2? emailAuthIntentV2;
  @JsonKey(name: 'createSubOrganizationIntentV6')
  final CreateSubOrganizationIntentV6? createSubOrganizationIntentV6;
  @JsonKey(name: 'deletePrivateKeysIntent')
  final DeletePrivateKeysIntent? deletePrivateKeysIntent;
  @JsonKey(name: 'deleteWalletsIntent')
  final DeleteWalletsIntent? deleteWalletsIntent;
  @JsonKey(name: 'createReadWriteSessionIntentV2')
  final CreateReadWriteSessionIntentV2? createReadWriteSessionIntentV2;
  @JsonKey(name: 'deleteSubOrganizationIntent')
  final DeleteSubOrganizationIntent? deleteSubOrganizationIntent;
  @JsonKey(name: 'initOtpAuthIntent')
  final InitOtpAuthIntent? initOtpAuthIntent;
  @JsonKey(name: 'otpAuthIntent')
  final OtpAuthIntent? otpAuthIntent;
  @JsonKey(name: 'createSubOrganizationIntentV7')
  final CreateSubOrganizationIntentV7? createSubOrganizationIntentV7;
  @JsonKey(name: 'updateWalletIntent')
  final UpdateWalletIntent? updateWalletIntent;
  @JsonKey(name: 'updatePolicyIntentV2')
  final UpdatePolicyIntentV2? updatePolicyIntentV2;
  @JsonKey(name: 'createUsersIntentV3')
  final CreateUsersIntentV3? createUsersIntentV3;
  @JsonKey(name: 'initOtpAuthIntentV2')
  final InitOtpAuthIntentV2? initOtpAuthIntentV2;
  @JsonKey(name: 'initOtpIntent')
  final InitOtpIntent? initOtpIntent;
  @JsonKey(name: 'verifyOtpIntent')
  final VerifyOtpIntent? verifyOtpIntent;
  @JsonKey(name: 'otpLoginIntent')
  final OtpLoginIntent? otpLoginIntent;
  @JsonKey(name: 'stampLoginIntent')
  final StampLoginIntent? stampLoginIntent;
  @JsonKey(name: 'oauthLoginIntent')
  final OauthLoginIntent? oauthLoginIntent;
  @JsonKey(name: 'updateUserNameIntent')
  final UpdateUserNameIntent? updateUserNameIntent;
  @JsonKey(name: 'updateUserEmailIntent')
  final UpdateUserEmailIntent? updateUserEmailIntent;
  @JsonKey(name: 'updateUserPhoneNumberIntent')
  final UpdateUserPhoneNumberIntent? updateUserPhoneNumberIntent;
  @JsonKey(name: 'initFiatOnRampIntent')
  final InitFiatOnRampIntent? initFiatOnRampIntent;
  @JsonKey(name: 'createSmartContractInterfaceIntent')
  final CreateSmartContractInterfaceIntent? createSmartContractInterfaceIntent;
  @JsonKey(name: 'deleteSmartContractInterfaceIntent')
  final DeleteSmartContractInterfaceIntent? deleteSmartContractInterfaceIntent;
  static const fromJsonFactory = _$IntentFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is Intent &&
            (identical(other.createOrganizationIntent, createOrganizationIntent) ||
                const DeepCollectionEquality().equals(
                    other.createOrganizationIntent,
                    createOrganizationIntent)) &&
            (identical(other.createAuthenticatorsIntent, createAuthenticatorsIntent) ||
                const DeepCollectionEquality().equals(
                    other.createAuthenticatorsIntent,
                    createAuthenticatorsIntent)) &&
            (identical(other.createUsersIntent, createUsersIntent) ||
                const DeepCollectionEquality()
                    .equals(other.createUsersIntent, createUsersIntent)) &&
            (identical(other.createPrivateKeysIntent, createPrivateKeysIntent) ||
                const DeepCollectionEquality().equals(
                    other.createPrivateKeysIntent, createPrivateKeysIntent)) &&
            (identical(other.signRawPayloadIntent, signRawPayloadIntent) ||
                const DeepCollectionEquality().equals(
                    other.signRawPayloadIntent, signRawPayloadIntent)) &&
            (identical(other.createInvitationsIntent, createInvitationsIntent) ||
                const DeepCollectionEquality().equals(
                    other.createInvitationsIntent, createInvitationsIntent)) &&
            (identical(other.acceptInvitationIntent, acceptInvitationIntent) ||
                const DeepCollectionEquality().equals(
                    other.acceptInvitationIntent, acceptInvitationIntent)) &&
            (identical(other.createPolicyIntent, createPolicyIntent) ||
                const DeepCollectionEquality()
                    .equals(other.createPolicyIntent, createPolicyIntent)) &&
            (identical(other.disablePrivateKeyIntent, disablePrivateKeyIntent) ||
                const DeepCollectionEquality().equals(
                    other.disablePrivateKeyIntent, disablePrivateKeyIntent)) &&
            (identical(other.deleteUsersIntent, deleteUsersIntent) ||
                const DeepCollectionEquality()
                    .equals(other.deleteUsersIntent, deleteUsersIntent)) &&
            (identical(other.deleteAuthenticatorsIntent, deleteAuthenticatorsIntent) || const DeepCollectionEquality().equals(other.deleteAuthenticatorsIntent, deleteAuthenticatorsIntent)) &&
            (identical(other.deleteInvitationIntent, deleteInvitationIntent) || const DeepCollectionEquality().equals(other.deleteInvitationIntent, deleteInvitationIntent)) &&
            (identical(other.deleteOrganizationIntent, deleteOrganizationIntent) || const DeepCollectionEquality().equals(other.deleteOrganizationIntent, deleteOrganizationIntent)) &&
            (identical(other.deletePolicyIntent, deletePolicyIntent) || const DeepCollectionEquality().equals(other.deletePolicyIntent, deletePolicyIntent)) &&
            (identical(other.createUserTagIntent, createUserTagIntent) || const DeepCollectionEquality().equals(other.createUserTagIntent, createUserTagIntent)) &&
            (identical(other.deleteUserTagsIntent, deleteUserTagsIntent) || const DeepCollectionEquality().equals(other.deleteUserTagsIntent, deleteUserTagsIntent)) &&
            (identical(other.signTransactionIntent, signTransactionIntent) || const DeepCollectionEquality().equals(other.signTransactionIntent, signTransactionIntent)) &&
            (identical(other.createApiKeysIntent, createApiKeysIntent) || const DeepCollectionEquality().equals(other.createApiKeysIntent, createApiKeysIntent)) &&
            (identical(other.deleteApiKeysIntent, deleteApiKeysIntent) || const DeepCollectionEquality().equals(other.deleteApiKeysIntent, deleteApiKeysIntent)) &&
            (identical(other.approveActivityIntent, approveActivityIntent) || const DeepCollectionEquality().equals(other.approveActivityIntent, approveActivityIntent)) &&
            (identical(other.rejectActivityIntent, rejectActivityIntent) || const DeepCollectionEquality().equals(other.rejectActivityIntent, rejectActivityIntent)) &&
            (identical(other.createPrivateKeyTagIntent, createPrivateKeyTagIntent) || const DeepCollectionEquality().equals(other.createPrivateKeyTagIntent, createPrivateKeyTagIntent)) &&
            (identical(other.deletePrivateKeyTagsIntent, deletePrivateKeyTagsIntent) || const DeepCollectionEquality().equals(other.deletePrivateKeyTagsIntent, deletePrivateKeyTagsIntent)) &&
            (identical(other.createPolicyIntentV2, createPolicyIntentV2) || const DeepCollectionEquality().equals(other.createPolicyIntentV2, createPolicyIntentV2)) &&
            (identical(other.setPaymentMethodIntent, setPaymentMethodIntent) || const DeepCollectionEquality().equals(other.setPaymentMethodIntent, setPaymentMethodIntent)) &&
            (identical(other.activateBillingTierIntent, activateBillingTierIntent) || const DeepCollectionEquality().equals(other.activateBillingTierIntent, activateBillingTierIntent)) &&
            (identical(other.deletePaymentMethodIntent, deletePaymentMethodIntent) || const DeepCollectionEquality().equals(other.deletePaymentMethodIntent, deletePaymentMethodIntent)) &&
            (identical(other.createPolicyIntentV3, createPolicyIntentV3) || const DeepCollectionEquality().equals(other.createPolicyIntentV3, createPolicyIntentV3)) &&
            (identical(other.createApiOnlyUsersIntent, createApiOnlyUsersIntent) || const DeepCollectionEquality().equals(other.createApiOnlyUsersIntent, createApiOnlyUsersIntent)) &&
            (identical(other.updateRootQuorumIntent, updateRootQuorumIntent) || const DeepCollectionEquality().equals(other.updateRootQuorumIntent, updateRootQuorumIntent)) &&
            (identical(other.updateUserTagIntent, updateUserTagIntent) || const DeepCollectionEquality().equals(other.updateUserTagIntent, updateUserTagIntent)) &&
            (identical(other.updatePrivateKeyTagIntent, updatePrivateKeyTagIntent) || const DeepCollectionEquality().equals(other.updatePrivateKeyTagIntent, updatePrivateKeyTagIntent)) &&
            (identical(other.createAuthenticatorsIntentV2, createAuthenticatorsIntentV2) || const DeepCollectionEquality().equals(other.createAuthenticatorsIntentV2, createAuthenticatorsIntentV2)) &&
            (identical(other.acceptInvitationIntentV2, acceptInvitationIntentV2) || const DeepCollectionEquality().equals(other.acceptInvitationIntentV2, acceptInvitationIntentV2)) &&
            (identical(other.createOrganizationIntentV2, createOrganizationIntentV2) || const DeepCollectionEquality().equals(other.createOrganizationIntentV2, createOrganizationIntentV2)) &&
            (identical(other.createUsersIntentV2, createUsersIntentV2) || const DeepCollectionEquality().equals(other.createUsersIntentV2, createUsersIntentV2)) &&
            (identical(other.createSubOrganizationIntent, createSubOrganizationIntent) || const DeepCollectionEquality().equals(other.createSubOrganizationIntent, createSubOrganizationIntent)) &&
            (identical(other.createSubOrganizationIntentV2, createSubOrganizationIntentV2) || const DeepCollectionEquality().equals(other.createSubOrganizationIntentV2, createSubOrganizationIntentV2)) &&
            (identical(other.updateAllowedOriginsIntent, updateAllowedOriginsIntent) || const DeepCollectionEquality().equals(other.updateAllowedOriginsIntent, updateAllowedOriginsIntent)) &&
            (identical(other.createPrivateKeysIntentV2, createPrivateKeysIntentV2) || const DeepCollectionEquality().equals(other.createPrivateKeysIntentV2, createPrivateKeysIntentV2)) &&
            (identical(other.updateUserIntent, updateUserIntent) || const DeepCollectionEquality().equals(other.updateUserIntent, updateUserIntent)) &&
            (identical(other.updatePolicyIntent, updatePolicyIntent) || const DeepCollectionEquality().equals(other.updatePolicyIntent, updatePolicyIntent)) &&
            (identical(other.setPaymentMethodIntentV2, setPaymentMethodIntentV2) || const DeepCollectionEquality().equals(other.setPaymentMethodIntentV2, setPaymentMethodIntentV2)) &&
            (identical(other.createSubOrganizationIntentV3, createSubOrganizationIntentV3) || const DeepCollectionEquality().equals(other.createSubOrganizationIntentV3, createSubOrganizationIntentV3)) &&
            (identical(other.createWalletIntent, createWalletIntent) || const DeepCollectionEquality().equals(other.createWalletIntent, createWalletIntent)) &&
            (identical(other.createWalletAccountsIntent, createWalletAccountsIntent) || const DeepCollectionEquality().equals(other.createWalletAccountsIntent, createWalletAccountsIntent)) &&
            (identical(other.initUserEmailRecoveryIntent, initUserEmailRecoveryIntent) || const DeepCollectionEquality().equals(other.initUserEmailRecoveryIntent, initUserEmailRecoveryIntent)) &&
            (identical(other.recoverUserIntent, recoverUserIntent) || const DeepCollectionEquality().equals(other.recoverUserIntent, recoverUserIntent)) &&
            (identical(other.setOrganizationFeatureIntent, setOrganizationFeatureIntent) || const DeepCollectionEquality().equals(other.setOrganizationFeatureIntent, setOrganizationFeatureIntent)) &&
            (identical(other.removeOrganizationFeatureIntent, removeOrganizationFeatureIntent) || const DeepCollectionEquality().equals(other.removeOrganizationFeatureIntent, removeOrganizationFeatureIntent)) &&
            (identical(other.signRawPayloadIntentV2, signRawPayloadIntentV2) || const DeepCollectionEquality().equals(other.signRawPayloadIntentV2, signRawPayloadIntentV2)) &&
            (identical(other.signTransactionIntentV2, signTransactionIntentV2) || const DeepCollectionEquality().equals(other.signTransactionIntentV2, signTransactionIntentV2)) &&
            (identical(other.exportPrivateKeyIntent, exportPrivateKeyIntent) || const DeepCollectionEquality().equals(other.exportPrivateKeyIntent, exportPrivateKeyIntent)) &&
            (identical(other.exportWalletIntent, exportWalletIntent) || const DeepCollectionEquality().equals(other.exportWalletIntent, exportWalletIntent)) &&
            (identical(other.createSubOrganizationIntentV4, createSubOrganizationIntentV4) || const DeepCollectionEquality().equals(other.createSubOrganizationIntentV4, createSubOrganizationIntentV4)) &&
            (identical(other.emailAuthIntent, emailAuthIntent) || const DeepCollectionEquality().equals(other.emailAuthIntent, emailAuthIntent)) &&
            (identical(other.exportWalletAccountIntent, exportWalletAccountIntent) || const DeepCollectionEquality().equals(other.exportWalletAccountIntent, exportWalletAccountIntent)) &&
            (identical(other.initImportWalletIntent, initImportWalletIntent) || const DeepCollectionEquality().equals(other.initImportWalletIntent, initImportWalletIntent)) &&
            (identical(other.importWalletIntent, importWalletIntent) || const DeepCollectionEquality().equals(other.importWalletIntent, importWalletIntent)) &&
            (identical(other.initImportPrivateKeyIntent, initImportPrivateKeyIntent) || const DeepCollectionEquality().equals(other.initImportPrivateKeyIntent, initImportPrivateKeyIntent)) &&
            (identical(other.importPrivateKeyIntent, importPrivateKeyIntent) || const DeepCollectionEquality().equals(other.importPrivateKeyIntent, importPrivateKeyIntent)) &&
            (identical(other.createPoliciesIntent, createPoliciesIntent) || const DeepCollectionEquality().equals(other.createPoliciesIntent, createPoliciesIntent)) &&
            (identical(other.signRawPayloadsIntent, signRawPayloadsIntent) || const DeepCollectionEquality().equals(other.signRawPayloadsIntent, signRawPayloadsIntent)) &&
            (identical(other.createReadOnlySessionIntent, createReadOnlySessionIntent) || const DeepCollectionEquality().equals(other.createReadOnlySessionIntent, createReadOnlySessionIntent)) &&
            (identical(other.createOauthProvidersIntent, createOauthProvidersIntent) || const DeepCollectionEquality().equals(other.createOauthProvidersIntent, createOauthProvidersIntent)) &&
            (identical(other.deleteOauthProvidersIntent, deleteOauthProvidersIntent) || const DeepCollectionEquality().equals(other.deleteOauthProvidersIntent, deleteOauthProvidersIntent)) &&
            (identical(other.createSubOrganizationIntentV5, createSubOrganizationIntentV5) || const DeepCollectionEquality().equals(other.createSubOrganizationIntentV5, createSubOrganizationIntentV5)) &&
            (identical(other.oauthIntent, oauthIntent) || const DeepCollectionEquality().equals(other.oauthIntent, oauthIntent)) &&
            (identical(other.createApiKeysIntentV2, createApiKeysIntentV2) || const DeepCollectionEquality().equals(other.createApiKeysIntentV2, createApiKeysIntentV2)) &&
            (identical(other.createReadWriteSessionIntent, createReadWriteSessionIntent) || const DeepCollectionEquality().equals(other.createReadWriteSessionIntent, createReadWriteSessionIntent)) &&
            (identical(other.emailAuthIntentV2, emailAuthIntentV2) || const DeepCollectionEquality().equals(other.emailAuthIntentV2, emailAuthIntentV2)) &&
            (identical(other.createSubOrganizationIntentV6, createSubOrganizationIntentV6) || const DeepCollectionEquality().equals(other.createSubOrganizationIntentV6, createSubOrganizationIntentV6)) &&
            (identical(other.deletePrivateKeysIntent, deletePrivateKeysIntent) || const DeepCollectionEquality().equals(other.deletePrivateKeysIntent, deletePrivateKeysIntent)) &&
            (identical(other.deleteWalletsIntent, deleteWalletsIntent) || const DeepCollectionEquality().equals(other.deleteWalletsIntent, deleteWalletsIntent)) &&
            (identical(other.createReadWriteSessionIntentV2, createReadWriteSessionIntentV2) || const DeepCollectionEquality().equals(other.createReadWriteSessionIntentV2, createReadWriteSessionIntentV2)) &&
            (identical(other.deleteSubOrganizationIntent, deleteSubOrganizationIntent) || const DeepCollectionEquality().equals(other.deleteSubOrganizationIntent, deleteSubOrganizationIntent)) &&
            (identical(other.initOtpAuthIntent, initOtpAuthIntent) || const DeepCollectionEquality().equals(other.initOtpAuthIntent, initOtpAuthIntent)) &&
            (identical(other.otpAuthIntent, otpAuthIntent) || const DeepCollectionEquality().equals(other.otpAuthIntent, otpAuthIntent)) &&
            (identical(other.createSubOrganizationIntentV7, createSubOrganizationIntentV7) || const DeepCollectionEquality().equals(other.createSubOrganizationIntentV7, createSubOrganizationIntentV7)) &&
            (identical(other.updateWalletIntent, updateWalletIntent) || const DeepCollectionEquality().equals(other.updateWalletIntent, updateWalletIntent)) &&
            (identical(other.updatePolicyIntentV2, updatePolicyIntentV2) || const DeepCollectionEquality().equals(other.updatePolicyIntentV2, updatePolicyIntentV2)) &&
            (identical(other.createUsersIntentV3, createUsersIntentV3) || const DeepCollectionEquality().equals(other.createUsersIntentV3, createUsersIntentV3)) &&
            (identical(other.initOtpAuthIntentV2, initOtpAuthIntentV2) || const DeepCollectionEquality().equals(other.initOtpAuthIntentV2, initOtpAuthIntentV2)) &&
            (identical(other.initOtpIntent, initOtpIntent) || const DeepCollectionEquality().equals(other.initOtpIntent, initOtpIntent)) &&
            (identical(other.verifyOtpIntent, verifyOtpIntent) || const DeepCollectionEquality().equals(other.verifyOtpIntent, verifyOtpIntent)) &&
            (identical(other.otpLoginIntent, otpLoginIntent) || const DeepCollectionEquality().equals(other.otpLoginIntent, otpLoginIntent)) &&
            (identical(other.stampLoginIntent, stampLoginIntent) || const DeepCollectionEquality().equals(other.stampLoginIntent, stampLoginIntent)) &&
            (identical(other.oauthLoginIntent, oauthLoginIntent) || const DeepCollectionEquality().equals(other.oauthLoginIntent, oauthLoginIntent)) &&
            (identical(other.updateUserNameIntent, updateUserNameIntent) || const DeepCollectionEquality().equals(other.updateUserNameIntent, updateUserNameIntent)) &&
            (identical(other.updateUserEmailIntent, updateUserEmailIntent) || const DeepCollectionEquality().equals(other.updateUserEmailIntent, updateUserEmailIntent)) &&
            (identical(other.updateUserPhoneNumberIntent, updateUserPhoneNumberIntent) || const DeepCollectionEquality().equals(other.updateUserPhoneNumberIntent, updateUserPhoneNumberIntent)) &&
            (identical(other.initFiatOnRampIntent, initFiatOnRampIntent) || const DeepCollectionEquality().equals(other.initFiatOnRampIntent, initFiatOnRampIntent)) &&
            (identical(other.createSmartContractInterfaceIntent, createSmartContractInterfaceIntent) || const DeepCollectionEquality().equals(other.createSmartContractInterfaceIntent, createSmartContractInterfaceIntent)) &&
            (identical(other.deleteSmartContractInterfaceIntent, deleteSmartContractInterfaceIntent) || const DeepCollectionEquality().equals(other.deleteSmartContractInterfaceIntent, deleteSmartContractInterfaceIntent)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(createOrganizationIntent) ^
      const DeepCollectionEquality().hash(createAuthenticatorsIntent) ^
      const DeepCollectionEquality().hash(createUsersIntent) ^
      const DeepCollectionEquality().hash(createPrivateKeysIntent) ^
      const DeepCollectionEquality().hash(signRawPayloadIntent) ^
      const DeepCollectionEquality().hash(createInvitationsIntent) ^
      const DeepCollectionEquality().hash(acceptInvitationIntent) ^
      const DeepCollectionEquality().hash(createPolicyIntent) ^
      const DeepCollectionEquality().hash(disablePrivateKeyIntent) ^
      const DeepCollectionEquality().hash(deleteUsersIntent) ^
      const DeepCollectionEquality().hash(deleteAuthenticatorsIntent) ^
      const DeepCollectionEquality().hash(deleteInvitationIntent) ^
      const DeepCollectionEquality().hash(deleteOrganizationIntent) ^
      const DeepCollectionEquality().hash(deletePolicyIntent) ^
      const DeepCollectionEquality().hash(createUserTagIntent) ^
      const DeepCollectionEquality().hash(deleteUserTagsIntent) ^
      const DeepCollectionEquality().hash(signTransactionIntent) ^
      const DeepCollectionEquality().hash(createApiKeysIntent) ^
      const DeepCollectionEquality().hash(deleteApiKeysIntent) ^
      const DeepCollectionEquality().hash(approveActivityIntent) ^
      const DeepCollectionEquality().hash(rejectActivityIntent) ^
      const DeepCollectionEquality().hash(createPrivateKeyTagIntent) ^
      const DeepCollectionEquality().hash(deletePrivateKeyTagsIntent) ^
      const DeepCollectionEquality().hash(createPolicyIntentV2) ^
      const DeepCollectionEquality().hash(setPaymentMethodIntent) ^
      const DeepCollectionEquality().hash(activateBillingTierIntent) ^
      const DeepCollectionEquality().hash(deletePaymentMethodIntent) ^
      const DeepCollectionEquality().hash(createPolicyIntentV3) ^
      const DeepCollectionEquality().hash(createApiOnlyUsersIntent) ^
      const DeepCollectionEquality().hash(updateRootQuorumIntent) ^
      const DeepCollectionEquality().hash(updateUserTagIntent) ^
      const DeepCollectionEquality().hash(updatePrivateKeyTagIntent) ^
      const DeepCollectionEquality().hash(createAuthenticatorsIntentV2) ^
      const DeepCollectionEquality().hash(acceptInvitationIntentV2) ^
      const DeepCollectionEquality().hash(createOrganizationIntentV2) ^
      const DeepCollectionEquality().hash(createUsersIntentV2) ^
      const DeepCollectionEquality().hash(createSubOrganizationIntent) ^
      const DeepCollectionEquality().hash(createSubOrganizationIntentV2) ^
      const DeepCollectionEquality().hash(updateAllowedOriginsIntent) ^
      const DeepCollectionEquality().hash(createPrivateKeysIntentV2) ^
      const DeepCollectionEquality().hash(updateUserIntent) ^
      const DeepCollectionEquality().hash(updatePolicyIntent) ^
      const DeepCollectionEquality().hash(setPaymentMethodIntentV2) ^
      const DeepCollectionEquality().hash(createSubOrganizationIntentV3) ^
      const DeepCollectionEquality().hash(createWalletIntent) ^
      const DeepCollectionEquality().hash(createWalletAccountsIntent) ^
      const DeepCollectionEquality().hash(initUserEmailRecoveryIntent) ^
      const DeepCollectionEquality().hash(recoverUserIntent) ^
      const DeepCollectionEquality().hash(setOrganizationFeatureIntent) ^
      const DeepCollectionEquality().hash(removeOrganizationFeatureIntent) ^
      const DeepCollectionEquality().hash(signRawPayloadIntentV2) ^
      const DeepCollectionEquality().hash(signTransactionIntentV2) ^
      const DeepCollectionEquality().hash(exportPrivateKeyIntent) ^
      const DeepCollectionEquality().hash(exportWalletIntent) ^
      const DeepCollectionEquality().hash(createSubOrganizationIntentV4) ^
      const DeepCollectionEquality().hash(emailAuthIntent) ^
      const DeepCollectionEquality().hash(exportWalletAccountIntent) ^
      const DeepCollectionEquality().hash(initImportWalletIntent) ^
      const DeepCollectionEquality().hash(importWalletIntent) ^
      const DeepCollectionEquality().hash(initImportPrivateKeyIntent) ^
      const DeepCollectionEquality().hash(importPrivateKeyIntent) ^
      const DeepCollectionEquality().hash(createPoliciesIntent) ^
      const DeepCollectionEquality().hash(signRawPayloadsIntent) ^
      const DeepCollectionEquality().hash(createReadOnlySessionIntent) ^
      const DeepCollectionEquality().hash(createOauthProvidersIntent) ^
      const DeepCollectionEquality().hash(deleteOauthProvidersIntent) ^
      const DeepCollectionEquality().hash(createSubOrganizationIntentV5) ^
      const DeepCollectionEquality().hash(oauthIntent) ^
      const DeepCollectionEquality().hash(createApiKeysIntentV2) ^
      const DeepCollectionEquality().hash(createReadWriteSessionIntent) ^
      const DeepCollectionEquality().hash(emailAuthIntentV2) ^
      const DeepCollectionEquality().hash(createSubOrganizationIntentV6) ^
      const DeepCollectionEquality().hash(deletePrivateKeysIntent) ^
      const DeepCollectionEquality().hash(deleteWalletsIntent) ^
      const DeepCollectionEquality().hash(createReadWriteSessionIntentV2) ^
      const DeepCollectionEquality().hash(deleteSubOrganizationIntent) ^
      const DeepCollectionEquality().hash(initOtpAuthIntent) ^
      const DeepCollectionEquality().hash(otpAuthIntent) ^
      const DeepCollectionEquality().hash(createSubOrganizationIntentV7) ^
      const DeepCollectionEquality().hash(updateWalletIntent) ^
      const DeepCollectionEquality().hash(updatePolicyIntentV2) ^
      const DeepCollectionEquality().hash(createUsersIntentV3) ^
      const DeepCollectionEquality().hash(initOtpAuthIntentV2) ^
      const DeepCollectionEquality().hash(initOtpIntent) ^
      const DeepCollectionEquality().hash(verifyOtpIntent) ^
      const DeepCollectionEquality().hash(otpLoginIntent) ^
      const DeepCollectionEquality().hash(stampLoginIntent) ^
      const DeepCollectionEquality().hash(oauthLoginIntent) ^
      const DeepCollectionEquality().hash(updateUserNameIntent) ^
      const DeepCollectionEquality().hash(updateUserEmailIntent) ^
      const DeepCollectionEquality().hash(updateUserPhoneNumberIntent) ^
      const DeepCollectionEquality().hash(initFiatOnRampIntent) ^
      const DeepCollectionEquality().hash(createSmartContractInterfaceIntent) ^
      const DeepCollectionEquality().hash(deleteSmartContractInterfaceIntent) ^
      runtimeType.hashCode;
}

extension $IntentExtension on Intent {
  Intent copyWith(
      {CreateOrganizationIntent? createOrganizationIntent,
      CreateAuthenticatorsIntent? createAuthenticatorsIntent,
      CreateUsersIntent? createUsersIntent,
      CreatePrivateKeysIntent? createPrivateKeysIntent,
      SignRawPayloadIntent? signRawPayloadIntent,
      CreateInvitationsIntent? createInvitationsIntent,
      AcceptInvitationIntent? acceptInvitationIntent,
      CreatePolicyIntent? createPolicyIntent,
      DisablePrivateKeyIntent? disablePrivateKeyIntent,
      DeleteUsersIntent? deleteUsersIntent,
      DeleteAuthenticatorsIntent? deleteAuthenticatorsIntent,
      DeleteInvitationIntent? deleteInvitationIntent,
      DeleteOrganizationIntent? deleteOrganizationIntent,
      DeletePolicyIntent? deletePolicyIntent,
      CreateUserTagIntent? createUserTagIntent,
      DeleteUserTagsIntent? deleteUserTagsIntent,
      SignTransactionIntent? signTransactionIntent,
      CreateApiKeysIntent? createApiKeysIntent,
      DeleteApiKeysIntent? deleteApiKeysIntent,
      ApproveActivityIntent? approveActivityIntent,
      RejectActivityIntent? rejectActivityIntent,
      CreatePrivateKeyTagIntent? createPrivateKeyTagIntent,
      DeletePrivateKeyTagsIntent? deletePrivateKeyTagsIntent,
      CreatePolicyIntentV2? createPolicyIntentV2,
      SetPaymentMethodIntent? setPaymentMethodIntent,
      ActivateBillingTierIntent? activateBillingTierIntent,
      DeletePaymentMethodIntent? deletePaymentMethodIntent,
      CreatePolicyIntentV3? createPolicyIntentV3,
      CreateApiOnlyUsersIntent? createApiOnlyUsersIntent,
      UpdateRootQuorumIntent? updateRootQuorumIntent,
      UpdateUserTagIntent? updateUserTagIntent,
      UpdatePrivateKeyTagIntent? updatePrivateKeyTagIntent,
      CreateAuthenticatorsIntentV2? createAuthenticatorsIntentV2,
      AcceptInvitationIntentV2? acceptInvitationIntentV2,
      CreateOrganizationIntentV2? createOrganizationIntentV2,
      CreateUsersIntentV2? createUsersIntentV2,
      CreateSubOrganizationIntent? createSubOrganizationIntent,
      CreateSubOrganizationIntentV2? createSubOrganizationIntentV2,
      UpdateAllowedOriginsIntent? updateAllowedOriginsIntent,
      CreatePrivateKeysIntentV2? createPrivateKeysIntentV2,
      UpdateUserIntent? updateUserIntent,
      UpdatePolicyIntent? updatePolicyIntent,
      SetPaymentMethodIntentV2? setPaymentMethodIntentV2,
      CreateSubOrganizationIntentV3? createSubOrganizationIntentV3,
      CreateWalletIntent? createWalletIntent,
      CreateWalletAccountsIntent? createWalletAccountsIntent,
      InitUserEmailRecoveryIntent? initUserEmailRecoveryIntent,
      RecoverUserIntent? recoverUserIntent,
      SetOrganizationFeatureIntent? setOrganizationFeatureIntent,
      RemoveOrganizationFeatureIntent? removeOrganizationFeatureIntent,
      SignRawPayloadIntentV2? signRawPayloadIntentV2,
      SignTransactionIntentV2? signTransactionIntentV2,
      ExportPrivateKeyIntent? exportPrivateKeyIntent,
      ExportWalletIntent? exportWalletIntent,
      CreateSubOrganizationIntentV4? createSubOrganizationIntentV4,
      EmailAuthIntent? emailAuthIntent,
      ExportWalletAccountIntent? exportWalletAccountIntent,
      InitImportWalletIntent? initImportWalletIntent,
      ImportWalletIntent? importWalletIntent,
      InitImportPrivateKeyIntent? initImportPrivateKeyIntent,
      ImportPrivateKeyIntent? importPrivateKeyIntent,
      CreatePoliciesIntent? createPoliciesIntent,
      SignRawPayloadsIntent? signRawPayloadsIntent,
      CreateReadOnlySessionIntent? createReadOnlySessionIntent,
      CreateOauthProvidersIntent? createOauthProvidersIntent,
      DeleteOauthProvidersIntent? deleteOauthProvidersIntent,
      CreateSubOrganizationIntentV5? createSubOrganizationIntentV5,
      OauthIntent? oauthIntent,
      CreateApiKeysIntentV2? createApiKeysIntentV2,
      CreateReadWriteSessionIntent? createReadWriteSessionIntent,
      EmailAuthIntentV2? emailAuthIntentV2,
      CreateSubOrganizationIntentV6? createSubOrganizationIntentV6,
      DeletePrivateKeysIntent? deletePrivateKeysIntent,
      DeleteWalletsIntent? deleteWalletsIntent,
      CreateReadWriteSessionIntentV2? createReadWriteSessionIntentV2,
      DeleteSubOrganizationIntent? deleteSubOrganizationIntent,
      InitOtpAuthIntent? initOtpAuthIntent,
      OtpAuthIntent? otpAuthIntent,
      CreateSubOrganizationIntentV7? createSubOrganizationIntentV7,
      UpdateWalletIntent? updateWalletIntent,
      UpdatePolicyIntentV2? updatePolicyIntentV2,
      CreateUsersIntentV3? createUsersIntentV3,
      InitOtpAuthIntentV2? initOtpAuthIntentV2,
      InitOtpIntent? initOtpIntent,
      VerifyOtpIntent? verifyOtpIntent,
      OtpLoginIntent? otpLoginIntent,
      StampLoginIntent? stampLoginIntent,
      OauthLoginIntent? oauthLoginIntent,
      UpdateUserNameIntent? updateUserNameIntent,
      UpdateUserEmailIntent? updateUserEmailIntent,
      UpdateUserPhoneNumberIntent? updateUserPhoneNumberIntent,
      InitFiatOnRampIntent? initFiatOnRampIntent,
      CreateSmartContractInterfaceIntent? createSmartContractInterfaceIntent,
      DeleteSmartContractInterfaceIntent? deleteSmartContractInterfaceIntent}) {
    return Intent(
        createOrganizationIntent:
            createOrganizationIntent ?? this.createOrganizationIntent,
        createAuthenticatorsIntent:
            createAuthenticatorsIntent ?? this.createAuthenticatorsIntent,
        createUsersIntent: createUsersIntent ?? this.createUsersIntent,
        createPrivateKeysIntent:
            createPrivateKeysIntent ?? this.createPrivateKeysIntent,
        signRawPayloadIntent: signRawPayloadIntent ?? this.signRawPayloadIntent,
        createInvitationsIntent:
            createInvitationsIntent ?? this.createInvitationsIntent,
        acceptInvitationIntent:
            acceptInvitationIntent ?? this.acceptInvitationIntent,
        createPolicyIntent: createPolicyIntent ?? this.createPolicyIntent,
        disablePrivateKeyIntent:
            disablePrivateKeyIntent ?? this.disablePrivateKeyIntent,
        deleteUsersIntent: deleteUsersIntent ?? this.deleteUsersIntent,
        deleteAuthenticatorsIntent:
            deleteAuthenticatorsIntent ?? this.deleteAuthenticatorsIntent,
        deleteInvitationIntent:
            deleteInvitationIntent ?? this.deleteInvitationIntent,
        deleteOrganizationIntent:
            deleteOrganizationIntent ?? this.deleteOrganizationIntent,
        deletePolicyIntent: deletePolicyIntent ?? this.deletePolicyIntent,
        createUserTagIntent: createUserTagIntent ?? this.createUserTagIntent,
        deleteUserTagsIntent: deleteUserTagsIntent ?? this.deleteUserTagsIntent,
        signTransactionIntent:
            signTransactionIntent ?? this.signTransactionIntent,
        createApiKeysIntent: createApiKeysIntent ?? this.createApiKeysIntent,
        deleteApiKeysIntent: deleteApiKeysIntent ?? this.deleteApiKeysIntent,
        approveActivityIntent:
            approveActivityIntent ?? this.approveActivityIntent,
        rejectActivityIntent: rejectActivityIntent ?? this.rejectActivityIntent,
        createPrivateKeyTagIntent:
            createPrivateKeyTagIntent ?? this.createPrivateKeyTagIntent,
        deletePrivateKeyTagsIntent:
            deletePrivateKeyTagsIntent ?? this.deletePrivateKeyTagsIntent,
        createPolicyIntentV2: createPolicyIntentV2 ?? this.createPolicyIntentV2,
        setPaymentMethodIntent:
            setPaymentMethodIntent ?? this.setPaymentMethodIntent,
        activateBillingTierIntent:
            activateBillingTierIntent ?? this.activateBillingTierIntent,
        deletePaymentMethodIntent:
            deletePaymentMethodIntent ?? this.deletePaymentMethodIntent,
        createPolicyIntentV3: createPolicyIntentV3 ?? this.createPolicyIntentV3,
        createApiOnlyUsersIntent:
            createApiOnlyUsersIntent ?? this.createApiOnlyUsersIntent,
        updateRootQuorumIntent:
            updateRootQuorumIntent ?? this.updateRootQuorumIntent,
        updateUserTagIntent: updateUserTagIntent ?? this.updateUserTagIntent,
        updatePrivateKeyTagIntent:
            updatePrivateKeyTagIntent ?? this.updatePrivateKeyTagIntent,
        createAuthenticatorsIntentV2:
            createAuthenticatorsIntentV2 ?? this.createAuthenticatorsIntentV2,
        acceptInvitationIntentV2:
            acceptInvitationIntentV2 ?? this.acceptInvitationIntentV2,
        createOrganizationIntentV2:
            createOrganizationIntentV2 ?? this.createOrganizationIntentV2,
        createUsersIntentV2: createUsersIntentV2 ?? this.createUsersIntentV2,
        createSubOrganizationIntent:
            createSubOrganizationIntent ?? this.createSubOrganizationIntent,
        createSubOrganizationIntentV2:
            createSubOrganizationIntentV2 ?? this.createSubOrganizationIntentV2,
        updateAllowedOriginsIntent:
            updateAllowedOriginsIntent ?? this.updateAllowedOriginsIntent,
        createPrivateKeysIntentV2:
            createPrivateKeysIntentV2 ?? this.createPrivateKeysIntentV2,
        updateUserIntent: updateUserIntent ?? this.updateUserIntent,
        updatePolicyIntent: updatePolicyIntent ?? this.updatePolicyIntent,
        setPaymentMethodIntentV2:
            setPaymentMethodIntentV2 ?? this.setPaymentMethodIntentV2,
        createSubOrganizationIntentV3:
            createSubOrganizationIntentV3 ?? this.createSubOrganizationIntentV3,
        createWalletIntent: createWalletIntent ?? this.createWalletIntent,
        createWalletAccountsIntent:
            createWalletAccountsIntent ?? this.createWalletAccountsIntent,
        initUserEmailRecoveryIntent:
            initUserEmailRecoveryIntent ?? this.initUserEmailRecoveryIntent,
        recoverUserIntent: recoverUserIntent ?? this.recoverUserIntent,
        setOrganizationFeatureIntent:
            setOrganizationFeatureIntent ?? this.setOrganizationFeatureIntent,
        removeOrganizationFeatureIntent: removeOrganizationFeatureIntent ??
            this.removeOrganizationFeatureIntent,
        signRawPayloadIntentV2:
            signRawPayloadIntentV2 ?? this.signRawPayloadIntentV2,
        signTransactionIntentV2:
            signTransactionIntentV2 ?? this.signTransactionIntentV2,
        exportPrivateKeyIntent:
            exportPrivateKeyIntent ?? this.exportPrivateKeyIntent,
        exportWalletIntent: exportWalletIntent ?? this.exportWalletIntent,
        createSubOrganizationIntentV4:
            createSubOrganizationIntentV4 ?? this.createSubOrganizationIntentV4,
        emailAuthIntent: emailAuthIntent ?? this.emailAuthIntent,
        exportWalletAccountIntent:
            exportWalletAccountIntent ?? this.exportWalletAccountIntent,
        initImportWalletIntent:
            initImportWalletIntent ?? this.initImportWalletIntent,
        importWalletIntent: importWalletIntent ?? this.importWalletIntent,
        initImportPrivateKeyIntent:
            initImportPrivateKeyIntent ?? this.initImportPrivateKeyIntent,
        importPrivateKeyIntent:
            importPrivateKeyIntent ?? this.importPrivateKeyIntent,
        createPoliciesIntent: createPoliciesIntent ?? this.createPoliciesIntent,
        signRawPayloadsIntent:
            signRawPayloadsIntent ?? this.signRawPayloadsIntent,
        createReadOnlySessionIntent:
            createReadOnlySessionIntent ?? this.createReadOnlySessionIntent,
        createOauthProvidersIntent:
            createOauthProvidersIntent ?? this.createOauthProvidersIntent,
        deleteOauthProvidersIntent:
            deleteOauthProvidersIntent ?? this.deleteOauthProvidersIntent,
        createSubOrganizationIntentV5:
            createSubOrganizationIntentV5 ?? this.createSubOrganizationIntentV5,
        oauthIntent: oauthIntent ?? this.oauthIntent,
        createApiKeysIntentV2:
            createApiKeysIntentV2 ?? this.createApiKeysIntentV2,
        createReadWriteSessionIntent:
            createReadWriteSessionIntent ?? this.createReadWriteSessionIntent,
        emailAuthIntentV2: emailAuthIntentV2 ?? this.emailAuthIntentV2,
        createSubOrganizationIntentV6:
            createSubOrganizationIntentV6 ?? this.createSubOrganizationIntentV6,
        deletePrivateKeysIntent:
            deletePrivateKeysIntent ?? this.deletePrivateKeysIntent,
        deleteWalletsIntent: deleteWalletsIntent ?? this.deleteWalletsIntent,
        createReadWriteSessionIntentV2: createReadWriteSessionIntentV2 ??
            this.createReadWriteSessionIntentV2,
        deleteSubOrganizationIntent:
            deleteSubOrganizationIntent ?? this.deleteSubOrganizationIntent,
        initOtpAuthIntent: initOtpAuthIntent ?? this.initOtpAuthIntent,
        otpAuthIntent: otpAuthIntent ?? this.otpAuthIntent,
        createSubOrganizationIntentV7:
            createSubOrganizationIntentV7 ?? this.createSubOrganizationIntentV7,
        updateWalletIntent: updateWalletIntent ?? this.updateWalletIntent,
        updatePolicyIntentV2: updatePolicyIntentV2 ?? this.updatePolicyIntentV2,
        createUsersIntentV3: createUsersIntentV3 ?? this.createUsersIntentV3,
        initOtpAuthIntentV2: initOtpAuthIntentV2 ?? this.initOtpAuthIntentV2,
        initOtpIntent: initOtpIntent ?? this.initOtpIntent,
        verifyOtpIntent: verifyOtpIntent ?? this.verifyOtpIntent,
        otpLoginIntent: otpLoginIntent ?? this.otpLoginIntent,
        stampLoginIntent: stampLoginIntent ?? this.stampLoginIntent,
        oauthLoginIntent: oauthLoginIntent ?? this.oauthLoginIntent,
        updateUserNameIntent: updateUserNameIntent ?? this.updateUserNameIntent,
        updateUserEmailIntent:
            updateUserEmailIntent ?? this.updateUserEmailIntent,
        updateUserPhoneNumberIntent:
            updateUserPhoneNumberIntent ?? this.updateUserPhoneNumberIntent,
        initFiatOnRampIntent: initFiatOnRampIntent ?? this.initFiatOnRampIntent,
        createSmartContractInterfaceIntent:
            createSmartContractInterfaceIntent ??
                this.createSmartContractInterfaceIntent,
        deleteSmartContractInterfaceIntent:
            deleteSmartContractInterfaceIntent ??
                this.deleteSmartContractInterfaceIntent);
  }

  Intent copyWithWrapped(
      {Wrapped<CreateOrganizationIntent?>? createOrganizationIntent,
      Wrapped<CreateAuthenticatorsIntent?>? createAuthenticatorsIntent,
      Wrapped<CreateUsersIntent?>? createUsersIntent,
      Wrapped<CreatePrivateKeysIntent?>? createPrivateKeysIntent,
      Wrapped<SignRawPayloadIntent?>? signRawPayloadIntent,
      Wrapped<CreateInvitationsIntent?>? createInvitationsIntent,
      Wrapped<AcceptInvitationIntent?>? acceptInvitationIntent,
      Wrapped<CreatePolicyIntent?>? createPolicyIntent,
      Wrapped<DisablePrivateKeyIntent?>? disablePrivateKeyIntent,
      Wrapped<DeleteUsersIntent?>? deleteUsersIntent,
      Wrapped<DeleteAuthenticatorsIntent?>? deleteAuthenticatorsIntent,
      Wrapped<DeleteInvitationIntent?>? deleteInvitationIntent,
      Wrapped<DeleteOrganizationIntent?>? deleteOrganizationIntent,
      Wrapped<DeletePolicyIntent?>? deletePolicyIntent,
      Wrapped<CreateUserTagIntent?>? createUserTagIntent,
      Wrapped<DeleteUserTagsIntent?>? deleteUserTagsIntent,
      Wrapped<SignTransactionIntent?>? signTransactionIntent,
      Wrapped<CreateApiKeysIntent?>? createApiKeysIntent,
      Wrapped<DeleteApiKeysIntent?>? deleteApiKeysIntent,
      Wrapped<ApproveActivityIntent?>? approveActivityIntent,
      Wrapped<RejectActivityIntent?>? rejectActivityIntent,
      Wrapped<CreatePrivateKeyTagIntent?>? createPrivateKeyTagIntent,
      Wrapped<DeletePrivateKeyTagsIntent?>? deletePrivateKeyTagsIntent,
      Wrapped<CreatePolicyIntentV2?>? createPolicyIntentV2,
      Wrapped<SetPaymentMethodIntent?>? setPaymentMethodIntent,
      Wrapped<ActivateBillingTierIntent?>? activateBillingTierIntent,
      Wrapped<DeletePaymentMethodIntent?>? deletePaymentMethodIntent,
      Wrapped<CreatePolicyIntentV3?>? createPolicyIntentV3,
      Wrapped<CreateApiOnlyUsersIntent?>? createApiOnlyUsersIntent,
      Wrapped<UpdateRootQuorumIntent?>? updateRootQuorumIntent,
      Wrapped<UpdateUserTagIntent?>? updateUserTagIntent,
      Wrapped<UpdatePrivateKeyTagIntent?>? updatePrivateKeyTagIntent,
      Wrapped<CreateAuthenticatorsIntentV2?>? createAuthenticatorsIntentV2,
      Wrapped<AcceptInvitationIntentV2?>? acceptInvitationIntentV2,
      Wrapped<CreateOrganizationIntentV2?>? createOrganizationIntentV2,
      Wrapped<CreateUsersIntentV2?>? createUsersIntentV2,
      Wrapped<CreateSubOrganizationIntent?>? createSubOrganizationIntent,
      Wrapped<CreateSubOrganizationIntentV2?>? createSubOrganizationIntentV2,
      Wrapped<UpdateAllowedOriginsIntent?>? updateAllowedOriginsIntent,
      Wrapped<CreatePrivateKeysIntentV2?>? createPrivateKeysIntentV2,
      Wrapped<UpdateUserIntent?>? updateUserIntent,
      Wrapped<UpdatePolicyIntent?>? updatePolicyIntent,
      Wrapped<SetPaymentMethodIntentV2?>? setPaymentMethodIntentV2,
      Wrapped<CreateSubOrganizationIntentV3?>? createSubOrganizationIntentV3,
      Wrapped<CreateWalletIntent?>? createWalletIntent,
      Wrapped<CreateWalletAccountsIntent?>? createWalletAccountsIntent,
      Wrapped<InitUserEmailRecoveryIntent?>? initUserEmailRecoveryIntent,
      Wrapped<RecoverUserIntent?>? recoverUserIntent,
      Wrapped<SetOrganizationFeatureIntent?>? setOrganizationFeatureIntent,
      Wrapped<RemoveOrganizationFeatureIntent?>?
          removeOrganizationFeatureIntent,
      Wrapped<SignRawPayloadIntentV2?>? signRawPayloadIntentV2,
      Wrapped<SignTransactionIntentV2?>? signTransactionIntentV2,
      Wrapped<ExportPrivateKeyIntent?>? exportPrivateKeyIntent,
      Wrapped<ExportWalletIntent?>? exportWalletIntent,
      Wrapped<CreateSubOrganizationIntentV4?>? createSubOrganizationIntentV4,
      Wrapped<EmailAuthIntent?>? emailAuthIntent,
      Wrapped<ExportWalletAccountIntent?>? exportWalletAccountIntent,
      Wrapped<InitImportWalletIntent?>? initImportWalletIntent,
      Wrapped<ImportWalletIntent?>? importWalletIntent,
      Wrapped<InitImportPrivateKeyIntent?>? initImportPrivateKeyIntent,
      Wrapped<ImportPrivateKeyIntent?>? importPrivateKeyIntent,
      Wrapped<CreatePoliciesIntent?>? createPoliciesIntent,
      Wrapped<SignRawPayloadsIntent?>? signRawPayloadsIntent,
      Wrapped<CreateReadOnlySessionIntent?>? createReadOnlySessionIntent,
      Wrapped<CreateOauthProvidersIntent?>? createOauthProvidersIntent,
      Wrapped<DeleteOauthProvidersIntent?>? deleteOauthProvidersIntent,
      Wrapped<CreateSubOrganizationIntentV5?>? createSubOrganizationIntentV5,
      Wrapped<OauthIntent?>? oauthIntent,
      Wrapped<CreateApiKeysIntentV2?>? createApiKeysIntentV2,
      Wrapped<CreateReadWriteSessionIntent?>? createReadWriteSessionIntent,
      Wrapped<EmailAuthIntentV2?>? emailAuthIntentV2,
      Wrapped<CreateSubOrganizationIntentV6?>? createSubOrganizationIntentV6,
      Wrapped<DeletePrivateKeysIntent?>? deletePrivateKeysIntent,
      Wrapped<DeleteWalletsIntent?>? deleteWalletsIntent,
      Wrapped<CreateReadWriteSessionIntentV2?>? createReadWriteSessionIntentV2,
      Wrapped<DeleteSubOrganizationIntent?>? deleteSubOrganizationIntent,
      Wrapped<InitOtpAuthIntent?>? initOtpAuthIntent,
      Wrapped<OtpAuthIntent?>? otpAuthIntent,
      Wrapped<CreateSubOrganizationIntentV7?>? createSubOrganizationIntentV7,
      Wrapped<UpdateWalletIntent?>? updateWalletIntent,
      Wrapped<UpdatePolicyIntentV2?>? updatePolicyIntentV2,
      Wrapped<CreateUsersIntentV3?>? createUsersIntentV3,
      Wrapped<InitOtpAuthIntentV2?>? initOtpAuthIntentV2,
      Wrapped<InitOtpIntent?>? initOtpIntent,
      Wrapped<VerifyOtpIntent?>? verifyOtpIntent,
      Wrapped<OtpLoginIntent?>? otpLoginIntent,
      Wrapped<StampLoginIntent?>? stampLoginIntent,
      Wrapped<OauthLoginIntent?>? oauthLoginIntent,
      Wrapped<UpdateUserNameIntent?>? updateUserNameIntent,
      Wrapped<UpdateUserEmailIntent?>? updateUserEmailIntent,
      Wrapped<UpdateUserPhoneNumberIntent?>? updateUserPhoneNumberIntent,
      Wrapped<InitFiatOnRampIntent?>? initFiatOnRampIntent,
      Wrapped<CreateSmartContractInterfaceIntent?>?
          createSmartContractInterfaceIntent,
      Wrapped<DeleteSmartContractInterfaceIntent?>?
          deleteSmartContractInterfaceIntent}) {
    return Intent(
        createOrganizationIntent: (createOrganizationIntent != null
            ? createOrganizationIntent.value
            : this.createOrganizationIntent),
        createAuthenticatorsIntent: (createAuthenticatorsIntent != null
            ? createAuthenticatorsIntent.value
            : this.createAuthenticatorsIntent),
        createUsersIntent: (createUsersIntent != null
            ? createUsersIntent.value
            : this.createUsersIntent),
        createPrivateKeysIntent: (createPrivateKeysIntent != null
            ? createPrivateKeysIntent.value
            : this.createPrivateKeysIntent),
        signRawPayloadIntent: (signRawPayloadIntent != null
            ? signRawPayloadIntent.value
            : this.signRawPayloadIntent),
        createInvitationsIntent: (createInvitationsIntent != null
            ? createInvitationsIntent.value
            : this.createInvitationsIntent),
        acceptInvitationIntent: (acceptInvitationIntent != null
            ? acceptInvitationIntent.value
            : this.acceptInvitationIntent),
        createPolicyIntent: (createPolicyIntent != null
            ? createPolicyIntent.value
            : this.createPolicyIntent),
        disablePrivateKeyIntent: (disablePrivateKeyIntent != null
            ? disablePrivateKeyIntent.value
            : this.disablePrivateKeyIntent),
        deleteUsersIntent: (deleteUsersIntent != null
            ? deleteUsersIntent.value
            : this.deleteUsersIntent),
        deleteAuthenticatorsIntent: (deleteAuthenticatorsIntent != null
            ? deleteAuthenticatorsIntent.value
            : this.deleteAuthenticatorsIntent),
        deleteInvitationIntent: (deleteInvitationIntent != null
            ? deleteInvitationIntent.value
            : this.deleteInvitationIntent),
        deleteOrganizationIntent: (deleteOrganizationIntent != null
            ? deleteOrganizationIntent.value
            : this.deleteOrganizationIntent),
        deletePolicyIntent: (deletePolicyIntent != null
            ? deletePolicyIntent.value
            : this.deletePolicyIntent),
        createUserTagIntent: (createUserTagIntent != null
            ? createUserTagIntent.value
            : this.createUserTagIntent),
        deleteUserTagsIntent: (deleteUserTagsIntent != null
            ? deleteUserTagsIntent.value
            : this.deleteUserTagsIntent),
        signTransactionIntent: (signTransactionIntent != null
            ? signTransactionIntent.value
            : this.signTransactionIntent),
        createApiKeysIntent: (createApiKeysIntent != null
            ? createApiKeysIntent.value
            : this.createApiKeysIntent),
        deleteApiKeysIntent: (deleteApiKeysIntent != null
            ? deleteApiKeysIntent.value
            : this.deleteApiKeysIntent),
        approveActivityIntent: (approveActivityIntent != null
            ? approveActivityIntent.value
            : this.approveActivityIntent),
        rejectActivityIntent: (rejectActivityIntent != null
            ? rejectActivityIntent.value
            : this.rejectActivityIntent),
        createPrivateKeyTagIntent: (createPrivateKeyTagIntent != null
            ? createPrivateKeyTagIntent.value
            : this.createPrivateKeyTagIntent),
        deletePrivateKeyTagsIntent: (deletePrivateKeyTagsIntent != null
            ? deletePrivateKeyTagsIntent.value
            : this.deletePrivateKeyTagsIntent),
        createPolicyIntentV2: (createPolicyIntentV2 != null
            ? createPolicyIntentV2.value
            : this.createPolicyIntentV2),
        setPaymentMethodIntent: (setPaymentMethodIntent != null
            ? setPaymentMethodIntent.value
            : this.setPaymentMethodIntent),
        activateBillingTierIntent: (activateBillingTierIntent != null
            ? activateBillingTierIntent.value
            : this.activateBillingTierIntent),
        deletePaymentMethodIntent: (deletePaymentMethodIntent != null
            ? deletePaymentMethodIntent.value
            : this.deletePaymentMethodIntent),
        createPolicyIntentV3: (createPolicyIntentV3 != null
            ? createPolicyIntentV3.value
            : this.createPolicyIntentV3),
        createApiOnlyUsersIntent: (createApiOnlyUsersIntent != null
            ? createApiOnlyUsersIntent.value
            : this.createApiOnlyUsersIntent),
        updateRootQuorumIntent: (updateRootQuorumIntent != null
            ? updateRootQuorumIntent.value
            : this.updateRootQuorumIntent),
        updateUserTagIntent: (updateUserTagIntent != null
            ? updateUserTagIntent.value
            : this.updateUserTagIntent),
        updatePrivateKeyTagIntent: (updatePrivateKeyTagIntent != null
            ? updatePrivateKeyTagIntent.value
            : this.updatePrivateKeyTagIntent),
        createAuthenticatorsIntentV2: (createAuthenticatorsIntentV2 != null
            ? createAuthenticatorsIntentV2.value
            : this.createAuthenticatorsIntentV2),
        acceptInvitationIntentV2: (acceptInvitationIntentV2 != null
            ? acceptInvitationIntentV2.value
            : this.acceptInvitationIntentV2),
        createOrganizationIntentV2: (createOrganizationIntentV2 != null
            ? createOrganizationIntentV2.value
            : this.createOrganizationIntentV2),
        createUsersIntentV2: (createUsersIntentV2 != null
            ? createUsersIntentV2.value
            : this.createUsersIntentV2),
        createSubOrganizationIntent: (createSubOrganizationIntent != null
            ? createSubOrganizationIntent.value
            : this.createSubOrganizationIntent),
        createSubOrganizationIntentV2: (createSubOrganizationIntentV2 != null
            ? createSubOrganizationIntentV2.value
            : this.createSubOrganizationIntentV2),
        updateAllowedOriginsIntent: (updateAllowedOriginsIntent != null
            ? updateAllowedOriginsIntent.value
            : this.updateAllowedOriginsIntent),
        createPrivateKeysIntentV2: (createPrivateKeysIntentV2 != null
            ? createPrivateKeysIntentV2.value
            : this.createPrivateKeysIntentV2),
        updateUserIntent: (updateUserIntent != null
            ? updateUserIntent.value
            : this.updateUserIntent),
        updatePolicyIntent: (updatePolicyIntent != null
            ? updatePolicyIntent.value
            : this.updatePolicyIntent),
        setPaymentMethodIntentV2: (setPaymentMethodIntentV2 != null
            ? setPaymentMethodIntentV2.value
            : this.setPaymentMethodIntentV2),
        createSubOrganizationIntentV3: (createSubOrganizationIntentV3 != null
            ? createSubOrganizationIntentV3.value
            : this.createSubOrganizationIntentV3),
        createWalletIntent: (createWalletIntent != null
            ? createWalletIntent.value
            : this.createWalletIntent),
        createWalletAccountsIntent: (createWalletAccountsIntent != null
            ? createWalletAccountsIntent.value
            : this.createWalletAccountsIntent),
        initUserEmailRecoveryIntent: (initUserEmailRecoveryIntent != null
            ? initUserEmailRecoveryIntent.value
            : this.initUserEmailRecoveryIntent),
        recoverUserIntent: (recoverUserIntent != null
            ? recoverUserIntent.value
            : this.recoverUserIntent),
        setOrganizationFeatureIntent: (setOrganizationFeatureIntent != null
            ? setOrganizationFeatureIntent.value
            : this.setOrganizationFeatureIntent),
        removeOrganizationFeatureIntent: (removeOrganizationFeatureIntent != null
            ? removeOrganizationFeatureIntent.value
            : this.removeOrganizationFeatureIntent),
        signRawPayloadIntentV2: (signRawPayloadIntentV2 != null
            ? signRawPayloadIntentV2.value
            : this.signRawPayloadIntentV2),
        signTransactionIntentV2: (signTransactionIntentV2 != null
            ? signTransactionIntentV2.value
            : this.signTransactionIntentV2),
        exportPrivateKeyIntent: (exportPrivateKeyIntent != null
            ? exportPrivateKeyIntent.value
            : this.exportPrivateKeyIntent),
        exportWalletIntent: (exportWalletIntent != null
            ? exportWalletIntent.value
            : this.exportWalletIntent),
        createSubOrganizationIntentV4: (createSubOrganizationIntentV4 != null
            ? createSubOrganizationIntentV4.value
            : this.createSubOrganizationIntentV4),
        emailAuthIntent: (emailAuthIntent != null
            ? emailAuthIntent.value
            : this.emailAuthIntent),
        exportWalletAccountIntent:
            (exportWalletAccountIntent != null ? exportWalletAccountIntent.value : this.exportWalletAccountIntent),
        initImportWalletIntent: (initImportWalletIntent != null ? initImportWalletIntent.value : this.initImportWalletIntent),
        importWalletIntent: (importWalletIntent != null ? importWalletIntent.value : this.importWalletIntent),
        initImportPrivateKeyIntent: (initImportPrivateKeyIntent != null ? initImportPrivateKeyIntent.value : this.initImportPrivateKeyIntent),
        importPrivateKeyIntent: (importPrivateKeyIntent != null ? importPrivateKeyIntent.value : this.importPrivateKeyIntent),
        createPoliciesIntent: (createPoliciesIntent != null ? createPoliciesIntent.value : this.createPoliciesIntent),
        signRawPayloadsIntent: (signRawPayloadsIntent != null ? signRawPayloadsIntent.value : this.signRawPayloadsIntent),
        createReadOnlySessionIntent: (createReadOnlySessionIntent != null ? createReadOnlySessionIntent.value : this.createReadOnlySessionIntent),
        createOauthProvidersIntent: (createOauthProvidersIntent != null ? createOauthProvidersIntent.value : this.createOauthProvidersIntent),
        deleteOauthProvidersIntent: (deleteOauthProvidersIntent != null ? deleteOauthProvidersIntent.value : this.deleteOauthProvidersIntent),
        createSubOrganizationIntentV5: (createSubOrganizationIntentV5 != null ? createSubOrganizationIntentV5.value : this.createSubOrganizationIntentV5),
        oauthIntent: (oauthIntent != null ? oauthIntent.value : this.oauthIntent),
        createApiKeysIntentV2: (createApiKeysIntentV2 != null ? createApiKeysIntentV2.value : this.createApiKeysIntentV2),
        createReadWriteSessionIntent: (createReadWriteSessionIntent != null ? createReadWriteSessionIntent.value : this.createReadWriteSessionIntent),
        emailAuthIntentV2: (emailAuthIntentV2 != null ? emailAuthIntentV2.value : this.emailAuthIntentV2),
        createSubOrganizationIntentV6: (createSubOrganizationIntentV6 != null ? createSubOrganizationIntentV6.value : this.createSubOrganizationIntentV6),
        deletePrivateKeysIntent: (deletePrivateKeysIntent != null ? deletePrivateKeysIntent.value : this.deletePrivateKeysIntent),
        deleteWalletsIntent: (deleteWalletsIntent != null ? deleteWalletsIntent.value : this.deleteWalletsIntent),
        createReadWriteSessionIntentV2: (createReadWriteSessionIntentV2 != null ? createReadWriteSessionIntentV2.value : this.createReadWriteSessionIntentV2),
        deleteSubOrganizationIntent: (deleteSubOrganizationIntent != null ? deleteSubOrganizationIntent.value : this.deleteSubOrganizationIntent),
        initOtpAuthIntent: (initOtpAuthIntent != null ? initOtpAuthIntent.value : this.initOtpAuthIntent),
        otpAuthIntent: (otpAuthIntent != null ? otpAuthIntent.value : this.otpAuthIntent),
        createSubOrganizationIntentV7: (createSubOrganizationIntentV7 != null ? createSubOrganizationIntentV7.value : this.createSubOrganizationIntentV7),
        updateWalletIntent: (updateWalletIntent != null ? updateWalletIntent.value : this.updateWalletIntent),
        updatePolicyIntentV2: (updatePolicyIntentV2 != null ? updatePolicyIntentV2.value : this.updatePolicyIntentV2),
        createUsersIntentV3: (createUsersIntentV3 != null ? createUsersIntentV3.value : this.createUsersIntentV3),
        initOtpAuthIntentV2: (initOtpAuthIntentV2 != null ? initOtpAuthIntentV2.value : this.initOtpAuthIntentV2),
        initOtpIntent: (initOtpIntent != null ? initOtpIntent.value : this.initOtpIntent),
        verifyOtpIntent: (verifyOtpIntent != null ? verifyOtpIntent.value : this.verifyOtpIntent),
        otpLoginIntent: (otpLoginIntent != null ? otpLoginIntent.value : this.otpLoginIntent),
        stampLoginIntent: (stampLoginIntent != null ? stampLoginIntent.value : this.stampLoginIntent),
        oauthLoginIntent: (oauthLoginIntent != null ? oauthLoginIntent.value : this.oauthLoginIntent),
        updateUserNameIntent: (updateUserNameIntent != null ? updateUserNameIntent.value : this.updateUserNameIntent),
        updateUserEmailIntent: (updateUserEmailIntent != null ? updateUserEmailIntent.value : this.updateUserEmailIntent),
        updateUserPhoneNumberIntent: (updateUserPhoneNumberIntent != null ? updateUserPhoneNumberIntent.value : this.updateUserPhoneNumberIntent),
        initFiatOnRampIntent: (initFiatOnRampIntent != null ? initFiatOnRampIntent.value : this.initFiatOnRampIntent),
        createSmartContractInterfaceIntent: (createSmartContractInterfaceIntent != null ? createSmartContractInterfaceIntent.value : this.createSmartContractInterfaceIntent),
        deleteSmartContractInterfaceIntent: (deleteSmartContractInterfaceIntent != null ? deleteSmartContractInterfaceIntent.value : this.deleteSmartContractInterfaceIntent));
  }
}

@JsonSerializable(explicitToJson: true)
class InvitationParams {
  const InvitationParams({
    required this.receiverUserName,
    required this.receiverUserEmail,
    required this.receiverUserTags,
    required this.accessType,
    required this.senderUserId,
  });

  factory InvitationParams.fromJson(Map<String, dynamic> json) =>
      _$InvitationParamsFromJson(json);

  static const toJsonFactory = _$InvitationParamsToJson;
  Map<String, dynamic> toJson() => _$InvitationParamsToJson(this);

  @JsonKey(name: 'receiverUserName')
  final String receiverUserName;
  @JsonKey(name: 'receiverUserEmail')
  final String receiverUserEmail;
  @JsonKey(name: 'receiverUserTags', defaultValue: <String>[])
  final List<String> receiverUserTags;
  @JsonKey(
    name: 'accessType',
    toJson: accessTypeToJson,
    fromJson: accessTypeFromJson,
  )
  final enums.AccessType accessType;
  @JsonKey(name: 'senderUserId')
  final String senderUserId;
  static const fromJsonFactory = _$InvitationParamsFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is InvitationParams &&
            (identical(other.receiverUserName, receiverUserName) ||
                const DeepCollectionEquality()
                    .equals(other.receiverUserName, receiverUserName)) &&
            (identical(other.receiverUserEmail, receiverUserEmail) ||
                const DeepCollectionEquality()
                    .equals(other.receiverUserEmail, receiverUserEmail)) &&
            (identical(other.receiverUserTags, receiverUserTags) ||
                const DeepCollectionEquality()
                    .equals(other.receiverUserTags, receiverUserTags)) &&
            (identical(other.accessType, accessType) ||
                const DeepCollectionEquality()
                    .equals(other.accessType, accessType)) &&
            (identical(other.senderUserId, senderUserId) ||
                const DeepCollectionEquality()
                    .equals(other.senderUserId, senderUserId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(receiverUserName) ^
      const DeepCollectionEquality().hash(receiverUserEmail) ^
      const DeepCollectionEquality().hash(receiverUserTags) ^
      const DeepCollectionEquality().hash(accessType) ^
      const DeepCollectionEquality().hash(senderUserId) ^
      runtimeType.hashCode;
}

extension $InvitationParamsExtension on InvitationParams {
  InvitationParams copyWith(
      {String? receiverUserName,
      String? receiverUserEmail,
      List<String>? receiverUserTags,
      enums.AccessType? accessType,
      String? senderUserId}) {
    return InvitationParams(
        receiverUserName: receiverUserName ?? this.receiverUserName,
        receiverUserEmail: receiverUserEmail ?? this.receiverUserEmail,
        receiverUserTags: receiverUserTags ?? this.receiverUserTags,
        accessType: accessType ?? this.accessType,
        senderUserId: senderUserId ?? this.senderUserId);
  }

  InvitationParams copyWithWrapped(
      {Wrapped<String>? receiverUserName,
      Wrapped<String>? receiverUserEmail,
      Wrapped<List<String>>? receiverUserTags,
      Wrapped<enums.AccessType>? accessType,
      Wrapped<String>? senderUserId}) {
    return InvitationParams(
        receiverUserName: (receiverUserName != null
            ? receiverUserName.value
            : this.receiverUserName),
        receiverUserEmail: (receiverUserEmail != null
            ? receiverUserEmail.value
            : this.receiverUserEmail),
        receiverUserTags: (receiverUserTags != null
            ? receiverUserTags.value
            : this.receiverUserTags),
        accessType: (accessType != null ? accessType.value : this.accessType),
        senderUserId:
            (senderUserId != null ? senderUserId.value : this.senderUserId));
  }
}

@JsonSerializable(explicitToJson: true)
class ListPrivateKeyTagsRequest {
  const ListPrivateKeyTagsRequest({
    required this.organizationId,
  });

  factory ListPrivateKeyTagsRequest.fromJson(Map<String, dynamic> json) =>
      _$ListPrivateKeyTagsRequestFromJson(json);

  static const toJsonFactory = _$ListPrivateKeyTagsRequestToJson;
  Map<String, dynamic> toJson() => _$ListPrivateKeyTagsRequestToJson(this);

  @JsonKey(name: 'organizationId')
  final String organizationId;
  static const fromJsonFactory = _$ListPrivateKeyTagsRequestFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ListPrivateKeyTagsRequest &&
            (identical(other.organizationId, organizationId) ||
                const DeepCollectionEquality()
                    .equals(other.organizationId, organizationId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(organizationId) ^
      runtimeType.hashCode;
}

extension $ListPrivateKeyTagsRequestExtension on ListPrivateKeyTagsRequest {
  ListPrivateKeyTagsRequest copyWith({String? organizationId}) {
    return ListPrivateKeyTagsRequest(
        organizationId: organizationId ?? this.organizationId);
  }

  ListPrivateKeyTagsRequest copyWithWrapped({Wrapped<String>? organizationId}) {
    return ListPrivateKeyTagsRequest(
        organizationId: (organizationId != null
            ? organizationId.value
            : this.organizationId));
  }
}

@JsonSerializable(explicitToJson: true)
class ListPrivateKeyTagsResponse {
  const ListPrivateKeyTagsResponse({
    required this.privateKeyTags,
  });

  factory ListPrivateKeyTagsResponse.fromJson(Map<String, dynamic> json) =>
      _$ListPrivateKeyTagsResponseFromJson(json);

  static const toJsonFactory = _$ListPrivateKeyTagsResponseToJson;
  Map<String, dynamic> toJson() => _$ListPrivateKeyTagsResponseToJson(this);

  @JsonKey(name: 'privateKeyTags', defaultValue: <V1Tag>[])
  final List<V1Tag> privateKeyTags;
  static const fromJsonFactory = _$ListPrivateKeyTagsResponseFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ListPrivateKeyTagsResponse &&
            (identical(other.privateKeyTags, privateKeyTags) ||
                const DeepCollectionEquality()
                    .equals(other.privateKeyTags, privateKeyTags)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(privateKeyTags) ^
      runtimeType.hashCode;
}

extension $ListPrivateKeyTagsResponseExtension on ListPrivateKeyTagsResponse {
  ListPrivateKeyTagsResponse copyWith({List<V1Tag>? privateKeyTags}) {
    return ListPrivateKeyTagsResponse(
        privateKeyTags: privateKeyTags ?? this.privateKeyTags);
  }

  ListPrivateKeyTagsResponse copyWithWrapped(
      {Wrapped<List<V1Tag>>? privateKeyTags}) {
    return ListPrivateKeyTagsResponse(
        privateKeyTags: (privateKeyTags != null
            ? privateKeyTags.value
            : this.privateKeyTags));
  }
}

@JsonSerializable(explicitToJson: true)
class ListUserTagsRequest {
  const ListUserTagsRequest({
    required this.organizationId,
  });

  factory ListUserTagsRequest.fromJson(Map<String, dynamic> json) =>
      _$ListUserTagsRequestFromJson(json);

  static const toJsonFactory = _$ListUserTagsRequestToJson;
  Map<String, dynamic> toJson() => _$ListUserTagsRequestToJson(this);

  @JsonKey(name: 'organizationId')
  final String organizationId;
  static const fromJsonFactory = _$ListUserTagsRequestFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ListUserTagsRequest &&
            (identical(other.organizationId, organizationId) ||
                const DeepCollectionEquality()
                    .equals(other.organizationId, organizationId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(organizationId) ^
      runtimeType.hashCode;
}

extension $ListUserTagsRequestExtension on ListUserTagsRequest {
  ListUserTagsRequest copyWith({String? organizationId}) {
    return ListUserTagsRequest(
        organizationId: organizationId ?? this.organizationId);
  }

  ListUserTagsRequest copyWithWrapped({Wrapped<String>? organizationId}) {
    return ListUserTagsRequest(
        organizationId: (organizationId != null
            ? organizationId.value
            : this.organizationId));
  }
}

@JsonSerializable(explicitToJson: true)
class ListUserTagsResponse {
  const ListUserTagsResponse({
    required this.userTags,
  });

  factory ListUserTagsResponse.fromJson(Map<String, dynamic> json) =>
      _$ListUserTagsResponseFromJson(json);

  static const toJsonFactory = _$ListUserTagsResponseToJson;
  Map<String, dynamic> toJson() => _$ListUserTagsResponseToJson(this);

  @JsonKey(name: 'userTags', defaultValue: <V1Tag>[])
  final List<V1Tag> userTags;
  static const fromJsonFactory = _$ListUserTagsResponseFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ListUserTagsResponse &&
            (identical(other.userTags, userTags) ||
                const DeepCollectionEquality()
                    .equals(other.userTags, userTags)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(userTags) ^ runtimeType.hashCode;
}

extension $ListUserTagsResponseExtension on ListUserTagsResponse {
  ListUserTagsResponse copyWith({List<V1Tag>? userTags}) {
    return ListUserTagsResponse(userTags: userTags ?? this.userTags);
  }

  ListUserTagsResponse copyWithWrapped({Wrapped<List<V1Tag>>? userTags}) {
    return ListUserTagsResponse(
        userTags: (userTags != null ? userTags.value : this.userTags));
  }
}

@JsonSerializable(explicitToJson: true)
class OauthIntent {
  const OauthIntent({
    required this.oidcToken,
    required this.targetPublicKey,
    this.apiKeyName,
    this.expirationSeconds,
    this.invalidateExisting,
  });

  factory OauthIntent.fromJson(Map<String, dynamic> json) =>
      _$OauthIntentFromJson(json);

  static const toJsonFactory = _$OauthIntentToJson;
  Map<String, dynamic> toJson() => _$OauthIntentToJson(this);

  @JsonKey(name: 'oidcToken')
  final String oidcToken;
  @JsonKey(name: 'targetPublicKey')
  final String targetPublicKey;
  @JsonKey(name: 'apiKeyName')
  final String? apiKeyName;
  @JsonKey(name: 'expirationSeconds')
  final String? expirationSeconds;
  @JsonKey(name: 'invalidateExisting')
  final bool? invalidateExisting;
  static const fromJsonFactory = _$OauthIntentFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is OauthIntent &&
            (identical(other.oidcToken, oidcToken) ||
                const DeepCollectionEquality()
                    .equals(other.oidcToken, oidcToken)) &&
            (identical(other.targetPublicKey, targetPublicKey) ||
                const DeepCollectionEquality()
                    .equals(other.targetPublicKey, targetPublicKey)) &&
            (identical(other.apiKeyName, apiKeyName) ||
                const DeepCollectionEquality()
                    .equals(other.apiKeyName, apiKeyName)) &&
            (identical(other.expirationSeconds, expirationSeconds) ||
                const DeepCollectionEquality()
                    .equals(other.expirationSeconds, expirationSeconds)) &&
            (identical(other.invalidateExisting, invalidateExisting) ||
                const DeepCollectionEquality()
                    .equals(other.invalidateExisting, invalidateExisting)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(oidcToken) ^
      const DeepCollectionEquality().hash(targetPublicKey) ^
      const DeepCollectionEquality().hash(apiKeyName) ^
      const DeepCollectionEquality().hash(expirationSeconds) ^
      const DeepCollectionEquality().hash(invalidateExisting) ^
      runtimeType.hashCode;
}

extension $OauthIntentExtension on OauthIntent {
  OauthIntent copyWith(
      {String? oidcToken,
      String? targetPublicKey,
      String? apiKeyName,
      String? expirationSeconds,
      bool? invalidateExisting}) {
    return OauthIntent(
        oidcToken: oidcToken ?? this.oidcToken,
        targetPublicKey: targetPublicKey ?? this.targetPublicKey,
        apiKeyName: apiKeyName ?? this.apiKeyName,
        expirationSeconds: expirationSeconds ?? this.expirationSeconds,
        invalidateExisting: invalidateExisting ?? this.invalidateExisting);
  }

  OauthIntent copyWithWrapped(
      {Wrapped<String>? oidcToken,
      Wrapped<String>? targetPublicKey,
      Wrapped<String?>? apiKeyName,
      Wrapped<String?>? expirationSeconds,
      Wrapped<bool?>? invalidateExisting}) {
    return OauthIntent(
        oidcToken: (oidcToken != null ? oidcToken.value : this.oidcToken),
        targetPublicKey: (targetPublicKey != null
            ? targetPublicKey.value
            : this.targetPublicKey),
        apiKeyName: (apiKeyName != null ? apiKeyName.value : this.apiKeyName),
        expirationSeconds: (expirationSeconds != null
            ? expirationSeconds.value
            : this.expirationSeconds),
        invalidateExisting: (invalidateExisting != null
            ? invalidateExisting.value
            : this.invalidateExisting));
  }
}

@JsonSerializable(explicitToJson: true)
class OauthLoginIntent {
  const OauthLoginIntent({
    required this.oidcToken,
    required this.publicKey,
    this.expirationSeconds,
    this.invalidateExisting,
  });

  factory OauthLoginIntent.fromJson(Map<String, dynamic> json) =>
      _$OauthLoginIntentFromJson(json);

  static const toJsonFactory = _$OauthLoginIntentToJson;
  Map<String, dynamic> toJson() => _$OauthLoginIntentToJson(this);

  @JsonKey(name: 'oidcToken')
  final String oidcToken;
  @JsonKey(name: 'publicKey')
  final String publicKey;
  @JsonKey(name: 'expirationSeconds')
  final String? expirationSeconds;
  @JsonKey(name: 'invalidateExisting')
  final bool? invalidateExisting;
  static const fromJsonFactory = _$OauthLoginIntentFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is OauthLoginIntent &&
            (identical(other.oidcToken, oidcToken) ||
                const DeepCollectionEquality()
                    .equals(other.oidcToken, oidcToken)) &&
            (identical(other.publicKey, publicKey) ||
                const DeepCollectionEquality()
                    .equals(other.publicKey, publicKey)) &&
            (identical(other.expirationSeconds, expirationSeconds) ||
                const DeepCollectionEquality()
                    .equals(other.expirationSeconds, expirationSeconds)) &&
            (identical(other.invalidateExisting, invalidateExisting) ||
                const DeepCollectionEquality()
                    .equals(other.invalidateExisting, invalidateExisting)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(oidcToken) ^
      const DeepCollectionEquality().hash(publicKey) ^
      const DeepCollectionEquality().hash(expirationSeconds) ^
      const DeepCollectionEquality().hash(invalidateExisting) ^
      runtimeType.hashCode;
}

extension $OauthLoginIntentExtension on OauthLoginIntent {
  OauthLoginIntent copyWith(
      {String? oidcToken,
      String? publicKey,
      String? expirationSeconds,
      bool? invalidateExisting}) {
    return OauthLoginIntent(
        oidcToken: oidcToken ?? this.oidcToken,
        publicKey: publicKey ?? this.publicKey,
        expirationSeconds: expirationSeconds ?? this.expirationSeconds,
        invalidateExisting: invalidateExisting ?? this.invalidateExisting);
  }

  OauthLoginIntent copyWithWrapped(
      {Wrapped<String>? oidcToken,
      Wrapped<String>? publicKey,
      Wrapped<String?>? expirationSeconds,
      Wrapped<bool?>? invalidateExisting}) {
    return OauthLoginIntent(
        oidcToken: (oidcToken != null ? oidcToken.value : this.oidcToken),
        publicKey: (publicKey != null ? publicKey.value : this.publicKey),
        expirationSeconds: (expirationSeconds != null
            ? expirationSeconds.value
            : this.expirationSeconds),
        invalidateExisting: (invalidateExisting != null
            ? invalidateExisting.value
            : this.invalidateExisting));
  }
}

@JsonSerializable(explicitToJson: true)
class OauthLoginRequest {
  const OauthLoginRequest({
    required this.type,
    required this.timestampMs,
    required this.organizationId,
    required this.parameters,
  });

  factory OauthLoginRequest.fromJson(Map<String, dynamic> json) =>
      _$OauthLoginRequestFromJson(json);

  static const toJsonFactory = _$OauthLoginRequestToJson;
  Map<String, dynamic> toJson() => _$OauthLoginRequestToJson(this);

  @JsonKey(
    name: 'type',
    toJson: oauthLoginRequestTypeToJson,
    fromJson: oauthLoginRequestTypeFromJson,
  )
  final enums.OauthLoginRequestType type;
  @JsonKey(name: 'timestampMs')
  final String timestampMs;
  @JsonKey(name: 'organizationId')
  final String organizationId;
  @JsonKey(name: 'parameters')
  final OauthLoginIntent parameters;
  static const fromJsonFactory = _$OauthLoginRequestFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is OauthLoginRequest &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.timestampMs, timestampMs) ||
                const DeepCollectionEquality()
                    .equals(other.timestampMs, timestampMs)) &&
            (identical(other.organizationId, organizationId) ||
                const DeepCollectionEquality()
                    .equals(other.organizationId, organizationId)) &&
            (identical(other.parameters, parameters) ||
                const DeepCollectionEquality()
                    .equals(other.parameters, parameters)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(timestampMs) ^
      const DeepCollectionEquality().hash(organizationId) ^
      const DeepCollectionEquality().hash(parameters) ^
      runtimeType.hashCode;
}

extension $OauthLoginRequestExtension on OauthLoginRequest {
  OauthLoginRequest copyWith(
      {enums.OauthLoginRequestType? type,
      String? timestampMs,
      String? organizationId,
      OauthLoginIntent? parameters}) {
    return OauthLoginRequest(
        type: type ?? this.type,
        timestampMs: timestampMs ?? this.timestampMs,
        organizationId: organizationId ?? this.organizationId,
        parameters: parameters ?? this.parameters);
  }

  OauthLoginRequest copyWithWrapped(
      {Wrapped<enums.OauthLoginRequestType>? type,
      Wrapped<String>? timestampMs,
      Wrapped<String>? organizationId,
      Wrapped<OauthLoginIntent>? parameters}) {
    return OauthLoginRequest(
        type: (type != null ? type.value : this.type),
        timestampMs:
            (timestampMs != null ? timestampMs.value : this.timestampMs),
        organizationId: (organizationId != null
            ? organizationId.value
            : this.organizationId),
        parameters: (parameters != null ? parameters.value : this.parameters));
  }
}

@JsonSerializable(explicitToJson: true)
class OauthLoginResult {
  const OauthLoginResult({
    required this.session,
  });

  factory OauthLoginResult.fromJson(Map<String, dynamic> json) =>
      _$OauthLoginResultFromJson(json);

  static const toJsonFactory = _$OauthLoginResultToJson;
  Map<String, dynamic> toJson() => _$OauthLoginResultToJson(this);

  @JsonKey(name: 'session')
  final String session;
  static const fromJsonFactory = _$OauthLoginResultFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is OauthLoginResult &&
            (identical(other.session, session) ||
                const DeepCollectionEquality().equals(other.session, session)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(session) ^ runtimeType.hashCode;
}

extension $OauthLoginResultExtension on OauthLoginResult {
  OauthLoginResult copyWith({String? session}) {
    return OauthLoginResult(session: session ?? this.session);
  }

  OauthLoginResult copyWithWrapped({Wrapped<String>? session}) {
    return OauthLoginResult(
        session: (session != null ? session.value : this.session));
  }
}

@JsonSerializable(explicitToJson: true)
class OauthProvider {
  const OauthProvider({
    required this.providerId,
    required this.providerName,
    required this.issuer,
    required this.audience,
    required this.subject,
    required this.createdAt,
    required this.updatedAt,
  });

  factory OauthProvider.fromJson(Map<String, dynamic> json) =>
      _$OauthProviderFromJson(json);

  static const toJsonFactory = _$OauthProviderToJson;
  Map<String, dynamic> toJson() => _$OauthProviderToJson(this);

  @JsonKey(name: 'providerId')
  final String providerId;
  @JsonKey(name: 'providerName')
  final String providerName;
  @JsonKey(name: 'issuer')
  final String issuer;
  @JsonKey(name: 'audience')
  final String audience;
  @JsonKey(name: 'subject')
  final String subject;
  @JsonKey(name: 'createdAt')
  final ExternalDataV1Timestamp createdAt;
  @JsonKey(name: 'updatedAt')
  final ExternalDataV1Timestamp updatedAt;
  static const fromJsonFactory = _$OauthProviderFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is OauthProvider &&
            (identical(other.providerId, providerId) ||
                const DeepCollectionEquality()
                    .equals(other.providerId, providerId)) &&
            (identical(other.providerName, providerName) ||
                const DeepCollectionEquality()
                    .equals(other.providerName, providerName)) &&
            (identical(other.issuer, issuer) ||
                const DeepCollectionEquality().equals(other.issuer, issuer)) &&
            (identical(other.audience, audience) ||
                const DeepCollectionEquality()
                    .equals(other.audience, audience)) &&
            (identical(other.subject, subject) ||
                const DeepCollectionEquality()
                    .equals(other.subject, subject)) &&
            (identical(other.createdAt, createdAt) ||
                const DeepCollectionEquality()
                    .equals(other.createdAt, createdAt)) &&
            (identical(other.updatedAt, updatedAt) ||
                const DeepCollectionEquality()
                    .equals(other.updatedAt, updatedAt)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(providerId) ^
      const DeepCollectionEquality().hash(providerName) ^
      const DeepCollectionEquality().hash(issuer) ^
      const DeepCollectionEquality().hash(audience) ^
      const DeepCollectionEquality().hash(subject) ^
      const DeepCollectionEquality().hash(createdAt) ^
      const DeepCollectionEquality().hash(updatedAt) ^
      runtimeType.hashCode;
}

extension $OauthProviderExtension on OauthProvider {
  OauthProvider copyWith(
      {String? providerId,
      String? providerName,
      String? issuer,
      String? audience,
      String? subject,
      ExternalDataV1Timestamp? createdAt,
      ExternalDataV1Timestamp? updatedAt}) {
    return OauthProvider(
        providerId: providerId ?? this.providerId,
        providerName: providerName ?? this.providerName,
        issuer: issuer ?? this.issuer,
        audience: audience ?? this.audience,
        subject: subject ?? this.subject,
        createdAt: createdAt ?? this.createdAt,
        updatedAt: updatedAt ?? this.updatedAt);
  }

  OauthProvider copyWithWrapped(
      {Wrapped<String>? providerId,
      Wrapped<String>? providerName,
      Wrapped<String>? issuer,
      Wrapped<String>? audience,
      Wrapped<String>? subject,
      Wrapped<ExternalDataV1Timestamp>? createdAt,
      Wrapped<ExternalDataV1Timestamp>? updatedAt}) {
    return OauthProvider(
        providerId: (providerId != null ? providerId.value : this.providerId),
        providerName:
            (providerName != null ? providerName.value : this.providerName),
        issuer: (issuer != null ? issuer.value : this.issuer),
        audience: (audience != null ? audience.value : this.audience),
        subject: (subject != null ? subject.value : this.subject),
        createdAt: (createdAt != null ? createdAt.value : this.createdAt),
        updatedAt: (updatedAt != null ? updatedAt.value : this.updatedAt));
  }
}

@JsonSerializable(explicitToJson: true)
class OauthProviderParams {
  const OauthProviderParams({
    required this.providerName,
    required this.oidcToken,
  });

  factory OauthProviderParams.fromJson(Map<String, dynamic> json) =>
      _$OauthProviderParamsFromJson(json);

  static const toJsonFactory = _$OauthProviderParamsToJson;
  Map<String, dynamic> toJson() => _$OauthProviderParamsToJson(this);

  @JsonKey(name: 'providerName')
  final String providerName;
  @JsonKey(name: 'oidcToken')
  final String oidcToken;
  static const fromJsonFactory = _$OauthProviderParamsFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is OauthProviderParams &&
            (identical(other.providerName, providerName) ||
                const DeepCollectionEquality()
                    .equals(other.providerName, providerName)) &&
            (identical(other.oidcToken, oidcToken) ||
                const DeepCollectionEquality()
                    .equals(other.oidcToken, oidcToken)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(providerName) ^
      const DeepCollectionEquality().hash(oidcToken) ^
      runtimeType.hashCode;
}

extension $OauthProviderParamsExtension on OauthProviderParams {
  OauthProviderParams copyWith({String? providerName, String? oidcToken}) {
    return OauthProviderParams(
        providerName: providerName ?? this.providerName,
        oidcToken: oidcToken ?? this.oidcToken);
  }

  OauthProviderParams copyWithWrapped(
      {Wrapped<String>? providerName, Wrapped<String>? oidcToken}) {
    return OauthProviderParams(
        providerName:
            (providerName != null ? providerName.value : this.providerName),
        oidcToken: (oidcToken != null ? oidcToken.value : this.oidcToken));
  }
}

@JsonSerializable(explicitToJson: true)
class OauthRequest {
  const OauthRequest({
    required this.type,
    required this.timestampMs,
    required this.organizationId,
    required this.parameters,
  });

  factory OauthRequest.fromJson(Map<String, dynamic> json) =>
      _$OauthRequestFromJson(json);

  static const toJsonFactory = _$OauthRequestToJson;
  Map<String, dynamic> toJson() => _$OauthRequestToJson(this);

  @JsonKey(
    name: 'type',
    toJson: oauthRequestTypeToJson,
    fromJson: oauthRequestTypeFromJson,
  )
  final enums.OauthRequestType type;
  @JsonKey(name: 'timestampMs')
  final String timestampMs;
  @JsonKey(name: 'organizationId')
  final String organizationId;
  @JsonKey(name: 'parameters')
  final OauthIntent parameters;
  static const fromJsonFactory = _$OauthRequestFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is OauthRequest &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.timestampMs, timestampMs) ||
                const DeepCollectionEquality()
                    .equals(other.timestampMs, timestampMs)) &&
            (identical(other.organizationId, organizationId) ||
                const DeepCollectionEquality()
                    .equals(other.organizationId, organizationId)) &&
            (identical(other.parameters, parameters) ||
                const DeepCollectionEquality()
                    .equals(other.parameters, parameters)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(timestampMs) ^
      const DeepCollectionEquality().hash(organizationId) ^
      const DeepCollectionEquality().hash(parameters) ^
      runtimeType.hashCode;
}

extension $OauthRequestExtension on OauthRequest {
  OauthRequest copyWith(
      {enums.OauthRequestType? type,
      String? timestampMs,
      String? organizationId,
      OauthIntent? parameters}) {
    return OauthRequest(
        type: type ?? this.type,
        timestampMs: timestampMs ?? this.timestampMs,
        organizationId: organizationId ?? this.organizationId,
        parameters: parameters ?? this.parameters);
  }

  OauthRequest copyWithWrapped(
      {Wrapped<enums.OauthRequestType>? type,
      Wrapped<String>? timestampMs,
      Wrapped<String>? organizationId,
      Wrapped<OauthIntent>? parameters}) {
    return OauthRequest(
        type: (type != null ? type.value : this.type),
        timestampMs:
            (timestampMs != null ? timestampMs.value : this.timestampMs),
        organizationId: (organizationId != null
            ? organizationId.value
            : this.organizationId),
        parameters: (parameters != null ? parameters.value : this.parameters));
  }
}

@JsonSerializable(explicitToJson: true)
class OauthResult {
  const OauthResult({
    required this.userId,
    required this.apiKeyId,
    required this.credentialBundle,
  });

  factory OauthResult.fromJson(Map<String, dynamic> json) =>
      _$OauthResultFromJson(json);

  static const toJsonFactory = _$OauthResultToJson;
  Map<String, dynamic> toJson() => _$OauthResultToJson(this);

  @JsonKey(name: 'userId')
  final String userId;
  @JsonKey(name: 'apiKeyId')
  final String apiKeyId;
  @JsonKey(name: 'credentialBundle')
  final String credentialBundle;
  static const fromJsonFactory = _$OauthResultFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is OauthResult &&
            (identical(other.userId, userId) ||
                const DeepCollectionEquality().equals(other.userId, userId)) &&
            (identical(other.apiKeyId, apiKeyId) ||
                const DeepCollectionEquality()
                    .equals(other.apiKeyId, apiKeyId)) &&
            (identical(other.credentialBundle, credentialBundle) ||
                const DeepCollectionEquality()
                    .equals(other.credentialBundle, credentialBundle)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(userId) ^
      const DeepCollectionEquality().hash(apiKeyId) ^
      const DeepCollectionEquality().hash(credentialBundle) ^
      runtimeType.hashCode;
}

extension $OauthResultExtension on OauthResult {
  OauthResult copyWith(
      {String? userId, String? apiKeyId, String? credentialBundle}) {
    return OauthResult(
        userId: userId ?? this.userId,
        apiKeyId: apiKeyId ?? this.apiKeyId,
        credentialBundle: credentialBundle ?? this.credentialBundle);
  }

  OauthResult copyWithWrapped(
      {Wrapped<String>? userId,
      Wrapped<String>? apiKeyId,
      Wrapped<String>? credentialBundle}) {
    return OauthResult(
        userId: (userId != null ? userId.value : this.userId),
        apiKeyId: (apiKeyId != null ? apiKeyId.value : this.apiKeyId),
        credentialBundle: (credentialBundle != null
            ? credentialBundle.value
            : this.credentialBundle));
  }
}

@JsonSerializable(explicitToJson: true)
class OtpAuthIntent {
  const OtpAuthIntent({
    required this.otpId,
    required this.otpCode,
    required this.targetPublicKey,
    this.apiKeyName,
    this.expirationSeconds,
    this.invalidateExisting,
  });

  factory OtpAuthIntent.fromJson(Map<String, dynamic> json) =>
      _$OtpAuthIntentFromJson(json);

  static const toJsonFactory = _$OtpAuthIntentToJson;
  Map<String, dynamic> toJson() => _$OtpAuthIntentToJson(this);

  @JsonKey(name: 'otpId')
  final String otpId;
  @JsonKey(name: 'otpCode')
  final String otpCode;
  @JsonKey(name: 'targetPublicKey')
  final String targetPublicKey;
  @JsonKey(name: 'apiKeyName')
  final String? apiKeyName;
  @JsonKey(name: 'expirationSeconds')
  final String? expirationSeconds;
  @JsonKey(name: 'invalidateExisting')
  final bool? invalidateExisting;
  static const fromJsonFactory = _$OtpAuthIntentFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is OtpAuthIntent &&
            (identical(other.otpId, otpId) ||
                const DeepCollectionEquality().equals(other.otpId, otpId)) &&
            (identical(other.otpCode, otpCode) ||
                const DeepCollectionEquality()
                    .equals(other.otpCode, otpCode)) &&
            (identical(other.targetPublicKey, targetPublicKey) ||
                const DeepCollectionEquality()
                    .equals(other.targetPublicKey, targetPublicKey)) &&
            (identical(other.apiKeyName, apiKeyName) ||
                const DeepCollectionEquality()
                    .equals(other.apiKeyName, apiKeyName)) &&
            (identical(other.expirationSeconds, expirationSeconds) ||
                const DeepCollectionEquality()
                    .equals(other.expirationSeconds, expirationSeconds)) &&
            (identical(other.invalidateExisting, invalidateExisting) ||
                const DeepCollectionEquality()
                    .equals(other.invalidateExisting, invalidateExisting)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(otpId) ^
      const DeepCollectionEquality().hash(otpCode) ^
      const DeepCollectionEquality().hash(targetPublicKey) ^
      const DeepCollectionEquality().hash(apiKeyName) ^
      const DeepCollectionEquality().hash(expirationSeconds) ^
      const DeepCollectionEquality().hash(invalidateExisting) ^
      runtimeType.hashCode;
}

extension $OtpAuthIntentExtension on OtpAuthIntent {
  OtpAuthIntent copyWith(
      {String? otpId,
      String? otpCode,
      String? targetPublicKey,
      String? apiKeyName,
      String? expirationSeconds,
      bool? invalidateExisting}) {
    return OtpAuthIntent(
        otpId: otpId ?? this.otpId,
        otpCode: otpCode ?? this.otpCode,
        targetPublicKey: targetPublicKey ?? this.targetPublicKey,
        apiKeyName: apiKeyName ?? this.apiKeyName,
        expirationSeconds: expirationSeconds ?? this.expirationSeconds,
        invalidateExisting: invalidateExisting ?? this.invalidateExisting);
  }

  OtpAuthIntent copyWithWrapped(
      {Wrapped<String>? otpId,
      Wrapped<String>? otpCode,
      Wrapped<String>? targetPublicKey,
      Wrapped<String?>? apiKeyName,
      Wrapped<String?>? expirationSeconds,
      Wrapped<bool?>? invalidateExisting}) {
    return OtpAuthIntent(
        otpId: (otpId != null ? otpId.value : this.otpId),
        otpCode: (otpCode != null ? otpCode.value : this.otpCode),
        targetPublicKey: (targetPublicKey != null
            ? targetPublicKey.value
            : this.targetPublicKey),
        apiKeyName: (apiKeyName != null ? apiKeyName.value : this.apiKeyName),
        expirationSeconds: (expirationSeconds != null
            ? expirationSeconds.value
            : this.expirationSeconds),
        invalidateExisting: (invalidateExisting != null
            ? invalidateExisting.value
            : this.invalidateExisting));
  }
}

@JsonSerializable(explicitToJson: true)
class OtpAuthRequest {
  const OtpAuthRequest({
    required this.type,
    required this.timestampMs,
    required this.organizationId,
    required this.parameters,
  });

  factory OtpAuthRequest.fromJson(Map<String, dynamic> json) =>
      _$OtpAuthRequestFromJson(json);

  static const toJsonFactory = _$OtpAuthRequestToJson;
  Map<String, dynamic> toJson() => _$OtpAuthRequestToJson(this);

  @JsonKey(
    name: 'type',
    toJson: otpAuthRequestTypeToJson,
    fromJson: otpAuthRequestTypeFromJson,
  )
  final enums.OtpAuthRequestType type;
  @JsonKey(name: 'timestampMs')
  final String timestampMs;
  @JsonKey(name: 'organizationId')
  final String organizationId;
  @JsonKey(name: 'parameters')
  final OtpAuthIntent parameters;
  static const fromJsonFactory = _$OtpAuthRequestFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is OtpAuthRequest &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.timestampMs, timestampMs) ||
                const DeepCollectionEquality()
                    .equals(other.timestampMs, timestampMs)) &&
            (identical(other.organizationId, organizationId) ||
                const DeepCollectionEquality()
                    .equals(other.organizationId, organizationId)) &&
            (identical(other.parameters, parameters) ||
                const DeepCollectionEquality()
                    .equals(other.parameters, parameters)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(timestampMs) ^
      const DeepCollectionEquality().hash(organizationId) ^
      const DeepCollectionEquality().hash(parameters) ^
      runtimeType.hashCode;
}

extension $OtpAuthRequestExtension on OtpAuthRequest {
  OtpAuthRequest copyWith(
      {enums.OtpAuthRequestType? type,
      String? timestampMs,
      String? organizationId,
      OtpAuthIntent? parameters}) {
    return OtpAuthRequest(
        type: type ?? this.type,
        timestampMs: timestampMs ?? this.timestampMs,
        organizationId: organizationId ?? this.organizationId,
        parameters: parameters ?? this.parameters);
  }

  OtpAuthRequest copyWithWrapped(
      {Wrapped<enums.OtpAuthRequestType>? type,
      Wrapped<String>? timestampMs,
      Wrapped<String>? organizationId,
      Wrapped<OtpAuthIntent>? parameters}) {
    return OtpAuthRequest(
        type: (type != null ? type.value : this.type),
        timestampMs:
            (timestampMs != null ? timestampMs.value : this.timestampMs),
        organizationId: (organizationId != null
            ? organizationId.value
            : this.organizationId),
        parameters: (parameters != null ? parameters.value : this.parameters));
  }
}

@JsonSerializable(explicitToJson: true)
class OtpAuthResult {
  const OtpAuthResult({
    required this.userId,
    this.apiKeyId,
    this.credentialBundle,
  });

  factory OtpAuthResult.fromJson(Map<String, dynamic> json) =>
      _$OtpAuthResultFromJson(json);

  static const toJsonFactory = _$OtpAuthResultToJson;
  Map<String, dynamic> toJson() => _$OtpAuthResultToJson(this);

  @JsonKey(name: 'userId')
  final String userId;
  @JsonKey(name: 'apiKeyId')
  final String? apiKeyId;
  @JsonKey(name: 'credentialBundle')
  final String? credentialBundle;
  static const fromJsonFactory = _$OtpAuthResultFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is OtpAuthResult &&
            (identical(other.userId, userId) ||
                const DeepCollectionEquality().equals(other.userId, userId)) &&
            (identical(other.apiKeyId, apiKeyId) ||
                const DeepCollectionEquality()
                    .equals(other.apiKeyId, apiKeyId)) &&
            (identical(other.credentialBundle, credentialBundle) ||
                const DeepCollectionEquality()
                    .equals(other.credentialBundle, credentialBundle)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(userId) ^
      const DeepCollectionEquality().hash(apiKeyId) ^
      const DeepCollectionEquality().hash(credentialBundle) ^
      runtimeType.hashCode;
}

extension $OtpAuthResultExtension on OtpAuthResult {
  OtpAuthResult copyWith(
      {String? userId, String? apiKeyId, String? credentialBundle}) {
    return OtpAuthResult(
        userId: userId ?? this.userId,
        apiKeyId: apiKeyId ?? this.apiKeyId,
        credentialBundle: credentialBundle ?? this.credentialBundle);
  }

  OtpAuthResult copyWithWrapped(
      {Wrapped<String>? userId,
      Wrapped<String?>? apiKeyId,
      Wrapped<String?>? credentialBundle}) {
    return OtpAuthResult(
        userId: (userId != null ? userId.value : this.userId),
        apiKeyId: (apiKeyId != null ? apiKeyId.value : this.apiKeyId),
        credentialBundle: (credentialBundle != null
            ? credentialBundle.value
            : this.credentialBundle));
  }
}

@JsonSerializable(explicitToJson: true)
class OtpLoginIntent {
  const OtpLoginIntent({
    required this.verificationToken,
    required this.publicKey,
    this.expirationSeconds,
    this.invalidateExisting,
  });

  factory OtpLoginIntent.fromJson(Map<String, dynamic> json) =>
      _$OtpLoginIntentFromJson(json);

  static const toJsonFactory = _$OtpLoginIntentToJson;
  Map<String, dynamic> toJson() => _$OtpLoginIntentToJson(this);

  @JsonKey(name: 'verificationToken')
  final String verificationToken;
  @JsonKey(name: 'publicKey')
  final String publicKey;
  @JsonKey(name: 'expirationSeconds')
  final String? expirationSeconds;
  @JsonKey(name: 'invalidateExisting')
  final bool? invalidateExisting;
  static const fromJsonFactory = _$OtpLoginIntentFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is OtpLoginIntent &&
            (identical(other.verificationToken, verificationToken) ||
                const DeepCollectionEquality()
                    .equals(other.verificationToken, verificationToken)) &&
            (identical(other.publicKey, publicKey) ||
                const DeepCollectionEquality()
                    .equals(other.publicKey, publicKey)) &&
            (identical(other.expirationSeconds, expirationSeconds) ||
                const DeepCollectionEquality()
                    .equals(other.expirationSeconds, expirationSeconds)) &&
            (identical(other.invalidateExisting, invalidateExisting) ||
                const DeepCollectionEquality()
                    .equals(other.invalidateExisting, invalidateExisting)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(verificationToken) ^
      const DeepCollectionEquality().hash(publicKey) ^
      const DeepCollectionEquality().hash(expirationSeconds) ^
      const DeepCollectionEquality().hash(invalidateExisting) ^
      runtimeType.hashCode;
}

extension $OtpLoginIntentExtension on OtpLoginIntent {
  OtpLoginIntent copyWith(
      {String? verificationToken,
      String? publicKey,
      String? expirationSeconds,
      bool? invalidateExisting}) {
    return OtpLoginIntent(
        verificationToken: verificationToken ?? this.verificationToken,
        publicKey: publicKey ?? this.publicKey,
        expirationSeconds: expirationSeconds ?? this.expirationSeconds,
        invalidateExisting: invalidateExisting ?? this.invalidateExisting);
  }

  OtpLoginIntent copyWithWrapped(
      {Wrapped<String>? verificationToken,
      Wrapped<String>? publicKey,
      Wrapped<String?>? expirationSeconds,
      Wrapped<bool?>? invalidateExisting}) {
    return OtpLoginIntent(
        verificationToken: (verificationToken != null
            ? verificationToken.value
            : this.verificationToken),
        publicKey: (publicKey != null ? publicKey.value : this.publicKey),
        expirationSeconds: (expirationSeconds != null
            ? expirationSeconds.value
            : this.expirationSeconds),
        invalidateExisting: (invalidateExisting != null
            ? invalidateExisting.value
            : this.invalidateExisting));
  }
}

@JsonSerializable(explicitToJson: true)
class OtpLoginRequest {
  const OtpLoginRequest({
    required this.type,
    required this.timestampMs,
    required this.organizationId,
    required this.parameters,
  });

  factory OtpLoginRequest.fromJson(Map<String, dynamic> json) =>
      _$OtpLoginRequestFromJson(json);

  static const toJsonFactory = _$OtpLoginRequestToJson;
  Map<String, dynamic> toJson() => _$OtpLoginRequestToJson(this);

  @JsonKey(
    name: 'type',
    toJson: otpLoginRequestTypeToJson,
    fromJson: otpLoginRequestTypeFromJson,
  )
  final enums.OtpLoginRequestType type;
  @JsonKey(name: 'timestampMs')
  final String timestampMs;
  @JsonKey(name: 'organizationId')
  final String organizationId;
  @JsonKey(name: 'parameters')
  final OtpLoginIntent parameters;
  static const fromJsonFactory = _$OtpLoginRequestFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is OtpLoginRequest &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.timestampMs, timestampMs) ||
                const DeepCollectionEquality()
                    .equals(other.timestampMs, timestampMs)) &&
            (identical(other.organizationId, organizationId) ||
                const DeepCollectionEquality()
                    .equals(other.organizationId, organizationId)) &&
            (identical(other.parameters, parameters) ||
                const DeepCollectionEquality()
                    .equals(other.parameters, parameters)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(timestampMs) ^
      const DeepCollectionEquality().hash(organizationId) ^
      const DeepCollectionEquality().hash(parameters) ^
      runtimeType.hashCode;
}

extension $OtpLoginRequestExtension on OtpLoginRequest {
  OtpLoginRequest copyWith(
      {enums.OtpLoginRequestType? type,
      String? timestampMs,
      String? organizationId,
      OtpLoginIntent? parameters}) {
    return OtpLoginRequest(
        type: type ?? this.type,
        timestampMs: timestampMs ?? this.timestampMs,
        organizationId: organizationId ?? this.organizationId,
        parameters: parameters ?? this.parameters);
  }

  OtpLoginRequest copyWithWrapped(
      {Wrapped<enums.OtpLoginRequestType>? type,
      Wrapped<String>? timestampMs,
      Wrapped<String>? organizationId,
      Wrapped<OtpLoginIntent>? parameters}) {
    return OtpLoginRequest(
        type: (type != null ? type.value : this.type),
        timestampMs:
            (timestampMs != null ? timestampMs.value : this.timestampMs),
        organizationId: (organizationId != null
            ? organizationId.value
            : this.organizationId),
        parameters: (parameters != null ? parameters.value : this.parameters));
  }
}

@JsonSerializable(explicitToJson: true)
class OtpLoginResult {
  const OtpLoginResult({
    required this.session,
  });

  factory OtpLoginResult.fromJson(Map<String, dynamic> json) =>
      _$OtpLoginResultFromJson(json);

  static const toJsonFactory = _$OtpLoginResultToJson;
  Map<String, dynamic> toJson() => _$OtpLoginResultToJson(this);

  @JsonKey(name: 'session')
  final String session;
  static const fromJsonFactory = _$OtpLoginResultFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is OtpLoginResult &&
            (identical(other.session, session) ||
                const DeepCollectionEquality().equals(other.session, session)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(session) ^ runtimeType.hashCode;
}

extension $OtpLoginResultExtension on OtpLoginResult {
  OtpLoginResult copyWith({String? session}) {
    return OtpLoginResult(session: session ?? this.session);
  }

  OtpLoginResult copyWithWrapped({Wrapped<String>? session}) {
    return OtpLoginResult(
        session: (session != null ? session.value : this.session));
  }
}

@JsonSerializable(explicitToJson: true)
class Pagination {
  const Pagination({
    this.limit,
    this.before,
    this.after,
  });

  factory Pagination.fromJson(Map<String, dynamic> json) =>
      _$PaginationFromJson(json);

  static const toJsonFactory = _$PaginationToJson;
  Map<String, dynamic> toJson() => _$PaginationToJson(this);

  @JsonKey(name: 'limit')
  final String? limit;
  @JsonKey(name: 'before')
  final String? before;
  @JsonKey(name: 'after')
  final String? after;
  static const fromJsonFactory = _$PaginationFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is Pagination &&
            (identical(other.limit, limit) ||
                const DeepCollectionEquality().equals(other.limit, limit)) &&
            (identical(other.before, before) ||
                const DeepCollectionEquality().equals(other.before, before)) &&
            (identical(other.after, after) ||
                const DeepCollectionEquality().equals(other.after, after)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(limit) ^
      const DeepCollectionEquality().hash(before) ^
      const DeepCollectionEquality().hash(after) ^
      runtimeType.hashCode;
}

extension $PaginationExtension on Pagination {
  Pagination copyWith({String? limit, String? before, String? after}) {
    return Pagination(
        limit: limit ?? this.limit,
        before: before ?? this.before,
        after: after ?? this.after);
  }

  Pagination copyWithWrapped(
      {Wrapped<String?>? limit,
      Wrapped<String?>? before,
      Wrapped<String?>? after}) {
    return Pagination(
        limit: (limit != null ? limit.value : this.limit),
        before: (before != null ? before.value : this.before),
        after: (after != null ? after.value : this.after));
  }
}

@JsonSerializable(explicitToJson: true)
class Policy {
  const Policy({
    required this.policyId,
    required this.policyName,
    required this.effect,
    required this.createdAt,
    required this.updatedAt,
    required this.notes,
    this.consensus,
    this.condition,
  });

  factory Policy.fromJson(Map<String, dynamic> json) => _$PolicyFromJson(json);

  static const toJsonFactory = _$PolicyToJson;
  Map<String, dynamic> toJson() => _$PolicyToJson(this);

  @JsonKey(name: 'policyId')
  final String policyId;
  @JsonKey(name: 'policyName')
  final String policyName;
  @JsonKey(
    name: 'effect',
    toJson: effectToJson,
    fromJson: effectFromJson,
  )
  final enums.Effect effect;
  @JsonKey(name: 'createdAt')
  final ExternalDataV1Timestamp createdAt;
  @JsonKey(name: 'updatedAt')
  final ExternalDataV1Timestamp updatedAt;
  @JsonKey(name: 'notes')
  final String notes;
  @JsonKey(name: 'consensus')
  final String? consensus;
  @JsonKey(name: 'condition')
  final String? condition;
  static const fromJsonFactory = _$PolicyFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is Policy &&
            (identical(other.policyId, policyId) ||
                const DeepCollectionEquality()
                    .equals(other.policyId, policyId)) &&
            (identical(other.policyName, policyName) ||
                const DeepCollectionEquality()
                    .equals(other.policyName, policyName)) &&
            (identical(other.effect, effect) ||
                const DeepCollectionEquality().equals(other.effect, effect)) &&
            (identical(other.createdAt, createdAt) ||
                const DeepCollectionEquality()
                    .equals(other.createdAt, createdAt)) &&
            (identical(other.updatedAt, updatedAt) ||
                const DeepCollectionEquality()
                    .equals(other.updatedAt, updatedAt)) &&
            (identical(other.notes, notes) ||
                const DeepCollectionEquality().equals(other.notes, notes)) &&
            (identical(other.consensus, consensus) ||
                const DeepCollectionEquality()
                    .equals(other.consensus, consensus)) &&
            (identical(other.condition, condition) ||
                const DeepCollectionEquality()
                    .equals(other.condition, condition)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(policyId) ^
      const DeepCollectionEquality().hash(policyName) ^
      const DeepCollectionEquality().hash(effect) ^
      const DeepCollectionEquality().hash(createdAt) ^
      const DeepCollectionEquality().hash(updatedAt) ^
      const DeepCollectionEquality().hash(notes) ^
      const DeepCollectionEquality().hash(consensus) ^
      const DeepCollectionEquality().hash(condition) ^
      runtimeType.hashCode;
}

extension $PolicyExtension on Policy {
  Policy copyWith(
      {String? policyId,
      String? policyName,
      enums.Effect? effect,
      ExternalDataV1Timestamp? createdAt,
      ExternalDataV1Timestamp? updatedAt,
      String? notes,
      String? consensus,
      String? condition}) {
    return Policy(
        policyId: policyId ?? this.policyId,
        policyName: policyName ?? this.policyName,
        effect: effect ?? this.effect,
        createdAt: createdAt ?? this.createdAt,
        updatedAt: updatedAt ?? this.updatedAt,
        notes: notes ?? this.notes,
        consensus: consensus ?? this.consensus,
        condition: condition ?? this.condition);
  }

  Policy copyWithWrapped(
      {Wrapped<String>? policyId,
      Wrapped<String>? policyName,
      Wrapped<enums.Effect>? effect,
      Wrapped<ExternalDataV1Timestamp>? createdAt,
      Wrapped<ExternalDataV1Timestamp>? updatedAt,
      Wrapped<String>? notes,
      Wrapped<String?>? consensus,
      Wrapped<String?>? condition}) {
    return Policy(
        policyId: (policyId != null ? policyId.value : this.policyId),
        policyName: (policyName != null ? policyName.value : this.policyName),
        effect: (effect != null ? effect.value : this.effect),
        createdAt: (createdAt != null ? createdAt.value : this.createdAt),
        updatedAt: (updatedAt != null ? updatedAt.value : this.updatedAt),
        notes: (notes != null ? notes.value : this.notes),
        consensus: (consensus != null ? consensus.value : this.consensus),
        condition: (condition != null ? condition.value : this.condition));
  }
}

@JsonSerializable(explicitToJson: true)
class PrivateKey {
  const PrivateKey({
    required this.privateKeyId,
    required this.publicKey,
    required this.privateKeyName,
    required this.curve,
    required this.addresses,
    required this.privateKeyTags,
    required this.createdAt,
    required this.updatedAt,
    required this.exported,
    required this.imported,
  });

  factory PrivateKey.fromJson(Map<String, dynamic> json) =>
      _$PrivateKeyFromJson(json);

  static const toJsonFactory = _$PrivateKeyToJson;
  Map<String, dynamic> toJson() => _$PrivateKeyToJson(this);

  @JsonKey(name: 'privateKeyId')
  final String privateKeyId;
  @JsonKey(name: 'publicKey')
  final String publicKey;
  @JsonKey(name: 'privateKeyName')
  final String privateKeyName;
  @JsonKey(
    name: 'curve',
    toJson: curveToJson,
    fromJson: curveFromJson,
  )
  final enums.Curve curve;
  @JsonKey(name: 'addresses', defaultValue: <DataV1Address>[])
  final List<DataV1Address> addresses;
  @JsonKey(name: 'privateKeyTags', defaultValue: <String>[])
  final List<String> privateKeyTags;
  @JsonKey(name: 'createdAt')
  final ExternalDataV1Timestamp createdAt;
  @JsonKey(name: 'updatedAt')
  final ExternalDataV1Timestamp updatedAt;
  @JsonKey(name: 'exported')
  final bool exported;
  @JsonKey(name: 'imported')
  final bool imported;
  static const fromJsonFactory = _$PrivateKeyFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is PrivateKey &&
            (identical(other.privateKeyId, privateKeyId) ||
                const DeepCollectionEquality()
                    .equals(other.privateKeyId, privateKeyId)) &&
            (identical(other.publicKey, publicKey) ||
                const DeepCollectionEquality()
                    .equals(other.publicKey, publicKey)) &&
            (identical(other.privateKeyName, privateKeyName) ||
                const DeepCollectionEquality()
                    .equals(other.privateKeyName, privateKeyName)) &&
            (identical(other.curve, curve) ||
                const DeepCollectionEquality().equals(other.curve, curve)) &&
            (identical(other.addresses, addresses) ||
                const DeepCollectionEquality()
                    .equals(other.addresses, addresses)) &&
            (identical(other.privateKeyTags, privateKeyTags) ||
                const DeepCollectionEquality()
                    .equals(other.privateKeyTags, privateKeyTags)) &&
            (identical(other.createdAt, createdAt) ||
                const DeepCollectionEquality()
                    .equals(other.createdAt, createdAt)) &&
            (identical(other.updatedAt, updatedAt) ||
                const DeepCollectionEquality()
                    .equals(other.updatedAt, updatedAt)) &&
            (identical(other.exported, exported) ||
                const DeepCollectionEquality()
                    .equals(other.exported, exported)) &&
            (identical(other.imported, imported) ||
                const DeepCollectionEquality()
                    .equals(other.imported, imported)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(privateKeyId) ^
      const DeepCollectionEquality().hash(publicKey) ^
      const DeepCollectionEquality().hash(privateKeyName) ^
      const DeepCollectionEquality().hash(curve) ^
      const DeepCollectionEquality().hash(addresses) ^
      const DeepCollectionEquality().hash(privateKeyTags) ^
      const DeepCollectionEquality().hash(createdAt) ^
      const DeepCollectionEquality().hash(updatedAt) ^
      const DeepCollectionEquality().hash(exported) ^
      const DeepCollectionEquality().hash(imported) ^
      runtimeType.hashCode;
}

extension $PrivateKeyExtension on PrivateKey {
  PrivateKey copyWith(
      {String? privateKeyId,
      String? publicKey,
      String? privateKeyName,
      enums.Curve? curve,
      List<DataV1Address>? addresses,
      List<String>? privateKeyTags,
      ExternalDataV1Timestamp? createdAt,
      ExternalDataV1Timestamp? updatedAt,
      bool? exported,
      bool? imported}) {
    return PrivateKey(
        privateKeyId: privateKeyId ?? this.privateKeyId,
        publicKey: publicKey ?? this.publicKey,
        privateKeyName: privateKeyName ?? this.privateKeyName,
        curve: curve ?? this.curve,
        addresses: addresses ?? this.addresses,
        privateKeyTags: privateKeyTags ?? this.privateKeyTags,
        createdAt: createdAt ?? this.createdAt,
        updatedAt: updatedAt ?? this.updatedAt,
        exported: exported ?? this.exported,
        imported: imported ?? this.imported);
  }

  PrivateKey copyWithWrapped(
      {Wrapped<String>? privateKeyId,
      Wrapped<String>? publicKey,
      Wrapped<String>? privateKeyName,
      Wrapped<enums.Curve>? curve,
      Wrapped<List<DataV1Address>>? addresses,
      Wrapped<List<String>>? privateKeyTags,
      Wrapped<ExternalDataV1Timestamp>? createdAt,
      Wrapped<ExternalDataV1Timestamp>? updatedAt,
      Wrapped<bool>? exported,
      Wrapped<bool>? imported}) {
    return PrivateKey(
        privateKeyId:
            (privateKeyId != null ? privateKeyId.value : this.privateKeyId),
        publicKey: (publicKey != null ? publicKey.value : this.publicKey),
        privateKeyName: (privateKeyName != null
            ? privateKeyName.value
            : this.privateKeyName),
        curve: (curve != null ? curve.value : this.curve),
        addresses: (addresses != null ? addresses.value : this.addresses),
        privateKeyTags: (privateKeyTags != null
            ? privateKeyTags.value
            : this.privateKeyTags),
        createdAt: (createdAt != null ? createdAt.value : this.createdAt),
        updatedAt: (updatedAt != null ? updatedAt.value : this.updatedAt),
        exported: (exported != null ? exported.value : this.exported),
        imported: (imported != null ? imported.value : this.imported));
  }
}

@JsonSerializable(explicitToJson: true)
class PrivateKeyParams {
  const PrivateKeyParams({
    required this.privateKeyName,
    required this.curve,
    required this.privateKeyTags,
    required this.addressFormats,
  });

  factory PrivateKeyParams.fromJson(Map<String, dynamic> json) =>
      _$PrivateKeyParamsFromJson(json);

  static const toJsonFactory = _$PrivateKeyParamsToJson;
  Map<String, dynamic> toJson() => _$PrivateKeyParamsToJson(this);

  @JsonKey(name: 'privateKeyName')
  final String privateKeyName;
  @JsonKey(
    name: 'curve',
    toJson: curveToJson,
    fromJson: curveFromJson,
  )
  final enums.Curve curve;
  @JsonKey(name: 'privateKeyTags', defaultValue: <String>[])
  final List<String> privateKeyTags;
  @JsonKey(
    name: 'addressFormats',
    toJson: addressFormatListToJson,
    fromJson: addressFormatListFromJson,
  )
  final List<enums.AddressFormat> addressFormats;
  static const fromJsonFactory = _$PrivateKeyParamsFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is PrivateKeyParams &&
            (identical(other.privateKeyName, privateKeyName) ||
                const DeepCollectionEquality()
                    .equals(other.privateKeyName, privateKeyName)) &&
            (identical(other.curve, curve) ||
                const DeepCollectionEquality().equals(other.curve, curve)) &&
            (identical(other.privateKeyTags, privateKeyTags) ||
                const DeepCollectionEquality()
                    .equals(other.privateKeyTags, privateKeyTags)) &&
            (identical(other.addressFormats, addressFormats) ||
                const DeepCollectionEquality()
                    .equals(other.addressFormats, addressFormats)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(privateKeyName) ^
      const DeepCollectionEquality().hash(curve) ^
      const DeepCollectionEquality().hash(privateKeyTags) ^
      const DeepCollectionEquality().hash(addressFormats) ^
      runtimeType.hashCode;
}

extension $PrivateKeyParamsExtension on PrivateKeyParams {
  PrivateKeyParams copyWith(
      {String? privateKeyName,
      enums.Curve? curve,
      List<String>? privateKeyTags,
      List<enums.AddressFormat>? addressFormats}) {
    return PrivateKeyParams(
        privateKeyName: privateKeyName ?? this.privateKeyName,
        curve: curve ?? this.curve,
        privateKeyTags: privateKeyTags ?? this.privateKeyTags,
        addressFormats: addressFormats ?? this.addressFormats);
  }

  PrivateKeyParams copyWithWrapped(
      {Wrapped<String>? privateKeyName,
      Wrapped<enums.Curve>? curve,
      Wrapped<List<String>>? privateKeyTags,
      Wrapped<List<enums.AddressFormat>>? addressFormats}) {
    return PrivateKeyParams(
        privateKeyName: (privateKeyName != null
            ? privateKeyName.value
            : this.privateKeyName),
        curve: (curve != null ? curve.value : this.curve),
        privateKeyTags: (privateKeyTags != null
            ? privateKeyTags.value
            : this.privateKeyTags),
        addressFormats: (addressFormats != null
            ? addressFormats.value
            : this.addressFormats));
  }
}

@JsonSerializable(explicitToJson: true)
class PrivateKeyResult {
  const PrivateKeyResult({
    this.privateKeyId,
    this.addresses,
  });

  factory PrivateKeyResult.fromJson(Map<String, dynamic> json) =>
      _$PrivateKeyResultFromJson(json);

  static const toJsonFactory = _$PrivateKeyResultToJson;
  Map<String, dynamic> toJson() => _$PrivateKeyResultToJson(this);

  @JsonKey(name: 'privateKeyId')
  final String? privateKeyId;
  @JsonKey(name: 'addresses', defaultValue: <ActivityV1Address>[])
  final List<ActivityV1Address>? addresses;
  static const fromJsonFactory = _$PrivateKeyResultFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is PrivateKeyResult &&
            (identical(other.privateKeyId, privateKeyId) ||
                const DeepCollectionEquality()
                    .equals(other.privateKeyId, privateKeyId)) &&
            (identical(other.addresses, addresses) ||
                const DeepCollectionEquality()
                    .equals(other.addresses, addresses)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(privateKeyId) ^
      const DeepCollectionEquality().hash(addresses) ^
      runtimeType.hashCode;
}

extension $PrivateKeyResultExtension on PrivateKeyResult {
  PrivateKeyResult copyWith(
      {String? privateKeyId, List<ActivityV1Address>? addresses}) {
    return PrivateKeyResult(
        privateKeyId: privateKeyId ?? this.privateKeyId,
        addresses: addresses ?? this.addresses);
  }

  PrivateKeyResult copyWithWrapped(
      {Wrapped<String?>? privateKeyId,
      Wrapped<List<ActivityV1Address>?>? addresses}) {
    return PrivateKeyResult(
        privateKeyId:
            (privateKeyId != null ? privateKeyId.value : this.privateKeyId),
        addresses: (addresses != null ? addresses.value : this.addresses));
  }
}

@JsonSerializable(explicitToJson: true)
class PublicKeyCredentialWithAttestation {
  const PublicKeyCredentialWithAttestation({
    required this.id,
    required this.type,
    required this.rawId,
    this.authenticatorAttachment,
    required this.response,
    required this.clientExtensionResults,
  });

  factory PublicKeyCredentialWithAttestation.fromJson(
          Map<String, dynamic> json) =>
      _$PublicKeyCredentialWithAttestationFromJson(json);

  static const toJsonFactory = _$PublicKeyCredentialWithAttestationToJson;
  Map<String, dynamic> toJson() =>
      _$PublicKeyCredentialWithAttestationToJson(this);

  @JsonKey(name: 'id')
  final String id;
  @JsonKey(
    name: 'type',
    toJson: publicKeyCredentialWithAttestationTypeToJson,
    fromJson: publicKeyCredentialWithAttestationTypeFromJson,
  )
  final enums.PublicKeyCredentialWithAttestationType type;
  @JsonKey(name: 'rawId')
  final String rawId;
  @JsonKey(
    name: 'authenticatorAttachment',
    toJson:
        publicKeyCredentialWithAttestationAuthenticatorAttachmentNullableToJson,
    fromJson:
        publicKeyCredentialWithAttestationAuthenticatorAttachmentNullableFromJson,
  )
  final enums.PublicKeyCredentialWithAttestationAuthenticatorAttachment?
      authenticatorAttachment;
  @JsonKey(name: 'response')
  final AuthenticatorAttestationResponse response;
  @JsonKey(name: 'clientExtensionResults')
  final SimpleClientExtensionResults clientExtensionResults;
  static const fromJsonFactory = _$PublicKeyCredentialWithAttestationFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is PublicKeyCredentialWithAttestation &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.rawId, rawId) ||
                const DeepCollectionEquality().equals(other.rawId, rawId)) &&
            (identical(
                    other.authenticatorAttachment, authenticatorAttachment) ||
                const DeepCollectionEquality().equals(
                    other.authenticatorAttachment, authenticatorAttachment)) &&
            (identical(other.response, response) ||
                const DeepCollectionEquality()
                    .equals(other.response, response)) &&
            (identical(other.clientExtensionResults, clientExtensionResults) ||
                const DeepCollectionEquality().equals(
                    other.clientExtensionResults, clientExtensionResults)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(rawId) ^
      const DeepCollectionEquality().hash(authenticatorAttachment) ^
      const DeepCollectionEquality().hash(response) ^
      const DeepCollectionEquality().hash(clientExtensionResults) ^
      runtimeType.hashCode;
}

extension $PublicKeyCredentialWithAttestationExtension
    on PublicKeyCredentialWithAttestation {
  PublicKeyCredentialWithAttestation copyWith(
      {String? id,
      enums.PublicKeyCredentialWithAttestationType? type,
      String? rawId,
      enums.PublicKeyCredentialWithAttestationAuthenticatorAttachment?
          authenticatorAttachment,
      AuthenticatorAttestationResponse? response,
      SimpleClientExtensionResults? clientExtensionResults}) {
    return PublicKeyCredentialWithAttestation(
        id: id ?? this.id,
        type: type ?? this.type,
        rawId: rawId ?? this.rawId,
        authenticatorAttachment:
            authenticatorAttachment ?? this.authenticatorAttachment,
        response: response ?? this.response,
        clientExtensionResults:
            clientExtensionResults ?? this.clientExtensionResults);
  }

  PublicKeyCredentialWithAttestation copyWithWrapped(
      {Wrapped<String>? id,
      Wrapped<enums.PublicKeyCredentialWithAttestationType>? type,
      Wrapped<String>? rawId,
      Wrapped<enums.PublicKeyCredentialWithAttestationAuthenticatorAttachment?>?
          authenticatorAttachment,
      Wrapped<AuthenticatorAttestationResponse>? response,
      Wrapped<SimpleClientExtensionResults>? clientExtensionResults}) {
    return PublicKeyCredentialWithAttestation(
        id: (id != null ? id.value : this.id),
        type: (type != null ? type.value : this.type),
        rawId: (rawId != null ? rawId.value : this.rawId),
        authenticatorAttachment: (authenticatorAttachment != null
            ? authenticatorAttachment.value
            : this.authenticatorAttachment),
        response: (response != null ? response.value : this.response),
        clientExtensionResults: (clientExtensionResults != null
            ? clientExtensionResults.value
            : this.clientExtensionResults));
  }
}

@JsonSerializable(explicitToJson: true)
class RecoverUserIntent {
  const RecoverUserIntent({
    required this.authenticator,
    required this.userId,
  });

  factory RecoverUserIntent.fromJson(Map<String, dynamic> json) =>
      _$RecoverUserIntentFromJson(json);

  static const toJsonFactory = _$RecoverUserIntentToJson;
  Map<String, dynamic> toJson() => _$RecoverUserIntentToJson(this);

  @JsonKey(name: 'authenticator')
  final AuthenticatorParamsV2 authenticator;
  @JsonKey(name: 'userId')
  final String userId;
  static const fromJsonFactory = _$RecoverUserIntentFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is RecoverUserIntent &&
            (identical(other.authenticator, authenticator) ||
                const DeepCollectionEquality()
                    .equals(other.authenticator, authenticator)) &&
            (identical(other.userId, userId) ||
                const DeepCollectionEquality().equals(other.userId, userId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(authenticator) ^
      const DeepCollectionEquality().hash(userId) ^
      runtimeType.hashCode;
}

extension $RecoverUserIntentExtension on RecoverUserIntent {
  RecoverUserIntent copyWith(
      {AuthenticatorParamsV2? authenticator, String? userId}) {
    return RecoverUserIntent(
        authenticator: authenticator ?? this.authenticator,
        userId: userId ?? this.userId);
  }

  RecoverUserIntent copyWithWrapped(
      {Wrapped<AuthenticatorParamsV2>? authenticator,
      Wrapped<String>? userId}) {
    return RecoverUserIntent(
        authenticator:
            (authenticator != null ? authenticator.value : this.authenticator),
        userId: (userId != null ? userId.value : this.userId));
  }
}

@JsonSerializable(explicitToJson: true)
class RecoverUserRequest {
  const RecoverUserRequest({
    required this.type,
    required this.timestampMs,
    required this.organizationId,
    required this.parameters,
  });

  factory RecoverUserRequest.fromJson(Map<String, dynamic> json) =>
      _$RecoverUserRequestFromJson(json);

  static const toJsonFactory = _$RecoverUserRequestToJson;
  Map<String, dynamic> toJson() => _$RecoverUserRequestToJson(this);

  @JsonKey(
    name: 'type',
    toJson: recoverUserRequestTypeToJson,
    fromJson: recoverUserRequestTypeFromJson,
  )
  final enums.RecoverUserRequestType type;
  @JsonKey(name: 'timestampMs')
  final String timestampMs;
  @JsonKey(name: 'organizationId')
  final String organizationId;
  @JsonKey(name: 'parameters')
  final RecoverUserIntent parameters;
  static const fromJsonFactory = _$RecoverUserRequestFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is RecoverUserRequest &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.timestampMs, timestampMs) ||
                const DeepCollectionEquality()
                    .equals(other.timestampMs, timestampMs)) &&
            (identical(other.organizationId, organizationId) ||
                const DeepCollectionEquality()
                    .equals(other.organizationId, organizationId)) &&
            (identical(other.parameters, parameters) ||
                const DeepCollectionEquality()
                    .equals(other.parameters, parameters)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(timestampMs) ^
      const DeepCollectionEquality().hash(organizationId) ^
      const DeepCollectionEquality().hash(parameters) ^
      runtimeType.hashCode;
}

extension $RecoverUserRequestExtension on RecoverUserRequest {
  RecoverUserRequest copyWith(
      {enums.RecoverUserRequestType? type,
      String? timestampMs,
      String? organizationId,
      RecoverUserIntent? parameters}) {
    return RecoverUserRequest(
        type: type ?? this.type,
        timestampMs: timestampMs ?? this.timestampMs,
        organizationId: organizationId ?? this.organizationId,
        parameters: parameters ?? this.parameters);
  }

  RecoverUserRequest copyWithWrapped(
      {Wrapped<enums.RecoverUserRequestType>? type,
      Wrapped<String>? timestampMs,
      Wrapped<String>? organizationId,
      Wrapped<RecoverUserIntent>? parameters}) {
    return RecoverUserRequest(
        type: (type != null ? type.value : this.type),
        timestampMs:
            (timestampMs != null ? timestampMs.value : this.timestampMs),
        organizationId: (organizationId != null
            ? organizationId.value
            : this.organizationId),
        parameters: (parameters != null ? parameters.value : this.parameters));
  }
}

@JsonSerializable(explicitToJson: true)
class RecoverUserResult {
  const RecoverUserResult({
    required this.authenticatorId,
  });

  factory RecoverUserResult.fromJson(Map<String, dynamic> json) =>
      _$RecoverUserResultFromJson(json);

  static const toJsonFactory = _$RecoverUserResultToJson;
  Map<String, dynamic> toJson() => _$RecoverUserResultToJson(this);

  @JsonKey(name: 'authenticatorId', defaultValue: <String>[])
  final List<String> authenticatorId;
  static const fromJsonFactory = _$RecoverUserResultFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is RecoverUserResult &&
            (identical(other.authenticatorId, authenticatorId) ||
                const DeepCollectionEquality()
                    .equals(other.authenticatorId, authenticatorId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(authenticatorId) ^
      runtimeType.hashCode;
}

extension $RecoverUserResultExtension on RecoverUserResult {
  RecoverUserResult copyWith({List<String>? authenticatorId}) {
    return RecoverUserResult(
        authenticatorId: authenticatorId ?? this.authenticatorId);
  }

  RecoverUserResult copyWithWrapped({Wrapped<List<String>>? authenticatorId}) {
    return RecoverUserResult(
        authenticatorId: (authenticatorId != null
            ? authenticatorId.value
            : this.authenticatorId));
  }
}

@JsonSerializable(explicitToJson: true)
class RejectActivityIntent {
  const RejectActivityIntent({
    required this.fingerprint,
  });

  factory RejectActivityIntent.fromJson(Map<String, dynamic> json) =>
      _$RejectActivityIntentFromJson(json);

  static const toJsonFactory = _$RejectActivityIntentToJson;
  Map<String, dynamic> toJson() => _$RejectActivityIntentToJson(this);

  @JsonKey(name: 'fingerprint')
  final String fingerprint;
  static const fromJsonFactory = _$RejectActivityIntentFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is RejectActivityIntent &&
            (identical(other.fingerprint, fingerprint) ||
                const DeepCollectionEquality()
                    .equals(other.fingerprint, fingerprint)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(fingerprint) ^ runtimeType.hashCode;
}

extension $RejectActivityIntentExtension on RejectActivityIntent {
  RejectActivityIntent copyWith({String? fingerprint}) {
    return RejectActivityIntent(fingerprint: fingerprint ?? this.fingerprint);
  }

  RejectActivityIntent copyWithWrapped({Wrapped<String>? fingerprint}) {
    return RejectActivityIntent(
        fingerprint:
            (fingerprint != null ? fingerprint.value : this.fingerprint));
  }
}

@JsonSerializable(explicitToJson: true)
class RejectActivityRequest {
  const RejectActivityRequest({
    required this.type,
    required this.timestampMs,
    required this.organizationId,
    required this.parameters,
  });

  factory RejectActivityRequest.fromJson(Map<String, dynamic> json) =>
      _$RejectActivityRequestFromJson(json);

  static const toJsonFactory = _$RejectActivityRequestToJson;
  Map<String, dynamic> toJson() => _$RejectActivityRequestToJson(this);

  @JsonKey(
    name: 'type',
    toJson: rejectActivityRequestTypeToJson,
    fromJson: rejectActivityRequestTypeFromJson,
  )
  final enums.RejectActivityRequestType type;
  @JsonKey(name: 'timestampMs')
  final String timestampMs;
  @JsonKey(name: 'organizationId')
  final String organizationId;
  @JsonKey(name: 'parameters')
  final RejectActivityIntent parameters;
  static const fromJsonFactory = _$RejectActivityRequestFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is RejectActivityRequest &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.timestampMs, timestampMs) ||
                const DeepCollectionEquality()
                    .equals(other.timestampMs, timestampMs)) &&
            (identical(other.organizationId, organizationId) ||
                const DeepCollectionEquality()
                    .equals(other.organizationId, organizationId)) &&
            (identical(other.parameters, parameters) ||
                const DeepCollectionEquality()
                    .equals(other.parameters, parameters)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(timestampMs) ^
      const DeepCollectionEquality().hash(organizationId) ^
      const DeepCollectionEquality().hash(parameters) ^
      runtimeType.hashCode;
}

extension $RejectActivityRequestExtension on RejectActivityRequest {
  RejectActivityRequest copyWith(
      {enums.RejectActivityRequestType? type,
      String? timestampMs,
      String? organizationId,
      RejectActivityIntent? parameters}) {
    return RejectActivityRequest(
        type: type ?? this.type,
        timestampMs: timestampMs ?? this.timestampMs,
        organizationId: organizationId ?? this.organizationId,
        parameters: parameters ?? this.parameters);
  }

  RejectActivityRequest copyWithWrapped(
      {Wrapped<enums.RejectActivityRequestType>? type,
      Wrapped<String>? timestampMs,
      Wrapped<String>? organizationId,
      Wrapped<RejectActivityIntent>? parameters}) {
    return RejectActivityRequest(
        type: (type != null ? type.value : this.type),
        timestampMs:
            (timestampMs != null ? timestampMs.value : this.timestampMs),
        organizationId: (organizationId != null
            ? organizationId.value
            : this.organizationId),
        parameters: (parameters != null ? parameters.value : this.parameters));
  }
}

@JsonSerializable(explicitToJson: true)
class RemoveOrganizationFeatureIntent {
  const RemoveOrganizationFeatureIntent({
    required this.name,
  });

  factory RemoveOrganizationFeatureIntent.fromJson(Map<String, dynamic> json) =>
      _$RemoveOrganizationFeatureIntentFromJson(json);

  static const toJsonFactory = _$RemoveOrganizationFeatureIntentToJson;
  Map<String, dynamic> toJson() =>
      _$RemoveOrganizationFeatureIntentToJson(this);

  @JsonKey(
    name: 'name',
    toJson: featureNameToJson,
    fromJson: featureNameFromJson,
  )
  final enums.FeatureName name;
  static const fromJsonFactory = _$RemoveOrganizationFeatureIntentFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is RemoveOrganizationFeatureIntent &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(name) ^ runtimeType.hashCode;
}

extension $RemoveOrganizationFeatureIntentExtension
    on RemoveOrganizationFeatureIntent {
  RemoveOrganizationFeatureIntent copyWith({enums.FeatureName? name}) {
    return RemoveOrganizationFeatureIntent(name: name ?? this.name);
  }

  RemoveOrganizationFeatureIntent copyWithWrapped(
      {Wrapped<enums.FeatureName>? name}) {
    return RemoveOrganizationFeatureIntent(
        name: (name != null ? name.value : this.name));
  }
}

@JsonSerializable(explicitToJson: true)
class RemoveOrganizationFeatureRequest {
  const RemoveOrganizationFeatureRequest({
    required this.type,
    required this.timestampMs,
    required this.organizationId,
    required this.parameters,
  });

  factory RemoveOrganizationFeatureRequest.fromJson(
          Map<String, dynamic> json) =>
      _$RemoveOrganizationFeatureRequestFromJson(json);

  static const toJsonFactory = _$RemoveOrganizationFeatureRequestToJson;
  Map<String, dynamic> toJson() =>
      _$RemoveOrganizationFeatureRequestToJson(this);

  @JsonKey(
    name: 'type',
    toJson: removeOrganizationFeatureRequestTypeToJson,
    fromJson: removeOrganizationFeatureRequestTypeFromJson,
  )
  final enums.RemoveOrganizationFeatureRequestType type;
  @JsonKey(name: 'timestampMs')
  final String timestampMs;
  @JsonKey(name: 'organizationId')
  final String organizationId;
  @JsonKey(name: 'parameters')
  final RemoveOrganizationFeatureIntent parameters;
  static const fromJsonFactory = _$RemoveOrganizationFeatureRequestFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is RemoveOrganizationFeatureRequest &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.timestampMs, timestampMs) ||
                const DeepCollectionEquality()
                    .equals(other.timestampMs, timestampMs)) &&
            (identical(other.organizationId, organizationId) ||
                const DeepCollectionEquality()
                    .equals(other.organizationId, organizationId)) &&
            (identical(other.parameters, parameters) ||
                const DeepCollectionEquality()
                    .equals(other.parameters, parameters)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(timestampMs) ^
      const DeepCollectionEquality().hash(organizationId) ^
      const DeepCollectionEquality().hash(parameters) ^
      runtimeType.hashCode;
}

extension $RemoveOrganizationFeatureRequestExtension
    on RemoveOrganizationFeatureRequest {
  RemoveOrganizationFeatureRequest copyWith(
      {enums.RemoveOrganizationFeatureRequestType? type,
      String? timestampMs,
      String? organizationId,
      RemoveOrganizationFeatureIntent? parameters}) {
    return RemoveOrganizationFeatureRequest(
        type: type ?? this.type,
        timestampMs: timestampMs ?? this.timestampMs,
        organizationId: organizationId ?? this.organizationId,
        parameters: parameters ?? this.parameters);
  }

  RemoveOrganizationFeatureRequest copyWithWrapped(
      {Wrapped<enums.RemoveOrganizationFeatureRequestType>? type,
      Wrapped<String>? timestampMs,
      Wrapped<String>? organizationId,
      Wrapped<RemoveOrganizationFeatureIntent>? parameters}) {
    return RemoveOrganizationFeatureRequest(
        type: (type != null ? type.value : this.type),
        timestampMs:
            (timestampMs != null ? timestampMs.value : this.timestampMs),
        organizationId: (organizationId != null
            ? organizationId.value
            : this.organizationId),
        parameters: (parameters != null ? parameters.value : this.parameters));
  }
}

@JsonSerializable(explicitToJson: true)
class RemoveOrganizationFeatureResult {
  const RemoveOrganizationFeatureResult({
    required this.features,
  });

  factory RemoveOrganizationFeatureResult.fromJson(Map<String, dynamic> json) =>
      _$RemoveOrganizationFeatureResultFromJson(json);

  static const toJsonFactory = _$RemoveOrganizationFeatureResultToJson;
  Map<String, dynamic> toJson() =>
      _$RemoveOrganizationFeatureResultToJson(this);

  @JsonKey(name: 'features', defaultValue: <Feature>[])
  final List<Feature> features;
  static const fromJsonFactory = _$RemoveOrganizationFeatureResultFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is RemoveOrganizationFeatureResult &&
            (identical(other.features, features) ||
                const DeepCollectionEquality()
                    .equals(other.features, features)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(features) ^ runtimeType.hashCode;
}

extension $RemoveOrganizationFeatureResultExtension
    on RemoveOrganizationFeatureResult {
  RemoveOrganizationFeatureResult copyWith({List<Feature>? features}) {
    return RemoveOrganizationFeatureResult(features: features ?? this.features);
  }

  RemoveOrganizationFeatureResult copyWithWrapped(
      {Wrapped<List<Feature>>? features}) {
    return RemoveOrganizationFeatureResult(
        features: (features != null ? features.value : this.features));
  }
}

@JsonSerializable(explicitToJson: true)
class Result {
  const Result({
    this.createOrganizationResult,
    this.createAuthenticatorsResult,
    this.createUsersResult,
    this.createPrivateKeysResult,
    this.createInvitationsResult,
    this.acceptInvitationResult,
    this.signRawPayloadResult,
    this.createPolicyResult,
    this.disablePrivateKeyResult,
    this.deleteUsersResult,
    this.deleteAuthenticatorsResult,
    this.deleteInvitationResult,
    this.deleteOrganizationResult,
    this.deletePolicyResult,
    this.createUserTagResult,
    this.deleteUserTagsResult,
    this.signTransactionResult,
    this.deleteApiKeysResult,
    this.createApiKeysResult,
    this.createPrivateKeyTagResult,
    this.deletePrivateKeyTagsResult,
    this.setPaymentMethodResult,
    this.activateBillingTierResult,
    this.deletePaymentMethodResult,
    this.createApiOnlyUsersResult,
    this.updateRootQuorumResult,
    this.updateUserTagResult,
    this.updatePrivateKeyTagResult,
    this.createSubOrganizationResult,
    this.updateAllowedOriginsResult,
    this.createPrivateKeysResultV2,
    this.updateUserResult,
    this.updatePolicyResult,
    this.createSubOrganizationResultV3,
    this.createWalletResult,
    this.createWalletAccountsResult,
    this.initUserEmailRecoveryResult,
    this.recoverUserResult,
    this.setOrganizationFeatureResult,
    this.removeOrganizationFeatureResult,
    this.exportPrivateKeyResult,
    this.exportWalletResult,
    this.createSubOrganizationResultV4,
    this.emailAuthResult,
    this.exportWalletAccountResult,
    this.initImportWalletResult,
    this.importWalletResult,
    this.initImportPrivateKeyResult,
    this.importPrivateKeyResult,
    this.createPoliciesResult,
    this.signRawPayloadsResult,
    this.createReadOnlySessionResult,
    this.createOauthProvidersResult,
    this.deleteOauthProvidersResult,
    this.createSubOrganizationResultV5,
    this.oauthResult,
    this.createReadWriteSessionResult,
    this.createSubOrganizationResultV6,
    this.deletePrivateKeysResult,
    this.deleteWalletsResult,
    this.createReadWriteSessionResultV2,
    this.deleteSubOrganizationResult,
    this.initOtpAuthResult,
    this.otpAuthResult,
    this.createSubOrganizationResultV7,
    this.updateWalletResult,
    this.updatePolicyResultV2,
    this.initOtpAuthResultV2,
    this.initOtpResult,
    this.verifyOtpResult,
    this.otpLoginResult,
    this.stampLoginResult,
    this.oauthLoginResult,
    this.updateUserNameResult,
    this.updateUserEmailResult,
    this.updateUserPhoneNumberResult,
    this.initFiatOnRampResult,
    this.createSmartContractInterfaceResult,
    this.deleteSmartContractInterfaceResult,
  });

  factory Result.fromJson(Map<String, dynamic> json) => _$ResultFromJson(json);

  static const toJsonFactory = _$ResultToJson;
  Map<String, dynamic> toJson() => _$ResultToJson(this);

  @JsonKey(name: 'createOrganizationResult')
  final CreateOrganizationResult? createOrganizationResult;
  @JsonKey(name: 'createAuthenticatorsResult')
  final CreateAuthenticatorsResult? createAuthenticatorsResult;
  @JsonKey(name: 'createUsersResult')
  final CreateUsersResult? createUsersResult;
  @JsonKey(name: 'createPrivateKeysResult')
  final CreatePrivateKeysResult? createPrivateKeysResult;
  @JsonKey(name: 'createInvitationsResult')
  final CreateInvitationsResult? createInvitationsResult;
  @JsonKey(name: 'acceptInvitationResult')
  final AcceptInvitationResult? acceptInvitationResult;
  @JsonKey(name: 'signRawPayloadResult')
  final SignRawPayloadResult? signRawPayloadResult;
  @JsonKey(name: 'createPolicyResult')
  final CreatePolicyResult? createPolicyResult;
  @JsonKey(name: 'disablePrivateKeyResult')
  final DisablePrivateKeyResult? disablePrivateKeyResult;
  @JsonKey(name: 'deleteUsersResult')
  final DeleteUsersResult? deleteUsersResult;
  @JsonKey(name: 'deleteAuthenticatorsResult')
  final DeleteAuthenticatorsResult? deleteAuthenticatorsResult;
  @JsonKey(name: 'deleteInvitationResult')
  final DeleteInvitationResult? deleteInvitationResult;
  @JsonKey(name: 'deleteOrganizationResult')
  final DeleteOrganizationResult? deleteOrganizationResult;
  @JsonKey(name: 'deletePolicyResult')
  final DeletePolicyResult? deletePolicyResult;
  @JsonKey(name: 'createUserTagResult')
  final CreateUserTagResult? createUserTagResult;
  @JsonKey(name: 'deleteUserTagsResult')
  final DeleteUserTagsResult? deleteUserTagsResult;
  @JsonKey(name: 'signTransactionResult')
  final SignTransactionResult? signTransactionResult;
  @JsonKey(name: 'deleteApiKeysResult')
  final DeleteApiKeysResult? deleteApiKeysResult;
  @JsonKey(name: 'createApiKeysResult')
  final CreateApiKeysResult? createApiKeysResult;
  @JsonKey(name: 'createPrivateKeyTagResult')
  final CreatePrivateKeyTagResult? createPrivateKeyTagResult;
  @JsonKey(name: 'deletePrivateKeyTagsResult')
  final DeletePrivateKeyTagsResult? deletePrivateKeyTagsResult;
  @JsonKey(name: 'setPaymentMethodResult')
  final SetPaymentMethodResult? setPaymentMethodResult;
  @JsonKey(name: 'activateBillingTierResult')
  final ActivateBillingTierResult? activateBillingTierResult;
  @JsonKey(name: 'deletePaymentMethodResult')
  final DeletePaymentMethodResult? deletePaymentMethodResult;
  @JsonKey(name: 'createApiOnlyUsersResult')
  final CreateApiOnlyUsersResult? createApiOnlyUsersResult;
  @JsonKey(name: 'updateRootQuorumResult')
  final UpdateRootQuorumResult? updateRootQuorumResult;
  @JsonKey(name: 'updateUserTagResult')
  final UpdateUserTagResult? updateUserTagResult;
  @JsonKey(name: 'updatePrivateKeyTagResult')
  final UpdatePrivateKeyTagResult? updatePrivateKeyTagResult;
  @JsonKey(name: 'createSubOrganizationResult')
  final CreateSubOrganizationResult? createSubOrganizationResult;
  @JsonKey(name: 'updateAllowedOriginsResult')
  final UpdateAllowedOriginsResult? updateAllowedOriginsResult;
  @JsonKey(name: 'createPrivateKeysResultV2')
  final CreatePrivateKeysResultV2? createPrivateKeysResultV2;
  @JsonKey(name: 'updateUserResult')
  final UpdateUserResult? updateUserResult;
  @JsonKey(name: 'updatePolicyResult')
  final UpdatePolicyResult? updatePolicyResult;
  @JsonKey(name: 'createSubOrganizationResultV3')
  final CreateSubOrganizationResultV3? createSubOrganizationResultV3;
  @JsonKey(name: 'createWalletResult')
  final CreateWalletResult? createWalletResult;
  @JsonKey(name: 'createWalletAccountsResult')
  final CreateWalletAccountsResult? createWalletAccountsResult;
  @JsonKey(name: 'initUserEmailRecoveryResult')
  final InitUserEmailRecoveryResult? initUserEmailRecoveryResult;
  @JsonKey(name: 'recoverUserResult')
  final RecoverUserResult? recoverUserResult;
  @JsonKey(name: 'setOrganizationFeatureResult')
  final SetOrganizationFeatureResult? setOrganizationFeatureResult;
  @JsonKey(name: 'removeOrganizationFeatureResult')
  final RemoveOrganizationFeatureResult? removeOrganizationFeatureResult;
  @JsonKey(name: 'exportPrivateKeyResult')
  final ExportPrivateKeyResult? exportPrivateKeyResult;
  @JsonKey(name: 'exportWalletResult')
  final ExportWalletResult? exportWalletResult;
  @JsonKey(name: 'createSubOrganizationResultV4')
  final CreateSubOrganizationResultV4? createSubOrganizationResultV4;
  @JsonKey(name: 'emailAuthResult')
  final EmailAuthResult? emailAuthResult;
  @JsonKey(name: 'exportWalletAccountResult')
  final ExportWalletAccountResult? exportWalletAccountResult;
  @JsonKey(name: 'initImportWalletResult')
  final InitImportWalletResult? initImportWalletResult;
  @JsonKey(name: 'importWalletResult')
  final ImportWalletResult? importWalletResult;
  @JsonKey(name: 'initImportPrivateKeyResult')
  final InitImportPrivateKeyResult? initImportPrivateKeyResult;
  @JsonKey(name: 'importPrivateKeyResult')
  final ImportPrivateKeyResult? importPrivateKeyResult;
  @JsonKey(name: 'createPoliciesResult')
  final CreatePoliciesResult? createPoliciesResult;
  @JsonKey(name: 'signRawPayloadsResult')
  final SignRawPayloadsResult? signRawPayloadsResult;
  @JsonKey(name: 'createReadOnlySessionResult')
  final CreateReadOnlySessionResult? createReadOnlySessionResult;
  @JsonKey(name: 'createOauthProvidersResult')
  final CreateOauthProvidersResult? createOauthProvidersResult;
  @JsonKey(name: 'deleteOauthProvidersResult')
  final DeleteOauthProvidersResult? deleteOauthProvidersResult;
  @JsonKey(name: 'createSubOrganizationResultV5')
  final CreateSubOrganizationResultV5? createSubOrganizationResultV5;
  @JsonKey(name: 'oauthResult')
  final OauthResult? oauthResult;
  @JsonKey(name: 'createReadWriteSessionResult')
  final CreateReadWriteSessionResult? createReadWriteSessionResult;
  @JsonKey(name: 'createSubOrganizationResultV6')
  final CreateSubOrganizationResultV6? createSubOrganizationResultV6;
  @JsonKey(name: 'deletePrivateKeysResult')
  final DeletePrivateKeysResult? deletePrivateKeysResult;
  @JsonKey(name: 'deleteWalletsResult')
  final DeleteWalletsResult? deleteWalletsResult;
  @JsonKey(name: 'createReadWriteSessionResultV2')
  final CreateReadWriteSessionResultV2? createReadWriteSessionResultV2;
  @JsonKey(name: 'deleteSubOrganizationResult')
  final DeleteSubOrganizationResult? deleteSubOrganizationResult;
  @JsonKey(name: 'initOtpAuthResult')
  final InitOtpAuthResult? initOtpAuthResult;
  @JsonKey(name: 'otpAuthResult')
  final OtpAuthResult? otpAuthResult;
  @JsonKey(name: 'createSubOrganizationResultV7')
  final CreateSubOrganizationResultV7? createSubOrganizationResultV7;
  @JsonKey(name: 'updateWalletResult')
  final UpdateWalletResult? updateWalletResult;
  @JsonKey(name: 'updatePolicyResultV2')
  final UpdatePolicyResultV2? updatePolicyResultV2;
  @JsonKey(name: 'initOtpAuthResultV2')
  final InitOtpAuthResultV2? initOtpAuthResultV2;
  @JsonKey(name: 'initOtpResult')
  final InitOtpResult? initOtpResult;
  @JsonKey(name: 'verifyOtpResult')
  final VerifyOtpResult? verifyOtpResult;
  @JsonKey(name: 'otpLoginResult')
  final OtpLoginResult? otpLoginResult;
  @JsonKey(name: 'stampLoginResult')
  final StampLoginResult? stampLoginResult;
  @JsonKey(name: 'oauthLoginResult')
  final OauthLoginResult? oauthLoginResult;
  @JsonKey(name: 'updateUserNameResult')
  final UpdateUserNameResult? updateUserNameResult;
  @JsonKey(name: 'updateUserEmailResult')
  final UpdateUserEmailResult? updateUserEmailResult;
  @JsonKey(name: 'updateUserPhoneNumberResult')
  final UpdateUserPhoneNumberResult? updateUserPhoneNumberResult;
  @JsonKey(name: 'initFiatOnRampResult')
  final InitFiatOnRampResult? initFiatOnRampResult;
  @JsonKey(name: 'createSmartContractInterfaceResult')
  final CreateSmartContractInterfaceResult? createSmartContractInterfaceResult;
  @JsonKey(name: 'deleteSmartContractInterfaceResult')
  final DeleteSmartContractInterfaceResult? deleteSmartContractInterfaceResult;
  static const fromJsonFactory = _$ResultFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is Result &&
            (identical(other.createOrganizationResult, createOrganizationResult) ||
                const DeepCollectionEquality().equals(
                    other.createOrganizationResult,
                    createOrganizationResult)) &&
            (identical(other.createAuthenticatorsResult, createAuthenticatorsResult) ||
                const DeepCollectionEquality().equals(
                    other.createAuthenticatorsResult,
                    createAuthenticatorsResult)) &&
            (identical(other.createUsersResult, createUsersResult) ||
                const DeepCollectionEquality()
                    .equals(other.createUsersResult, createUsersResult)) &&
            (identical(other.createPrivateKeysResult, createPrivateKeysResult) ||
                const DeepCollectionEquality().equals(
                    other.createPrivateKeysResult, createPrivateKeysResult)) &&
            (identical(other.createInvitationsResult, createInvitationsResult) ||
                const DeepCollectionEquality().equals(
                    other.createInvitationsResult, createInvitationsResult)) &&
            (identical(other.acceptInvitationResult, acceptInvitationResult) ||
                const DeepCollectionEquality().equals(
                    other.acceptInvitationResult, acceptInvitationResult)) &&
            (identical(other.signRawPayloadResult, signRawPayloadResult) ||
                const DeepCollectionEquality().equals(
                    other.signRawPayloadResult, signRawPayloadResult)) &&
            (identical(other.createPolicyResult, createPolicyResult) ||
                const DeepCollectionEquality()
                    .equals(other.createPolicyResult, createPolicyResult)) &&
            (identical(other.disablePrivateKeyResult, disablePrivateKeyResult) ||
                const DeepCollectionEquality().equals(
                    other.disablePrivateKeyResult, disablePrivateKeyResult)) &&
            (identical(other.deleteUsersResult, deleteUsersResult) ||
                const DeepCollectionEquality().equals(other.deleteUsersResult, deleteUsersResult)) &&
            (identical(other.deleteAuthenticatorsResult, deleteAuthenticatorsResult) || const DeepCollectionEquality().equals(other.deleteAuthenticatorsResult, deleteAuthenticatorsResult)) &&
            (identical(other.deleteInvitationResult, deleteInvitationResult) || const DeepCollectionEquality().equals(other.deleteInvitationResult, deleteInvitationResult)) &&
            (identical(other.deleteOrganizationResult, deleteOrganizationResult) || const DeepCollectionEquality().equals(other.deleteOrganizationResult, deleteOrganizationResult)) &&
            (identical(other.deletePolicyResult, deletePolicyResult) || const DeepCollectionEquality().equals(other.deletePolicyResult, deletePolicyResult)) &&
            (identical(other.createUserTagResult, createUserTagResult) || const DeepCollectionEquality().equals(other.createUserTagResult, createUserTagResult)) &&
            (identical(other.deleteUserTagsResult, deleteUserTagsResult) || const DeepCollectionEquality().equals(other.deleteUserTagsResult, deleteUserTagsResult)) &&
            (identical(other.signTransactionResult, signTransactionResult) || const DeepCollectionEquality().equals(other.signTransactionResult, signTransactionResult)) &&
            (identical(other.deleteApiKeysResult, deleteApiKeysResult) || const DeepCollectionEquality().equals(other.deleteApiKeysResult, deleteApiKeysResult)) &&
            (identical(other.createApiKeysResult, createApiKeysResult) || const DeepCollectionEquality().equals(other.createApiKeysResult, createApiKeysResult)) &&
            (identical(other.createPrivateKeyTagResult, createPrivateKeyTagResult) || const DeepCollectionEquality().equals(other.createPrivateKeyTagResult, createPrivateKeyTagResult)) &&
            (identical(other.deletePrivateKeyTagsResult, deletePrivateKeyTagsResult) || const DeepCollectionEquality().equals(other.deletePrivateKeyTagsResult, deletePrivateKeyTagsResult)) &&
            (identical(other.setPaymentMethodResult, setPaymentMethodResult) || const DeepCollectionEquality().equals(other.setPaymentMethodResult, setPaymentMethodResult)) &&
            (identical(other.activateBillingTierResult, activateBillingTierResult) || const DeepCollectionEquality().equals(other.activateBillingTierResult, activateBillingTierResult)) &&
            (identical(other.deletePaymentMethodResult, deletePaymentMethodResult) || const DeepCollectionEquality().equals(other.deletePaymentMethodResult, deletePaymentMethodResult)) &&
            (identical(other.createApiOnlyUsersResult, createApiOnlyUsersResult) || const DeepCollectionEquality().equals(other.createApiOnlyUsersResult, createApiOnlyUsersResult)) &&
            (identical(other.updateRootQuorumResult, updateRootQuorumResult) || const DeepCollectionEquality().equals(other.updateRootQuorumResult, updateRootQuorumResult)) &&
            (identical(other.updateUserTagResult, updateUserTagResult) || const DeepCollectionEquality().equals(other.updateUserTagResult, updateUserTagResult)) &&
            (identical(other.updatePrivateKeyTagResult, updatePrivateKeyTagResult) || const DeepCollectionEquality().equals(other.updatePrivateKeyTagResult, updatePrivateKeyTagResult)) &&
            (identical(other.createSubOrganizationResult, createSubOrganizationResult) || const DeepCollectionEquality().equals(other.createSubOrganizationResult, createSubOrganizationResult)) &&
            (identical(other.updateAllowedOriginsResult, updateAllowedOriginsResult) || const DeepCollectionEquality().equals(other.updateAllowedOriginsResult, updateAllowedOriginsResult)) &&
            (identical(other.createPrivateKeysResultV2, createPrivateKeysResultV2) || const DeepCollectionEquality().equals(other.createPrivateKeysResultV2, createPrivateKeysResultV2)) &&
            (identical(other.updateUserResult, updateUserResult) || const DeepCollectionEquality().equals(other.updateUserResult, updateUserResult)) &&
            (identical(other.updatePolicyResult, updatePolicyResult) || const DeepCollectionEquality().equals(other.updatePolicyResult, updatePolicyResult)) &&
            (identical(other.createSubOrganizationResultV3, createSubOrganizationResultV3) || const DeepCollectionEquality().equals(other.createSubOrganizationResultV3, createSubOrganizationResultV3)) &&
            (identical(other.createWalletResult, createWalletResult) || const DeepCollectionEquality().equals(other.createWalletResult, createWalletResult)) &&
            (identical(other.createWalletAccountsResult, createWalletAccountsResult) || const DeepCollectionEquality().equals(other.createWalletAccountsResult, createWalletAccountsResult)) &&
            (identical(other.initUserEmailRecoveryResult, initUserEmailRecoveryResult) || const DeepCollectionEquality().equals(other.initUserEmailRecoveryResult, initUserEmailRecoveryResult)) &&
            (identical(other.recoverUserResult, recoverUserResult) || const DeepCollectionEquality().equals(other.recoverUserResult, recoverUserResult)) &&
            (identical(other.setOrganizationFeatureResult, setOrganizationFeatureResult) || const DeepCollectionEquality().equals(other.setOrganizationFeatureResult, setOrganizationFeatureResult)) &&
            (identical(other.removeOrganizationFeatureResult, removeOrganizationFeatureResult) || const DeepCollectionEquality().equals(other.removeOrganizationFeatureResult, removeOrganizationFeatureResult)) &&
            (identical(other.exportPrivateKeyResult, exportPrivateKeyResult) || const DeepCollectionEquality().equals(other.exportPrivateKeyResult, exportPrivateKeyResult)) &&
            (identical(other.exportWalletResult, exportWalletResult) || const DeepCollectionEquality().equals(other.exportWalletResult, exportWalletResult)) &&
            (identical(other.createSubOrganizationResultV4, createSubOrganizationResultV4) || const DeepCollectionEquality().equals(other.createSubOrganizationResultV4, createSubOrganizationResultV4)) &&
            (identical(other.emailAuthResult, emailAuthResult) || const DeepCollectionEquality().equals(other.emailAuthResult, emailAuthResult)) &&
            (identical(other.exportWalletAccountResult, exportWalletAccountResult) || const DeepCollectionEquality().equals(other.exportWalletAccountResult, exportWalletAccountResult)) &&
            (identical(other.initImportWalletResult, initImportWalletResult) || const DeepCollectionEquality().equals(other.initImportWalletResult, initImportWalletResult)) &&
            (identical(other.importWalletResult, importWalletResult) || const DeepCollectionEquality().equals(other.importWalletResult, importWalletResult)) &&
            (identical(other.initImportPrivateKeyResult, initImportPrivateKeyResult) || const DeepCollectionEquality().equals(other.initImportPrivateKeyResult, initImportPrivateKeyResult)) &&
            (identical(other.importPrivateKeyResult, importPrivateKeyResult) || const DeepCollectionEquality().equals(other.importPrivateKeyResult, importPrivateKeyResult)) &&
            (identical(other.createPoliciesResult, createPoliciesResult) || const DeepCollectionEquality().equals(other.createPoliciesResult, createPoliciesResult)) &&
            (identical(other.signRawPayloadsResult, signRawPayloadsResult) || const DeepCollectionEquality().equals(other.signRawPayloadsResult, signRawPayloadsResult)) &&
            (identical(other.createReadOnlySessionResult, createReadOnlySessionResult) || const DeepCollectionEquality().equals(other.createReadOnlySessionResult, createReadOnlySessionResult)) &&
            (identical(other.createOauthProvidersResult, createOauthProvidersResult) || const DeepCollectionEquality().equals(other.createOauthProvidersResult, createOauthProvidersResult)) &&
            (identical(other.deleteOauthProvidersResult, deleteOauthProvidersResult) || const DeepCollectionEquality().equals(other.deleteOauthProvidersResult, deleteOauthProvidersResult)) &&
            (identical(other.createSubOrganizationResultV5, createSubOrganizationResultV5) || const DeepCollectionEquality().equals(other.createSubOrganizationResultV5, createSubOrganizationResultV5)) &&
            (identical(other.oauthResult, oauthResult) || const DeepCollectionEquality().equals(other.oauthResult, oauthResult)) &&
            (identical(other.createReadWriteSessionResult, createReadWriteSessionResult) || const DeepCollectionEquality().equals(other.createReadWriteSessionResult, createReadWriteSessionResult)) &&
            (identical(other.createSubOrganizationResultV6, createSubOrganizationResultV6) || const DeepCollectionEquality().equals(other.createSubOrganizationResultV6, createSubOrganizationResultV6)) &&
            (identical(other.deletePrivateKeysResult, deletePrivateKeysResult) || const DeepCollectionEquality().equals(other.deletePrivateKeysResult, deletePrivateKeysResult)) &&
            (identical(other.deleteWalletsResult, deleteWalletsResult) || const DeepCollectionEquality().equals(other.deleteWalletsResult, deleteWalletsResult)) &&
            (identical(other.createReadWriteSessionResultV2, createReadWriteSessionResultV2) || const DeepCollectionEquality().equals(other.createReadWriteSessionResultV2, createReadWriteSessionResultV2)) &&
            (identical(other.deleteSubOrganizationResult, deleteSubOrganizationResult) || const DeepCollectionEquality().equals(other.deleteSubOrganizationResult, deleteSubOrganizationResult)) &&
            (identical(other.initOtpAuthResult, initOtpAuthResult) || const DeepCollectionEquality().equals(other.initOtpAuthResult, initOtpAuthResult)) &&
            (identical(other.otpAuthResult, otpAuthResult) || const DeepCollectionEquality().equals(other.otpAuthResult, otpAuthResult)) &&
            (identical(other.createSubOrganizationResultV7, createSubOrganizationResultV7) || const DeepCollectionEquality().equals(other.createSubOrganizationResultV7, createSubOrganizationResultV7)) &&
            (identical(other.updateWalletResult, updateWalletResult) || const DeepCollectionEquality().equals(other.updateWalletResult, updateWalletResult)) &&
            (identical(other.updatePolicyResultV2, updatePolicyResultV2) || const DeepCollectionEquality().equals(other.updatePolicyResultV2, updatePolicyResultV2)) &&
            (identical(other.initOtpAuthResultV2, initOtpAuthResultV2) || const DeepCollectionEquality().equals(other.initOtpAuthResultV2, initOtpAuthResultV2)) &&
            (identical(other.initOtpResult, initOtpResult) || const DeepCollectionEquality().equals(other.initOtpResult, initOtpResult)) &&
            (identical(other.verifyOtpResult, verifyOtpResult) || const DeepCollectionEquality().equals(other.verifyOtpResult, verifyOtpResult)) &&
            (identical(other.otpLoginResult, otpLoginResult) || const DeepCollectionEquality().equals(other.otpLoginResult, otpLoginResult)) &&
            (identical(other.stampLoginResult, stampLoginResult) || const DeepCollectionEquality().equals(other.stampLoginResult, stampLoginResult)) &&
            (identical(other.oauthLoginResult, oauthLoginResult) || const DeepCollectionEquality().equals(other.oauthLoginResult, oauthLoginResult)) &&
            (identical(other.updateUserNameResult, updateUserNameResult) || const DeepCollectionEquality().equals(other.updateUserNameResult, updateUserNameResult)) &&
            (identical(other.updateUserEmailResult, updateUserEmailResult) || const DeepCollectionEquality().equals(other.updateUserEmailResult, updateUserEmailResult)) &&
            (identical(other.updateUserPhoneNumberResult, updateUserPhoneNumberResult) || const DeepCollectionEquality().equals(other.updateUserPhoneNumberResult, updateUserPhoneNumberResult)) &&
            (identical(other.initFiatOnRampResult, initFiatOnRampResult) || const DeepCollectionEquality().equals(other.initFiatOnRampResult, initFiatOnRampResult)) &&
            (identical(other.createSmartContractInterfaceResult, createSmartContractInterfaceResult) || const DeepCollectionEquality().equals(other.createSmartContractInterfaceResult, createSmartContractInterfaceResult)) &&
            (identical(other.deleteSmartContractInterfaceResult, deleteSmartContractInterfaceResult) || const DeepCollectionEquality().equals(other.deleteSmartContractInterfaceResult, deleteSmartContractInterfaceResult)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(createOrganizationResult) ^
      const DeepCollectionEquality().hash(createAuthenticatorsResult) ^
      const DeepCollectionEquality().hash(createUsersResult) ^
      const DeepCollectionEquality().hash(createPrivateKeysResult) ^
      const DeepCollectionEquality().hash(createInvitationsResult) ^
      const DeepCollectionEquality().hash(acceptInvitationResult) ^
      const DeepCollectionEquality().hash(signRawPayloadResult) ^
      const DeepCollectionEquality().hash(createPolicyResult) ^
      const DeepCollectionEquality().hash(disablePrivateKeyResult) ^
      const DeepCollectionEquality().hash(deleteUsersResult) ^
      const DeepCollectionEquality().hash(deleteAuthenticatorsResult) ^
      const DeepCollectionEquality().hash(deleteInvitationResult) ^
      const DeepCollectionEquality().hash(deleteOrganizationResult) ^
      const DeepCollectionEquality().hash(deletePolicyResult) ^
      const DeepCollectionEquality().hash(createUserTagResult) ^
      const DeepCollectionEquality().hash(deleteUserTagsResult) ^
      const DeepCollectionEquality().hash(signTransactionResult) ^
      const DeepCollectionEquality().hash(deleteApiKeysResult) ^
      const DeepCollectionEquality().hash(createApiKeysResult) ^
      const DeepCollectionEquality().hash(createPrivateKeyTagResult) ^
      const DeepCollectionEquality().hash(deletePrivateKeyTagsResult) ^
      const DeepCollectionEquality().hash(setPaymentMethodResult) ^
      const DeepCollectionEquality().hash(activateBillingTierResult) ^
      const DeepCollectionEquality().hash(deletePaymentMethodResult) ^
      const DeepCollectionEquality().hash(createApiOnlyUsersResult) ^
      const DeepCollectionEquality().hash(updateRootQuorumResult) ^
      const DeepCollectionEquality().hash(updateUserTagResult) ^
      const DeepCollectionEquality().hash(updatePrivateKeyTagResult) ^
      const DeepCollectionEquality().hash(createSubOrganizationResult) ^
      const DeepCollectionEquality().hash(updateAllowedOriginsResult) ^
      const DeepCollectionEquality().hash(createPrivateKeysResultV2) ^
      const DeepCollectionEquality().hash(updateUserResult) ^
      const DeepCollectionEquality().hash(updatePolicyResult) ^
      const DeepCollectionEquality().hash(createSubOrganizationResultV3) ^
      const DeepCollectionEquality().hash(createWalletResult) ^
      const DeepCollectionEquality().hash(createWalletAccountsResult) ^
      const DeepCollectionEquality().hash(initUserEmailRecoveryResult) ^
      const DeepCollectionEquality().hash(recoverUserResult) ^
      const DeepCollectionEquality().hash(setOrganizationFeatureResult) ^
      const DeepCollectionEquality().hash(removeOrganizationFeatureResult) ^
      const DeepCollectionEquality().hash(exportPrivateKeyResult) ^
      const DeepCollectionEquality().hash(exportWalletResult) ^
      const DeepCollectionEquality().hash(createSubOrganizationResultV4) ^
      const DeepCollectionEquality().hash(emailAuthResult) ^
      const DeepCollectionEquality().hash(exportWalletAccountResult) ^
      const DeepCollectionEquality().hash(initImportWalletResult) ^
      const DeepCollectionEquality().hash(importWalletResult) ^
      const DeepCollectionEquality().hash(initImportPrivateKeyResult) ^
      const DeepCollectionEquality().hash(importPrivateKeyResult) ^
      const DeepCollectionEquality().hash(createPoliciesResult) ^
      const DeepCollectionEquality().hash(signRawPayloadsResult) ^
      const DeepCollectionEquality().hash(createReadOnlySessionResult) ^
      const DeepCollectionEquality().hash(createOauthProvidersResult) ^
      const DeepCollectionEquality().hash(deleteOauthProvidersResult) ^
      const DeepCollectionEquality().hash(createSubOrganizationResultV5) ^
      const DeepCollectionEquality().hash(oauthResult) ^
      const DeepCollectionEquality().hash(createReadWriteSessionResult) ^
      const DeepCollectionEquality().hash(createSubOrganizationResultV6) ^
      const DeepCollectionEquality().hash(deletePrivateKeysResult) ^
      const DeepCollectionEquality().hash(deleteWalletsResult) ^
      const DeepCollectionEquality().hash(createReadWriteSessionResultV2) ^
      const DeepCollectionEquality().hash(deleteSubOrganizationResult) ^
      const DeepCollectionEquality().hash(initOtpAuthResult) ^
      const DeepCollectionEquality().hash(otpAuthResult) ^
      const DeepCollectionEquality().hash(createSubOrganizationResultV7) ^
      const DeepCollectionEquality().hash(updateWalletResult) ^
      const DeepCollectionEquality().hash(updatePolicyResultV2) ^
      const DeepCollectionEquality().hash(initOtpAuthResultV2) ^
      const DeepCollectionEquality().hash(initOtpResult) ^
      const DeepCollectionEquality().hash(verifyOtpResult) ^
      const DeepCollectionEquality().hash(otpLoginResult) ^
      const DeepCollectionEquality().hash(stampLoginResult) ^
      const DeepCollectionEquality().hash(oauthLoginResult) ^
      const DeepCollectionEquality().hash(updateUserNameResult) ^
      const DeepCollectionEquality().hash(updateUserEmailResult) ^
      const DeepCollectionEquality().hash(updateUserPhoneNumberResult) ^
      const DeepCollectionEquality().hash(initFiatOnRampResult) ^
      const DeepCollectionEquality().hash(createSmartContractInterfaceResult) ^
      const DeepCollectionEquality().hash(deleteSmartContractInterfaceResult) ^
      runtimeType.hashCode;
}

extension $ResultExtension on Result {
  Result copyWith(
      {CreateOrganizationResult? createOrganizationResult,
      CreateAuthenticatorsResult? createAuthenticatorsResult,
      CreateUsersResult? createUsersResult,
      CreatePrivateKeysResult? createPrivateKeysResult,
      CreateInvitationsResult? createInvitationsResult,
      AcceptInvitationResult? acceptInvitationResult,
      SignRawPayloadResult? signRawPayloadResult,
      CreatePolicyResult? createPolicyResult,
      DisablePrivateKeyResult? disablePrivateKeyResult,
      DeleteUsersResult? deleteUsersResult,
      DeleteAuthenticatorsResult? deleteAuthenticatorsResult,
      DeleteInvitationResult? deleteInvitationResult,
      DeleteOrganizationResult? deleteOrganizationResult,
      DeletePolicyResult? deletePolicyResult,
      CreateUserTagResult? createUserTagResult,
      DeleteUserTagsResult? deleteUserTagsResult,
      SignTransactionResult? signTransactionResult,
      DeleteApiKeysResult? deleteApiKeysResult,
      CreateApiKeysResult? createApiKeysResult,
      CreatePrivateKeyTagResult? createPrivateKeyTagResult,
      DeletePrivateKeyTagsResult? deletePrivateKeyTagsResult,
      SetPaymentMethodResult? setPaymentMethodResult,
      ActivateBillingTierResult? activateBillingTierResult,
      DeletePaymentMethodResult? deletePaymentMethodResult,
      CreateApiOnlyUsersResult? createApiOnlyUsersResult,
      UpdateRootQuorumResult? updateRootQuorumResult,
      UpdateUserTagResult? updateUserTagResult,
      UpdatePrivateKeyTagResult? updatePrivateKeyTagResult,
      CreateSubOrganizationResult? createSubOrganizationResult,
      UpdateAllowedOriginsResult? updateAllowedOriginsResult,
      CreatePrivateKeysResultV2? createPrivateKeysResultV2,
      UpdateUserResult? updateUserResult,
      UpdatePolicyResult? updatePolicyResult,
      CreateSubOrganizationResultV3? createSubOrganizationResultV3,
      CreateWalletResult? createWalletResult,
      CreateWalletAccountsResult? createWalletAccountsResult,
      InitUserEmailRecoveryResult? initUserEmailRecoveryResult,
      RecoverUserResult? recoverUserResult,
      SetOrganizationFeatureResult? setOrganizationFeatureResult,
      RemoveOrganizationFeatureResult? removeOrganizationFeatureResult,
      ExportPrivateKeyResult? exportPrivateKeyResult,
      ExportWalletResult? exportWalletResult,
      CreateSubOrganizationResultV4? createSubOrganizationResultV4,
      EmailAuthResult? emailAuthResult,
      ExportWalletAccountResult? exportWalletAccountResult,
      InitImportWalletResult? initImportWalletResult,
      ImportWalletResult? importWalletResult,
      InitImportPrivateKeyResult? initImportPrivateKeyResult,
      ImportPrivateKeyResult? importPrivateKeyResult,
      CreatePoliciesResult? createPoliciesResult,
      SignRawPayloadsResult? signRawPayloadsResult,
      CreateReadOnlySessionResult? createReadOnlySessionResult,
      CreateOauthProvidersResult? createOauthProvidersResult,
      DeleteOauthProvidersResult? deleteOauthProvidersResult,
      CreateSubOrganizationResultV5? createSubOrganizationResultV5,
      OauthResult? oauthResult,
      CreateReadWriteSessionResult? createReadWriteSessionResult,
      CreateSubOrganizationResultV6? createSubOrganizationResultV6,
      DeletePrivateKeysResult? deletePrivateKeysResult,
      DeleteWalletsResult? deleteWalletsResult,
      CreateReadWriteSessionResultV2? createReadWriteSessionResultV2,
      DeleteSubOrganizationResult? deleteSubOrganizationResult,
      InitOtpAuthResult? initOtpAuthResult,
      OtpAuthResult? otpAuthResult,
      CreateSubOrganizationResultV7? createSubOrganizationResultV7,
      UpdateWalletResult? updateWalletResult,
      UpdatePolicyResultV2? updatePolicyResultV2,
      InitOtpAuthResultV2? initOtpAuthResultV2,
      InitOtpResult? initOtpResult,
      VerifyOtpResult? verifyOtpResult,
      OtpLoginResult? otpLoginResult,
      StampLoginResult? stampLoginResult,
      OauthLoginResult? oauthLoginResult,
      UpdateUserNameResult? updateUserNameResult,
      UpdateUserEmailResult? updateUserEmailResult,
      UpdateUserPhoneNumberResult? updateUserPhoneNumberResult,
      InitFiatOnRampResult? initFiatOnRampResult,
      CreateSmartContractInterfaceResult? createSmartContractInterfaceResult,
      DeleteSmartContractInterfaceResult? deleteSmartContractInterfaceResult}) {
    return Result(
        createOrganizationResult:
            createOrganizationResult ?? this.createOrganizationResult,
        createAuthenticatorsResult:
            createAuthenticatorsResult ?? this.createAuthenticatorsResult,
        createUsersResult: createUsersResult ?? this.createUsersResult,
        createPrivateKeysResult:
            createPrivateKeysResult ?? this.createPrivateKeysResult,
        createInvitationsResult:
            createInvitationsResult ?? this.createInvitationsResult,
        acceptInvitationResult:
            acceptInvitationResult ?? this.acceptInvitationResult,
        signRawPayloadResult: signRawPayloadResult ?? this.signRawPayloadResult,
        createPolicyResult: createPolicyResult ?? this.createPolicyResult,
        disablePrivateKeyResult:
            disablePrivateKeyResult ?? this.disablePrivateKeyResult,
        deleteUsersResult: deleteUsersResult ?? this.deleteUsersResult,
        deleteAuthenticatorsResult:
            deleteAuthenticatorsResult ?? this.deleteAuthenticatorsResult,
        deleteInvitationResult:
            deleteInvitationResult ?? this.deleteInvitationResult,
        deleteOrganizationResult:
            deleteOrganizationResult ?? this.deleteOrganizationResult,
        deletePolicyResult: deletePolicyResult ?? this.deletePolicyResult,
        createUserTagResult: createUserTagResult ?? this.createUserTagResult,
        deleteUserTagsResult: deleteUserTagsResult ?? this.deleteUserTagsResult,
        signTransactionResult:
            signTransactionResult ?? this.signTransactionResult,
        deleteApiKeysResult: deleteApiKeysResult ?? this.deleteApiKeysResult,
        createApiKeysResult: createApiKeysResult ?? this.createApiKeysResult,
        createPrivateKeyTagResult:
            createPrivateKeyTagResult ?? this.createPrivateKeyTagResult,
        deletePrivateKeyTagsResult:
            deletePrivateKeyTagsResult ?? this.deletePrivateKeyTagsResult,
        setPaymentMethodResult:
            setPaymentMethodResult ?? this.setPaymentMethodResult,
        activateBillingTierResult:
            activateBillingTierResult ?? this.activateBillingTierResult,
        deletePaymentMethodResult:
            deletePaymentMethodResult ?? this.deletePaymentMethodResult,
        createApiOnlyUsersResult:
            createApiOnlyUsersResult ?? this.createApiOnlyUsersResult,
        updateRootQuorumResult:
            updateRootQuorumResult ?? this.updateRootQuorumResult,
        updateUserTagResult: updateUserTagResult ?? this.updateUserTagResult,
        updatePrivateKeyTagResult:
            updatePrivateKeyTagResult ?? this.updatePrivateKeyTagResult,
        createSubOrganizationResult:
            createSubOrganizationResult ?? this.createSubOrganizationResult,
        updateAllowedOriginsResult:
            updateAllowedOriginsResult ?? this.updateAllowedOriginsResult,
        createPrivateKeysResultV2:
            createPrivateKeysResultV2 ?? this.createPrivateKeysResultV2,
        updateUserResult: updateUserResult ?? this.updateUserResult,
        updatePolicyResult: updatePolicyResult ?? this.updatePolicyResult,
        createSubOrganizationResultV3:
            createSubOrganizationResultV3 ?? this.createSubOrganizationResultV3,
        createWalletResult: createWalletResult ?? this.createWalletResult,
        createWalletAccountsResult:
            createWalletAccountsResult ?? this.createWalletAccountsResult,
        initUserEmailRecoveryResult:
            initUserEmailRecoveryResult ?? this.initUserEmailRecoveryResult,
        recoverUserResult: recoverUserResult ?? this.recoverUserResult,
        setOrganizationFeatureResult:
            setOrganizationFeatureResult ?? this.setOrganizationFeatureResult,
        removeOrganizationFeatureResult: removeOrganizationFeatureResult ??
            this.removeOrganizationFeatureResult,
        exportPrivateKeyResult:
            exportPrivateKeyResult ?? this.exportPrivateKeyResult,
        exportWalletResult: exportWalletResult ?? this.exportWalletResult,
        createSubOrganizationResultV4:
            createSubOrganizationResultV4 ?? this.createSubOrganizationResultV4,
        emailAuthResult: emailAuthResult ?? this.emailAuthResult,
        exportWalletAccountResult:
            exportWalletAccountResult ?? this.exportWalletAccountResult,
        initImportWalletResult:
            initImportWalletResult ?? this.initImportWalletResult,
        importWalletResult: importWalletResult ?? this.importWalletResult,
        initImportPrivateKeyResult:
            initImportPrivateKeyResult ?? this.initImportPrivateKeyResult,
        importPrivateKeyResult:
            importPrivateKeyResult ?? this.importPrivateKeyResult,
        createPoliciesResult: createPoliciesResult ?? this.createPoliciesResult,
        signRawPayloadsResult:
            signRawPayloadsResult ?? this.signRawPayloadsResult,
        createReadOnlySessionResult:
            createReadOnlySessionResult ?? this.createReadOnlySessionResult,
        createOauthProvidersResult:
            createOauthProvidersResult ?? this.createOauthProvidersResult,
        deleteOauthProvidersResult:
            deleteOauthProvidersResult ?? this.deleteOauthProvidersResult,
        createSubOrganizationResultV5:
            createSubOrganizationResultV5 ?? this.createSubOrganizationResultV5,
        oauthResult: oauthResult ?? this.oauthResult,
        createReadWriteSessionResult:
            createReadWriteSessionResult ?? this.createReadWriteSessionResult,
        createSubOrganizationResultV6:
            createSubOrganizationResultV6 ?? this.createSubOrganizationResultV6,
        deletePrivateKeysResult:
            deletePrivateKeysResult ?? this.deletePrivateKeysResult,
        deleteWalletsResult: deleteWalletsResult ?? this.deleteWalletsResult,
        createReadWriteSessionResultV2: createReadWriteSessionResultV2 ??
            this.createReadWriteSessionResultV2,
        deleteSubOrganizationResult:
            deleteSubOrganizationResult ?? this.deleteSubOrganizationResult,
        initOtpAuthResult: initOtpAuthResult ?? this.initOtpAuthResult,
        otpAuthResult: otpAuthResult ?? this.otpAuthResult,
        createSubOrganizationResultV7:
            createSubOrganizationResultV7 ?? this.createSubOrganizationResultV7,
        updateWalletResult: updateWalletResult ?? this.updateWalletResult,
        updatePolicyResultV2: updatePolicyResultV2 ?? this.updatePolicyResultV2,
        initOtpAuthResultV2: initOtpAuthResultV2 ?? this.initOtpAuthResultV2,
        initOtpResult: initOtpResult ?? this.initOtpResult,
        verifyOtpResult: verifyOtpResult ?? this.verifyOtpResult,
        otpLoginResult: otpLoginResult ?? this.otpLoginResult,
        stampLoginResult: stampLoginResult ?? this.stampLoginResult,
        oauthLoginResult: oauthLoginResult ?? this.oauthLoginResult,
        updateUserNameResult: updateUserNameResult ?? this.updateUserNameResult,
        updateUserEmailResult:
            updateUserEmailResult ?? this.updateUserEmailResult,
        updateUserPhoneNumberResult:
            updateUserPhoneNumberResult ?? this.updateUserPhoneNumberResult,
        initFiatOnRampResult: initFiatOnRampResult ?? this.initFiatOnRampResult,
        createSmartContractInterfaceResult:
            createSmartContractInterfaceResult ??
                this.createSmartContractInterfaceResult,
        deleteSmartContractInterfaceResult:
            deleteSmartContractInterfaceResult ??
                this.deleteSmartContractInterfaceResult);
  }

  Result copyWithWrapped(
      {Wrapped<CreateOrganizationResult?>? createOrganizationResult,
      Wrapped<CreateAuthenticatorsResult?>? createAuthenticatorsResult,
      Wrapped<CreateUsersResult?>? createUsersResult,
      Wrapped<CreatePrivateKeysResult?>? createPrivateKeysResult,
      Wrapped<CreateInvitationsResult?>? createInvitationsResult,
      Wrapped<AcceptInvitationResult?>? acceptInvitationResult,
      Wrapped<SignRawPayloadResult?>? signRawPayloadResult,
      Wrapped<CreatePolicyResult?>? createPolicyResult,
      Wrapped<DisablePrivateKeyResult?>? disablePrivateKeyResult,
      Wrapped<DeleteUsersResult?>? deleteUsersResult,
      Wrapped<DeleteAuthenticatorsResult?>? deleteAuthenticatorsResult,
      Wrapped<DeleteInvitationResult?>? deleteInvitationResult,
      Wrapped<DeleteOrganizationResult?>? deleteOrganizationResult,
      Wrapped<DeletePolicyResult?>? deletePolicyResult,
      Wrapped<CreateUserTagResult?>? createUserTagResult,
      Wrapped<DeleteUserTagsResult?>? deleteUserTagsResult,
      Wrapped<SignTransactionResult?>? signTransactionResult,
      Wrapped<DeleteApiKeysResult?>? deleteApiKeysResult,
      Wrapped<CreateApiKeysResult?>? createApiKeysResult,
      Wrapped<CreatePrivateKeyTagResult?>? createPrivateKeyTagResult,
      Wrapped<DeletePrivateKeyTagsResult?>? deletePrivateKeyTagsResult,
      Wrapped<SetPaymentMethodResult?>? setPaymentMethodResult,
      Wrapped<ActivateBillingTierResult?>? activateBillingTierResult,
      Wrapped<DeletePaymentMethodResult?>? deletePaymentMethodResult,
      Wrapped<CreateApiOnlyUsersResult?>? createApiOnlyUsersResult,
      Wrapped<UpdateRootQuorumResult?>? updateRootQuorumResult,
      Wrapped<UpdateUserTagResult?>? updateUserTagResult,
      Wrapped<UpdatePrivateKeyTagResult?>? updatePrivateKeyTagResult,
      Wrapped<CreateSubOrganizationResult?>? createSubOrganizationResult,
      Wrapped<UpdateAllowedOriginsResult?>? updateAllowedOriginsResult,
      Wrapped<CreatePrivateKeysResultV2?>? createPrivateKeysResultV2,
      Wrapped<UpdateUserResult?>? updateUserResult,
      Wrapped<UpdatePolicyResult?>? updatePolicyResult,
      Wrapped<CreateSubOrganizationResultV3?>? createSubOrganizationResultV3,
      Wrapped<CreateWalletResult?>? createWalletResult,
      Wrapped<CreateWalletAccountsResult?>? createWalletAccountsResult,
      Wrapped<InitUserEmailRecoveryResult?>? initUserEmailRecoveryResult,
      Wrapped<RecoverUserResult?>? recoverUserResult,
      Wrapped<SetOrganizationFeatureResult?>? setOrganizationFeatureResult,
      Wrapped<RemoveOrganizationFeatureResult?>?
          removeOrganizationFeatureResult,
      Wrapped<ExportPrivateKeyResult?>? exportPrivateKeyResult,
      Wrapped<ExportWalletResult?>? exportWalletResult,
      Wrapped<CreateSubOrganizationResultV4?>? createSubOrganizationResultV4,
      Wrapped<EmailAuthResult?>? emailAuthResult,
      Wrapped<ExportWalletAccountResult?>? exportWalletAccountResult,
      Wrapped<InitImportWalletResult?>? initImportWalletResult,
      Wrapped<ImportWalletResult?>? importWalletResult,
      Wrapped<InitImportPrivateKeyResult?>? initImportPrivateKeyResult,
      Wrapped<ImportPrivateKeyResult?>? importPrivateKeyResult,
      Wrapped<CreatePoliciesResult?>? createPoliciesResult,
      Wrapped<SignRawPayloadsResult?>? signRawPayloadsResult,
      Wrapped<CreateReadOnlySessionResult?>? createReadOnlySessionResult,
      Wrapped<CreateOauthProvidersResult?>? createOauthProvidersResult,
      Wrapped<DeleteOauthProvidersResult?>? deleteOauthProvidersResult,
      Wrapped<CreateSubOrganizationResultV5?>? createSubOrganizationResultV5,
      Wrapped<OauthResult?>? oauthResult,
      Wrapped<CreateReadWriteSessionResult?>? createReadWriteSessionResult,
      Wrapped<CreateSubOrganizationResultV6?>? createSubOrganizationResultV6,
      Wrapped<DeletePrivateKeysResult?>? deletePrivateKeysResult,
      Wrapped<DeleteWalletsResult?>? deleteWalletsResult,
      Wrapped<CreateReadWriteSessionResultV2?>? createReadWriteSessionResultV2,
      Wrapped<DeleteSubOrganizationResult?>? deleteSubOrganizationResult,
      Wrapped<InitOtpAuthResult?>? initOtpAuthResult,
      Wrapped<OtpAuthResult?>? otpAuthResult,
      Wrapped<CreateSubOrganizationResultV7?>? createSubOrganizationResultV7,
      Wrapped<UpdateWalletResult?>? updateWalletResult,
      Wrapped<UpdatePolicyResultV2?>? updatePolicyResultV2,
      Wrapped<InitOtpAuthResultV2?>? initOtpAuthResultV2,
      Wrapped<InitOtpResult?>? initOtpResult,
      Wrapped<VerifyOtpResult?>? verifyOtpResult,
      Wrapped<OtpLoginResult?>? otpLoginResult,
      Wrapped<StampLoginResult?>? stampLoginResult,
      Wrapped<OauthLoginResult?>? oauthLoginResult,
      Wrapped<UpdateUserNameResult?>? updateUserNameResult,
      Wrapped<UpdateUserEmailResult?>? updateUserEmailResult,
      Wrapped<UpdateUserPhoneNumberResult?>? updateUserPhoneNumberResult,
      Wrapped<InitFiatOnRampResult?>? initFiatOnRampResult,
      Wrapped<CreateSmartContractInterfaceResult?>?
          createSmartContractInterfaceResult,
      Wrapped<DeleteSmartContractInterfaceResult?>?
          deleteSmartContractInterfaceResult}) {
    return Result(
        createOrganizationResult: (createOrganizationResult != null
            ? createOrganizationResult.value
            : this.createOrganizationResult),
        createAuthenticatorsResult: (createAuthenticatorsResult != null
            ? createAuthenticatorsResult.value
            : this.createAuthenticatorsResult),
        createUsersResult: (createUsersResult != null
            ? createUsersResult.value
            : this.createUsersResult),
        createPrivateKeysResult: (createPrivateKeysResult != null
            ? createPrivateKeysResult.value
            : this.createPrivateKeysResult),
        createInvitationsResult: (createInvitationsResult != null
            ? createInvitationsResult.value
            : this.createInvitationsResult),
        acceptInvitationResult: (acceptInvitationResult != null
            ? acceptInvitationResult.value
            : this.acceptInvitationResult),
        signRawPayloadResult: (signRawPayloadResult != null
            ? signRawPayloadResult.value
            : this.signRawPayloadResult),
        createPolicyResult: (createPolicyResult != null
            ? createPolicyResult.value
            : this.createPolicyResult),
        disablePrivateKeyResult: (disablePrivateKeyResult != null
            ? disablePrivateKeyResult.value
            : this.disablePrivateKeyResult),
        deleteUsersResult: (deleteUsersResult != null
            ? deleteUsersResult.value
            : this.deleteUsersResult),
        deleteAuthenticatorsResult: (deleteAuthenticatorsResult != null
            ? deleteAuthenticatorsResult.value
            : this.deleteAuthenticatorsResult),
        deleteInvitationResult: (deleteInvitationResult != null
            ? deleteInvitationResult.value
            : this.deleteInvitationResult),
        deleteOrganizationResult: (deleteOrganizationResult != null
            ? deleteOrganizationResult.value
            : this.deleteOrganizationResult),
        deletePolicyResult: (deletePolicyResult != null
            ? deletePolicyResult.value
            : this.deletePolicyResult),
        createUserTagResult: (createUserTagResult != null
            ? createUserTagResult.value
            : this.createUserTagResult),
        deleteUserTagsResult: (deleteUserTagsResult != null
            ? deleteUserTagsResult.value
            : this.deleteUserTagsResult),
        signTransactionResult: (signTransactionResult != null
            ? signTransactionResult.value
            : this.signTransactionResult),
        deleteApiKeysResult: (deleteApiKeysResult != null
            ? deleteApiKeysResult.value
            : this.deleteApiKeysResult),
        createApiKeysResult: (createApiKeysResult != null
            ? createApiKeysResult.value
            : this.createApiKeysResult),
        createPrivateKeyTagResult: (createPrivateKeyTagResult != null
            ? createPrivateKeyTagResult.value
            : this.createPrivateKeyTagResult),
        deletePrivateKeyTagsResult: (deletePrivateKeyTagsResult != null
            ? deletePrivateKeyTagsResult.value
            : this.deletePrivateKeyTagsResult),
        setPaymentMethodResult: (setPaymentMethodResult != null
            ? setPaymentMethodResult.value
            : this.setPaymentMethodResult),
        activateBillingTierResult: (activateBillingTierResult != null
            ? activateBillingTierResult.value
            : this.activateBillingTierResult),
        deletePaymentMethodResult: (deletePaymentMethodResult != null
            ? deletePaymentMethodResult.value
            : this.deletePaymentMethodResult),
        createApiOnlyUsersResult: (createApiOnlyUsersResult != null
            ? createApiOnlyUsersResult.value
            : this.createApiOnlyUsersResult),
        updateRootQuorumResult: (updateRootQuorumResult != null
            ? updateRootQuorumResult.value
            : this.updateRootQuorumResult),
        updateUserTagResult: (updateUserTagResult != null
            ? updateUserTagResult.value
            : this.updateUserTagResult),
        updatePrivateKeyTagResult: (updatePrivateKeyTagResult != null
            ? updatePrivateKeyTagResult.value
            : this.updatePrivateKeyTagResult),
        createSubOrganizationResult: (createSubOrganizationResult != null
            ? createSubOrganizationResult.value
            : this.createSubOrganizationResult),
        updateAllowedOriginsResult: (updateAllowedOriginsResult != null
            ? updateAllowedOriginsResult.value
            : this.updateAllowedOriginsResult),
        createPrivateKeysResultV2: (createPrivateKeysResultV2 != null
            ? createPrivateKeysResultV2.value
            : this.createPrivateKeysResultV2),
        updateUserResult: (updateUserResult != null
            ? updateUserResult.value
            : this.updateUserResult),
        updatePolicyResult: (updatePolicyResult != null
            ? updatePolicyResult.value
            : this.updatePolicyResult),
        createSubOrganizationResultV3: (createSubOrganizationResultV3 != null
            ? createSubOrganizationResultV3.value
            : this.createSubOrganizationResultV3),
        createWalletResult: (createWalletResult != null
            ? createWalletResult.value
            : this.createWalletResult),
        createWalletAccountsResult: (createWalletAccountsResult != null
            ? createWalletAccountsResult.value
            : this.createWalletAccountsResult),
        initUserEmailRecoveryResult: (initUserEmailRecoveryResult != null
            ? initUserEmailRecoveryResult.value
            : this.initUserEmailRecoveryResult),
        recoverUserResult: (recoverUserResult != null
            ? recoverUserResult.value
            : this.recoverUserResult),
        setOrganizationFeatureResult: (setOrganizationFeatureResult != null
            ? setOrganizationFeatureResult.value
            : this.setOrganizationFeatureResult),
        removeOrganizationFeatureResult: (removeOrganizationFeatureResult != null
            ? removeOrganizationFeatureResult.value
            : this.removeOrganizationFeatureResult),
        exportPrivateKeyResult: (exportPrivateKeyResult != null
            ? exportPrivateKeyResult.value
            : this.exportPrivateKeyResult),
        exportWalletResult: (exportWalletResult != null
            ? exportWalletResult.value
            : this.exportWalletResult),
        createSubOrganizationResultV4: (createSubOrganizationResultV4 != null
            ? createSubOrganizationResultV4.value
            : this.createSubOrganizationResultV4),
        emailAuthResult: (emailAuthResult != null
            ? emailAuthResult.value
            : this.emailAuthResult),
        exportWalletAccountResult: (exportWalletAccountResult != null
            ? exportWalletAccountResult.value
            : this.exportWalletAccountResult),
        initImportWalletResult: (initImportWalletResult != null
            ? initImportWalletResult.value
            : this.initImportWalletResult),
        importWalletResult: (importWalletResult != null
            ? importWalletResult.value
            : this.importWalletResult),
        initImportPrivateKeyResult: (initImportPrivateKeyResult != null
            ? initImportPrivateKeyResult.value
            : this.initImportPrivateKeyResult),
        importPrivateKeyResult: (importPrivateKeyResult != null
            ? importPrivateKeyResult.value
            : this.importPrivateKeyResult),
        createPoliciesResult: (createPoliciesResult != null
            ? createPoliciesResult.value
            : this.createPoliciesResult),
        signRawPayloadsResult: (signRawPayloadsResult != null
            ? signRawPayloadsResult.value
            : this.signRawPayloadsResult),
        createReadOnlySessionResult: (createReadOnlySessionResult != null
            ? createReadOnlySessionResult.value
            : this.createReadOnlySessionResult),
        createOauthProvidersResult: (createOauthProvidersResult != null
            ? createOauthProvidersResult.value
            : this.createOauthProvidersResult),
        deleteOauthProvidersResult: (deleteOauthProvidersResult != null
            ? deleteOauthProvidersResult.value
            : this.deleteOauthProvidersResult),
        createSubOrganizationResultV5: (createSubOrganizationResultV5 != null ? createSubOrganizationResultV5.value : this.createSubOrganizationResultV5),
        oauthResult: (oauthResult != null ? oauthResult.value : this.oauthResult),
        createReadWriteSessionResult: (createReadWriteSessionResult != null ? createReadWriteSessionResult.value : this.createReadWriteSessionResult),
        createSubOrganizationResultV6: (createSubOrganizationResultV6 != null ? createSubOrganizationResultV6.value : this.createSubOrganizationResultV6),
        deletePrivateKeysResult: (deletePrivateKeysResult != null ? deletePrivateKeysResult.value : this.deletePrivateKeysResult),
        deleteWalletsResult: (deleteWalletsResult != null ? deleteWalletsResult.value : this.deleteWalletsResult),
        createReadWriteSessionResultV2: (createReadWriteSessionResultV2 != null ? createReadWriteSessionResultV2.value : this.createReadWriteSessionResultV2),
        deleteSubOrganizationResult: (deleteSubOrganizationResult != null ? deleteSubOrganizationResult.value : this.deleteSubOrganizationResult),
        initOtpAuthResult: (initOtpAuthResult != null ? initOtpAuthResult.value : this.initOtpAuthResult),
        otpAuthResult: (otpAuthResult != null ? otpAuthResult.value : this.otpAuthResult),
        createSubOrganizationResultV7: (createSubOrganizationResultV7 != null ? createSubOrganizationResultV7.value : this.createSubOrganizationResultV7),
        updateWalletResult: (updateWalletResult != null ? updateWalletResult.value : this.updateWalletResult),
        updatePolicyResultV2: (updatePolicyResultV2 != null ? updatePolicyResultV2.value : this.updatePolicyResultV2),
        initOtpAuthResultV2: (initOtpAuthResultV2 != null ? initOtpAuthResultV2.value : this.initOtpAuthResultV2),
        initOtpResult: (initOtpResult != null ? initOtpResult.value : this.initOtpResult),
        verifyOtpResult: (verifyOtpResult != null ? verifyOtpResult.value : this.verifyOtpResult),
        otpLoginResult: (otpLoginResult != null ? otpLoginResult.value : this.otpLoginResult),
        stampLoginResult: (stampLoginResult != null ? stampLoginResult.value : this.stampLoginResult),
        oauthLoginResult: (oauthLoginResult != null ? oauthLoginResult.value : this.oauthLoginResult),
        updateUserNameResult: (updateUserNameResult != null ? updateUserNameResult.value : this.updateUserNameResult),
        updateUserEmailResult: (updateUserEmailResult != null ? updateUserEmailResult.value : this.updateUserEmailResult),
        updateUserPhoneNumberResult: (updateUserPhoneNumberResult != null ? updateUserPhoneNumberResult.value : this.updateUserPhoneNumberResult),
        initFiatOnRampResult: (initFiatOnRampResult != null ? initFiatOnRampResult.value : this.initFiatOnRampResult),
        createSmartContractInterfaceResult: (createSmartContractInterfaceResult != null ? createSmartContractInterfaceResult.value : this.createSmartContractInterfaceResult),
        deleteSmartContractInterfaceResult: (deleteSmartContractInterfaceResult != null ? deleteSmartContractInterfaceResult.value : this.deleteSmartContractInterfaceResult));
  }
}

@JsonSerializable(explicitToJson: true)
class RootUserParams {
  const RootUserParams({
    required this.userName,
    this.userEmail,
    required this.apiKeys,
    required this.authenticators,
  });

  factory RootUserParams.fromJson(Map<String, dynamic> json) =>
      _$RootUserParamsFromJson(json);

  static const toJsonFactory = _$RootUserParamsToJson;
  Map<String, dynamic> toJson() => _$RootUserParamsToJson(this);

  @JsonKey(name: 'userName')
  final String userName;
  @JsonKey(name: 'userEmail')
  final String? userEmail;
  @JsonKey(name: 'apiKeys', defaultValue: <ApiKeyParams>[])
  final List<ApiKeyParams> apiKeys;
  @JsonKey(name: 'authenticators', defaultValue: <AuthenticatorParamsV2>[])
  final List<AuthenticatorParamsV2> authenticators;
  static const fromJsonFactory = _$RootUserParamsFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is RootUserParams &&
            (identical(other.userName, userName) ||
                const DeepCollectionEquality()
                    .equals(other.userName, userName)) &&
            (identical(other.userEmail, userEmail) ||
                const DeepCollectionEquality()
                    .equals(other.userEmail, userEmail)) &&
            (identical(other.apiKeys, apiKeys) ||
                const DeepCollectionEquality()
                    .equals(other.apiKeys, apiKeys)) &&
            (identical(other.authenticators, authenticators) ||
                const DeepCollectionEquality()
                    .equals(other.authenticators, authenticators)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(userName) ^
      const DeepCollectionEquality().hash(userEmail) ^
      const DeepCollectionEquality().hash(apiKeys) ^
      const DeepCollectionEquality().hash(authenticators) ^
      runtimeType.hashCode;
}

extension $RootUserParamsExtension on RootUserParams {
  RootUserParams copyWith(
      {String? userName,
      String? userEmail,
      List<ApiKeyParams>? apiKeys,
      List<AuthenticatorParamsV2>? authenticators}) {
    return RootUserParams(
        userName: userName ?? this.userName,
        userEmail: userEmail ?? this.userEmail,
        apiKeys: apiKeys ?? this.apiKeys,
        authenticators: authenticators ?? this.authenticators);
  }

  RootUserParams copyWithWrapped(
      {Wrapped<String>? userName,
      Wrapped<String?>? userEmail,
      Wrapped<List<ApiKeyParams>>? apiKeys,
      Wrapped<List<AuthenticatorParamsV2>>? authenticators}) {
    return RootUserParams(
        userName: (userName != null ? userName.value : this.userName),
        userEmail: (userEmail != null ? userEmail.value : this.userEmail),
        apiKeys: (apiKeys != null ? apiKeys.value : this.apiKeys),
        authenticators: (authenticators != null
            ? authenticators.value
            : this.authenticators));
  }
}

@JsonSerializable(explicitToJson: true)
class RootUserParamsV2 {
  const RootUserParamsV2({
    required this.userName,
    this.userEmail,
    required this.apiKeys,
    required this.authenticators,
    required this.oauthProviders,
  });

  factory RootUserParamsV2.fromJson(Map<String, dynamic> json) =>
      _$RootUserParamsV2FromJson(json);

  static const toJsonFactory = _$RootUserParamsV2ToJson;
  Map<String, dynamic> toJson() => _$RootUserParamsV2ToJson(this);

  @JsonKey(name: 'userName')
  final String userName;
  @JsonKey(name: 'userEmail')
  final String? userEmail;
  @JsonKey(name: 'apiKeys', defaultValue: <ApiKeyParams>[])
  final List<ApiKeyParams> apiKeys;
  @JsonKey(name: 'authenticators', defaultValue: <AuthenticatorParamsV2>[])
  final List<AuthenticatorParamsV2> authenticators;
  @JsonKey(name: 'oauthProviders', defaultValue: <OauthProviderParams>[])
  final List<OauthProviderParams> oauthProviders;
  static const fromJsonFactory = _$RootUserParamsV2FromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is RootUserParamsV2 &&
            (identical(other.userName, userName) ||
                const DeepCollectionEquality()
                    .equals(other.userName, userName)) &&
            (identical(other.userEmail, userEmail) ||
                const DeepCollectionEquality()
                    .equals(other.userEmail, userEmail)) &&
            (identical(other.apiKeys, apiKeys) ||
                const DeepCollectionEquality()
                    .equals(other.apiKeys, apiKeys)) &&
            (identical(other.authenticators, authenticators) ||
                const DeepCollectionEquality()
                    .equals(other.authenticators, authenticators)) &&
            (identical(other.oauthProviders, oauthProviders) ||
                const DeepCollectionEquality()
                    .equals(other.oauthProviders, oauthProviders)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(userName) ^
      const DeepCollectionEquality().hash(userEmail) ^
      const DeepCollectionEquality().hash(apiKeys) ^
      const DeepCollectionEquality().hash(authenticators) ^
      const DeepCollectionEquality().hash(oauthProviders) ^
      runtimeType.hashCode;
}

extension $RootUserParamsV2Extension on RootUserParamsV2 {
  RootUserParamsV2 copyWith(
      {String? userName,
      String? userEmail,
      List<ApiKeyParams>? apiKeys,
      List<AuthenticatorParamsV2>? authenticators,
      List<OauthProviderParams>? oauthProviders}) {
    return RootUserParamsV2(
        userName: userName ?? this.userName,
        userEmail: userEmail ?? this.userEmail,
        apiKeys: apiKeys ?? this.apiKeys,
        authenticators: authenticators ?? this.authenticators,
        oauthProviders: oauthProviders ?? this.oauthProviders);
  }

  RootUserParamsV2 copyWithWrapped(
      {Wrapped<String>? userName,
      Wrapped<String?>? userEmail,
      Wrapped<List<ApiKeyParams>>? apiKeys,
      Wrapped<List<AuthenticatorParamsV2>>? authenticators,
      Wrapped<List<OauthProviderParams>>? oauthProviders}) {
    return RootUserParamsV2(
        userName: (userName != null ? userName.value : this.userName),
        userEmail: (userEmail != null ? userEmail.value : this.userEmail),
        apiKeys: (apiKeys != null ? apiKeys.value : this.apiKeys),
        authenticators: (authenticators != null
            ? authenticators.value
            : this.authenticators),
        oauthProviders: (oauthProviders != null
            ? oauthProviders.value
            : this.oauthProviders));
  }
}

@JsonSerializable(explicitToJson: true)
class RootUserParamsV3 {
  const RootUserParamsV3({
    required this.userName,
    this.userEmail,
    required this.apiKeys,
    required this.authenticators,
    required this.oauthProviders,
  });

  factory RootUserParamsV3.fromJson(Map<String, dynamic> json) =>
      _$RootUserParamsV3FromJson(json);

  static const toJsonFactory = _$RootUserParamsV3ToJson;
  Map<String, dynamic> toJson() => _$RootUserParamsV3ToJson(this);

  @JsonKey(name: 'userName')
  final String userName;
  @JsonKey(name: 'userEmail')
  final String? userEmail;
  @JsonKey(name: 'apiKeys', defaultValue: <ApiKeyParamsV2>[])
  final List<ApiKeyParamsV2> apiKeys;
  @JsonKey(name: 'authenticators', defaultValue: <AuthenticatorParamsV2>[])
  final List<AuthenticatorParamsV2> authenticators;
  @JsonKey(name: 'oauthProviders', defaultValue: <OauthProviderParams>[])
  final List<OauthProviderParams> oauthProviders;
  static const fromJsonFactory = _$RootUserParamsV3FromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is RootUserParamsV3 &&
            (identical(other.userName, userName) ||
                const DeepCollectionEquality()
                    .equals(other.userName, userName)) &&
            (identical(other.userEmail, userEmail) ||
                const DeepCollectionEquality()
                    .equals(other.userEmail, userEmail)) &&
            (identical(other.apiKeys, apiKeys) ||
                const DeepCollectionEquality()
                    .equals(other.apiKeys, apiKeys)) &&
            (identical(other.authenticators, authenticators) ||
                const DeepCollectionEquality()
                    .equals(other.authenticators, authenticators)) &&
            (identical(other.oauthProviders, oauthProviders) ||
                const DeepCollectionEquality()
                    .equals(other.oauthProviders, oauthProviders)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(userName) ^
      const DeepCollectionEquality().hash(userEmail) ^
      const DeepCollectionEquality().hash(apiKeys) ^
      const DeepCollectionEquality().hash(authenticators) ^
      const DeepCollectionEquality().hash(oauthProviders) ^
      runtimeType.hashCode;
}

extension $RootUserParamsV3Extension on RootUserParamsV3 {
  RootUserParamsV3 copyWith(
      {String? userName,
      String? userEmail,
      List<ApiKeyParamsV2>? apiKeys,
      List<AuthenticatorParamsV2>? authenticators,
      List<OauthProviderParams>? oauthProviders}) {
    return RootUserParamsV3(
        userName: userName ?? this.userName,
        userEmail: userEmail ?? this.userEmail,
        apiKeys: apiKeys ?? this.apiKeys,
        authenticators: authenticators ?? this.authenticators,
        oauthProviders: oauthProviders ?? this.oauthProviders);
  }

  RootUserParamsV3 copyWithWrapped(
      {Wrapped<String>? userName,
      Wrapped<String?>? userEmail,
      Wrapped<List<ApiKeyParamsV2>>? apiKeys,
      Wrapped<List<AuthenticatorParamsV2>>? authenticators,
      Wrapped<List<OauthProviderParams>>? oauthProviders}) {
    return RootUserParamsV3(
        userName: (userName != null ? userName.value : this.userName),
        userEmail: (userEmail != null ? userEmail.value : this.userEmail),
        apiKeys: (apiKeys != null ? apiKeys.value : this.apiKeys),
        authenticators: (authenticators != null
            ? authenticators.value
            : this.authenticators),
        oauthProviders: (oauthProviders != null
            ? oauthProviders.value
            : this.oauthProviders));
  }
}

@JsonSerializable(explicitToJson: true)
class RootUserParamsV4 {
  const RootUserParamsV4({
    required this.userName,
    this.userEmail,
    this.userPhoneNumber,
    required this.apiKeys,
    required this.authenticators,
    required this.oauthProviders,
  });

  factory RootUserParamsV4.fromJson(Map<String, dynamic> json) =>
      _$RootUserParamsV4FromJson(json);

  static const toJsonFactory = _$RootUserParamsV4ToJson;
  Map<String, dynamic> toJson() => _$RootUserParamsV4ToJson(this);

  @JsonKey(name: 'userName')
  final String userName;
  @JsonKey(name: 'userEmail')
  final String? userEmail;
  @JsonKey(name: 'userPhoneNumber')
  final String? userPhoneNumber;
  @JsonKey(name: 'apiKeys', defaultValue: <ApiKeyParamsV2>[])
  final List<ApiKeyParamsV2> apiKeys;
  @JsonKey(name: 'authenticators', defaultValue: <AuthenticatorParamsV2>[])
  final List<AuthenticatorParamsV2> authenticators;
  @JsonKey(name: 'oauthProviders', defaultValue: <OauthProviderParams>[])
  final List<OauthProviderParams> oauthProviders;
  static const fromJsonFactory = _$RootUserParamsV4FromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is RootUserParamsV4 &&
            (identical(other.userName, userName) ||
                const DeepCollectionEquality()
                    .equals(other.userName, userName)) &&
            (identical(other.userEmail, userEmail) ||
                const DeepCollectionEquality()
                    .equals(other.userEmail, userEmail)) &&
            (identical(other.userPhoneNumber, userPhoneNumber) ||
                const DeepCollectionEquality()
                    .equals(other.userPhoneNumber, userPhoneNumber)) &&
            (identical(other.apiKeys, apiKeys) ||
                const DeepCollectionEquality()
                    .equals(other.apiKeys, apiKeys)) &&
            (identical(other.authenticators, authenticators) ||
                const DeepCollectionEquality()
                    .equals(other.authenticators, authenticators)) &&
            (identical(other.oauthProviders, oauthProviders) ||
                const DeepCollectionEquality()
                    .equals(other.oauthProviders, oauthProviders)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(userName) ^
      const DeepCollectionEquality().hash(userEmail) ^
      const DeepCollectionEquality().hash(userPhoneNumber) ^
      const DeepCollectionEquality().hash(apiKeys) ^
      const DeepCollectionEquality().hash(authenticators) ^
      const DeepCollectionEquality().hash(oauthProviders) ^
      runtimeType.hashCode;
}

extension $RootUserParamsV4Extension on RootUserParamsV4 {
  RootUserParamsV4 copyWith(
      {String? userName,
      String? userEmail,
      String? userPhoneNumber,
      List<ApiKeyParamsV2>? apiKeys,
      List<AuthenticatorParamsV2>? authenticators,
      List<OauthProviderParams>? oauthProviders}) {
    return RootUserParamsV4(
        userName: userName ?? this.userName,
        userEmail: userEmail ?? this.userEmail,
        userPhoneNumber: userPhoneNumber ?? this.userPhoneNumber,
        apiKeys: apiKeys ?? this.apiKeys,
        authenticators: authenticators ?? this.authenticators,
        oauthProviders: oauthProviders ?? this.oauthProviders);
  }

  RootUserParamsV4 copyWithWrapped(
      {Wrapped<String>? userName,
      Wrapped<String?>? userEmail,
      Wrapped<String?>? userPhoneNumber,
      Wrapped<List<ApiKeyParamsV2>>? apiKeys,
      Wrapped<List<AuthenticatorParamsV2>>? authenticators,
      Wrapped<List<OauthProviderParams>>? oauthProviders}) {
    return RootUserParamsV4(
        userName: (userName != null ? userName.value : this.userName),
        userEmail: (userEmail != null ? userEmail.value : this.userEmail),
        userPhoneNumber: (userPhoneNumber != null
            ? userPhoneNumber.value
            : this.userPhoneNumber),
        apiKeys: (apiKeys != null ? apiKeys.value : this.apiKeys),
        authenticators: (authenticators != null
            ? authenticators.value
            : this.authenticators),
        oauthProviders: (oauthProviders != null
            ? oauthProviders.value
            : this.oauthProviders));
  }
}

@JsonSerializable(explicitToJson: true)
class Selector {
  const Selector({
    this.subject,
    this.$operator,
    this.target,
  });

  factory Selector.fromJson(Map<String, dynamic> json) =>
      _$SelectorFromJson(json);

  static const toJsonFactory = _$SelectorToJson;
  Map<String, dynamic> toJson() => _$SelectorToJson(this);

  @JsonKey(name: 'subject')
  final String? subject;
  @JsonKey(
    name: 'operator',
    toJson: operatorNullableToJson,
    fromJson: operatorNullableFromJson,
  )
  final enums.Operator? $operator;
  @JsonKey(name: 'target')
  final String? target;
  static const fromJsonFactory = _$SelectorFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is Selector &&
            (identical(other.subject, subject) ||
                const DeepCollectionEquality()
                    .equals(other.subject, subject)) &&
            (identical(other.$operator, $operator) ||
                const DeepCollectionEquality()
                    .equals(other.$operator, $operator)) &&
            (identical(other.target, target) ||
                const DeepCollectionEquality().equals(other.target, target)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(subject) ^
      const DeepCollectionEquality().hash($operator) ^
      const DeepCollectionEquality().hash(target) ^
      runtimeType.hashCode;
}

extension $SelectorExtension on Selector {
  Selector copyWith(
      {String? subject, enums.Operator? $operator, String? target}) {
    return Selector(
        subject: subject ?? this.subject,
        $operator: $operator ?? this.$operator,
        target: target ?? this.target);
  }

  Selector copyWithWrapped(
      {Wrapped<String?>? subject,
      Wrapped<enums.Operator?>? $operator,
      Wrapped<String?>? target}) {
    return Selector(
        subject: (subject != null ? subject.value : this.subject),
        $operator: ($operator != null ? $operator.value : this.$operator),
        target: (target != null ? target.value : this.target));
  }
}

@JsonSerializable(explicitToJson: true)
class SelectorV2 {
  const SelectorV2({
    this.subject,
    this.$operator,
    this.targets,
  });

  factory SelectorV2.fromJson(Map<String, dynamic> json) =>
      _$SelectorV2FromJson(json);

  static const toJsonFactory = _$SelectorV2ToJson;
  Map<String, dynamic> toJson() => _$SelectorV2ToJson(this);

  @JsonKey(name: 'subject')
  final String? subject;
  @JsonKey(
    name: 'operator',
    toJson: operatorNullableToJson,
    fromJson: operatorNullableFromJson,
  )
  final enums.Operator? $operator;
  @JsonKey(name: 'targets', defaultValue: <String>[])
  final List<String>? targets;
  static const fromJsonFactory = _$SelectorV2FromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is SelectorV2 &&
            (identical(other.subject, subject) ||
                const DeepCollectionEquality()
                    .equals(other.subject, subject)) &&
            (identical(other.$operator, $operator) ||
                const DeepCollectionEquality()
                    .equals(other.$operator, $operator)) &&
            (identical(other.targets, targets) ||
                const DeepCollectionEquality().equals(other.targets, targets)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(subject) ^
      const DeepCollectionEquality().hash($operator) ^
      const DeepCollectionEquality().hash(targets) ^
      runtimeType.hashCode;
}

extension $SelectorV2Extension on SelectorV2 {
  SelectorV2 copyWith(
      {String? subject, enums.Operator? $operator, List<String>? targets}) {
    return SelectorV2(
        subject: subject ?? this.subject,
        $operator: $operator ?? this.$operator,
        targets: targets ?? this.targets);
  }

  SelectorV2 copyWithWrapped(
      {Wrapped<String?>? subject,
      Wrapped<enums.Operator?>? $operator,
      Wrapped<List<String>?>? targets}) {
    return SelectorV2(
        subject: (subject != null ? subject.value : this.subject),
        $operator: ($operator != null ? $operator.value : this.$operator),
        targets: (targets != null ? targets.value : this.targets));
  }
}

@JsonSerializable(explicitToJson: true)
class SetOrganizationFeatureIntent {
  const SetOrganizationFeatureIntent({
    required this.name,
    this.$value,
  });

  factory SetOrganizationFeatureIntent.fromJson(Map<String, dynamic> json) =>
      _$SetOrganizationFeatureIntentFromJson(json);

  static const toJsonFactory = _$SetOrganizationFeatureIntentToJson;
  Map<String, dynamic> toJson() => _$SetOrganizationFeatureIntentToJson(this);

  @JsonKey(
    name: 'name',
    toJson: featureNameToJson,
    fromJson: featureNameFromJson,
  )
  final enums.FeatureName name;
  @JsonKey(name: 'value')
  final String? $value;
  static const fromJsonFactory = _$SetOrganizationFeatureIntentFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is SetOrganizationFeatureIntent &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.$value, $value) ||
                const DeepCollectionEquality().equals(other.$value, $value)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash($value) ^
      runtimeType.hashCode;
}

extension $SetOrganizationFeatureIntentExtension
    on SetOrganizationFeatureIntent {
  SetOrganizationFeatureIntent copyWith(
      {enums.FeatureName? name, String? $value}) {
    return SetOrganizationFeatureIntent(
        name: name ?? this.name, $value: $value ?? this.$value);
  }

  SetOrganizationFeatureIntent copyWithWrapped(
      {Wrapped<enums.FeatureName>? name, Wrapped<String?>? $value}) {
    return SetOrganizationFeatureIntent(
        name: (name != null ? name.value : this.name),
        $value: ($value != null ? $value.value : this.$value));
  }
}

@JsonSerializable(explicitToJson: true)
class SetOrganizationFeatureRequest {
  const SetOrganizationFeatureRequest({
    required this.type,
    required this.timestampMs,
    required this.organizationId,
    required this.parameters,
  });

  factory SetOrganizationFeatureRequest.fromJson(Map<String, dynamic> json) =>
      _$SetOrganizationFeatureRequestFromJson(json);

  static const toJsonFactory = _$SetOrganizationFeatureRequestToJson;
  Map<String, dynamic> toJson() => _$SetOrganizationFeatureRequestToJson(this);

  @JsonKey(
    name: 'type',
    toJson: setOrganizationFeatureRequestTypeToJson,
    fromJson: setOrganizationFeatureRequestTypeFromJson,
  )
  final enums.SetOrganizationFeatureRequestType type;
  @JsonKey(name: 'timestampMs')
  final String timestampMs;
  @JsonKey(name: 'organizationId')
  final String organizationId;
  @JsonKey(name: 'parameters')
  final SetOrganizationFeatureIntent parameters;
  static const fromJsonFactory = _$SetOrganizationFeatureRequestFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is SetOrganizationFeatureRequest &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.timestampMs, timestampMs) ||
                const DeepCollectionEquality()
                    .equals(other.timestampMs, timestampMs)) &&
            (identical(other.organizationId, organizationId) ||
                const DeepCollectionEquality()
                    .equals(other.organizationId, organizationId)) &&
            (identical(other.parameters, parameters) ||
                const DeepCollectionEquality()
                    .equals(other.parameters, parameters)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(timestampMs) ^
      const DeepCollectionEquality().hash(organizationId) ^
      const DeepCollectionEquality().hash(parameters) ^
      runtimeType.hashCode;
}

extension $SetOrganizationFeatureRequestExtension
    on SetOrganizationFeatureRequest {
  SetOrganizationFeatureRequest copyWith(
      {enums.SetOrganizationFeatureRequestType? type,
      String? timestampMs,
      String? organizationId,
      SetOrganizationFeatureIntent? parameters}) {
    return SetOrganizationFeatureRequest(
        type: type ?? this.type,
        timestampMs: timestampMs ?? this.timestampMs,
        organizationId: organizationId ?? this.organizationId,
        parameters: parameters ?? this.parameters);
  }

  SetOrganizationFeatureRequest copyWithWrapped(
      {Wrapped<enums.SetOrganizationFeatureRequestType>? type,
      Wrapped<String>? timestampMs,
      Wrapped<String>? organizationId,
      Wrapped<SetOrganizationFeatureIntent>? parameters}) {
    return SetOrganizationFeatureRequest(
        type: (type != null ? type.value : this.type),
        timestampMs:
            (timestampMs != null ? timestampMs.value : this.timestampMs),
        organizationId: (organizationId != null
            ? organizationId.value
            : this.organizationId),
        parameters: (parameters != null ? parameters.value : this.parameters));
  }
}

@JsonSerializable(explicitToJson: true)
class SetOrganizationFeatureResult {
  const SetOrganizationFeatureResult({
    required this.features,
  });

  factory SetOrganizationFeatureResult.fromJson(Map<String, dynamic> json) =>
      _$SetOrganizationFeatureResultFromJson(json);

  static const toJsonFactory = _$SetOrganizationFeatureResultToJson;
  Map<String, dynamic> toJson() => _$SetOrganizationFeatureResultToJson(this);

  @JsonKey(name: 'features', defaultValue: <Feature>[])
  final List<Feature> features;
  static const fromJsonFactory = _$SetOrganizationFeatureResultFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is SetOrganizationFeatureResult &&
            (identical(other.features, features) ||
                const DeepCollectionEquality()
                    .equals(other.features, features)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(features) ^ runtimeType.hashCode;
}

extension $SetOrganizationFeatureResultExtension
    on SetOrganizationFeatureResult {
  SetOrganizationFeatureResult copyWith({List<Feature>? features}) {
    return SetOrganizationFeatureResult(features: features ?? this.features);
  }

  SetOrganizationFeatureResult copyWithWrapped(
      {Wrapped<List<Feature>>? features}) {
    return SetOrganizationFeatureResult(
        features: (features != null ? features.value : this.features));
  }
}

@JsonSerializable(explicitToJson: true)
class SetPaymentMethodIntent {
  const SetPaymentMethodIntent({
    required this.number,
    required this.cvv,
    required this.expiryMonth,
    required this.expiryYear,
    required this.cardHolderEmail,
    required this.cardHolderName,
  });

  factory SetPaymentMethodIntent.fromJson(Map<String, dynamic> json) =>
      _$SetPaymentMethodIntentFromJson(json);

  static const toJsonFactory = _$SetPaymentMethodIntentToJson;
  Map<String, dynamic> toJson() => _$SetPaymentMethodIntentToJson(this);

  @JsonKey(name: 'number')
  final String number;
  @JsonKey(name: 'cvv')
  final String cvv;
  @JsonKey(name: 'expiryMonth')
  final String expiryMonth;
  @JsonKey(name: 'expiryYear')
  final String expiryYear;
  @JsonKey(name: 'cardHolderEmail')
  final String cardHolderEmail;
  @JsonKey(name: 'cardHolderName')
  final String cardHolderName;
  static const fromJsonFactory = _$SetPaymentMethodIntentFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is SetPaymentMethodIntent &&
            (identical(other.number, number) ||
                const DeepCollectionEquality().equals(other.number, number)) &&
            (identical(other.cvv, cvv) ||
                const DeepCollectionEquality().equals(other.cvv, cvv)) &&
            (identical(other.expiryMonth, expiryMonth) ||
                const DeepCollectionEquality()
                    .equals(other.expiryMonth, expiryMonth)) &&
            (identical(other.expiryYear, expiryYear) ||
                const DeepCollectionEquality()
                    .equals(other.expiryYear, expiryYear)) &&
            (identical(other.cardHolderEmail, cardHolderEmail) ||
                const DeepCollectionEquality()
                    .equals(other.cardHolderEmail, cardHolderEmail)) &&
            (identical(other.cardHolderName, cardHolderName) ||
                const DeepCollectionEquality()
                    .equals(other.cardHolderName, cardHolderName)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(number) ^
      const DeepCollectionEquality().hash(cvv) ^
      const DeepCollectionEquality().hash(expiryMonth) ^
      const DeepCollectionEquality().hash(expiryYear) ^
      const DeepCollectionEquality().hash(cardHolderEmail) ^
      const DeepCollectionEquality().hash(cardHolderName) ^
      runtimeType.hashCode;
}

extension $SetPaymentMethodIntentExtension on SetPaymentMethodIntent {
  SetPaymentMethodIntent copyWith(
      {String? number,
      String? cvv,
      String? expiryMonth,
      String? expiryYear,
      String? cardHolderEmail,
      String? cardHolderName}) {
    return SetPaymentMethodIntent(
        number: number ?? this.number,
        cvv: cvv ?? this.cvv,
        expiryMonth: expiryMonth ?? this.expiryMonth,
        expiryYear: expiryYear ?? this.expiryYear,
        cardHolderEmail: cardHolderEmail ?? this.cardHolderEmail,
        cardHolderName: cardHolderName ?? this.cardHolderName);
  }

  SetPaymentMethodIntent copyWithWrapped(
      {Wrapped<String>? number,
      Wrapped<String>? cvv,
      Wrapped<String>? expiryMonth,
      Wrapped<String>? expiryYear,
      Wrapped<String>? cardHolderEmail,
      Wrapped<String>? cardHolderName}) {
    return SetPaymentMethodIntent(
        number: (number != null ? number.value : this.number),
        cvv: (cvv != null ? cvv.value : this.cvv),
        expiryMonth:
            (expiryMonth != null ? expiryMonth.value : this.expiryMonth),
        expiryYear: (expiryYear != null ? expiryYear.value : this.expiryYear),
        cardHolderEmail: (cardHolderEmail != null
            ? cardHolderEmail.value
            : this.cardHolderEmail),
        cardHolderName: (cardHolderName != null
            ? cardHolderName.value
            : this.cardHolderName));
  }
}

@JsonSerializable(explicitToJson: true)
class SetPaymentMethodIntentV2 {
  const SetPaymentMethodIntentV2({
    required this.paymentMethodId,
    required this.cardHolderEmail,
    required this.cardHolderName,
  });

  factory SetPaymentMethodIntentV2.fromJson(Map<String, dynamic> json) =>
      _$SetPaymentMethodIntentV2FromJson(json);

  static const toJsonFactory = _$SetPaymentMethodIntentV2ToJson;
  Map<String, dynamic> toJson() => _$SetPaymentMethodIntentV2ToJson(this);

  @JsonKey(name: 'paymentMethodId')
  final String paymentMethodId;
  @JsonKey(name: 'cardHolderEmail')
  final String cardHolderEmail;
  @JsonKey(name: 'cardHolderName')
  final String cardHolderName;
  static const fromJsonFactory = _$SetPaymentMethodIntentV2FromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is SetPaymentMethodIntentV2 &&
            (identical(other.paymentMethodId, paymentMethodId) ||
                const DeepCollectionEquality()
                    .equals(other.paymentMethodId, paymentMethodId)) &&
            (identical(other.cardHolderEmail, cardHolderEmail) ||
                const DeepCollectionEquality()
                    .equals(other.cardHolderEmail, cardHolderEmail)) &&
            (identical(other.cardHolderName, cardHolderName) ||
                const DeepCollectionEquality()
                    .equals(other.cardHolderName, cardHolderName)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(paymentMethodId) ^
      const DeepCollectionEquality().hash(cardHolderEmail) ^
      const DeepCollectionEquality().hash(cardHolderName) ^
      runtimeType.hashCode;
}

extension $SetPaymentMethodIntentV2Extension on SetPaymentMethodIntentV2 {
  SetPaymentMethodIntentV2 copyWith(
      {String? paymentMethodId,
      String? cardHolderEmail,
      String? cardHolderName}) {
    return SetPaymentMethodIntentV2(
        paymentMethodId: paymentMethodId ?? this.paymentMethodId,
        cardHolderEmail: cardHolderEmail ?? this.cardHolderEmail,
        cardHolderName: cardHolderName ?? this.cardHolderName);
  }

  SetPaymentMethodIntentV2 copyWithWrapped(
      {Wrapped<String>? paymentMethodId,
      Wrapped<String>? cardHolderEmail,
      Wrapped<String>? cardHolderName}) {
    return SetPaymentMethodIntentV2(
        paymentMethodId: (paymentMethodId != null
            ? paymentMethodId.value
            : this.paymentMethodId),
        cardHolderEmail: (cardHolderEmail != null
            ? cardHolderEmail.value
            : this.cardHolderEmail),
        cardHolderName: (cardHolderName != null
            ? cardHolderName.value
            : this.cardHolderName));
  }
}

@JsonSerializable(explicitToJson: true)
class SetPaymentMethodResult {
  const SetPaymentMethodResult({
    required this.lastFour,
    required this.cardHolderName,
    required this.cardHolderEmail,
  });

  factory SetPaymentMethodResult.fromJson(Map<String, dynamic> json) =>
      _$SetPaymentMethodResultFromJson(json);

  static const toJsonFactory = _$SetPaymentMethodResultToJson;
  Map<String, dynamic> toJson() => _$SetPaymentMethodResultToJson(this);

  @JsonKey(name: 'lastFour')
  final String lastFour;
  @JsonKey(name: 'cardHolderName')
  final String cardHolderName;
  @JsonKey(name: 'cardHolderEmail')
  final String cardHolderEmail;
  static const fromJsonFactory = _$SetPaymentMethodResultFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is SetPaymentMethodResult &&
            (identical(other.lastFour, lastFour) ||
                const DeepCollectionEquality()
                    .equals(other.lastFour, lastFour)) &&
            (identical(other.cardHolderName, cardHolderName) ||
                const DeepCollectionEquality()
                    .equals(other.cardHolderName, cardHolderName)) &&
            (identical(other.cardHolderEmail, cardHolderEmail) ||
                const DeepCollectionEquality()
                    .equals(other.cardHolderEmail, cardHolderEmail)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(lastFour) ^
      const DeepCollectionEquality().hash(cardHolderName) ^
      const DeepCollectionEquality().hash(cardHolderEmail) ^
      runtimeType.hashCode;
}

extension $SetPaymentMethodResultExtension on SetPaymentMethodResult {
  SetPaymentMethodResult copyWith(
      {String? lastFour, String? cardHolderName, String? cardHolderEmail}) {
    return SetPaymentMethodResult(
        lastFour: lastFour ?? this.lastFour,
        cardHolderName: cardHolderName ?? this.cardHolderName,
        cardHolderEmail: cardHolderEmail ?? this.cardHolderEmail);
  }

  SetPaymentMethodResult copyWithWrapped(
      {Wrapped<String>? lastFour,
      Wrapped<String>? cardHolderName,
      Wrapped<String>? cardHolderEmail}) {
    return SetPaymentMethodResult(
        lastFour: (lastFour != null ? lastFour.value : this.lastFour),
        cardHolderName: (cardHolderName != null
            ? cardHolderName.value
            : this.cardHolderName),
        cardHolderEmail: (cardHolderEmail != null
            ? cardHolderEmail.value
            : this.cardHolderEmail));
  }
}

@JsonSerializable(explicitToJson: true)
class SignRawPayloadIntent {
  const SignRawPayloadIntent({
    required this.privateKeyId,
    required this.payload,
    required this.encoding,
    required this.hashFunction,
  });

  factory SignRawPayloadIntent.fromJson(Map<String, dynamic> json) =>
      _$SignRawPayloadIntentFromJson(json);

  static const toJsonFactory = _$SignRawPayloadIntentToJson;
  Map<String, dynamic> toJson() => _$SignRawPayloadIntentToJson(this);

  @JsonKey(name: 'privateKeyId')
  final String privateKeyId;
  @JsonKey(name: 'payload')
  final String payload;
  @JsonKey(
    name: 'encoding',
    toJson: payloadEncodingToJson,
    fromJson: payloadEncodingFromJson,
  )
  final enums.PayloadEncoding encoding;
  @JsonKey(
    name: 'hashFunction',
    toJson: hashFunctionToJson,
    fromJson: hashFunctionFromJson,
  )
  final enums.HashFunction hashFunction;
  static const fromJsonFactory = _$SignRawPayloadIntentFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is SignRawPayloadIntent &&
            (identical(other.privateKeyId, privateKeyId) ||
                const DeepCollectionEquality()
                    .equals(other.privateKeyId, privateKeyId)) &&
            (identical(other.payload, payload) ||
                const DeepCollectionEquality()
                    .equals(other.payload, payload)) &&
            (identical(other.encoding, encoding) ||
                const DeepCollectionEquality()
                    .equals(other.encoding, encoding)) &&
            (identical(other.hashFunction, hashFunction) ||
                const DeepCollectionEquality()
                    .equals(other.hashFunction, hashFunction)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(privateKeyId) ^
      const DeepCollectionEquality().hash(payload) ^
      const DeepCollectionEquality().hash(encoding) ^
      const DeepCollectionEquality().hash(hashFunction) ^
      runtimeType.hashCode;
}

extension $SignRawPayloadIntentExtension on SignRawPayloadIntent {
  SignRawPayloadIntent copyWith(
      {String? privateKeyId,
      String? payload,
      enums.PayloadEncoding? encoding,
      enums.HashFunction? hashFunction}) {
    return SignRawPayloadIntent(
        privateKeyId: privateKeyId ?? this.privateKeyId,
        payload: payload ?? this.payload,
        encoding: encoding ?? this.encoding,
        hashFunction: hashFunction ?? this.hashFunction);
  }

  SignRawPayloadIntent copyWithWrapped(
      {Wrapped<String>? privateKeyId,
      Wrapped<String>? payload,
      Wrapped<enums.PayloadEncoding>? encoding,
      Wrapped<enums.HashFunction>? hashFunction}) {
    return SignRawPayloadIntent(
        privateKeyId:
            (privateKeyId != null ? privateKeyId.value : this.privateKeyId),
        payload: (payload != null ? payload.value : this.payload),
        encoding: (encoding != null ? encoding.value : this.encoding),
        hashFunction:
            (hashFunction != null ? hashFunction.value : this.hashFunction));
  }
}

@JsonSerializable(explicitToJson: true)
class SignRawPayloadIntentV2 {
  const SignRawPayloadIntentV2({
    required this.signWith,
    required this.payload,
    required this.encoding,
    required this.hashFunction,
  });

  factory SignRawPayloadIntentV2.fromJson(Map<String, dynamic> json) =>
      _$SignRawPayloadIntentV2FromJson(json);

  static const toJsonFactory = _$SignRawPayloadIntentV2ToJson;
  Map<String, dynamic> toJson() => _$SignRawPayloadIntentV2ToJson(this);

  @JsonKey(name: 'signWith')
  final String signWith;
  @JsonKey(name: 'payload')
  final String payload;
  @JsonKey(
    name: 'encoding',
    toJson: payloadEncodingToJson,
    fromJson: payloadEncodingFromJson,
  )
  final enums.PayloadEncoding encoding;
  @JsonKey(
    name: 'hashFunction',
    toJson: hashFunctionToJson,
    fromJson: hashFunctionFromJson,
  )
  final enums.HashFunction hashFunction;
  static const fromJsonFactory = _$SignRawPayloadIntentV2FromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is SignRawPayloadIntentV2 &&
            (identical(other.signWith, signWith) ||
                const DeepCollectionEquality()
                    .equals(other.signWith, signWith)) &&
            (identical(other.payload, payload) ||
                const DeepCollectionEquality()
                    .equals(other.payload, payload)) &&
            (identical(other.encoding, encoding) ||
                const DeepCollectionEquality()
                    .equals(other.encoding, encoding)) &&
            (identical(other.hashFunction, hashFunction) ||
                const DeepCollectionEquality()
                    .equals(other.hashFunction, hashFunction)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(signWith) ^
      const DeepCollectionEquality().hash(payload) ^
      const DeepCollectionEquality().hash(encoding) ^
      const DeepCollectionEquality().hash(hashFunction) ^
      runtimeType.hashCode;
}

extension $SignRawPayloadIntentV2Extension on SignRawPayloadIntentV2 {
  SignRawPayloadIntentV2 copyWith(
      {String? signWith,
      String? payload,
      enums.PayloadEncoding? encoding,
      enums.HashFunction? hashFunction}) {
    return SignRawPayloadIntentV2(
        signWith: signWith ?? this.signWith,
        payload: payload ?? this.payload,
        encoding: encoding ?? this.encoding,
        hashFunction: hashFunction ?? this.hashFunction);
  }

  SignRawPayloadIntentV2 copyWithWrapped(
      {Wrapped<String>? signWith,
      Wrapped<String>? payload,
      Wrapped<enums.PayloadEncoding>? encoding,
      Wrapped<enums.HashFunction>? hashFunction}) {
    return SignRawPayloadIntentV2(
        signWith: (signWith != null ? signWith.value : this.signWith),
        payload: (payload != null ? payload.value : this.payload),
        encoding: (encoding != null ? encoding.value : this.encoding),
        hashFunction:
            (hashFunction != null ? hashFunction.value : this.hashFunction));
  }
}

@JsonSerializable(explicitToJson: true)
class SignRawPayloadRequest {
  const SignRawPayloadRequest({
    required this.type,
    required this.timestampMs,
    required this.organizationId,
    required this.parameters,
  });

  factory SignRawPayloadRequest.fromJson(Map<String, dynamic> json) =>
      _$SignRawPayloadRequestFromJson(json);

  static const toJsonFactory = _$SignRawPayloadRequestToJson;
  Map<String, dynamic> toJson() => _$SignRawPayloadRequestToJson(this);

  @JsonKey(
    name: 'type',
    toJson: signRawPayloadRequestTypeToJson,
    fromJson: signRawPayloadRequestTypeFromJson,
  )
  final enums.SignRawPayloadRequestType type;
  @JsonKey(name: 'timestampMs')
  final String timestampMs;
  @JsonKey(name: 'organizationId')
  final String organizationId;
  @JsonKey(name: 'parameters')
  final SignRawPayloadIntentV2 parameters;
  static const fromJsonFactory = _$SignRawPayloadRequestFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is SignRawPayloadRequest &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.timestampMs, timestampMs) ||
                const DeepCollectionEquality()
                    .equals(other.timestampMs, timestampMs)) &&
            (identical(other.organizationId, organizationId) ||
                const DeepCollectionEquality()
                    .equals(other.organizationId, organizationId)) &&
            (identical(other.parameters, parameters) ||
                const DeepCollectionEquality()
                    .equals(other.parameters, parameters)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(timestampMs) ^
      const DeepCollectionEquality().hash(organizationId) ^
      const DeepCollectionEquality().hash(parameters) ^
      runtimeType.hashCode;
}

extension $SignRawPayloadRequestExtension on SignRawPayloadRequest {
  SignRawPayloadRequest copyWith(
      {enums.SignRawPayloadRequestType? type,
      String? timestampMs,
      String? organizationId,
      SignRawPayloadIntentV2? parameters}) {
    return SignRawPayloadRequest(
        type: type ?? this.type,
        timestampMs: timestampMs ?? this.timestampMs,
        organizationId: organizationId ?? this.organizationId,
        parameters: parameters ?? this.parameters);
  }

  SignRawPayloadRequest copyWithWrapped(
      {Wrapped<enums.SignRawPayloadRequestType>? type,
      Wrapped<String>? timestampMs,
      Wrapped<String>? organizationId,
      Wrapped<SignRawPayloadIntentV2>? parameters}) {
    return SignRawPayloadRequest(
        type: (type != null ? type.value : this.type),
        timestampMs:
            (timestampMs != null ? timestampMs.value : this.timestampMs),
        organizationId: (organizationId != null
            ? organizationId.value
            : this.organizationId),
        parameters: (parameters != null ? parameters.value : this.parameters));
  }
}

@JsonSerializable(explicitToJson: true)
class SignRawPayloadResult {
  const SignRawPayloadResult({
    required this.r,
    required this.s,
    required this.v,
  });

  factory SignRawPayloadResult.fromJson(Map<String, dynamic> json) =>
      _$SignRawPayloadResultFromJson(json);

  static const toJsonFactory = _$SignRawPayloadResultToJson;
  Map<String, dynamic> toJson() => _$SignRawPayloadResultToJson(this);

  @JsonKey(name: 'r')
  final String r;
  @JsonKey(name: 's')
  final String s;
  @JsonKey(name: 'v')
  final String v;
  static const fromJsonFactory = _$SignRawPayloadResultFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is SignRawPayloadResult &&
            (identical(other.r, r) ||
                const DeepCollectionEquality().equals(other.r, r)) &&
            (identical(other.s, s) ||
                const DeepCollectionEquality().equals(other.s, s)) &&
            (identical(other.v, v) ||
                const DeepCollectionEquality().equals(other.v, v)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(r) ^
      const DeepCollectionEquality().hash(s) ^
      const DeepCollectionEquality().hash(v) ^
      runtimeType.hashCode;
}

extension $SignRawPayloadResultExtension on SignRawPayloadResult {
  SignRawPayloadResult copyWith({String? r, String? s, String? v}) {
    return SignRawPayloadResult(r: r ?? this.r, s: s ?? this.s, v: v ?? this.v);
  }

  SignRawPayloadResult copyWithWrapped(
      {Wrapped<String>? r, Wrapped<String>? s, Wrapped<String>? v}) {
    return SignRawPayloadResult(
        r: (r != null ? r.value : this.r),
        s: (s != null ? s.value : this.s),
        v: (v != null ? v.value : this.v));
  }
}

@JsonSerializable(explicitToJson: true)
class SignRawPayloadsIntent {
  const SignRawPayloadsIntent({
    required this.signWith,
    required this.payloads,
    required this.encoding,
    required this.hashFunction,
  });

  factory SignRawPayloadsIntent.fromJson(Map<String, dynamic> json) =>
      _$SignRawPayloadsIntentFromJson(json);

  static const toJsonFactory = _$SignRawPayloadsIntentToJson;
  Map<String, dynamic> toJson() => _$SignRawPayloadsIntentToJson(this);

  @JsonKey(name: 'signWith')
  final String signWith;
  @JsonKey(name: 'payloads', defaultValue: <String>[])
  final List<String> payloads;
  @JsonKey(
    name: 'encoding',
    toJson: payloadEncodingToJson,
    fromJson: payloadEncodingFromJson,
  )
  final enums.PayloadEncoding encoding;
  @JsonKey(
    name: 'hashFunction',
    toJson: hashFunctionToJson,
    fromJson: hashFunctionFromJson,
  )
  final enums.HashFunction hashFunction;
  static const fromJsonFactory = _$SignRawPayloadsIntentFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is SignRawPayloadsIntent &&
            (identical(other.signWith, signWith) ||
                const DeepCollectionEquality()
                    .equals(other.signWith, signWith)) &&
            (identical(other.payloads, payloads) ||
                const DeepCollectionEquality()
                    .equals(other.payloads, payloads)) &&
            (identical(other.encoding, encoding) ||
                const DeepCollectionEquality()
                    .equals(other.encoding, encoding)) &&
            (identical(other.hashFunction, hashFunction) ||
                const DeepCollectionEquality()
                    .equals(other.hashFunction, hashFunction)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(signWith) ^
      const DeepCollectionEquality().hash(payloads) ^
      const DeepCollectionEquality().hash(encoding) ^
      const DeepCollectionEquality().hash(hashFunction) ^
      runtimeType.hashCode;
}

extension $SignRawPayloadsIntentExtension on SignRawPayloadsIntent {
  SignRawPayloadsIntent copyWith(
      {String? signWith,
      List<String>? payloads,
      enums.PayloadEncoding? encoding,
      enums.HashFunction? hashFunction}) {
    return SignRawPayloadsIntent(
        signWith: signWith ?? this.signWith,
        payloads: payloads ?? this.payloads,
        encoding: encoding ?? this.encoding,
        hashFunction: hashFunction ?? this.hashFunction);
  }

  SignRawPayloadsIntent copyWithWrapped(
      {Wrapped<String>? signWith,
      Wrapped<List<String>>? payloads,
      Wrapped<enums.PayloadEncoding>? encoding,
      Wrapped<enums.HashFunction>? hashFunction}) {
    return SignRawPayloadsIntent(
        signWith: (signWith != null ? signWith.value : this.signWith),
        payloads: (payloads != null ? payloads.value : this.payloads),
        encoding: (encoding != null ? encoding.value : this.encoding),
        hashFunction:
            (hashFunction != null ? hashFunction.value : this.hashFunction));
  }
}

@JsonSerializable(explicitToJson: true)
class SignRawPayloadsRequest {
  const SignRawPayloadsRequest({
    required this.type,
    required this.timestampMs,
    required this.organizationId,
    required this.parameters,
  });

  factory SignRawPayloadsRequest.fromJson(Map<String, dynamic> json) =>
      _$SignRawPayloadsRequestFromJson(json);

  static const toJsonFactory = _$SignRawPayloadsRequestToJson;
  Map<String, dynamic> toJson() => _$SignRawPayloadsRequestToJson(this);

  @JsonKey(
    name: 'type',
    toJson: signRawPayloadsRequestTypeToJson,
    fromJson: signRawPayloadsRequestTypeFromJson,
  )
  final enums.SignRawPayloadsRequestType type;
  @JsonKey(name: 'timestampMs')
  final String timestampMs;
  @JsonKey(name: 'organizationId')
  final String organizationId;
  @JsonKey(name: 'parameters')
  final SignRawPayloadsIntent parameters;
  static const fromJsonFactory = _$SignRawPayloadsRequestFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is SignRawPayloadsRequest &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.timestampMs, timestampMs) ||
                const DeepCollectionEquality()
                    .equals(other.timestampMs, timestampMs)) &&
            (identical(other.organizationId, organizationId) ||
                const DeepCollectionEquality()
                    .equals(other.organizationId, organizationId)) &&
            (identical(other.parameters, parameters) ||
                const DeepCollectionEquality()
                    .equals(other.parameters, parameters)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(timestampMs) ^
      const DeepCollectionEquality().hash(organizationId) ^
      const DeepCollectionEquality().hash(parameters) ^
      runtimeType.hashCode;
}

extension $SignRawPayloadsRequestExtension on SignRawPayloadsRequest {
  SignRawPayloadsRequest copyWith(
      {enums.SignRawPayloadsRequestType? type,
      String? timestampMs,
      String? organizationId,
      SignRawPayloadsIntent? parameters}) {
    return SignRawPayloadsRequest(
        type: type ?? this.type,
        timestampMs: timestampMs ?? this.timestampMs,
        organizationId: organizationId ?? this.organizationId,
        parameters: parameters ?? this.parameters);
  }

  SignRawPayloadsRequest copyWithWrapped(
      {Wrapped<enums.SignRawPayloadsRequestType>? type,
      Wrapped<String>? timestampMs,
      Wrapped<String>? organizationId,
      Wrapped<SignRawPayloadsIntent>? parameters}) {
    return SignRawPayloadsRequest(
        type: (type != null ? type.value : this.type),
        timestampMs:
            (timestampMs != null ? timestampMs.value : this.timestampMs),
        organizationId: (organizationId != null
            ? organizationId.value
            : this.organizationId),
        parameters: (parameters != null ? parameters.value : this.parameters));
  }
}

@JsonSerializable(explicitToJson: true)
class SignRawPayloadsResult {
  const SignRawPayloadsResult({
    this.signatures,
  });

  factory SignRawPayloadsResult.fromJson(Map<String, dynamic> json) =>
      _$SignRawPayloadsResultFromJson(json);

  static const toJsonFactory = _$SignRawPayloadsResultToJson;
  Map<String, dynamic> toJson() => _$SignRawPayloadsResultToJson(this);

  @JsonKey(name: 'signatures', defaultValue: <SignRawPayloadResult>[])
  final List<SignRawPayloadResult>? signatures;
  static const fromJsonFactory = _$SignRawPayloadsResultFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is SignRawPayloadsResult &&
            (identical(other.signatures, signatures) ||
                const DeepCollectionEquality()
                    .equals(other.signatures, signatures)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(signatures) ^ runtimeType.hashCode;
}

extension $SignRawPayloadsResultExtension on SignRawPayloadsResult {
  SignRawPayloadsResult copyWith({List<SignRawPayloadResult>? signatures}) {
    return SignRawPayloadsResult(signatures: signatures ?? this.signatures);
  }

  SignRawPayloadsResult copyWithWrapped(
      {Wrapped<List<SignRawPayloadResult>?>? signatures}) {
    return SignRawPayloadsResult(
        signatures: (signatures != null ? signatures.value : this.signatures));
  }
}

@JsonSerializable(explicitToJson: true)
class SignTransactionIntent {
  const SignTransactionIntent({
    required this.privateKeyId,
    required this.unsignedTransaction,
    required this.type,
  });

  factory SignTransactionIntent.fromJson(Map<String, dynamic> json) =>
      _$SignTransactionIntentFromJson(json);

  static const toJsonFactory = _$SignTransactionIntentToJson;
  Map<String, dynamic> toJson() => _$SignTransactionIntentToJson(this);

  @JsonKey(name: 'privateKeyId')
  final String privateKeyId;
  @JsonKey(name: 'unsignedTransaction')
  final String unsignedTransaction;
  @JsonKey(
    name: 'type',
    toJson: transactionTypeToJson,
    fromJson: transactionTypeFromJson,
  )
  final enums.TransactionType type;
  static const fromJsonFactory = _$SignTransactionIntentFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is SignTransactionIntent &&
            (identical(other.privateKeyId, privateKeyId) ||
                const DeepCollectionEquality()
                    .equals(other.privateKeyId, privateKeyId)) &&
            (identical(other.unsignedTransaction, unsignedTransaction) ||
                const DeepCollectionEquality()
                    .equals(other.unsignedTransaction, unsignedTransaction)) &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(privateKeyId) ^
      const DeepCollectionEquality().hash(unsignedTransaction) ^
      const DeepCollectionEquality().hash(type) ^
      runtimeType.hashCode;
}

extension $SignTransactionIntentExtension on SignTransactionIntent {
  SignTransactionIntent copyWith(
      {String? privateKeyId,
      String? unsignedTransaction,
      enums.TransactionType? type}) {
    return SignTransactionIntent(
        privateKeyId: privateKeyId ?? this.privateKeyId,
        unsignedTransaction: unsignedTransaction ?? this.unsignedTransaction,
        type: type ?? this.type);
  }

  SignTransactionIntent copyWithWrapped(
      {Wrapped<String>? privateKeyId,
      Wrapped<String>? unsignedTransaction,
      Wrapped<enums.TransactionType>? type}) {
    return SignTransactionIntent(
        privateKeyId:
            (privateKeyId != null ? privateKeyId.value : this.privateKeyId),
        unsignedTransaction: (unsignedTransaction != null
            ? unsignedTransaction.value
            : this.unsignedTransaction),
        type: (type != null ? type.value : this.type));
  }
}

@JsonSerializable(explicitToJson: true)
class SignTransactionIntentV2 {
  const SignTransactionIntentV2({
    required this.signWith,
    required this.unsignedTransaction,
    required this.type,
  });

  factory SignTransactionIntentV2.fromJson(Map<String, dynamic> json) =>
      _$SignTransactionIntentV2FromJson(json);

  static const toJsonFactory = _$SignTransactionIntentV2ToJson;
  Map<String, dynamic> toJson() => _$SignTransactionIntentV2ToJson(this);

  @JsonKey(name: 'signWith')
  final String signWith;
  @JsonKey(name: 'unsignedTransaction')
  final String unsignedTransaction;
  @JsonKey(
    name: 'type',
    toJson: transactionTypeToJson,
    fromJson: transactionTypeFromJson,
  )
  final enums.TransactionType type;
  static const fromJsonFactory = _$SignTransactionIntentV2FromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is SignTransactionIntentV2 &&
            (identical(other.signWith, signWith) ||
                const DeepCollectionEquality()
                    .equals(other.signWith, signWith)) &&
            (identical(other.unsignedTransaction, unsignedTransaction) ||
                const DeepCollectionEquality()
                    .equals(other.unsignedTransaction, unsignedTransaction)) &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(signWith) ^
      const DeepCollectionEquality().hash(unsignedTransaction) ^
      const DeepCollectionEquality().hash(type) ^
      runtimeType.hashCode;
}

extension $SignTransactionIntentV2Extension on SignTransactionIntentV2 {
  SignTransactionIntentV2 copyWith(
      {String? signWith,
      String? unsignedTransaction,
      enums.TransactionType? type}) {
    return SignTransactionIntentV2(
        signWith: signWith ?? this.signWith,
        unsignedTransaction: unsignedTransaction ?? this.unsignedTransaction,
        type: type ?? this.type);
  }

  SignTransactionIntentV2 copyWithWrapped(
      {Wrapped<String>? signWith,
      Wrapped<String>? unsignedTransaction,
      Wrapped<enums.TransactionType>? type}) {
    return SignTransactionIntentV2(
        signWith: (signWith != null ? signWith.value : this.signWith),
        unsignedTransaction: (unsignedTransaction != null
            ? unsignedTransaction.value
            : this.unsignedTransaction),
        type: (type != null ? type.value : this.type));
  }
}

@JsonSerializable(explicitToJson: true)
class SignTransactionRequest {
  const SignTransactionRequest({
    required this.type,
    required this.timestampMs,
    required this.organizationId,
    required this.parameters,
  });

  factory SignTransactionRequest.fromJson(Map<String, dynamic> json) =>
      _$SignTransactionRequestFromJson(json);

  static const toJsonFactory = _$SignTransactionRequestToJson;
  Map<String, dynamic> toJson() => _$SignTransactionRequestToJson(this);

  @JsonKey(
    name: 'type',
    toJson: signTransactionRequestTypeToJson,
    fromJson: signTransactionRequestTypeFromJson,
  )
  final enums.SignTransactionRequestType type;
  @JsonKey(name: 'timestampMs')
  final String timestampMs;
  @JsonKey(name: 'organizationId')
  final String organizationId;
  @JsonKey(name: 'parameters')
  final SignTransactionIntentV2 parameters;
  static const fromJsonFactory = _$SignTransactionRequestFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is SignTransactionRequest &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.timestampMs, timestampMs) ||
                const DeepCollectionEquality()
                    .equals(other.timestampMs, timestampMs)) &&
            (identical(other.organizationId, organizationId) ||
                const DeepCollectionEquality()
                    .equals(other.organizationId, organizationId)) &&
            (identical(other.parameters, parameters) ||
                const DeepCollectionEquality()
                    .equals(other.parameters, parameters)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(timestampMs) ^
      const DeepCollectionEquality().hash(organizationId) ^
      const DeepCollectionEquality().hash(parameters) ^
      runtimeType.hashCode;
}

extension $SignTransactionRequestExtension on SignTransactionRequest {
  SignTransactionRequest copyWith(
      {enums.SignTransactionRequestType? type,
      String? timestampMs,
      String? organizationId,
      SignTransactionIntentV2? parameters}) {
    return SignTransactionRequest(
        type: type ?? this.type,
        timestampMs: timestampMs ?? this.timestampMs,
        organizationId: organizationId ?? this.organizationId,
        parameters: parameters ?? this.parameters);
  }

  SignTransactionRequest copyWithWrapped(
      {Wrapped<enums.SignTransactionRequestType>? type,
      Wrapped<String>? timestampMs,
      Wrapped<String>? organizationId,
      Wrapped<SignTransactionIntentV2>? parameters}) {
    return SignTransactionRequest(
        type: (type != null ? type.value : this.type),
        timestampMs:
            (timestampMs != null ? timestampMs.value : this.timestampMs),
        organizationId: (organizationId != null
            ? organizationId.value
            : this.organizationId),
        parameters: (parameters != null ? parameters.value : this.parameters));
  }
}

@JsonSerializable(explicitToJson: true)
class SignTransactionResult {
  const SignTransactionResult({
    required this.signedTransaction,
  });

  factory SignTransactionResult.fromJson(Map<String, dynamic> json) =>
      _$SignTransactionResultFromJson(json);

  static const toJsonFactory = _$SignTransactionResultToJson;
  Map<String, dynamic> toJson() => _$SignTransactionResultToJson(this);

  @JsonKey(name: 'signedTransaction')
  final String signedTransaction;
  static const fromJsonFactory = _$SignTransactionResultFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is SignTransactionResult &&
            (identical(other.signedTransaction, signedTransaction) ||
                const DeepCollectionEquality()
                    .equals(other.signedTransaction, signedTransaction)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(signedTransaction) ^
      runtimeType.hashCode;
}

extension $SignTransactionResultExtension on SignTransactionResult {
  SignTransactionResult copyWith({String? signedTransaction}) {
    return SignTransactionResult(
        signedTransaction: signedTransaction ?? this.signedTransaction);
  }

  SignTransactionResult copyWithWrapped({Wrapped<String>? signedTransaction}) {
    return SignTransactionResult(
        signedTransaction: (signedTransaction != null
            ? signedTransaction.value
            : this.signedTransaction));
  }
}

@JsonSerializable(explicitToJson: true)
class SimpleClientExtensionResults {
  const SimpleClientExtensionResults({
    this.appid,
    this.appidExclude,
    this.credProps,
  });

  factory SimpleClientExtensionResults.fromJson(Map<String, dynamic> json) =>
      _$SimpleClientExtensionResultsFromJson(json);

  static const toJsonFactory = _$SimpleClientExtensionResultsToJson;
  Map<String, dynamic> toJson() => _$SimpleClientExtensionResultsToJson(this);

  @JsonKey(name: 'appid')
  final bool? appid;
  @JsonKey(name: 'appidExclude')
  final bool? appidExclude;
  @JsonKey(name: 'credProps')
  final CredPropsAuthenticationExtensionsClientOutputs? credProps;
  static const fromJsonFactory = _$SimpleClientExtensionResultsFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is SimpleClientExtensionResults &&
            (identical(other.appid, appid) ||
                const DeepCollectionEquality().equals(other.appid, appid)) &&
            (identical(other.appidExclude, appidExclude) ||
                const DeepCollectionEquality()
                    .equals(other.appidExclude, appidExclude)) &&
            (identical(other.credProps, credProps) ||
                const DeepCollectionEquality()
                    .equals(other.credProps, credProps)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(appid) ^
      const DeepCollectionEquality().hash(appidExclude) ^
      const DeepCollectionEquality().hash(credProps) ^
      runtimeType.hashCode;
}

extension $SimpleClientExtensionResultsExtension
    on SimpleClientExtensionResults {
  SimpleClientExtensionResults copyWith(
      {bool? appid,
      bool? appidExclude,
      CredPropsAuthenticationExtensionsClientOutputs? credProps}) {
    return SimpleClientExtensionResults(
        appid: appid ?? this.appid,
        appidExclude: appidExclude ?? this.appidExclude,
        credProps: credProps ?? this.credProps);
  }

  SimpleClientExtensionResults copyWithWrapped(
      {Wrapped<bool?>? appid,
      Wrapped<bool?>? appidExclude,
      Wrapped<CredPropsAuthenticationExtensionsClientOutputs?>? credProps}) {
    return SimpleClientExtensionResults(
        appid: (appid != null ? appid.value : this.appid),
        appidExclude:
            (appidExclude != null ? appidExclude.value : this.appidExclude),
        credProps: (credProps != null ? credProps.value : this.credProps));
  }
}

@JsonSerializable(explicitToJson: true)
class SmsCustomizationParams {
  const SmsCustomizationParams({
    this.template,
  });

  factory SmsCustomizationParams.fromJson(Map<String, dynamic> json) =>
      _$SmsCustomizationParamsFromJson(json);

  static const toJsonFactory = _$SmsCustomizationParamsToJson;
  Map<String, dynamic> toJson() => _$SmsCustomizationParamsToJson(this);

  @JsonKey(name: 'template')
  final String? template;
  static const fromJsonFactory = _$SmsCustomizationParamsFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is SmsCustomizationParams &&
            (identical(other.template, template) ||
                const DeepCollectionEquality()
                    .equals(other.template, template)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(template) ^ runtimeType.hashCode;
}

extension $SmsCustomizationParamsExtension on SmsCustomizationParams {
  SmsCustomizationParams copyWith({String? template}) {
    return SmsCustomizationParams(template: template ?? this.template);
  }

  SmsCustomizationParams copyWithWrapped({Wrapped<String?>? template}) {
    return SmsCustomizationParams(
        template: (template != null ? template.value : this.template));
  }
}

@JsonSerializable(explicitToJson: true)
class StampLoginIntent {
  const StampLoginIntent({
    required this.publicKey,
    this.expirationSeconds,
    this.invalidateExisting,
  });

  factory StampLoginIntent.fromJson(Map<String, dynamic> json) =>
      _$StampLoginIntentFromJson(json);

  static const toJsonFactory = _$StampLoginIntentToJson;
  Map<String, dynamic> toJson() => _$StampLoginIntentToJson(this);

  @JsonKey(name: 'publicKey')
  final String publicKey;
  @JsonKey(name: 'expirationSeconds')
  final String? expirationSeconds;
  @JsonKey(name: 'invalidateExisting')
  final bool? invalidateExisting;
  static const fromJsonFactory = _$StampLoginIntentFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is StampLoginIntent &&
            (identical(other.publicKey, publicKey) ||
                const DeepCollectionEquality()
                    .equals(other.publicKey, publicKey)) &&
            (identical(other.expirationSeconds, expirationSeconds) ||
                const DeepCollectionEquality()
                    .equals(other.expirationSeconds, expirationSeconds)) &&
            (identical(other.invalidateExisting, invalidateExisting) ||
                const DeepCollectionEquality()
                    .equals(other.invalidateExisting, invalidateExisting)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(publicKey) ^
      const DeepCollectionEquality().hash(expirationSeconds) ^
      const DeepCollectionEquality().hash(invalidateExisting) ^
      runtimeType.hashCode;
}

extension $StampLoginIntentExtension on StampLoginIntent {
  StampLoginIntent copyWith(
      {String? publicKey,
      String? expirationSeconds,
      bool? invalidateExisting}) {
    return StampLoginIntent(
        publicKey: publicKey ?? this.publicKey,
        expirationSeconds: expirationSeconds ?? this.expirationSeconds,
        invalidateExisting: invalidateExisting ?? this.invalidateExisting);
  }

  StampLoginIntent copyWithWrapped(
      {Wrapped<String>? publicKey,
      Wrapped<String?>? expirationSeconds,
      Wrapped<bool?>? invalidateExisting}) {
    return StampLoginIntent(
        publicKey: (publicKey != null ? publicKey.value : this.publicKey),
        expirationSeconds: (expirationSeconds != null
            ? expirationSeconds.value
            : this.expirationSeconds),
        invalidateExisting: (invalidateExisting != null
            ? invalidateExisting.value
            : this.invalidateExisting));
  }
}

@JsonSerializable(explicitToJson: true)
class StampLoginRequest {
  const StampLoginRequest({
    required this.type,
    required this.timestampMs,
    required this.organizationId,
    required this.parameters,
  });

  factory StampLoginRequest.fromJson(Map<String, dynamic> json) =>
      _$StampLoginRequestFromJson(json);

  static const toJsonFactory = _$StampLoginRequestToJson;
  Map<String, dynamic> toJson() => _$StampLoginRequestToJson(this);

  @JsonKey(
    name: 'type',
    toJson: stampLoginRequestTypeToJson,
    fromJson: stampLoginRequestTypeFromJson,
  )
  final enums.StampLoginRequestType type;
  @JsonKey(name: 'timestampMs')
  final String timestampMs;
  @JsonKey(name: 'organizationId')
  final String organizationId;
  @JsonKey(name: 'parameters')
  final StampLoginIntent parameters;
  static const fromJsonFactory = _$StampLoginRequestFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is StampLoginRequest &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.timestampMs, timestampMs) ||
                const DeepCollectionEquality()
                    .equals(other.timestampMs, timestampMs)) &&
            (identical(other.organizationId, organizationId) ||
                const DeepCollectionEquality()
                    .equals(other.organizationId, organizationId)) &&
            (identical(other.parameters, parameters) ||
                const DeepCollectionEquality()
                    .equals(other.parameters, parameters)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(timestampMs) ^
      const DeepCollectionEquality().hash(organizationId) ^
      const DeepCollectionEquality().hash(parameters) ^
      runtimeType.hashCode;
}

extension $StampLoginRequestExtension on StampLoginRequest {
  StampLoginRequest copyWith(
      {enums.StampLoginRequestType? type,
      String? timestampMs,
      String? organizationId,
      StampLoginIntent? parameters}) {
    return StampLoginRequest(
        type: type ?? this.type,
        timestampMs: timestampMs ?? this.timestampMs,
        organizationId: organizationId ?? this.organizationId,
        parameters: parameters ?? this.parameters);
  }

  StampLoginRequest copyWithWrapped(
      {Wrapped<enums.StampLoginRequestType>? type,
      Wrapped<String>? timestampMs,
      Wrapped<String>? organizationId,
      Wrapped<StampLoginIntent>? parameters}) {
    return StampLoginRequest(
        type: (type != null ? type.value : this.type),
        timestampMs:
            (timestampMs != null ? timestampMs.value : this.timestampMs),
        organizationId: (organizationId != null
            ? organizationId.value
            : this.organizationId),
        parameters: (parameters != null ? parameters.value : this.parameters));
  }
}

@JsonSerializable(explicitToJson: true)
class StampLoginResult {
  const StampLoginResult({
    required this.session,
  });

  factory StampLoginResult.fromJson(Map<String, dynamic> json) =>
      _$StampLoginResultFromJson(json);

  static const toJsonFactory = _$StampLoginResultToJson;
  Map<String, dynamic> toJson() => _$StampLoginResultToJson(this);

  @JsonKey(name: 'session')
  final String session;
  static const fromJsonFactory = _$StampLoginResultFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is StampLoginResult &&
            (identical(other.session, session) ||
                const DeepCollectionEquality().equals(other.session, session)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(session) ^ runtimeType.hashCode;
}

extension $StampLoginResultExtension on StampLoginResult {
  StampLoginResult copyWith({String? session}) {
    return StampLoginResult(session: session ?? this.session);
  }

  StampLoginResult copyWithWrapped({Wrapped<String>? session}) {
    return StampLoginResult(
        session: (session != null ? session.value : this.session));
  }
}

@JsonSerializable(explicitToJson: true)
class Status {
  const Status({
    this.code,
    this.message,
    this.details,
  });

  factory Status.fromJson(Map<String, dynamic> json) => _$StatusFromJson(json);

  static const toJsonFactory = _$StatusToJson;
  Map<String, dynamic> toJson() => _$StatusToJson(this);

  @JsonKey(name: 'code')
  final int? code;
  @JsonKey(name: 'message')
  final String? message;
  @JsonKey(name: 'details', defaultValue: <Any>[])
  final List<Any>? details;
  static const fromJsonFactory = _$StatusFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is Status &&
            (identical(other.code, code) ||
                const DeepCollectionEquality().equals(other.code, code)) &&
            (identical(other.message, message) ||
                const DeepCollectionEquality()
                    .equals(other.message, message)) &&
            (identical(other.details, details) ||
                const DeepCollectionEquality().equals(other.details, details)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(code) ^
      const DeepCollectionEquality().hash(message) ^
      const DeepCollectionEquality().hash(details) ^
      runtimeType.hashCode;
}

extension $StatusExtension on Status {
  Status copyWith({int? code, String? message, List<Any>? details}) {
    return Status(
        code: code ?? this.code,
        message: message ?? this.message,
        details: details ?? this.details);
  }

  Status copyWithWrapped(
      {Wrapped<int?>? code,
      Wrapped<String?>? message,
      Wrapped<List<Any>?>? details}) {
    return Status(
        code: (code != null ? code.value : this.code),
        message: (message != null ? message.value : this.message),
        details: (details != null ? details.value : this.details));
  }
}

@JsonSerializable(explicitToJson: true)
class UpdateAllowedOriginsIntent {
  const UpdateAllowedOriginsIntent({
    required this.allowedOrigins,
  });

  factory UpdateAllowedOriginsIntent.fromJson(Map<String, dynamic> json) =>
      _$UpdateAllowedOriginsIntentFromJson(json);

  static const toJsonFactory = _$UpdateAllowedOriginsIntentToJson;
  Map<String, dynamic> toJson() => _$UpdateAllowedOriginsIntentToJson(this);

  @JsonKey(name: 'allowedOrigins', defaultValue: <String>[])
  final List<String> allowedOrigins;
  static const fromJsonFactory = _$UpdateAllowedOriginsIntentFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is UpdateAllowedOriginsIntent &&
            (identical(other.allowedOrigins, allowedOrigins) ||
                const DeepCollectionEquality()
                    .equals(other.allowedOrigins, allowedOrigins)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(allowedOrigins) ^
      runtimeType.hashCode;
}

extension $UpdateAllowedOriginsIntentExtension on UpdateAllowedOriginsIntent {
  UpdateAllowedOriginsIntent copyWith({List<String>? allowedOrigins}) {
    return UpdateAllowedOriginsIntent(
        allowedOrigins: allowedOrigins ?? this.allowedOrigins);
  }

  UpdateAllowedOriginsIntent copyWithWrapped(
      {Wrapped<List<String>>? allowedOrigins}) {
    return UpdateAllowedOriginsIntent(
        allowedOrigins: (allowedOrigins != null
            ? allowedOrigins.value
            : this.allowedOrigins));
  }
}

@JsonSerializable(explicitToJson: true)
class UpdateAllowedOriginsResult {
  const UpdateAllowedOriginsResult();

  factory UpdateAllowedOriginsResult.fromJson(Map<String, dynamic> json) =>
      _$UpdateAllowedOriginsResultFromJson(json);

  static const toJsonFactory = _$UpdateAllowedOriginsResultToJson;
  Map<String, dynamic> toJson() => _$UpdateAllowedOriginsResultToJson(this);

  static const fromJsonFactory = _$UpdateAllowedOriginsResultFromJson;

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode => runtimeType.hashCode;
}

@JsonSerializable(explicitToJson: true)
class UpdatePolicyIntent {
  const UpdatePolicyIntent({
    required this.policyId,
    this.policyName,
    this.policyEffect,
    this.policyCondition,
    this.policyConsensus,
    this.policyNotes,
  });

  factory UpdatePolicyIntent.fromJson(Map<String, dynamic> json) =>
      _$UpdatePolicyIntentFromJson(json);

  static const toJsonFactory = _$UpdatePolicyIntentToJson;
  Map<String, dynamic> toJson() => _$UpdatePolicyIntentToJson(this);

  @JsonKey(name: 'policyId')
  final String policyId;
  @JsonKey(name: 'policyName')
  final String? policyName;
  @JsonKey(
    name: 'policyEffect',
    toJson: effectNullableToJson,
    fromJson: effectNullableFromJson,
  )
  final enums.Effect? policyEffect;
  @JsonKey(name: 'policyCondition')
  final String? policyCondition;
  @JsonKey(name: 'policyConsensus')
  final String? policyConsensus;
  @JsonKey(name: 'policyNotes')
  final String? policyNotes;
  static const fromJsonFactory = _$UpdatePolicyIntentFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is UpdatePolicyIntent &&
            (identical(other.policyId, policyId) ||
                const DeepCollectionEquality()
                    .equals(other.policyId, policyId)) &&
            (identical(other.policyName, policyName) ||
                const DeepCollectionEquality()
                    .equals(other.policyName, policyName)) &&
            (identical(other.policyEffect, policyEffect) ||
                const DeepCollectionEquality()
                    .equals(other.policyEffect, policyEffect)) &&
            (identical(other.policyCondition, policyCondition) ||
                const DeepCollectionEquality()
                    .equals(other.policyCondition, policyCondition)) &&
            (identical(other.policyConsensus, policyConsensus) ||
                const DeepCollectionEquality()
                    .equals(other.policyConsensus, policyConsensus)) &&
            (identical(other.policyNotes, policyNotes) ||
                const DeepCollectionEquality()
                    .equals(other.policyNotes, policyNotes)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(policyId) ^
      const DeepCollectionEquality().hash(policyName) ^
      const DeepCollectionEquality().hash(policyEffect) ^
      const DeepCollectionEquality().hash(policyCondition) ^
      const DeepCollectionEquality().hash(policyConsensus) ^
      const DeepCollectionEquality().hash(policyNotes) ^
      runtimeType.hashCode;
}

extension $UpdatePolicyIntentExtension on UpdatePolicyIntent {
  UpdatePolicyIntent copyWith(
      {String? policyId,
      String? policyName,
      enums.Effect? policyEffect,
      String? policyCondition,
      String? policyConsensus,
      String? policyNotes}) {
    return UpdatePolicyIntent(
        policyId: policyId ?? this.policyId,
        policyName: policyName ?? this.policyName,
        policyEffect: policyEffect ?? this.policyEffect,
        policyCondition: policyCondition ?? this.policyCondition,
        policyConsensus: policyConsensus ?? this.policyConsensus,
        policyNotes: policyNotes ?? this.policyNotes);
  }

  UpdatePolicyIntent copyWithWrapped(
      {Wrapped<String>? policyId,
      Wrapped<String?>? policyName,
      Wrapped<enums.Effect?>? policyEffect,
      Wrapped<String?>? policyCondition,
      Wrapped<String?>? policyConsensus,
      Wrapped<String?>? policyNotes}) {
    return UpdatePolicyIntent(
        policyId: (policyId != null ? policyId.value : this.policyId),
        policyName: (policyName != null ? policyName.value : this.policyName),
        policyEffect:
            (policyEffect != null ? policyEffect.value : this.policyEffect),
        policyCondition: (policyCondition != null
            ? policyCondition.value
            : this.policyCondition),
        policyConsensus: (policyConsensus != null
            ? policyConsensus.value
            : this.policyConsensus),
        policyNotes:
            (policyNotes != null ? policyNotes.value : this.policyNotes));
  }
}

@JsonSerializable(explicitToJson: true)
class UpdatePolicyIntentV2 {
  const UpdatePolicyIntentV2({
    required this.policyId,
    this.policyName,
    this.policyEffect,
    this.policyCondition,
    this.policyConsensus,
    this.policyNotes,
  });

  factory UpdatePolicyIntentV2.fromJson(Map<String, dynamic> json) =>
      _$UpdatePolicyIntentV2FromJson(json);

  static const toJsonFactory = _$UpdatePolicyIntentV2ToJson;
  Map<String, dynamic> toJson() => _$UpdatePolicyIntentV2ToJson(this);

  @JsonKey(name: 'policyId')
  final String policyId;
  @JsonKey(name: 'policyName')
  final String? policyName;
  @JsonKey(
    name: 'policyEffect',
    toJson: effectNullableToJson,
    fromJson: effectNullableFromJson,
  )
  final enums.Effect? policyEffect;
  @JsonKey(name: 'policyCondition')
  final String? policyCondition;
  @JsonKey(name: 'policyConsensus')
  final String? policyConsensus;
  @JsonKey(name: 'policyNotes')
  final String? policyNotes;
  static const fromJsonFactory = _$UpdatePolicyIntentV2FromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is UpdatePolicyIntentV2 &&
            (identical(other.policyId, policyId) ||
                const DeepCollectionEquality()
                    .equals(other.policyId, policyId)) &&
            (identical(other.policyName, policyName) ||
                const DeepCollectionEquality()
                    .equals(other.policyName, policyName)) &&
            (identical(other.policyEffect, policyEffect) ||
                const DeepCollectionEquality()
                    .equals(other.policyEffect, policyEffect)) &&
            (identical(other.policyCondition, policyCondition) ||
                const DeepCollectionEquality()
                    .equals(other.policyCondition, policyCondition)) &&
            (identical(other.policyConsensus, policyConsensus) ||
                const DeepCollectionEquality()
                    .equals(other.policyConsensus, policyConsensus)) &&
            (identical(other.policyNotes, policyNotes) ||
                const DeepCollectionEquality()
                    .equals(other.policyNotes, policyNotes)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(policyId) ^
      const DeepCollectionEquality().hash(policyName) ^
      const DeepCollectionEquality().hash(policyEffect) ^
      const DeepCollectionEquality().hash(policyCondition) ^
      const DeepCollectionEquality().hash(policyConsensus) ^
      const DeepCollectionEquality().hash(policyNotes) ^
      runtimeType.hashCode;
}

extension $UpdatePolicyIntentV2Extension on UpdatePolicyIntentV2 {
  UpdatePolicyIntentV2 copyWith(
      {String? policyId,
      String? policyName,
      enums.Effect? policyEffect,
      String? policyCondition,
      String? policyConsensus,
      String? policyNotes}) {
    return UpdatePolicyIntentV2(
        policyId: policyId ?? this.policyId,
        policyName: policyName ?? this.policyName,
        policyEffect: policyEffect ?? this.policyEffect,
        policyCondition: policyCondition ?? this.policyCondition,
        policyConsensus: policyConsensus ?? this.policyConsensus,
        policyNotes: policyNotes ?? this.policyNotes);
  }

  UpdatePolicyIntentV2 copyWithWrapped(
      {Wrapped<String>? policyId,
      Wrapped<String?>? policyName,
      Wrapped<enums.Effect?>? policyEffect,
      Wrapped<String?>? policyCondition,
      Wrapped<String?>? policyConsensus,
      Wrapped<String?>? policyNotes}) {
    return UpdatePolicyIntentV2(
        policyId: (policyId != null ? policyId.value : this.policyId),
        policyName: (policyName != null ? policyName.value : this.policyName),
        policyEffect:
            (policyEffect != null ? policyEffect.value : this.policyEffect),
        policyCondition: (policyCondition != null
            ? policyCondition.value
            : this.policyCondition),
        policyConsensus: (policyConsensus != null
            ? policyConsensus.value
            : this.policyConsensus),
        policyNotes:
            (policyNotes != null ? policyNotes.value : this.policyNotes));
  }
}

@JsonSerializable(explicitToJson: true)
class UpdatePolicyRequest {
  const UpdatePolicyRequest({
    required this.type,
    required this.timestampMs,
    required this.organizationId,
    required this.parameters,
  });

  factory UpdatePolicyRequest.fromJson(Map<String, dynamic> json) =>
      _$UpdatePolicyRequestFromJson(json);

  static const toJsonFactory = _$UpdatePolicyRequestToJson;
  Map<String, dynamic> toJson() => _$UpdatePolicyRequestToJson(this);

  @JsonKey(
    name: 'type',
    toJson: updatePolicyRequestTypeToJson,
    fromJson: updatePolicyRequestTypeFromJson,
  )
  final enums.UpdatePolicyRequestType type;
  @JsonKey(name: 'timestampMs')
  final String timestampMs;
  @JsonKey(name: 'organizationId')
  final String organizationId;
  @JsonKey(name: 'parameters')
  final UpdatePolicyIntentV2 parameters;
  static const fromJsonFactory = _$UpdatePolicyRequestFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is UpdatePolicyRequest &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.timestampMs, timestampMs) ||
                const DeepCollectionEquality()
                    .equals(other.timestampMs, timestampMs)) &&
            (identical(other.organizationId, organizationId) ||
                const DeepCollectionEquality()
                    .equals(other.organizationId, organizationId)) &&
            (identical(other.parameters, parameters) ||
                const DeepCollectionEquality()
                    .equals(other.parameters, parameters)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(timestampMs) ^
      const DeepCollectionEquality().hash(organizationId) ^
      const DeepCollectionEquality().hash(parameters) ^
      runtimeType.hashCode;
}

extension $UpdatePolicyRequestExtension on UpdatePolicyRequest {
  UpdatePolicyRequest copyWith(
      {enums.UpdatePolicyRequestType? type,
      String? timestampMs,
      String? organizationId,
      UpdatePolicyIntentV2? parameters}) {
    return UpdatePolicyRequest(
        type: type ?? this.type,
        timestampMs: timestampMs ?? this.timestampMs,
        organizationId: organizationId ?? this.organizationId,
        parameters: parameters ?? this.parameters);
  }

  UpdatePolicyRequest copyWithWrapped(
      {Wrapped<enums.UpdatePolicyRequestType>? type,
      Wrapped<String>? timestampMs,
      Wrapped<String>? organizationId,
      Wrapped<UpdatePolicyIntentV2>? parameters}) {
    return UpdatePolicyRequest(
        type: (type != null ? type.value : this.type),
        timestampMs:
            (timestampMs != null ? timestampMs.value : this.timestampMs),
        organizationId: (organizationId != null
            ? organizationId.value
            : this.organizationId),
        parameters: (parameters != null ? parameters.value : this.parameters));
  }
}

@JsonSerializable(explicitToJson: true)
class UpdatePolicyResult {
  const UpdatePolicyResult({
    required this.policyId,
  });

  factory UpdatePolicyResult.fromJson(Map<String, dynamic> json) =>
      _$UpdatePolicyResultFromJson(json);

  static const toJsonFactory = _$UpdatePolicyResultToJson;
  Map<String, dynamic> toJson() => _$UpdatePolicyResultToJson(this);

  @JsonKey(name: 'policyId')
  final String policyId;
  static const fromJsonFactory = _$UpdatePolicyResultFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is UpdatePolicyResult &&
            (identical(other.policyId, policyId) ||
                const DeepCollectionEquality()
                    .equals(other.policyId, policyId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(policyId) ^ runtimeType.hashCode;
}

extension $UpdatePolicyResultExtension on UpdatePolicyResult {
  UpdatePolicyResult copyWith({String? policyId}) {
    return UpdatePolicyResult(policyId: policyId ?? this.policyId);
  }

  UpdatePolicyResult copyWithWrapped({Wrapped<String>? policyId}) {
    return UpdatePolicyResult(
        policyId: (policyId != null ? policyId.value : this.policyId));
  }
}

@JsonSerializable(explicitToJson: true)
class UpdatePolicyResultV2 {
  const UpdatePolicyResultV2({
    required this.policyId,
  });

  factory UpdatePolicyResultV2.fromJson(Map<String, dynamic> json) =>
      _$UpdatePolicyResultV2FromJson(json);

  static const toJsonFactory = _$UpdatePolicyResultV2ToJson;
  Map<String, dynamic> toJson() => _$UpdatePolicyResultV2ToJson(this);

  @JsonKey(name: 'policyId')
  final String policyId;
  static const fromJsonFactory = _$UpdatePolicyResultV2FromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is UpdatePolicyResultV2 &&
            (identical(other.policyId, policyId) ||
                const DeepCollectionEquality()
                    .equals(other.policyId, policyId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(policyId) ^ runtimeType.hashCode;
}

extension $UpdatePolicyResultV2Extension on UpdatePolicyResultV2 {
  UpdatePolicyResultV2 copyWith({String? policyId}) {
    return UpdatePolicyResultV2(policyId: policyId ?? this.policyId);
  }

  UpdatePolicyResultV2 copyWithWrapped({Wrapped<String>? policyId}) {
    return UpdatePolicyResultV2(
        policyId: (policyId != null ? policyId.value : this.policyId));
  }
}

@JsonSerializable(explicitToJson: true)
class UpdatePrivateKeyTagIntent {
  const UpdatePrivateKeyTagIntent({
    required this.privateKeyTagId,
    this.newPrivateKeyTagName,
    required this.addPrivateKeyIds,
    required this.removePrivateKeyIds,
  });

  factory UpdatePrivateKeyTagIntent.fromJson(Map<String, dynamic> json) =>
      _$UpdatePrivateKeyTagIntentFromJson(json);

  static const toJsonFactory = _$UpdatePrivateKeyTagIntentToJson;
  Map<String, dynamic> toJson() => _$UpdatePrivateKeyTagIntentToJson(this);

  @JsonKey(name: 'privateKeyTagId')
  final String privateKeyTagId;
  @JsonKey(name: 'newPrivateKeyTagName')
  final String? newPrivateKeyTagName;
  @JsonKey(name: 'addPrivateKeyIds', defaultValue: <String>[])
  final List<String> addPrivateKeyIds;
  @JsonKey(name: 'removePrivateKeyIds', defaultValue: <String>[])
  final List<String> removePrivateKeyIds;
  static const fromJsonFactory = _$UpdatePrivateKeyTagIntentFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is UpdatePrivateKeyTagIntent &&
            (identical(other.privateKeyTagId, privateKeyTagId) ||
                const DeepCollectionEquality()
                    .equals(other.privateKeyTagId, privateKeyTagId)) &&
            (identical(other.newPrivateKeyTagName, newPrivateKeyTagName) ||
                const DeepCollectionEquality().equals(
                    other.newPrivateKeyTagName, newPrivateKeyTagName)) &&
            (identical(other.addPrivateKeyIds, addPrivateKeyIds) ||
                const DeepCollectionEquality()
                    .equals(other.addPrivateKeyIds, addPrivateKeyIds)) &&
            (identical(other.removePrivateKeyIds, removePrivateKeyIds) ||
                const DeepCollectionEquality()
                    .equals(other.removePrivateKeyIds, removePrivateKeyIds)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(privateKeyTagId) ^
      const DeepCollectionEquality().hash(newPrivateKeyTagName) ^
      const DeepCollectionEquality().hash(addPrivateKeyIds) ^
      const DeepCollectionEquality().hash(removePrivateKeyIds) ^
      runtimeType.hashCode;
}

extension $UpdatePrivateKeyTagIntentExtension on UpdatePrivateKeyTagIntent {
  UpdatePrivateKeyTagIntent copyWith(
      {String? privateKeyTagId,
      String? newPrivateKeyTagName,
      List<String>? addPrivateKeyIds,
      List<String>? removePrivateKeyIds}) {
    return UpdatePrivateKeyTagIntent(
        privateKeyTagId: privateKeyTagId ?? this.privateKeyTagId,
        newPrivateKeyTagName: newPrivateKeyTagName ?? this.newPrivateKeyTagName,
        addPrivateKeyIds: addPrivateKeyIds ?? this.addPrivateKeyIds,
        removePrivateKeyIds: removePrivateKeyIds ?? this.removePrivateKeyIds);
  }

  UpdatePrivateKeyTagIntent copyWithWrapped(
      {Wrapped<String>? privateKeyTagId,
      Wrapped<String?>? newPrivateKeyTagName,
      Wrapped<List<String>>? addPrivateKeyIds,
      Wrapped<List<String>>? removePrivateKeyIds}) {
    return UpdatePrivateKeyTagIntent(
        privateKeyTagId: (privateKeyTagId != null
            ? privateKeyTagId.value
            : this.privateKeyTagId),
        newPrivateKeyTagName: (newPrivateKeyTagName != null
            ? newPrivateKeyTagName.value
            : this.newPrivateKeyTagName),
        addPrivateKeyIds: (addPrivateKeyIds != null
            ? addPrivateKeyIds.value
            : this.addPrivateKeyIds),
        removePrivateKeyIds: (removePrivateKeyIds != null
            ? removePrivateKeyIds.value
            : this.removePrivateKeyIds));
  }
}

@JsonSerializable(explicitToJson: true)
class UpdatePrivateKeyTagRequest {
  const UpdatePrivateKeyTagRequest({
    required this.type,
    required this.timestampMs,
    required this.organizationId,
    required this.parameters,
  });

  factory UpdatePrivateKeyTagRequest.fromJson(Map<String, dynamic> json) =>
      _$UpdatePrivateKeyTagRequestFromJson(json);

  static const toJsonFactory = _$UpdatePrivateKeyTagRequestToJson;
  Map<String, dynamic> toJson() => _$UpdatePrivateKeyTagRequestToJson(this);

  @JsonKey(
    name: 'type',
    toJson: updatePrivateKeyTagRequestTypeToJson,
    fromJson: updatePrivateKeyTagRequestTypeFromJson,
  )
  final enums.UpdatePrivateKeyTagRequestType type;
  @JsonKey(name: 'timestampMs')
  final String timestampMs;
  @JsonKey(name: 'organizationId')
  final String organizationId;
  @JsonKey(name: 'parameters')
  final UpdatePrivateKeyTagIntent parameters;
  static const fromJsonFactory = _$UpdatePrivateKeyTagRequestFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is UpdatePrivateKeyTagRequest &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.timestampMs, timestampMs) ||
                const DeepCollectionEquality()
                    .equals(other.timestampMs, timestampMs)) &&
            (identical(other.organizationId, organizationId) ||
                const DeepCollectionEquality()
                    .equals(other.organizationId, organizationId)) &&
            (identical(other.parameters, parameters) ||
                const DeepCollectionEquality()
                    .equals(other.parameters, parameters)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(timestampMs) ^
      const DeepCollectionEquality().hash(organizationId) ^
      const DeepCollectionEquality().hash(parameters) ^
      runtimeType.hashCode;
}

extension $UpdatePrivateKeyTagRequestExtension on UpdatePrivateKeyTagRequest {
  UpdatePrivateKeyTagRequest copyWith(
      {enums.UpdatePrivateKeyTagRequestType? type,
      String? timestampMs,
      String? organizationId,
      UpdatePrivateKeyTagIntent? parameters}) {
    return UpdatePrivateKeyTagRequest(
        type: type ?? this.type,
        timestampMs: timestampMs ?? this.timestampMs,
        organizationId: organizationId ?? this.organizationId,
        parameters: parameters ?? this.parameters);
  }

  UpdatePrivateKeyTagRequest copyWithWrapped(
      {Wrapped<enums.UpdatePrivateKeyTagRequestType>? type,
      Wrapped<String>? timestampMs,
      Wrapped<String>? organizationId,
      Wrapped<UpdatePrivateKeyTagIntent>? parameters}) {
    return UpdatePrivateKeyTagRequest(
        type: (type != null ? type.value : this.type),
        timestampMs:
            (timestampMs != null ? timestampMs.value : this.timestampMs),
        organizationId: (organizationId != null
            ? organizationId.value
            : this.organizationId),
        parameters: (parameters != null ? parameters.value : this.parameters));
  }
}

@JsonSerializable(explicitToJson: true)
class UpdatePrivateKeyTagResult {
  const UpdatePrivateKeyTagResult({
    required this.privateKeyTagId,
  });

  factory UpdatePrivateKeyTagResult.fromJson(Map<String, dynamic> json) =>
      _$UpdatePrivateKeyTagResultFromJson(json);

  static const toJsonFactory = _$UpdatePrivateKeyTagResultToJson;
  Map<String, dynamic> toJson() => _$UpdatePrivateKeyTagResultToJson(this);

  @JsonKey(name: 'privateKeyTagId')
  final String privateKeyTagId;
  static const fromJsonFactory = _$UpdatePrivateKeyTagResultFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is UpdatePrivateKeyTagResult &&
            (identical(other.privateKeyTagId, privateKeyTagId) ||
                const DeepCollectionEquality()
                    .equals(other.privateKeyTagId, privateKeyTagId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(privateKeyTagId) ^
      runtimeType.hashCode;
}

extension $UpdatePrivateKeyTagResultExtension on UpdatePrivateKeyTagResult {
  UpdatePrivateKeyTagResult copyWith({String? privateKeyTagId}) {
    return UpdatePrivateKeyTagResult(
        privateKeyTagId: privateKeyTagId ?? this.privateKeyTagId);
  }

  UpdatePrivateKeyTagResult copyWithWrapped(
      {Wrapped<String>? privateKeyTagId}) {
    return UpdatePrivateKeyTagResult(
        privateKeyTagId: (privateKeyTagId != null
            ? privateKeyTagId.value
            : this.privateKeyTagId));
  }
}

@JsonSerializable(explicitToJson: true)
class UpdateRootQuorumIntent {
  const UpdateRootQuorumIntent({
    required this.threshold,
    required this.userIds,
  });

  factory UpdateRootQuorumIntent.fromJson(Map<String, dynamic> json) =>
      _$UpdateRootQuorumIntentFromJson(json);

  static const toJsonFactory = _$UpdateRootQuorumIntentToJson;
  Map<String, dynamic> toJson() => _$UpdateRootQuorumIntentToJson(this);

  @JsonKey(name: 'threshold')
  final int threshold;
  @JsonKey(name: 'userIds', defaultValue: <String>[])
  final List<String> userIds;
  static const fromJsonFactory = _$UpdateRootQuorumIntentFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is UpdateRootQuorumIntent &&
            (identical(other.threshold, threshold) ||
                const DeepCollectionEquality()
                    .equals(other.threshold, threshold)) &&
            (identical(other.userIds, userIds) ||
                const DeepCollectionEquality().equals(other.userIds, userIds)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(threshold) ^
      const DeepCollectionEquality().hash(userIds) ^
      runtimeType.hashCode;
}

extension $UpdateRootQuorumIntentExtension on UpdateRootQuorumIntent {
  UpdateRootQuorumIntent copyWith({int? threshold, List<String>? userIds}) {
    return UpdateRootQuorumIntent(
        threshold: threshold ?? this.threshold,
        userIds: userIds ?? this.userIds);
  }

  UpdateRootQuorumIntent copyWithWrapped(
      {Wrapped<int>? threshold, Wrapped<List<String>>? userIds}) {
    return UpdateRootQuorumIntent(
        threshold: (threshold != null ? threshold.value : this.threshold),
        userIds: (userIds != null ? userIds.value : this.userIds));
  }
}

@JsonSerializable(explicitToJson: true)
class UpdateRootQuorumRequest {
  const UpdateRootQuorumRequest({
    required this.type,
    required this.timestampMs,
    required this.organizationId,
    required this.parameters,
  });

  factory UpdateRootQuorumRequest.fromJson(Map<String, dynamic> json) =>
      _$UpdateRootQuorumRequestFromJson(json);

  static const toJsonFactory = _$UpdateRootQuorumRequestToJson;
  Map<String, dynamic> toJson() => _$UpdateRootQuorumRequestToJson(this);

  @JsonKey(
    name: 'type',
    toJson: updateRootQuorumRequestTypeToJson,
    fromJson: updateRootQuorumRequestTypeFromJson,
  )
  final enums.UpdateRootQuorumRequestType type;
  @JsonKey(name: 'timestampMs')
  final String timestampMs;
  @JsonKey(name: 'organizationId')
  final String organizationId;
  @JsonKey(name: 'parameters')
  final UpdateRootQuorumIntent parameters;
  static const fromJsonFactory = _$UpdateRootQuorumRequestFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is UpdateRootQuorumRequest &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.timestampMs, timestampMs) ||
                const DeepCollectionEquality()
                    .equals(other.timestampMs, timestampMs)) &&
            (identical(other.organizationId, organizationId) ||
                const DeepCollectionEquality()
                    .equals(other.organizationId, organizationId)) &&
            (identical(other.parameters, parameters) ||
                const DeepCollectionEquality()
                    .equals(other.parameters, parameters)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(timestampMs) ^
      const DeepCollectionEquality().hash(organizationId) ^
      const DeepCollectionEquality().hash(parameters) ^
      runtimeType.hashCode;
}

extension $UpdateRootQuorumRequestExtension on UpdateRootQuorumRequest {
  UpdateRootQuorumRequest copyWith(
      {enums.UpdateRootQuorumRequestType? type,
      String? timestampMs,
      String? organizationId,
      UpdateRootQuorumIntent? parameters}) {
    return UpdateRootQuorumRequest(
        type: type ?? this.type,
        timestampMs: timestampMs ?? this.timestampMs,
        organizationId: organizationId ?? this.organizationId,
        parameters: parameters ?? this.parameters);
  }

  UpdateRootQuorumRequest copyWithWrapped(
      {Wrapped<enums.UpdateRootQuorumRequestType>? type,
      Wrapped<String>? timestampMs,
      Wrapped<String>? organizationId,
      Wrapped<UpdateRootQuorumIntent>? parameters}) {
    return UpdateRootQuorumRequest(
        type: (type != null ? type.value : this.type),
        timestampMs:
            (timestampMs != null ? timestampMs.value : this.timestampMs),
        organizationId: (organizationId != null
            ? organizationId.value
            : this.organizationId),
        parameters: (parameters != null ? parameters.value : this.parameters));
  }
}

@JsonSerializable(explicitToJson: true)
class UpdateRootQuorumResult {
  const UpdateRootQuorumResult();

  factory UpdateRootQuorumResult.fromJson(Map<String, dynamic> json) =>
      _$UpdateRootQuorumResultFromJson(json);

  static const toJsonFactory = _$UpdateRootQuorumResultToJson;
  Map<String, dynamic> toJson() => _$UpdateRootQuorumResultToJson(this);

  static const fromJsonFactory = _$UpdateRootQuorumResultFromJson;

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode => runtimeType.hashCode;
}

@JsonSerializable(explicitToJson: true)
class UpdateUserEmailIntent {
  const UpdateUserEmailIntent({
    required this.userId,
    required this.userEmail,
    this.verificationToken,
  });

  factory UpdateUserEmailIntent.fromJson(Map<String, dynamic> json) =>
      _$UpdateUserEmailIntentFromJson(json);

  static const toJsonFactory = _$UpdateUserEmailIntentToJson;
  Map<String, dynamic> toJson() => _$UpdateUserEmailIntentToJson(this);

  @JsonKey(name: 'userId')
  final String userId;
  @JsonKey(name: 'userEmail')
  final String userEmail;
  @JsonKey(name: 'verificationToken')
  final String? verificationToken;
  static const fromJsonFactory = _$UpdateUserEmailIntentFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is UpdateUserEmailIntent &&
            (identical(other.userId, userId) ||
                const DeepCollectionEquality().equals(other.userId, userId)) &&
            (identical(other.userEmail, userEmail) ||
                const DeepCollectionEquality()
                    .equals(other.userEmail, userEmail)) &&
            (identical(other.verificationToken, verificationToken) ||
                const DeepCollectionEquality()
                    .equals(other.verificationToken, verificationToken)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(userId) ^
      const DeepCollectionEquality().hash(userEmail) ^
      const DeepCollectionEquality().hash(verificationToken) ^
      runtimeType.hashCode;
}

extension $UpdateUserEmailIntentExtension on UpdateUserEmailIntent {
  UpdateUserEmailIntent copyWith(
      {String? userId, String? userEmail, String? verificationToken}) {
    return UpdateUserEmailIntent(
        userId: userId ?? this.userId,
        userEmail: userEmail ?? this.userEmail,
        verificationToken: verificationToken ?? this.verificationToken);
  }

  UpdateUserEmailIntent copyWithWrapped(
      {Wrapped<String>? userId,
      Wrapped<String>? userEmail,
      Wrapped<String?>? verificationToken}) {
    return UpdateUserEmailIntent(
        userId: (userId != null ? userId.value : this.userId),
        userEmail: (userEmail != null ? userEmail.value : this.userEmail),
        verificationToken: (verificationToken != null
            ? verificationToken.value
            : this.verificationToken));
  }
}

@JsonSerializable(explicitToJson: true)
class UpdateUserEmailRequest {
  const UpdateUserEmailRequest({
    required this.type,
    required this.timestampMs,
    required this.organizationId,
    required this.parameters,
  });

  factory UpdateUserEmailRequest.fromJson(Map<String, dynamic> json) =>
      _$UpdateUserEmailRequestFromJson(json);

  static const toJsonFactory = _$UpdateUserEmailRequestToJson;
  Map<String, dynamic> toJson() => _$UpdateUserEmailRequestToJson(this);

  @JsonKey(
    name: 'type',
    toJson: updateUserEmailRequestTypeToJson,
    fromJson: updateUserEmailRequestTypeFromJson,
  )
  final enums.UpdateUserEmailRequestType type;
  @JsonKey(name: 'timestampMs')
  final String timestampMs;
  @JsonKey(name: 'organizationId')
  final String organizationId;
  @JsonKey(name: 'parameters')
  final UpdateUserEmailIntent parameters;
  static const fromJsonFactory = _$UpdateUserEmailRequestFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is UpdateUserEmailRequest &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.timestampMs, timestampMs) ||
                const DeepCollectionEquality()
                    .equals(other.timestampMs, timestampMs)) &&
            (identical(other.organizationId, organizationId) ||
                const DeepCollectionEquality()
                    .equals(other.organizationId, organizationId)) &&
            (identical(other.parameters, parameters) ||
                const DeepCollectionEquality()
                    .equals(other.parameters, parameters)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(timestampMs) ^
      const DeepCollectionEquality().hash(organizationId) ^
      const DeepCollectionEquality().hash(parameters) ^
      runtimeType.hashCode;
}

extension $UpdateUserEmailRequestExtension on UpdateUserEmailRequest {
  UpdateUserEmailRequest copyWith(
      {enums.UpdateUserEmailRequestType? type,
      String? timestampMs,
      String? organizationId,
      UpdateUserEmailIntent? parameters}) {
    return UpdateUserEmailRequest(
        type: type ?? this.type,
        timestampMs: timestampMs ?? this.timestampMs,
        organizationId: organizationId ?? this.organizationId,
        parameters: parameters ?? this.parameters);
  }

  UpdateUserEmailRequest copyWithWrapped(
      {Wrapped<enums.UpdateUserEmailRequestType>? type,
      Wrapped<String>? timestampMs,
      Wrapped<String>? organizationId,
      Wrapped<UpdateUserEmailIntent>? parameters}) {
    return UpdateUserEmailRequest(
        type: (type != null ? type.value : this.type),
        timestampMs:
            (timestampMs != null ? timestampMs.value : this.timestampMs),
        organizationId: (organizationId != null
            ? organizationId.value
            : this.organizationId),
        parameters: (parameters != null ? parameters.value : this.parameters));
  }
}

@JsonSerializable(explicitToJson: true)
class UpdateUserEmailResult {
  const UpdateUserEmailResult({
    required this.userId,
  });

  factory UpdateUserEmailResult.fromJson(Map<String, dynamic> json) =>
      _$UpdateUserEmailResultFromJson(json);

  static const toJsonFactory = _$UpdateUserEmailResultToJson;
  Map<String, dynamic> toJson() => _$UpdateUserEmailResultToJson(this);

  @JsonKey(name: 'userId')
  final String userId;
  static const fromJsonFactory = _$UpdateUserEmailResultFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is UpdateUserEmailResult &&
            (identical(other.userId, userId) ||
                const DeepCollectionEquality().equals(other.userId, userId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(userId) ^ runtimeType.hashCode;
}

extension $UpdateUserEmailResultExtension on UpdateUserEmailResult {
  UpdateUserEmailResult copyWith({String? userId}) {
    return UpdateUserEmailResult(userId: userId ?? this.userId);
  }

  UpdateUserEmailResult copyWithWrapped({Wrapped<String>? userId}) {
    return UpdateUserEmailResult(
        userId: (userId != null ? userId.value : this.userId));
  }
}

@JsonSerializable(explicitToJson: true)
class UpdateUserIntent {
  const UpdateUserIntent({
    required this.userId,
    this.userName,
    this.userEmail,
    this.userTagIds,
    this.userPhoneNumber,
  });

  factory UpdateUserIntent.fromJson(Map<String, dynamic> json) =>
      _$UpdateUserIntentFromJson(json);

  static const toJsonFactory = _$UpdateUserIntentToJson;
  Map<String, dynamic> toJson() => _$UpdateUserIntentToJson(this);

  @JsonKey(name: 'userId')
  final String userId;
  @JsonKey(name: 'userName')
  final String? userName;
  @JsonKey(name: 'userEmail')
  final String? userEmail;
  @JsonKey(name: 'userTagIds', defaultValue: <String>[])
  final List<String>? userTagIds;
  @JsonKey(name: 'userPhoneNumber')
  final String? userPhoneNumber;
  static const fromJsonFactory = _$UpdateUserIntentFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is UpdateUserIntent &&
            (identical(other.userId, userId) ||
                const DeepCollectionEquality().equals(other.userId, userId)) &&
            (identical(other.userName, userName) ||
                const DeepCollectionEquality()
                    .equals(other.userName, userName)) &&
            (identical(other.userEmail, userEmail) ||
                const DeepCollectionEquality()
                    .equals(other.userEmail, userEmail)) &&
            (identical(other.userTagIds, userTagIds) ||
                const DeepCollectionEquality()
                    .equals(other.userTagIds, userTagIds)) &&
            (identical(other.userPhoneNumber, userPhoneNumber) ||
                const DeepCollectionEquality()
                    .equals(other.userPhoneNumber, userPhoneNumber)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(userId) ^
      const DeepCollectionEquality().hash(userName) ^
      const DeepCollectionEquality().hash(userEmail) ^
      const DeepCollectionEquality().hash(userTagIds) ^
      const DeepCollectionEquality().hash(userPhoneNumber) ^
      runtimeType.hashCode;
}

extension $UpdateUserIntentExtension on UpdateUserIntent {
  UpdateUserIntent copyWith(
      {String? userId,
      String? userName,
      String? userEmail,
      List<String>? userTagIds,
      String? userPhoneNumber}) {
    return UpdateUserIntent(
        userId: userId ?? this.userId,
        userName: userName ?? this.userName,
        userEmail: userEmail ?? this.userEmail,
        userTagIds: userTagIds ?? this.userTagIds,
        userPhoneNumber: userPhoneNumber ?? this.userPhoneNumber);
  }

  UpdateUserIntent copyWithWrapped(
      {Wrapped<String>? userId,
      Wrapped<String?>? userName,
      Wrapped<String?>? userEmail,
      Wrapped<List<String>?>? userTagIds,
      Wrapped<String?>? userPhoneNumber}) {
    return UpdateUserIntent(
        userId: (userId != null ? userId.value : this.userId),
        userName: (userName != null ? userName.value : this.userName),
        userEmail: (userEmail != null ? userEmail.value : this.userEmail),
        userTagIds: (userTagIds != null ? userTagIds.value : this.userTagIds),
        userPhoneNumber: (userPhoneNumber != null
            ? userPhoneNumber.value
            : this.userPhoneNumber));
  }
}

@JsonSerializable(explicitToJson: true)
class UpdateUserNameIntent {
  const UpdateUserNameIntent({
    required this.userId,
    required this.userName,
  });

  factory UpdateUserNameIntent.fromJson(Map<String, dynamic> json) =>
      _$UpdateUserNameIntentFromJson(json);

  static const toJsonFactory = _$UpdateUserNameIntentToJson;
  Map<String, dynamic> toJson() => _$UpdateUserNameIntentToJson(this);

  @JsonKey(name: 'userId')
  final String userId;
  @JsonKey(name: 'userName')
  final String userName;
  static const fromJsonFactory = _$UpdateUserNameIntentFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is UpdateUserNameIntent &&
            (identical(other.userId, userId) ||
                const DeepCollectionEquality().equals(other.userId, userId)) &&
            (identical(other.userName, userName) ||
                const DeepCollectionEquality()
                    .equals(other.userName, userName)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(userId) ^
      const DeepCollectionEquality().hash(userName) ^
      runtimeType.hashCode;
}

extension $UpdateUserNameIntentExtension on UpdateUserNameIntent {
  UpdateUserNameIntent copyWith({String? userId, String? userName}) {
    return UpdateUserNameIntent(
        userId: userId ?? this.userId, userName: userName ?? this.userName);
  }

  UpdateUserNameIntent copyWithWrapped(
      {Wrapped<String>? userId, Wrapped<String>? userName}) {
    return UpdateUserNameIntent(
        userId: (userId != null ? userId.value : this.userId),
        userName: (userName != null ? userName.value : this.userName));
  }
}

@JsonSerializable(explicitToJson: true)
class UpdateUserNameRequest {
  const UpdateUserNameRequest({
    required this.type,
    required this.timestampMs,
    required this.organizationId,
    required this.parameters,
  });

  factory UpdateUserNameRequest.fromJson(Map<String, dynamic> json) =>
      _$UpdateUserNameRequestFromJson(json);

  static const toJsonFactory = _$UpdateUserNameRequestToJson;
  Map<String, dynamic> toJson() => _$UpdateUserNameRequestToJson(this);

  @JsonKey(
    name: 'type',
    toJson: updateUserNameRequestTypeToJson,
    fromJson: updateUserNameRequestTypeFromJson,
  )
  final enums.UpdateUserNameRequestType type;
  @JsonKey(name: 'timestampMs')
  final String timestampMs;
  @JsonKey(name: 'organizationId')
  final String organizationId;
  @JsonKey(name: 'parameters')
  final UpdateUserNameIntent parameters;
  static const fromJsonFactory = _$UpdateUserNameRequestFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is UpdateUserNameRequest &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.timestampMs, timestampMs) ||
                const DeepCollectionEquality()
                    .equals(other.timestampMs, timestampMs)) &&
            (identical(other.organizationId, organizationId) ||
                const DeepCollectionEquality()
                    .equals(other.organizationId, organizationId)) &&
            (identical(other.parameters, parameters) ||
                const DeepCollectionEquality()
                    .equals(other.parameters, parameters)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(timestampMs) ^
      const DeepCollectionEquality().hash(organizationId) ^
      const DeepCollectionEquality().hash(parameters) ^
      runtimeType.hashCode;
}

extension $UpdateUserNameRequestExtension on UpdateUserNameRequest {
  UpdateUserNameRequest copyWith(
      {enums.UpdateUserNameRequestType? type,
      String? timestampMs,
      String? organizationId,
      UpdateUserNameIntent? parameters}) {
    return UpdateUserNameRequest(
        type: type ?? this.type,
        timestampMs: timestampMs ?? this.timestampMs,
        organizationId: organizationId ?? this.organizationId,
        parameters: parameters ?? this.parameters);
  }

  UpdateUserNameRequest copyWithWrapped(
      {Wrapped<enums.UpdateUserNameRequestType>? type,
      Wrapped<String>? timestampMs,
      Wrapped<String>? organizationId,
      Wrapped<UpdateUserNameIntent>? parameters}) {
    return UpdateUserNameRequest(
        type: (type != null ? type.value : this.type),
        timestampMs:
            (timestampMs != null ? timestampMs.value : this.timestampMs),
        organizationId: (organizationId != null
            ? organizationId.value
            : this.organizationId),
        parameters: (parameters != null ? parameters.value : this.parameters));
  }
}

@JsonSerializable(explicitToJson: true)
class UpdateUserNameResult {
  const UpdateUserNameResult({
    required this.userId,
  });

  factory UpdateUserNameResult.fromJson(Map<String, dynamic> json) =>
      _$UpdateUserNameResultFromJson(json);

  static const toJsonFactory = _$UpdateUserNameResultToJson;
  Map<String, dynamic> toJson() => _$UpdateUserNameResultToJson(this);

  @JsonKey(name: 'userId')
  final String userId;
  static const fromJsonFactory = _$UpdateUserNameResultFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is UpdateUserNameResult &&
            (identical(other.userId, userId) ||
                const DeepCollectionEquality().equals(other.userId, userId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(userId) ^ runtimeType.hashCode;
}

extension $UpdateUserNameResultExtension on UpdateUserNameResult {
  UpdateUserNameResult copyWith({String? userId}) {
    return UpdateUserNameResult(userId: userId ?? this.userId);
  }

  UpdateUserNameResult copyWithWrapped({Wrapped<String>? userId}) {
    return UpdateUserNameResult(
        userId: (userId != null ? userId.value : this.userId));
  }
}

@JsonSerializable(explicitToJson: true)
class UpdateUserPhoneNumberIntent {
  const UpdateUserPhoneNumberIntent({
    required this.userId,
    required this.userPhoneNumber,
    this.verificationToken,
  });

  factory UpdateUserPhoneNumberIntent.fromJson(Map<String, dynamic> json) =>
      _$UpdateUserPhoneNumberIntentFromJson(json);

  static const toJsonFactory = _$UpdateUserPhoneNumberIntentToJson;
  Map<String, dynamic> toJson() => _$UpdateUserPhoneNumberIntentToJson(this);

  @JsonKey(name: 'userId')
  final String userId;
  @JsonKey(name: 'userPhoneNumber')
  final String userPhoneNumber;
  @JsonKey(name: 'verificationToken')
  final String? verificationToken;
  static const fromJsonFactory = _$UpdateUserPhoneNumberIntentFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is UpdateUserPhoneNumberIntent &&
            (identical(other.userId, userId) ||
                const DeepCollectionEquality().equals(other.userId, userId)) &&
            (identical(other.userPhoneNumber, userPhoneNumber) ||
                const DeepCollectionEquality()
                    .equals(other.userPhoneNumber, userPhoneNumber)) &&
            (identical(other.verificationToken, verificationToken) ||
                const DeepCollectionEquality()
                    .equals(other.verificationToken, verificationToken)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(userId) ^
      const DeepCollectionEquality().hash(userPhoneNumber) ^
      const DeepCollectionEquality().hash(verificationToken) ^
      runtimeType.hashCode;
}

extension $UpdateUserPhoneNumberIntentExtension on UpdateUserPhoneNumberIntent {
  UpdateUserPhoneNumberIntent copyWith(
      {String? userId, String? userPhoneNumber, String? verificationToken}) {
    return UpdateUserPhoneNumberIntent(
        userId: userId ?? this.userId,
        userPhoneNumber: userPhoneNumber ?? this.userPhoneNumber,
        verificationToken: verificationToken ?? this.verificationToken);
  }

  UpdateUserPhoneNumberIntent copyWithWrapped(
      {Wrapped<String>? userId,
      Wrapped<String>? userPhoneNumber,
      Wrapped<String?>? verificationToken}) {
    return UpdateUserPhoneNumberIntent(
        userId: (userId != null ? userId.value : this.userId),
        userPhoneNumber: (userPhoneNumber != null
            ? userPhoneNumber.value
            : this.userPhoneNumber),
        verificationToken: (verificationToken != null
            ? verificationToken.value
            : this.verificationToken));
  }
}

@JsonSerializable(explicitToJson: true)
class UpdateUserPhoneNumberRequest {
  const UpdateUserPhoneNumberRequest({
    required this.type,
    required this.timestampMs,
    required this.organizationId,
    required this.parameters,
  });

  factory UpdateUserPhoneNumberRequest.fromJson(Map<String, dynamic> json) =>
      _$UpdateUserPhoneNumberRequestFromJson(json);

  static const toJsonFactory = _$UpdateUserPhoneNumberRequestToJson;
  Map<String, dynamic> toJson() => _$UpdateUserPhoneNumberRequestToJson(this);

  @JsonKey(
    name: 'type',
    toJson: updateUserPhoneNumberRequestTypeToJson,
    fromJson: updateUserPhoneNumberRequestTypeFromJson,
  )
  final enums.UpdateUserPhoneNumberRequestType type;
  @JsonKey(name: 'timestampMs')
  final String timestampMs;
  @JsonKey(name: 'organizationId')
  final String organizationId;
  @JsonKey(name: 'parameters')
  final UpdateUserPhoneNumberIntent parameters;
  static const fromJsonFactory = _$UpdateUserPhoneNumberRequestFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is UpdateUserPhoneNumberRequest &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.timestampMs, timestampMs) ||
                const DeepCollectionEquality()
                    .equals(other.timestampMs, timestampMs)) &&
            (identical(other.organizationId, organizationId) ||
                const DeepCollectionEquality()
                    .equals(other.organizationId, organizationId)) &&
            (identical(other.parameters, parameters) ||
                const DeepCollectionEquality()
                    .equals(other.parameters, parameters)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(timestampMs) ^
      const DeepCollectionEquality().hash(organizationId) ^
      const DeepCollectionEquality().hash(parameters) ^
      runtimeType.hashCode;
}

extension $UpdateUserPhoneNumberRequestExtension
    on UpdateUserPhoneNumberRequest {
  UpdateUserPhoneNumberRequest copyWith(
      {enums.UpdateUserPhoneNumberRequestType? type,
      String? timestampMs,
      String? organizationId,
      UpdateUserPhoneNumberIntent? parameters}) {
    return UpdateUserPhoneNumberRequest(
        type: type ?? this.type,
        timestampMs: timestampMs ?? this.timestampMs,
        organizationId: organizationId ?? this.organizationId,
        parameters: parameters ?? this.parameters);
  }

  UpdateUserPhoneNumberRequest copyWithWrapped(
      {Wrapped<enums.UpdateUserPhoneNumberRequestType>? type,
      Wrapped<String>? timestampMs,
      Wrapped<String>? organizationId,
      Wrapped<UpdateUserPhoneNumberIntent>? parameters}) {
    return UpdateUserPhoneNumberRequest(
        type: (type != null ? type.value : this.type),
        timestampMs:
            (timestampMs != null ? timestampMs.value : this.timestampMs),
        organizationId: (organizationId != null
            ? organizationId.value
            : this.organizationId),
        parameters: (parameters != null ? parameters.value : this.parameters));
  }
}

@JsonSerializable(explicitToJson: true)
class UpdateUserPhoneNumberResult {
  const UpdateUserPhoneNumberResult({
    required this.userId,
  });

  factory UpdateUserPhoneNumberResult.fromJson(Map<String, dynamic> json) =>
      _$UpdateUserPhoneNumberResultFromJson(json);

  static const toJsonFactory = _$UpdateUserPhoneNumberResultToJson;
  Map<String, dynamic> toJson() => _$UpdateUserPhoneNumberResultToJson(this);

  @JsonKey(name: 'userId')
  final String userId;
  static const fromJsonFactory = _$UpdateUserPhoneNumberResultFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is UpdateUserPhoneNumberResult &&
            (identical(other.userId, userId) ||
                const DeepCollectionEquality().equals(other.userId, userId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(userId) ^ runtimeType.hashCode;
}

extension $UpdateUserPhoneNumberResultExtension on UpdateUserPhoneNumberResult {
  UpdateUserPhoneNumberResult copyWith({String? userId}) {
    return UpdateUserPhoneNumberResult(userId: userId ?? this.userId);
  }

  UpdateUserPhoneNumberResult copyWithWrapped({Wrapped<String>? userId}) {
    return UpdateUserPhoneNumberResult(
        userId: (userId != null ? userId.value : this.userId));
  }
}

@JsonSerializable(explicitToJson: true)
class UpdateUserRequest {
  const UpdateUserRequest({
    required this.type,
    required this.timestampMs,
    required this.organizationId,
    required this.parameters,
  });

  factory UpdateUserRequest.fromJson(Map<String, dynamic> json) =>
      _$UpdateUserRequestFromJson(json);

  static const toJsonFactory = _$UpdateUserRequestToJson;
  Map<String, dynamic> toJson() => _$UpdateUserRequestToJson(this);

  @JsonKey(
    name: 'type',
    toJson: updateUserRequestTypeToJson,
    fromJson: updateUserRequestTypeFromJson,
  )
  final enums.UpdateUserRequestType type;
  @JsonKey(name: 'timestampMs')
  final String timestampMs;
  @JsonKey(name: 'organizationId')
  final String organizationId;
  @JsonKey(name: 'parameters')
  final UpdateUserIntent parameters;
  static const fromJsonFactory = _$UpdateUserRequestFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is UpdateUserRequest &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.timestampMs, timestampMs) ||
                const DeepCollectionEquality()
                    .equals(other.timestampMs, timestampMs)) &&
            (identical(other.organizationId, organizationId) ||
                const DeepCollectionEquality()
                    .equals(other.organizationId, organizationId)) &&
            (identical(other.parameters, parameters) ||
                const DeepCollectionEquality()
                    .equals(other.parameters, parameters)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(timestampMs) ^
      const DeepCollectionEquality().hash(organizationId) ^
      const DeepCollectionEquality().hash(parameters) ^
      runtimeType.hashCode;
}

extension $UpdateUserRequestExtension on UpdateUserRequest {
  UpdateUserRequest copyWith(
      {enums.UpdateUserRequestType? type,
      String? timestampMs,
      String? organizationId,
      UpdateUserIntent? parameters}) {
    return UpdateUserRequest(
        type: type ?? this.type,
        timestampMs: timestampMs ?? this.timestampMs,
        organizationId: organizationId ?? this.organizationId,
        parameters: parameters ?? this.parameters);
  }

  UpdateUserRequest copyWithWrapped(
      {Wrapped<enums.UpdateUserRequestType>? type,
      Wrapped<String>? timestampMs,
      Wrapped<String>? organizationId,
      Wrapped<UpdateUserIntent>? parameters}) {
    return UpdateUserRequest(
        type: (type != null ? type.value : this.type),
        timestampMs:
            (timestampMs != null ? timestampMs.value : this.timestampMs),
        organizationId: (organizationId != null
            ? organizationId.value
            : this.organizationId),
        parameters: (parameters != null ? parameters.value : this.parameters));
  }
}

@JsonSerializable(explicitToJson: true)
class UpdateUserResult {
  const UpdateUserResult({
    required this.userId,
  });

  factory UpdateUserResult.fromJson(Map<String, dynamic> json) =>
      _$UpdateUserResultFromJson(json);

  static const toJsonFactory = _$UpdateUserResultToJson;
  Map<String, dynamic> toJson() => _$UpdateUserResultToJson(this);

  @JsonKey(name: 'userId')
  final String userId;
  static const fromJsonFactory = _$UpdateUserResultFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is UpdateUserResult &&
            (identical(other.userId, userId) ||
                const DeepCollectionEquality().equals(other.userId, userId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(userId) ^ runtimeType.hashCode;
}

extension $UpdateUserResultExtension on UpdateUserResult {
  UpdateUserResult copyWith({String? userId}) {
    return UpdateUserResult(userId: userId ?? this.userId);
  }

  UpdateUserResult copyWithWrapped({Wrapped<String>? userId}) {
    return UpdateUserResult(
        userId: (userId != null ? userId.value : this.userId));
  }
}

@JsonSerializable(explicitToJson: true)
class UpdateUserTagIntent {
  const UpdateUserTagIntent({
    required this.userTagId,
    this.newUserTagName,
    required this.addUserIds,
    required this.removeUserIds,
  });

  factory UpdateUserTagIntent.fromJson(Map<String, dynamic> json) =>
      _$UpdateUserTagIntentFromJson(json);

  static const toJsonFactory = _$UpdateUserTagIntentToJson;
  Map<String, dynamic> toJson() => _$UpdateUserTagIntentToJson(this);

  @JsonKey(name: 'userTagId')
  final String userTagId;
  @JsonKey(name: 'newUserTagName')
  final String? newUserTagName;
  @JsonKey(name: 'addUserIds', defaultValue: <String>[])
  final List<String> addUserIds;
  @JsonKey(name: 'removeUserIds', defaultValue: <String>[])
  final List<String> removeUserIds;
  static const fromJsonFactory = _$UpdateUserTagIntentFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is UpdateUserTagIntent &&
            (identical(other.userTagId, userTagId) ||
                const DeepCollectionEquality()
                    .equals(other.userTagId, userTagId)) &&
            (identical(other.newUserTagName, newUserTagName) ||
                const DeepCollectionEquality()
                    .equals(other.newUserTagName, newUserTagName)) &&
            (identical(other.addUserIds, addUserIds) ||
                const DeepCollectionEquality()
                    .equals(other.addUserIds, addUserIds)) &&
            (identical(other.removeUserIds, removeUserIds) ||
                const DeepCollectionEquality()
                    .equals(other.removeUserIds, removeUserIds)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(userTagId) ^
      const DeepCollectionEquality().hash(newUserTagName) ^
      const DeepCollectionEquality().hash(addUserIds) ^
      const DeepCollectionEquality().hash(removeUserIds) ^
      runtimeType.hashCode;
}

extension $UpdateUserTagIntentExtension on UpdateUserTagIntent {
  UpdateUserTagIntent copyWith(
      {String? userTagId,
      String? newUserTagName,
      List<String>? addUserIds,
      List<String>? removeUserIds}) {
    return UpdateUserTagIntent(
        userTagId: userTagId ?? this.userTagId,
        newUserTagName: newUserTagName ?? this.newUserTagName,
        addUserIds: addUserIds ?? this.addUserIds,
        removeUserIds: removeUserIds ?? this.removeUserIds);
  }

  UpdateUserTagIntent copyWithWrapped(
      {Wrapped<String>? userTagId,
      Wrapped<String?>? newUserTagName,
      Wrapped<List<String>>? addUserIds,
      Wrapped<List<String>>? removeUserIds}) {
    return UpdateUserTagIntent(
        userTagId: (userTagId != null ? userTagId.value : this.userTagId),
        newUserTagName: (newUserTagName != null
            ? newUserTagName.value
            : this.newUserTagName),
        addUserIds: (addUserIds != null ? addUserIds.value : this.addUserIds),
        removeUserIds:
            (removeUserIds != null ? removeUserIds.value : this.removeUserIds));
  }
}

@JsonSerializable(explicitToJson: true)
class UpdateUserTagRequest {
  const UpdateUserTagRequest({
    required this.type,
    required this.timestampMs,
    required this.organizationId,
    required this.parameters,
  });

  factory UpdateUserTagRequest.fromJson(Map<String, dynamic> json) =>
      _$UpdateUserTagRequestFromJson(json);

  static const toJsonFactory = _$UpdateUserTagRequestToJson;
  Map<String, dynamic> toJson() => _$UpdateUserTagRequestToJson(this);

  @JsonKey(
    name: 'type',
    toJson: updateUserTagRequestTypeToJson,
    fromJson: updateUserTagRequestTypeFromJson,
  )
  final enums.UpdateUserTagRequestType type;
  @JsonKey(name: 'timestampMs')
  final String timestampMs;
  @JsonKey(name: 'organizationId')
  final String organizationId;
  @JsonKey(name: 'parameters')
  final UpdateUserTagIntent parameters;
  static const fromJsonFactory = _$UpdateUserTagRequestFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is UpdateUserTagRequest &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.timestampMs, timestampMs) ||
                const DeepCollectionEquality()
                    .equals(other.timestampMs, timestampMs)) &&
            (identical(other.organizationId, organizationId) ||
                const DeepCollectionEquality()
                    .equals(other.organizationId, organizationId)) &&
            (identical(other.parameters, parameters) ||
                const DeepCollectionEquality()
                    .equals(other.parameters, parameters)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(timestampMs) ^
      const DeepCollectionEquality().hash(organizationId) ^
      const DeepCollectionEquality().hash(parameters) ^
      runtimeType.hashCode;
}

extension $UpdateUserTagRequestExtension on UpdateUserTagRequest {
  UpdateUserTagRequest copyWith(
      {enums.UpdateUserTagRequestType? type,
      String? timestampMs,
      String? organizationId,
      UpdateUserTagIntent? parameters}) {
    return UpdateUserTagRequest(
        type: type ?? this.type,
        timestampMs: timestampMs ?? this.timestampMs,
        organizationId: organizationId ?? this.organizationId,
        parameters: parameters ?? this.parameters);
  }

  UpdateUserTagRequest copyWithWrapped(
      {Wrapped<enums.UpdateUserTagRequestType>? type,
      Wrapped<String>? timestampMs,
      Wrapped<String>? organizationId,
      Wrapped<UpdateUserTagIntent>? parameters}) {
    return UpdateUserTagRequest(
        type: (type != null ? type.value : this.type),
        timestampMs:
            (timestampMs != null ? timestampMs.value : this.timestampMs),
        organizationId: (organizationId != null
            ? organizationId.value
            : this.organizationId),
        parameters: (parameters != null ? parameters.value : this.parameters));
  }
}

@JsonSerializable(explicitToJson: true)
class UpdateUserTagResult {
  const UpdateUserTagResult({
    required this.userTagId,
  });

  factory UpdateUserTagResult.fromJson(Map<String, dynamic> json) =>
      _$UpdateUserTagResultFromJson(json);

  static const toJsonFactory = _$UpdateUserTagResultToJson;
  Map<String, dynamic> toJson() => _$UpdateUserTagResultToJson(this);

  @JsonKey(name: 'userTagId')
  final String userTagId;
  static const fromJsonFactory = _$UpdateUserTagResultFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is UpdateUserTagResult &&
            (identical(other.userTagId, userTagId) ||
                const DeepCollectionEquality()
                    .equals(other.userTagId, userTagId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(userTagId) ^ runtimeType.hashCode;
}

extension $UpdateUserTagResultExtension on UpdateUserTagResult {
  UpdateUserTagResult copyWith({String? userTagId}) {
    return UpdateUserTagResult(userTagId: userTagId ?? this.userTagId);
  }

  UpdateUserTagResult copyWithWrapped({Wrapped<String>? userTagId}) {
    return UpdateUserTagResult(
        userTagId: (userTagId != null ? userTagId.value : this.userTagId));
  }
}

@JsonSerializable(explicitToJson: true)
class UpdateWalletIntent {
  const UpdateWalletIntent({
    required this.walletId,
    this.walletName,
  });

  factory UpdateWalletIntent.fromJson(Map<String, dynamic> json) =>
      _$UpdateWalletIntentFromJson(json);

  static const toJsonFactory = _$UpdateWalletIntentToJson;
  Map<String, dynamic> toJson() => _$UpdateWalletIntentToJson(this);

  @JsonKey(name: 'walletId')
  final String walletId;
  @JsonKey(name: 'walletName')
  final String? walletName;
  static const fromJsonFactory = _$UpdateWalletIntentFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is UpdateWalletIntent &&
            (identical(other.walletId, walletId) ||
                const DeepCollectionEquality()
                    .equals(other.walletId, walletId)) &&
            (identical(other.walletName, walletName) ||
                const DeepCollectionEquality()
                    .equals(other.walletName, walletName)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(walletId) ^
      const DeepCollectionEquality().hash(walletName) ^
      runtimeType.hashCode;
}

extension $UpdateWalletIntentExtension on UpdateWalletIntent {
  UpdateWalletIntent copyWith({String? walletId, String? walletName}) {
    return UpdateWalletIntent(
        walletId: walletId ?? this.walletId,
        walletName: walletName ?? this.walletName);
  }

  UpdateWalletIntent copyWithWrapped(
      {Wrapped<String>? walletId, Wrapped<String?>? walletName}) {
    return UpdateWalletIntent(
        walletId: (walletId != null ? walletId.value : this.walletId),
        walletName: (walletName != null ? walletName.value : this.walletName));
  }
}

@JsonSerializable(explicitToJson: true)
class UpdateWalletRequest {
  const UpdateWalletRequest({
    required this.type,
    required this.timestampMs,
    required this.organizationId,
    required this.parameters,
  });

  factory UpdateWalletRequest.fromJson(Map<String, dynamic> json) =>
      _$UpdateWalletRequestFromJson(json);

  static const toJsonFactory = _$UpdateWalletRequestToJson;
  Map<String, dynamic> toJson() => _$UpdateWalletRequestToJson(this);

  @JsonKey(
    name: 'type',
    toJson: updateWalletRequestTypeToJson,
    fromJson: updateWalletRequestTypeFromJson,
  )
  final enums.UpdateWalletRequestType type;
  @JsonKey(name: 'timestampMs')
  final String timestampMs;
  @JsonKey(name: 'organizationId')
  final String organizationId;
  @JsonKey(name: 'parameters')
  final UpdateWalletIntent parameters;
  static const fromJsonFactory = _$UpdateWalletRequestFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is UpdateWalletRequest &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.timestampMs, timestampMs) ||
                const DeepCollectionEquality()
                    .equals(other.timestampMs, timestampMs)) &&
            (identical(other.organizationId, organizationId) ||
                const DeepCollectionEquality()
                    .equals(other.organizationId, organizationId)) &&
            (identical(other.parameters, parameters) ||
                const DeepCollectionEquality()
                    .equals(other.parameters, parameters)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(timestampMs) ^
      const DeepCollectionEquality().hash(organizationId) ^
      const DeepCollectionEquality().hash(parameters) ^
      runtimeType.hashCode;
}

extension $UpdateWalletRequestExtension on UpdateWalletRequest {
  UpdateWalletRequest copyWith(
      {enums.UpdateWalletRequestType? type,
      String? timestampMs,
      String? organizationId,
      UpdateWalletIntent? parameters}) {
    return UpdateWalletRequest(
        type: type ?? this.type,
        timestampMs: timestampMs ?? this.timestampMs,
        organizationId: organizationId ?? this.organizationId,
        parameters: parameters ?? this.parameters);
  }

  UpdateWalletRequest copyWithWrapped(
      {Wrapped<enums.UpdateWalletRequestType>? type,
      Wrapped<String>? timestampMs,
      Wrapped<String>? organizationId,
      Wrapped<UpdateWalletIntent>? parameters}) {
    return UpdateWalletRequest(
        type: (type != null ? type.value : this.type),
        timestampMs:
            (timestampMs != null ? timestampMs.value : this.timestampMs),
        organizationId: (organizationId != null
            ? organizationId.value
            : this.organizationId),
        parameters: (parameters != null ? parameters.value : this.parameters));
  }
}

@JsonSerializable(explicitToJson: true)
class UpdateWalletResult {
  const UpdateWalletResult({
    required this.walletId,
  });

  factory UpdateWalletResult.fromJson(Map<String, dynamic> json) =>
      _$UpdateWalletResultFromJson(json);

  static const toJsonFactory = _$UpdateWalletResultToJson;
  Map<String, dynamic> toJson() => _$UpdateWalletResultToJson(this);

  @JsonKey(name: 'walletId')
  final String walletId;
  static const fromJsonFactory = _$UpdateWalletResultFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is UpdateWalletResult &&
            (identical(other.walletId, walletId) ||
                const DeepCollectionEquality()
                    .equals(other.walletId, walletId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(walletId) ^ runtimeType.hashCode;
}

extension $UpdateWalletResultExtension on UpdateWalletResult {
  UpdateWalletResult copyWith({String? walletId}) {
    return UpdateWalletResult(walletId: walletId ?? this.walletId);
  }

  UpdateWalletResult copyWithWrapped({Wrapped<String>? walletId}) {
    return UpdateWalletResult(
        walletId: (walletId != null ? walletId.value : this.walletId));
  }
}

@JsonSerializable(explicitToJson: true)
class User {
  const User({
    required this.userId,
    required this.userName,
    this.userEmail,
    this.userPhoneNumber,
    required this.authenticators,
    required this.apiKeys,
    required this.userTags,
    required this.oauthProviders,
    required this.createdAt,
    required this.updatedAt,
  });

  factory User.fromJson(Map<String, dynamic> json) => _$UserFromJson(json);

  static const toJsonFactory = _$UserToJson;
  Map<String, dynamic> toJson() => _$UserToJson(this);

  @JsonKey(name: 'userId')
  final String userId;
  @JsonKey(name: 'userName')
  final String userName;
  @JsonKey(name: 'userEmail')
  final String? userEmail;
  @JsonKey(name: 'userPhoneNumber')
  final String? userPhoneNumber;
  @JsonKey(name: 'authenticators', defaultValue: <Authenticator>[])
  final List<Authenticator> authenticators;
  @JsonKey(name: 'apiKeys', defaultValue: <ApiKey>[])
  final List<ApiKey> apiKeys;
  @JsonKey(name: 'userTags', defaultValue: <String>[])
  final List<String> userTags;
  @JsonKey(name: 'oauthProviders', defaultValue: <OauthProvider>[])
  final List<OauthProvider> oauthProviders;
  @JsonKey(name: 'createdAt')
  final ExternalDataV1Timestamp createdAt;
  @JsonKey(name: 'updatedAt')
  final ExternalDataV1Timestamp updatedAt;
  static const fromJsonFactory = _$UserFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is User &&
            (identical(other.userId, userId) ||
                const DeepCollectionEquality().equals(other.userId, userId)) &&
            (identical(other.userName, userName) ||
                const DeepCollectionEquality()
                    .equals(other.userName, userName)) &&
            (identical(other.userEmail, userEmail) ||
                const DeepCollectionEquality()
                    .equals(other.userEmail, userEmail)) &&
            (identical(other.userPhoneNumber, userPhoneNumber) ||
                const DeepCollectionEquality()
                    .equals(other.userPhoneNumber, userPhoneNumber)) &&
            (identical(other.authenticators, authenticators) ||
                const DeepCollectionEquality()
                    .equals(other.authenticators, authenticators)) &&
            (identical(other.apiKeys, apiKeys) ||
                const DeepCollectionEquality()
                    .equals(other.apiKeys, apiKeys)) &&
            (identical(other.userTags, userTags) ||
                const DeepCollectionEquality()
                    .equals(other.userTags, userTags)) &&
            (identical(other.oauthProviders, oauthProviders) ||
                const DeepCollectionEquality()
                    .equals(other.oauthProviders, oauthProviders)) &&
            (identical(other.createdAt, createdAt) ||
                const DeepCollectionEquality()
                    .equals(other.createdAt, createdAt)) &&
            (identical(other.updatedAt, updatedAt) ||
                const DeepCollectionEquality()
                    .equals(other.updatedAt, updatedAt)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(userId) ^
      const DeepCollectionEquality().hash(userName) ^
      const DeepCollectionEquality().hash(userEmail) ^
      const DeepCollectionEquality().hash(userPhoneNumber) ^
      const DeepCollectionEquality().hash(authenticators) ^
      const DeepCollectionEquality().hash(apiKeys) ^
      const DeepCollectionEquality().hash(userTags) ^
      const DeepCollectionEquality().hash(oauthProviders) ^
      const DeepCollectionEquality().hash(createdAt) ^
      const DeepCollectionEquality().hash(updatedAt) ^
      runtimeType.hashCode;
}

extension $UserExtension on User {
  User copyWith(
      {String? userId,
      String? userName,
      String? userEmail,
      String? userPhoneNumber,
      List<Authenticator>? authenticators,
      List<ApiKey>? apiKeys,
      List<String>? userTags,
      List<OauthProvider>? oauthProviders,
      ExternalDataV1Timestamp? createdAt,
      ExternalDataV1Timestamp? updatedAt}) {
    return User(
        userId: userId ?? this.userId,
        userName: userName ?? this.userName,
        userEmail: userEmail ?? this.userEmail,
        userPhoneNumber: userPhoneNumber ?? this.userPhoneNumber,
        authenticators: authenticators ?? this.authenticators,
        apiKeys: apiKeys ?? this.apiKeys,
        userTags: userTags ?? this.userTags,
        oauthProviders: oauthProviders ?? this.oauthProviders,
        createdAt: createdAt ?? this.createdAt,
        updatedAt: updatedAt ?? this.updatedAt);
  }

  User copyWithWrapped(
      {Wrapped<String>? userId,
      Wrapped<String>? userName,
      Wrapped<String?>? userEmail,
      Wrapped<String?>? userPhoneNumber,
      Wrapped<List<Authenticator>>? authenticators,
      Wrapped<List<ApiKey>>? apiKeys,
      Wrapped<List<String>>? userTags,
      Wrapped<List<OauthProvider>>? oauthProviders,
      Wrapped<ExternalDataV1Timestamp>? createdAt,
      Wrapped<ExternalDataV1Timestamp>? updatedAt}) {
    return User(
        userId: (userId != null ? userId.value : this.userId),
        userName: (userName != null ? userName.value : this.userName),
        userEmail: (userEmail != null ? userEmail.value : this.userEmail),
        userPhoneNumber: (userPhoneNumber != null
            ? userPhoneNumber.value
            : this.userPhoneNumber),
        authenticators: (authenticators != null
            ? authenticators.value
            : this.authenticators),
        apiKeys: (apiKeys != null ? apiKeys.value : this.apiKeys),
        userTags: (userTags != null ? userTags.value : this.userTags),
        oauthProviders: (oauthProviders != null
            ? oauthProviders.value
            : this.oauthProviders),
        createdAt: (createdAt != null ? createdAt.value : this.createdAt),
        updatedAt: (updatedAt != null ? updatedAt.value : this.updatedAt));
  }
}

@JsonSerializable(explicitToJson: true)
class UserParams {
  const UserParams({
    required this.userName,
    this.userEmail,
    required this.accessType,
    required this.apiKeys,
    required this.authenticators,
    required this.userTags,
  });

  factory UserParams.fromJson(Map<String, dynamic> json) =>
      _$UserParamsFromJson(json);

  static const toJsonFactory = _$UserParamsToJson;
  Map<String, dynamic> toJson() => _$UserParamsToJson(this);

  @JsonKey(name: 'userName')
  final String userName;
  @JsonKey(name: 'userEmail')
  final String? userEmail;
  @JsonKey(
    name: 'accessType',
    toJson: accessTypeToJson,
    fromJson: accessTypeFromJson,
  )
  final enums.AccessType accessType;
  @JsonKey(name: 'apiKeys', defaultValue: <ApiKeyParams>[])
  final List<ApiKeyParams> apiKeys;
  @JsonKey(name: 'authenticators', defaultValue: <AuthenticatorParams>[])
  final List<AuthenticatorParams> authenticators;
  @JsonKey(name: 'userTags', defaultValue: <String>[])
  final List<String> userTags;
  static const fromJsonFactory = _$UserParamsFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is UserParams &&
            (identical(other.userName, userName) ||
                const DeepCollectionEquality()
                    .equals(other.userName, userName)) &&
            (identical(other.userEmail, userEmail) ||
                const DeepCollectionEquality()
                    .equals(other.userEmail, userEmail)) &&
            (identical(other.accessType, accessType) ||
                const DeepCollectionEquality()
                    .equals(other.accessType, accessType)) &&
            (identical(other.apiKeys, apiKeys) ||
                const DeepCollectionEquality()
                    .equals(other.apiKeys, apiKeys)) &&
            (identical(other.authenticators, authenticators) ||
                const DeepCollectionEquality()
                    .equals(other.authenticators, authenticators)) &&
            (identical(other.userTags, userTags) ||
                const DeepCollectionEquality()
                    .equals(other.userTags, userTags)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(userName) ^
      const DeepCollectionEquality().hash(userEmail) ^
      const DeepCollectionEquality().hash(accessType) ^
      const DeepCollectionEquality().hash(apiKeys) ^
      const DeepCollectionEquality().hash(authenticators) ^
      const DeepCollectionEquality().hash(userTags) ^
      runtimeType.hashCode;
}

extension $UserParamsExtension on UserParams {
  UserParams copyWith(
      {String? userName,
      String? userEmail,
      enums.AccessType? accessType,
      List<ApiKeyParams>? apiKeys,
      List<AuthenticatorParams>? authenticators,
      List<String>? userTags}) {
    return UserParams(
        userName: userName ?? this.userName,
        userEmail: userEmail ?? this.userEmail,
        accessType: accessType ?? this.accessType,
        apiKeys: apiKeys ?? this.apiKeys,
        authenticators: authenticators ?? this.authenticators,
        userTags: userTags ?? this.userTags);
  }

  UserParams copyWithWrapped(
      {Wrapped<String>? userName,
      Wrapped<String?>? userEmail,
      Wrapped<enums.AccessType>? accessType,
      Wrapped<List<ApiKeyParams>>? apiKeys,
      Wrapped<List<AuthenticatorParams>>? authenticators,
      Wrapped<List<String>>? userTags}) {
    return UserParams(
        userName: (userName != null ? userName.value : this.userName),
        userEmail: (userEmail != null ? userEmail.value : this.userEmail),
        accessType: (accessType != null ? accessType.value : this.accessType),
        apiKeys: (apiKeys != null ? apiKeys.value : this.apiKeys),
        authenticators: (authenticators != null
            ? authenticators.value
            : this.authenticators),
        userTags: (userTags != null ? userTags.value : this.userTags));
  }
}

@JsonSerializable(explicitToJson: true)
class UserParamsV2 {
  const UserParamsV2({
    required this.userName,
    this.userEmail,
    required this.apiKeys,
    required this.authenticators,
    required this.userTags,
  });

  factory UserParamsV2.fromJson(Map<String, dynamic> json) =>
      _$UserParamsV2FromJson(json);

  static const toJsonFactory = _$UserParamsV2ToJson;
  Map<String, dynamic> toJson() => _$UserParamsV2ToJson(this);

  @JsonKey(name: 'userName')
  final String userName;
  @JsonKey(name: 'userEmail')
  final String? userEmail;
  @JsonKey(name: 'apiKeys', defaultValue: <ApiKeyParams>[])
  final List<ApiKeyParams> apiKeys;
  @JsonKey(name: 'authenticators', defaultValue: <AuthenticatorParamsV2>[])
  final List<AuthenticatorParamsV2> authenticators;
  @JsonKey(name: 'userTags', defaultValue: <String>[])
  final List<String> userTags;
  static const fromJsonFactory = _$UserParamsV2FromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is UserParamsV2 &&
            (identical(other.userName, userName) ||
                const DeepCollectionEquality()
                    .equals(other.userName, userName)) &&
            (identical(other.userEmail, userEmail) ||
                const DeepCollectionEquality()
                    .equals(other.userEmail, userEmail)) &&
            (identical(other.apiKeys, apiKeys) ||
                const DeepCollectionEquality()
                    .equals(other.apiKeys, apiKeys)) &&
            (identical(other.authenticators, authenticators) ||
                const DeepCollectionEquality()
                    .equals(other.authenticators, authenticators)) &&
            (identical(other.userTags, userTags) ||
                const DeepCollectionEquality()
                    .equals(other.userTags, userTags)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(userName) ^
      const DeepCollectionEquality().hash(userEmail) ^
      const DeepCollectionEquality().hash(apiKeys) ^
      const DeepCollectionEquality().hash(authenticators) ^
      const DeepCollectionEquality().hash(userTags) ^
      runtimeType.hashCode;
}

extension $UserParamsV2Extension on UserParamsV2 {
  UserParamsV2 copyWith(
      {String? userName,
      String? userEmail,
      List<ApiKeyParams>? apiKeys,
      List<AuthenticatorParamsV2>? authenticators,
      List<String>? userTags}) {
    return UserParamsV2(
        userName: userName ?? this.userName,
        userEmail: userEmail ?? this.userEmail,
        apiKeys: apiKeys ?? this.apiKeys,
        authenticators: authenticators ?? this.authenticators,
        userTags: userTags ?? this.userTags);
  }

  UserParamsV2 copyWithWrapped(
      {Wrapped<String>? userName,
      Wrapped<String?>? userEmail,
      Wrapped<List<ApiKeyParams>>? apiKeys,
      Wrapped<List<AuthenticatorParamsV2>>? authenticators,
      Wrapped<List<String>>? userTags}) {
    return UserParamsV2(
        userName: (userName != null ? userName.value : this.userName),
        userEmail: (userEmail != null ? userEmail.value : this.userEmail),
        apiKeys: (apiKeys != null ? apiKeys.value : this.apiKeys),
        authenticators: (authenticators != null
            ? authenticators.value
            : this.authenticators),
        userTags: (userTags != null ? userTags.value : this.userTags));
  }
}

@JsonSerializable(explicitToJson: true)
class UserParamsV3 {
  const UserParamsV3({
    required this.userName,
    this.userEmail,
    this.userPhoneNumber,
    required this.apiKeys,
    required this.authenticators,
    required this.oauthProviders,
    required this.userTags,
  });

  factory UserParamsV3.fromJson(Map<String, dynamic> json) =>
      _$UserParamsV3FromJson(json);

  static const toJsonFactory = _$UserParamsV3ToJson;
  Map<String, dynamic> toJson() => _$UserParamsV3ToJson(this);

  @JsonKey(name: 'userName')
  final String userName;
  @JsonKey(name: 'userEmail')
  final String? userEmail;
  @JsonKey(name: 'userPhoneNumber')
  final String? userPhoneNumber;
  @JsonKey(name: 'apiKeys', defaultValue: <ApiKeyParamsV2>[])
  final List<ApiKeyParamsV2> apiKeys;
  @JsonKey(name: 'authenticators', defaultValue: <AuthenticatorParamsV2>[])
  final List<AuthenticatorParamsV2> authenticators;
  @JsonKey(name: 'oauthProviders', defaultValue: <OauthProviderParams>[])
  final List<OauthProviderParams> oauthProviders;
  @JsonKey(name: 'userTags', defaultValue: <String>[])
  final List<String> userTags;
  static const fromJsonFactory = _$UserParamsV3FromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is UserParamsV3 &&
            (identical(other.userName, userName) ||
                const DeepCollectionEquality()
                    .equals(other.userName, userName)) &&
            (identical(other.userEmail, userEmail) ||
                const DeepCollectionEquality()
                    .equals(other.userEmail, userEmail)) &&
            (identical(other.userPhoneNumber, userPhoneNumber) ||
                const DeepCollectionEquality()
                    .equals(other.userPhoneNumber, userPhoneNumber)) &&
            (identical(other.apiKeys, apiKeys) ||
                const DeepCollectionEquality()
                    .equals(other.apiKeys, apiKeys)) &&
            (identical(other.authenticators, authenticators) ||
                const DeepCollectionEquality()
                    .equals(other.authenticators, authenticators)) &&
            (identical(other.oauthProviders, oauthProviders) ||
                const DeepCollectionEquality()
                    .equals(other.oauthProviders, oauthProviders)) &&
            (identical(other.userTags, userTags) ||
                const DeepCollectionEquality()
                    .equals(other.userTags, userTags)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(userName) ^
      const DeepCollectionEquality().hash(userEmail) ^
      const DeepCollectionEquality().hash(userPhoneNumber) ^
      const DeepCollectionEquality().hash(apiKeys) ^
      const DeepCollectionEquality().hash(authenticators) ^
      const DeepCollectionEquality().hash(oauthProviders) ^
      const DeepCollectionEquality().hash(userTags) ^
      runtimeType.hashCode;
}

extension $UserParamsV3Extension on UserParamsV3 {
  UserParamsV3 copyWith(
      {String? userName,
      String? userEmail,
      String? userPhoneNumber,
      List<ApiKeyParamsV2>? apiKeys,
      List<AuthenticatorParamsV2>? authenticators,
      List<OauthProviderParams>? oauthProviders,
      List<String>? userTags}) {
    return UserParamsV3(
        userName: userName ?? this.userName,
        userEmail: userEmail ?? this.userEmail,
        userPhoneNumber: userPhoneNumber ?? this.userPhoneNumber,
        apiKeys: apiKeys ?? this.apiKeys,
        authenticators: authenticators ?? this.authenticators,
        oauthProviders: oauthProviders ?? this.oauthProviders,
        userTags: userTags ?? this.userTags);
  }

  UserParamsV3 copyWithWrapped(
      {Wrapped<String>? userName,
      Wrapped<String?>? userEmail,
      Wrapped<String?>? userPhoneNumber,
      Wrapped<List<ApiKeyParamsV2>>? apiKeys,
      Wrapped<List<AuthenticatorParamsV2>>? authenticators,
      Wrapped<List<OauthProviderParams>>? oauthProviders,
      Wrapped<List<String>>? userTags}) {
    return UserParamsV3(
        userName: (userName != null ? userName.value : this.userName),
        userEmail: (userEmail != null ? userEmail.value : this.userEmail),
        userPhoneNumber: (userPhoneNumber != null
            ? userPhoneNumber.value
            : this.userPhoneNumber),
        apiKeys: (apiKeys != null ? apiKeys.value : this.apiKeys),
        authenticators: (authenticators != null
            ? authenticators.value
            : this.authenticators),
        oauthProviders: (oauthProviders != null
            ? oauthProviders.value
            : this.oauthProviders),
        userTags: (userTags != null ? userTags.value : this.userTags));
  }
}

@JsonSerializable(explicitToJson: true)
class VerifyOtpIntent {
  const VerifyOtpIntent({
    required this.otpId,
    required this.otpCode,
    this.expirationSeconds,
  });

  factory VerifyOtpIntent.fromJson(Map<String, dynamic> json) =>
      _$VerifyOtpIntentFromJson(json);

  static const toJsonFactory = _$VerifyOtpIntentToJson;
  Map<String, dynamic> toJson() => _$VerifyOtpIntentToJson(this);

  @JsonKey(name: 'otpId')
  final String otpId;
  @JsonKey(name: 'otpCode')
  final String otpCode;
  @JsonKey(name: 'expirationSeconds')
  final String? expirationSeconds;
  static const fromJsonFactory = _$VerifyOtpIntentFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is VerifyOtpIntent &&
            (identical(other.otpId, otpId) ||
                const DeepCollectionEquality().equals(other.otpId, otpId)) &&
            (identical(other.otpCode, otpCode) ||
                const DeepCollectionEquality()
                    .equals(other.otpCode, otpCode)) &&
            (identical(other.expirationSeconds, expirationSeconds) ||
                const DeepCollectionEquality()
                    .equals(other.expirationSeconds, expirationSeconds)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(otpId) ^
      const DeepCollectionEquality().hash(otpCode) ^
      const DeepCollectionEquality().hash(expirationSeconds) ^
      runtimeType.hashCode;
}

extension $VerifyOtpIntentExtension on VerifyOtpIntent {
  VerifyOtpIntent copyWith(
      {String? otpId, String? otpCode, String? expirationSeconds}) {
    return VerifyOtpIntent(
        otpId: otpId ?? this.otpId,
        otpCode: otpCode ?? this.otpCode,
        expirationSeconds: expirationSeconds ?? this.expirationSeconds);
  }

  VerifyOtpIntent copyWithWrapped(
      {Wrapped<String>? otpId,
      Wrapped<String>? otpCode,
      Wrapped<String?>? expirationSeconds}) {
    return VerifyOtpIntent(
        otpId: (otpId != null ? otpId.value : this.otpId),
        otpCode: (otpCode != null ? otpCode.value : this.otpCode),
        expirationSeconds: (expirationSeconds != null
            ? expirationSeconds.value
            : this.expirationSeconds));
  }
}

@JsonSerializable(explicitToJson: true)
class VerifyOtpRequest {
  const VerifyOtpRequest({
    required this.type,
    required this.timestampMs,
    required this.organizationId,
    required this.parameters,
  });

  factory VerifyOtpRequest.fromJson(Map<String, dynamic> json) =>
      _$VerifyOtpRequestFromJson(json);

  static const toJsonFactory = _$VerifyOtpRequestToJson;
  Map<String, dynamic> toJson() => _$VerifyOtpRequestToJson(this);

  @JsonKey(
    name: 'type',
    toJson: verifyOtpRequestTypeToJson,
    fromJson: verifyOtpRequestTypeFromJson,
  )
  final enums.VerifyOtpRequestType type;
  @JsonKey(name: 'timestampMs')
  final String timestampMs;
  @JsonKey(name: 'organizationId')
  final String organizationId;
  @JsonKey(name: 'parameters')
  final VerifyOtpIntent parameters;
  static const fromJsonFactory = _$VerifyOtpRequestFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is VerifyOtpRequest &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.timestampMs, timestampMs) ||
                const DeepCollectionEquality()
                    .equals(other.timestampMs, timestampMs)) &&
            (identical(other.organizationId, organizationId) ||
                const DeepCollectionEquality()
                    .equals(other.organizationId, organizationId)) &&
            (identical(other.parameters, parameters) ||
                const DeepCollectionEquality()
                    .equals(other.parameters, parameters)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(timestampMs) ^
      const DeepCollectionEquality().hash(organizationId) ^
      const DeepCollectionEquality().hash(parameters) ^
      runtimeType.hashCode;
}

extension $VerifyOtpRequestExtension on VerifyOtpRequest {
  VerifyOtpRequest copyWith(
      {enums.VerifyOtpRequestType? type,
      String? timestampMs,
      String? organizationId,
      VerifyOtpIntent? parameters}) {
    return VerifyOtpRequest(
        type: type ?? this.type,
        timestampMs: timestampMs ?? this.timestampMs,
        organizationId: organizationId ?? this.organizationId,
        parameters: parameters ?? this.parameters);
  }

  VerifyOtpRequest copyWithWrapped(
      {Wrapped<enums.VerifyOtpRequestType>? type,
      Wrapped<String>? timestampMs,
      Wrapped<String>? organizationId,
      Wrapped<VerifyOtpIntent>? parameters}) {
    return VerifyOtpRequest(
        type: (type != null ? type.value : this.type),
        timestampMs:
            (timestampMs != null ? timestampMs.value : this.timestampMs),
        organizationId: (organizationId != null
            ? organizationId.value
            : this.organizationId),
        parameters: (parameters != null ? parameters.value : this.parameters));
  }
}

@JsonSerializable(explicitToJson: true)
class VerifyOtpResult {
  const VerifyOtpResult({
    required this.verificationToken,
  });

  factory VerifyOtpResult.fromJson(Map<String, dynamic> json) =>
      _$VerifyOtpResultFromJson(json);

  static const toJsonFactory = _$VerifyOtpResultToJson;
  Map<String, dynamic> toJson() => _$VerifyOtpResultToJson(this);

  @JsonKey(name: 'verificationToken')
  final String verificationToken;
  static const fromJsonFactory = _$VerifyOtpResultFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is VerifyOtpResult &&
            (identical(other.verificationToken, verificationToken) ||
                const DeepCollectionEquality()
                    .equals(other.verificationToken, verificationToken)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(verificationToken) ^
      runtimeType.hashCode;
}

extension $VerifyOtpResultExtension on VerifyOtpResult {
  VerifyOtpResult copyWith({String? verificationToken}) {
    return VerifyOtpResult(
        verificationToken: verificationToken ?? this.verificationToken);
  }

  VerifyOtpResult copyWithWrapped({Wrapped<String>? verificationToken}) {
    return VerifyOtpResult(
        verificationToken: (verificationToken != null
            ? verificationToken.value
            : this.verificationToken));
  }
}

@JsonSerializable(explicitToJson: true)
class Vote {
  const Vote({
    required this.id,
    required this.userId,
    required this.user,
    required this.activityId,
    required this.selection,
    required this.message,
    required this.publicKey,
    required this.signature,
    required this.scheme,
    required this.createdAt,
  });

  factory Vote.fromJson(Map<String, dynamic> json) => _$VoteFromJson(json);

  static const toJsonFactory = _$VoteToJson;
  Map<String, dynamic> toJson() => _$VoteToJson(this);

  @JsonKey(name: 'id')
  final String id;
  @JsonKey(name: 'userId')
  final String userId;
  @JsonKey(name: 'user')
  final User user;
  @JsonKey(name: 'activityId')
  final String activityId;
  @JsonKey(
    name: 'selection',
    toJson: voteSelectionToJson,
    fromJson: voteSelectionFromJson,
  )
  final enums.VoteSelection selection;
  @JsonKey(name: 'message')
  final String message;
  @JsonKey(name: 'publicKey')
  final String publicKey;
  @JsonKey(name: 'signature')
  final String signature;
  @JsonKey(name: 'scheme')
  final String scheme;
  @JsonKey(name: 'createdAt')
  final ExternalDataV1Timestamp createdAt;
  static const fromJsonFactory = _$VoteFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is Vote &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.userId, userId) ||
                const DeepCollectionEquality().equals(other.userId, userId)) &&
            (identical(other.user, user) ||
                const DeepCollectionEquality().equals(other.user, user)) &&
            (identical(other.activityId, activityId) ||
                const DeepCollectionEquality()
                    .equals(other.activityId, activityId)) &&
            (identical(other.selection, selection) ||
                const DeepCollectionEquality()
                    .equals(other.selection, selection)) &&
            (identical(other.message, message) ||
                const DeepCollectionEquality()
                    .equals(other.message, message)) &&
            (identical(other.publicKey, publicKey) ||
                const DeepCollectionEquality()
                    .equals(other.publicKey, publicKey)) &&
            (identical(other.signature, signature) ||
                const DeepCollectionEquality()
                    .equals(other.signature, signature)) &&
            (identical(other.scheme, scheme) ||
                const DeepCollectionEquality().equals(other.scheme, scheme)) &&
            (identical(other.createdAt, createdAt) ||
                const DeepCollectionEquality()
                    .equals(other.createdAt, createdAt)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(userId) ^
      const DeepCollectionEquality().hash(user) ^
      const DeepCollectionEquality().hash(activityId) ^
      const DeepCollectionEquality().hash(selection) ^
      const DeepCollectionEquality().hash(message) ^
      const DeepCollectionEquality().hash(publicKey) ^
      const DeepCollectionEquality().hash(signature) ^
      const DeepCollectionEquality().hash(scheme) ^
      const DeepCollectionEquality().hash(createdAt) ^
      runtimeType.hashCode;
}

extension $VoteExtension on Vote {
  Vote copyWith(
      {String? id,
      String? userId,
      User? user,
      String? activityId,
      enums.VoteSelection? selection,
      String? message,
      String? publicKey,
      String? signature,
      String? scheme,
      ExternalDataV1Timestamp? createdAt}) {
    return Vote(
        id: id ?? this.id,
        userId: userId ?? this.userId,
        user: user ?? this.user,
        activityId: activityId ?? this.activityId,
        selection: selection ?? this.selection,
        message: message ?? this.message,
        publicKey: publicKey ?? this.publicKey,
        signature: signature ?? this.signature,
        scheme: scheme ?? this.scheme,
        createdAt: createdAt ?? this.createdAt);
  }

  Vote copyWithWrapped(
      {Wrapped<String>? id,
      Wrapped<String>? userId,
      Wrapped<User>? user,
      Wrapped<String>? activityId,
      Wrapped<enums.VoteSelection>? selection,
      Wrapped<String>? message,
      Wrapped<String>? publicKey,
      Wrapped<String>? signature,
      Wrapped<String>? scheme,
      Wrapped<ExternalDataV1Timestamp>? createdAt}) {
    return Vote(
        id: (id != null ? id.value : this.id),
        userId: (userId != null ? userId.value : this.userId),
        user: (user != null ? user.value : this.user),
        activityId: (activityId != null ? activityId.value : this.activityId),
        selection: (selection != null ? selection.value : this.selection),
        message: (message != null ? message.value : this.message),
        publicKey: (publicKey != null ? publicKey.value : this.publicKey),
        signature: (signature != null ? signature.value : this.signature),
        scheme: (scheme != null ? scheme.value : this.scheme),
        createdAt: (createdAt != null ? createdAt.value : this.createdAt));
  }
}

@JsonSerializable(explicitToJson: true)
class Wallet {
  const Wallet({
    required this.walletId,
    required this.walletName,
    required this.createdAt,
    required this.updatedAt,
    required this.exported,
    required this.imported,
  });

  factory Wallet.fromJson(Map<String, dynamic> json) => _$WalletFromJson(json);

  static const toJsonFactory = _$WalletToJson;
  Map<String, dynamic> toJson() => _$WalletToJson(this);

  @JsonKey(name: 'walletId')
  final String walletId;
  @JsonKey(name: 'walletName')
  final String walletName;
  @JsonKey(name: 'createdAt')
  final ExternalDataV1Timestamp createdAt;
  @JsonKey(name: 'updatedAt')
  final ExternalDataV1Timestamp updatedAt;
  @JsonKey(name: 'exported')
  final bool exported;
  @JsonKey(name: 'imported')
  final bool imported;
  static const fromJsonFactory = _$WalletFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is Wallet &&
            (identical(other.walletId, walletId) ||
                const DeepCollectionEquality()
                    .equals(other.walletId, walletId)) &&
            (identical(other.walletName, walletName) ||
                const DeepCollectionEquality()
                    .equals(other.walletName, walletName)) &&
            (identical(other.createdAt, createdAt) ||
                const DeepCollectionEquality()
                    .equals(other.createdAt, createdAt)) &&
            (identical(other.updatedAt, updatedAt) ||
                const DeepCollectionEquality()
                    .equals(other.updatedAt, updatedAt)) &&
            (identical(other.exported, exported) ||
                const DeepCollectionEquality()
                    .equals(other.exported, exported)) &&
            (identical(other.imported, imported) ||
                const DeepCollectionEquality()
                    .equals(other.imported, imported)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(walletId) ^
      const DeepCollectionEquality().hash(walletName) ^
      const DeepCollectionEquality().hash(createdAt) ^
      const DeepCollectionEquality().hash(updatedAt) ^
      const DeepCollectionEquality().hash(exported) ^
      const DeepCollectionEquality().hash(imported) ^
      runtimeType.hashCode;
}

extension $WalletExtension on Wallet {
  Wallet copyWith(
      {String? walletId,
      String? walletName,
      ExternalDataV1Timestamp? createdAt,
      ExternalDataV1Timestamp? updatedAt,
      bool? exported,
      bool? imported}) {
    return Wallet(
        walletId: walletId ?? this.walletId,
        walletName: walletName ?? this.walletName,
        createdAt: createdAt ?? this.createdAt,
        updatedAt: updatedAt ?? this.updatedAt,
        exported: exported ?? this.exported,
        imported: imported ?? this.imported);
  }

  Wallet copyWithWrapped(
      {Wrapped<String>? walletId,
      Wrapped<String>? walletName,
      Wrapped<ExternalDataV1Timestamp>? createdAt,
      Wrapped<ExternalDataV1Timestamp>? updatedAt,
      Wrapped<bool>? exported,
      Wrapped<bool>? imported}) {
    return Wallet(
        walletId: (walletId != null ? walletId.value : this.walletId),
        walletName: (walletName != null ? walletName.value : this.walletName),
        createdAt: (createdAt != null ? createdAt.value : this.createdAt),
        updatedAt: (updatedAt != null ? updatedAt.value : this.updatedAt),
        exported: (exported != null ? exported.value : this.exported),
        imported: (imported != null ? imported.value : this.imported));
  }
}

@JsonSerializable(explicitToJson: true)
class WalletAccount {
  const WalletAccount({
    required this.walletAccountId,
    required this.organizationId,
    required this.walletId,
    required this.curve,
    required this.pathFormat,
    required this.path,
    required this.addressFormat,
    required this.address,
    required this.createdAt,
    required this.updatedAt,
    this.publicKey,
  });

  factory WalletAccount.fromJson(Map<String, dynamic> json) =>
      _$WalletAccountFromJson(json);

  static const toJsonFactory = _$WalletAccountToJson;
  Map<String, dynamic> toJson() => _$WalletAccountToJson(this);

  @JsonKey(name: 'walletAccountId')
  final String walletAccountId;
  @JsonKey(name: 'organizationId')
  final String organizationId;
  @JsonKey(name: 'walletId')
  final String walletId;
  @JsonKey(
    name: 'curve',
    toJson: curveToJson,
    fromJson: curveFromJson,
  )
  final enums.Curve curve;
  @JsonKey(
    name: 'pathFormat',
    toJson: pathFormatToJson,
    fromJson: pathFormatFromJson,
  )
  final enums.PathFormat pathFormat;
  @JsonKey(name: 'path')
  final String path;
  @JsonKey(
    name: 'addressFormat',
    toJson: addressFormatToJson,
    fromJson: addressFormatFromJson,
  )
  final enums.AddressFormat addressFormat;
  @JsonKey(name: 'address')
  final String address;
  @JsonKey(name: 'createdAt')
  final ExternalDataV1Timestamp createdAt;
  @JsonKey(name: 'updatedAt')
  final ExternalDataV1Timestamp updatedAt;
  @JsonKey(name: 'publicKey')
  final String? publicKey;
  static const fromJsonFactory = _$WalletAccountFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is WalletAccount &&
            (identical(other.walletAccountId, walletAccountId) ||
                const DeepCollectionEquality()
                    .equals(other.walletAccountId, walletAccountId)) &&
            (identical(other.organizationId, organizationId) ||
                const DeepCollectionEquality()
                    .equals(other.organizationId, organizationId)) &&
            (identical(other.walletId, walletId) ||
                const DeepCollectionEquality()
                    .equals(other.walletId, walletId)) &&
            (identical(other.curve, curve) ||
                const DeepCollectionEquality().equals(other.curve, curve)) &&
            (identical(other.pathFormat, pathFormat) ||
                const DeepCollectionEquality()
                    .equals(other.pathFormat, pathFormat)) &&
            (identical(other.path, path) ||
                const DeepCollectionEquality().equals(other.path, path)) &&
            (identical(other.addressFormat, addressFormat) ||
                const DeepCollectionEquality()
                    .equals(other.addressFormat, addressFormat)) &&
            (identical(other.address, address) ||
                const DeepCollectionEquality()
                    .equals(other.address, address)) &&
            (identical(other.createdAt, createdAt) ||
                const DeepCollectionEquality()
                    .equals(other.createdAt, createdAt)) &&
            (identical(other.updatedAt, updatedAt) ||
                const DeepCollectionEquality()
                    .equals(other.updatedAt, updatedAt)) &&
            (identical(other.publicKey, publicKey) ||
                const DeepCollectionEquality()
                    .equals(other.publicKey, publicKey)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(walletAccountId) ^
      const DeepCollectionEquality().hash(organizationId) ^
      const DeepCollectionEquality().hash(walletId) ^
      const DeepCollectionEquality().hash(curve) ^
      const DeepCollectionEquality().hash(pathFormat) ^
      const DeepCollectionEquality().hash(path) ^
      const DeepCollectionEquality().hash(addressFormat) ^
      const DeepCollectionEquality().hash(address) ^
      const DeepCollectionEquality().hash(createdAt) ^
      const DeepCollectionEquality().hash(updatedAt) ^
      const DeepCollectionEquality().hash(publicKey) ^
      runtimeType.hashCode;
}

extension $WalletAccountExtension on WalletAccount {
  WalletAccount copyWith(
      {String? walletAccountId,
      String? organizationId,
      String? walletId,
      enums.Curve? curve,
      enums.PathFormat? pathFormat,
      String? path,
      enums.AddressFormat? addressFormat,
      String? address,
      ExternalDataV1Timestamp? createdAt,
      ExternalDataV1Timestamp? updatedAt,
      String? publicKey}) {
    return WalletAccount(
        walletAccountId: walletAccountId ?? this.walletAccountId,
        organizationId: organizationId ?? this.organizationId,
        walletId: walletId ?? this.walletId,
        curve: curve ?? this.curve,
        pathFormat: pathFormat ?? this.pathFormat,
        path: path ?? this.path,
        addressFormat: addressFormat ?? this.addressFormat,
        address: address ?? this.address,
        createdAt: createdAt ?? this.createdAt,
        updatedAt: updatedAt ?? this.updatedAt,
        publicKey: publicKey ?? this.publicKey);
  }

  WalletAccount copyWithWrapped(
      {Wrapped<String>? walletAccountId,
      Wrapped<String>? organizationId,
      Wrapped<String>? walletId,
      Wrapped<enums.Curve>? curve,
      Wrapped<enums.PathFormat>? pathFormat,
      Wrapped<String>? path,
      Wrapped<enums.AddressFormat>? addressFormat,
      Wrapped<String>? address,
      Wrapped<ExternalDataV1Timestamp>? createdAt,
      Wrapped<ExternalDataV1Timestamp>? updatedAt,
      Wrapped<String?>? publicKey}) {
    return WalletAccount(
        walletAccountId: (walletAccountId != null
            ? walletAccountId.value
            : this.walletAccountId),
        organizationId: (organizationId != null
            ? organizationId.value
            : this.organizationId),
        walletId: (walletId != null ? walletId.value : this.walletId),
        curve: (curve != null ? curve.value : this.curve),
        pathFormat: (pathFormat != null ? pathFormat.value : this.pathFormat),
        path: (path != null ? path.value : this.path),
        addressFormat:
            (addressFormat != null ? addressFormat.value : this.addressFormat),
        address: (address != null ? address.value : this.address),
        createdAt: (createdAt != null ? createdAt.value : this.createdAt),
        updatedAt: (updatedAt != null ? updatedAt.value : this.updatedAt),
        publicKey: (publicKey != null ? publicKey.value : this.publicKey));
  }
}

@JsonSerializable(explicitToJson: true)
class WalletAccountParams {
  const WalletAccountParams({
    required this.curve,
    required this.pathFormat,
    required this.path,
    required this.addressFormat,
  });

  factory WalletAccountParams.fromJson(Map<String, dynamic> json) =>
      _$WalletAccountParamsFromJson(json);

  static const toJsonFactory = _$WalletAccountParamsToJson;
  Map<String, dynamic> toJson() => _$WalletAccountParamsToJson(this);

  @JsonKey(
    name: 'curve',
    toJson: curveToJson,
    fromJson: curveFromJson,
  )
  final enums.Curve curve;
  @JsonKey(
    name: 'pathFormat',
    toJson: pathFormatToJson,
    fromJson: pathFormatFromJson,
  )
  final enums.PathFormat pathFormat;
  @JsonKey(name: 'path')
  final String path;
  @JsonKey(
    name: 'addressFormat',
    toJson: addressFormatToJson,
    fromJson: addressFormatFromJson,
  )
  final enums.AddressFormat addressFormat;
  static const fromJsonFactory = _$WalletAccountParamsFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is WalletAccountParams &&
            (identical(other.curve, curve) ||
                const DeepCollectionEquality().equals(other.curve, curve)) &&
            (identical(other.pathFormat, pathFormat) ||
                const DeepCollectionEquality()
                    .equals(other.pathFormat, pathFormat)) &&
            (identical(other.path, path) ||
                const DeepCollectionEquality().equals(other.path, path)) &&
            (identical(other.addressFormat, addressFormat) ||
                const DeepCollectionEquality()
                    .equals(other.addressFormat, addressFormat)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(curve) ^
      const DeepCollectionEquality().hash(pathFormat) ^
      const DeepCollectionEquality().hash(path) ^
      const DeepCollectionEquality().hash(addressFormat) ^
      runtimeType.hashCode;
}

extension $WalletAccountParamsExtension on WalletAccountParams {
  WalletAccountParams copyWith(
      {enums.Curve? curve,
      enums.PathFormat? pathFormat,
      String? path,
      enums.AddressFormat? addressFormat}) {
    return WalletAccountParams(
        curve: curve ?? this.curve,
        pathFormat: pathFormat ?? this.pathFormat,
        path: path ?? this.path,
        addressFormat: addressFormat ?? this.addressFormat);
  }

  WalletAccountParams copyWithWrapped(
      {Wrapped<enums.Curve>? curve,
      Wrapped<enums.PathFormat>? pathFormat,
      Wrapped<String>? path,
      Wrapped<enums.AddressFormat>? addressFormat}) {
    return WalletAccountParams(
        curve: (curve != null ? curve.value : this.curve),
        pathFormat: (pathFormat != null ? pathFormat.value : this.pathFormat),
        path: (path != null ? path.value : this.path),
        addressFormat:
            (addressFormat != null ? addressFormat.value : this.addressFormat));
  }
}

@JsonSerializable(explicitToJson: true)
class WalletParams {
  const WalletParams({
    required this.walletName,
    required this.accounts,
    this.mnemonicLength,
  });

  factory WalletParams.fromJson(Map<String, dynamic> json) =>
      _$WalletParamsFromJson(json);

  static const toJsonFactory = _$WalletParamsToJson;
  Map<String, dynamic> toJson() => _$WalletParamsToJson(this);

  @JsonKey(name: 'walletName')
  final String walletName;
  @JsonKey(name: 'accounts', defaultValue: <WalletAccountParams>[])
  final List<WalletAccountParams> accounts;
  @JsonKey(name: 'mnemonicLength')
  final int? mnemonicLength;
  static const fromJsonFactory = _$WalletParamsFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is WalletParams &&
            (identical(other.walletName, walletName) ||
                const DeepCollectionEquality()
                    .equals(other.walletName, walletName)) &&
            (identical(other.accounts, accounts) ||
                const DeepCollectionEquality()
                    .equals(other.accounts, accounts)) &&
            (identical(other.mnemonicLength, mnemonicLength) ||
                const DeepCollectionEquality()
                    .equals(other.mnemonicLength, mnemonicLength)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(walletName) ^
      const DeepCollectionEquality().hash(accounts) ^
      const DeepCollectionEquality().hash(mnemonicLength) ^
      runtimeType.hashCode;
}

extension $WalletParamsExtension on WalletParams {
  WalletParams copyWith(
      {String? walletName,
      List<WalletAccountParams>? accounts,
      int? mnemonicLength}) {
    return WalletParams(
        walletName: walletName ?? this.walletName,
        accounts: accounts ?? this.accounts,
        mnemonicLength: mnemonicLength ?? this.mnemonicLength);
  }

  WalletParams copyWithWrapped(
      {Wrapped<String>? walletName,
      Wrapped<List<WalletAccountParams>>? accounts,
      Wrapped<int?>? mnemonicLength}) {
    return WalletParams(
        walletName: (walletName != null ? walletName.value : this.walletName),
        accounts: (accounts != null ? accounts.value : this.accounts),
        mnemonicLength: (mnemonicLength != null
            ? mnemonicLength.value
            : this.mnemonicLength));
  }
}

@JsonSerializable(explicitToJson: true)
class WalletResult {
  const WalletResult({
    required this.walletId,
    required this.addresses,
  });

  factory WalletResult.fromJson(Map<String, dynamic> json) =>
      _$WalletResultFromJson(json);

  static const toJsonFactory = _$WalletResultToJson;
  Map<String, dynamic> toJson() => _$WalletResultToJson(this);

  @JsonKey(name: 'walletId')
  final String walletId;
  @JsonKey(name: 'addresses', defaultValue: <String>[])
  final List<String> addresses;
  static const fromJsonFactory = _$WalletResultFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is WalletResult &&
            (identical(other.walletId, walletId) ||
                const DeepCollectionEquality()
                    .equals(other.walletId, walletId)) &&
            (identical(other.addresses, addresses) ||
                const DeepCollectionEquality()
                    .equals(other.addresses, addresses)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(walletId) ^
      const DeepCollectionEquality().hash(addresses) ^
      runtimeType.hashCode;
}

extension $WalletResultExtension on WalletResult {
  WalletResult copyWith({String? walletId, List<String>? addresses}) {
    return WalletResult(
        walletId: walletId ?? this.walletId,
        addresses: addresses ?? this.addresses);
  }

  WalletResult copyWithWrapped(
      {Wrapped<String>? walletId, Wrapped<List<String>>? addresses}) {
    return WalletResult(
        walletId: (walletId != null ? walletId.value : this.walletId),
        addresses: (addresses != null ? addresses.value : this.addresses));
  }
}

@JsonSerializable(explicitToJson: true)
class ActivityV1Address {
  const ActivityV1Address({
    this.format,
    this.address,
  });

  factory ActivityV1Address.fromJson(Map<String, dynamic> json) =>
      _$ActivityV1AddressFromJson(json);

  static const toJsonFactory = _$ActivityV1AddressToJson;
  Map<String, dynamic> toJson() => _$ActivityV1AddressToJson(this);

  @JsonKey(
    name: 'format',
    toJson: addressFormatNullableToJson,
    fromJson: addressFormatNullableFromJson,
  )
  final enums.AddressFormat? format;
  @JsonKey(name: 'address')
  final String? address;
  static const fromJsonFactory = _$ActivityV1AddressFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ActivityV1Address &&
            (identical(other.format, format) ||
                const DeepCollectionEquality().equals(other.format, format)) &&
            (identical(other.address, address) ||
                const DeepCollectionEquality().equals(other.address, address)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(format) ^
      const DeepCollectionEquality().hash(address) ^
      runtimeType.hashCode;
}

extension $ActivityV1AddressExtension on ActivityV1Address {
  ActivityV1Address copyWith({enums.AddressFormat? format, String? address}) {
    return ActivityV1Address(
        format: format ?? this.format, address: address ?? this.address);
  }

  ActivityV1Address copyWithWrapped(
      {Wrapped<enums.AddressFormat?>? format, Wrapped<String?>? address}) {
    return ActivityV1Address(
        format: (format != null ? format.value : this.format),
        address: (address != null ? address.value : this.address));
  }
}

@JsonSerializable(explicitToJson: true)
class ActivityV1PolicyEvaluation {
  const ActivityV1PolicyEvaluation({
    required this.id,
    required this.activityId,
    required this.organizationId,
    required this.voteId,
    required this.policyEvaluations,
    required this.createdAt,
  });

  factory ActivityV1PolicyEvaluation.fromJson(Map<String, dynamic> json) =>
      _$ActivityV1PolicyEvaluationFromJson(json);

  static const toJsonFactory = _$ActivityV1PolicyEvaluationToJson;
  Map<String, dynamic> toJson() => _$ActivityV1PolicyEvaluationToJson(this);

  @JsonKey(name: 'id')
  final String id;
  @JsonKey(name: 'activityId')
  final String activityId;
  @JsonKey(name: 'organizationId')
  final String organizationId;
  @JsonKey(name: 'voteId')
  final String voteId;
  @JsonKey(name: 'policyEvaluations', defaultValue: <UmpV1PolicyEvaluation>[])
  final List<UmpV1PolicyEvaluation> policyEvaluations;
  @JsonKey(name: 'createdAt')
  final ExternalDataV1Timestamp createdAt;
  static const fromJsonFactory = _$ActivityV1PolicyEvaluationFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ActivityV1PolicyEvaluation &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.activityId, activityId) ||
                const DeepCollectionEquality()
                    .equals(other.activityId, activityId)) &&
            (identical(other.organizationId, organizationId) ||
                const DeepCollectionEquality()
                    .equals(other.organizationId, organizationId)) &&
            (identical(other.voteId, voteId) ||
                const DeepCollectionEquality().equals(other.voteId, voteId)) &&
            (identical(other.policyEvaluations, policyEvaluations) ||
                const DeepCollectionEquality()
                    .equals(other.policyEvaluations, policyEvaluations)) &&
            (identical(other.createdAt, createdAt) ||
                const DeepCollectionEquality()
                    .equals(other.createdAt, createdAt)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(activityId) ^
      const DeepCollectionEquality().hash(organizationId) ^
      const DeepCollectionEquality().hash(voteId) ^
      const DeepCollectionEquality().hash(policyEvaluations) ^
      const DeepCollectionEquality().hash(createdAt) ^
      runtimeType.hashCode;
}

extension $ActivityV1PolicyEvaluationExtension on ActivityV1PolicyEvaluation {
  ActivityV1PolicyEvaluation copyWith(
      {String? id,
      String? activityId,
      String? organizationId,
      String? voteId,
      List<UmpV1PolicyEvaluation>? policyEvaluations,
      ExternalDataV1Timestamp? createdAt}) {
    return ActivityV1PolicyEvaluation(
        id: id ?? this.id,
        activityId: activityId ?? this.activityId,
        organizationId: organizationId ?? this.organizationId,
        voteId: voteId ?? this.voteId,
        policyEvaluations: policyEvaluations ?? this.policyEvaluations,
        createdAt: createdAt ?? this.createdAt);
  }

  ActivityV1PolicyEvaluation copyWithWrapped(
      {Wrapped<String>? id,
      Wrapped<String>? activityId,
      Wrapped<String>? organizationId,
      Wrapped<String>? voteId,
      Wrapped<List<UmpV1PolicyEvaluation>>? policyEvaluations,
      Wrapped<ExternalDataV1Timestamp>? createdAt}) {
    return ActivityV1PolicyEvaluation(
        id: (id != null ? id.value : this.id),
        activityId: (activityId != null ? activityId.value : this.activityId),
        organizationId: (organizationId != null
            ? organizationId.value
            : this.organizationId),
        voteId: (voteId != null ? voteId.value : this.voteId),
        policyEvaluations: (policyEvaluations != null
            ? policyEvaluations.value
            : this.policyEvaluations),
        createdAt: (createdAt != null ? createdAt.value : this.createdAt));
  }
}

@JsonSerializable(explicitToJson: true)
class DataV1Address {
  const DataV1Address({
    this.format,
    this.address,
  });

  factory DataV1Address.fromJson(Map<String, dynamic> json) =>
      _$DataV1AddressFromJson(json);

  static const toJsonFactory = _$DataV1AddressToJson;
  Map<String, dynamic> toJson() => _$DataV1AddressToJson(this);

  @JsonKey(
    name: 'format',
    toJson: addressFormatNullableToJson,
    fromJson: addressFormatNullableFromJson,
  )
  final enums.AddressFormat? format;
  @JsonKey(name: 'address')
  final String? address;
  static const fromJsonFactory = _$DataV1AddressFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is DataV1Address &&
            (identical(other.format, format) ||
                const DeepCollectionEquality().equals(other.format, format)) &&
            (identical(other.address, address) ||
                const DeepCollectionEquality().equals(other.address, address)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(format) ^
      const DeepCollectionEquality().hash(address) ^
      runtimeType.hashCode;
}

extension $DataV1AddressExtension on DataV1Address {
  DataV1Address copyWith({enums.AddressFormat? format, String? address}) {
    return DataV1Address(
        format: format ?? this.format, address: address ?? this.address);
  }

  DataV1Address copyWithWrapped(
      {Wrapped<enums.AddressFormat?>? format, Wrapped<String?>? address}) {
    return DataV1Address(
        format: (format != null ? format.value : this.format),
        address: (address != null ? address.value : this.address));
  }
}

@JsonSerializable(explicitToJson: true)
class DataV1SmartContractInterface {
  const DataV1SmartContractInterface({
    required this.organizationId,
    required this.smartContractInterfaceId,
    required this.smartContractAddress,
    required this.smartContractInterface,
    required this.type,
    required this.label,
    required this.notes,
    required this.createdAt,
    required this.updatedAt,
  });

  factory DataV1SmartContractInterface.fromJson(Map<String, dynamic> json) =>
      _$DataV1SmartContractInterfaceFromJson(json);

  static const toJsonFactory = _$DataV1SmartContractInterfaceToJson;
  Map<String, dynamic> toJson() => _$DataV1SmartContractInterfaceToJson(this);

  @JsonKey(name: 'organizationId')
  final String organizationId;
  @JsonKey(name: 'smartContractInterfaceId')
  final String smartContractInterfaceId;
  @JsonKey(name: 'smartContractAddress')
  final String smartContractAddress;
  @JsonKey(name: 'smartContractInterface')
  final String smartContractInterface;
  @JsonKey(name: 'type')
  final String type;
  @JsonKey(name: 'label')
  final String label;
  @JsonKey(name: 'notes')
  final String notes;
  @JsonKey(name: 'createdAt')
  final ExternalDataV1Timestamp createdAt;
  @JsonKey(name: 'updatedAt')
  final ExternalDataV1Timestamp updatedAt;
  static const fromJsonFactory = _$DataV1SmartContractInterfaceFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is DataV1SmartContractInterface &&
            (identical(other.organizationId, organizationId) ||
                const DeepCollectionEquality()
                    .equals(other.organizationId, organizationId)) &&
            (identical(
                    other.smartContractInterfaceId, smartContractInterfaceId) ||
                const DeepCollectionEquality().equals(
                    other.smartContractInterfaceId,
                    smartContractInterfaceId)) &&
            (identical(other.smartContractAddress, smartContractAddress) ||
                const DeepCollectionEquality().equals(
                    other.smartContractAddress, smartContractAddress)) &&
            (identical(other.smartContractInterface, smartContractInterface) ||
                const DeepCollectionEquality().equals(
                    other.smartContractInterface, smartContractInterface)) &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.label, label) ||
                const DeepCollectionEquality().equals(other.label, label)) &&
            (identical(other.notes, notes) ||
                const DeepCollectionEquality().equals(other.notes, notes)) &&
            (identical(other.createdAt, createdAt) ||
                const DeepCollectionEquality()
                    .equals(other.createdAt, createdAt)) &&
            (identical(other.updatedAt, updatedAt) ||
                const DeepCollectionEquality()
                    .equals(other.updatedAt, updatedAt)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(organizationId) ^
      const DeepCollectionEquality().hash(smartContractInterfaceId) ^
      const DeepCollectionEquality().hash(smartContractAddress) ^
      const DeepCollectionEquality().hash(smartContractInterface) ^
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(label) ^
      const DeepCollectionEquality().hash(notes) ^
      const DeepCollectionEquality().hash(createdAt) ^
      const DeepCollectionEquality().hash(updatedAt) ^
      runtimeType.hashCode;
}

extension $DataV1SmartContractInterfaceExtension
    on DataV1SmartContractInterface {
  DataV1SmartContractInterface copyWith(
      {String? organizationId,
      String? smartContractInterfaceId,
      String? smartContractAddress,
      String? smartContractInterface,
      String? type,
      String? label,
      String? notes,
      ExternalDataV1Timestamp? createdAt,
      ExternalDataV1Timestamp? updatedAt}) {
    return DataV1SmartContractInterface(
        organizationId: organizationId ?? this.organizationId,
        smartContractInterfaceId:
            smartContractInterfaceId ?? this.smartContractInterfaceId,
        smartContractAddress: smartContractAddress ?? this.smartContractAddress,
        smartContractInterface:
            smartContractInterface ?? this.smartContractInterface,
        type: type ?? this.type,
        label: label ?? this.label,
        notes: notes ?? this.notes,
        createdAt: createdAt ?? this.createdAt,
        updatedAt: updatedAt ?? this.updatedAt);
  }

  DataV1SmartContractInterface copyWithWrapped(
      {Wrapped<String>? organizationId,
      Wrapped<String>? smartContractInterfaceId,
      Wrapped<String>? smartContractAddress,
      Wrapped<String>? smartContractInterface,
      Wrapped<String>? type,
      Wrapped<String>? label,
      Wrapped<String>? notes,
      Wrapped<ExternalDataV1Timestamp>? createdAt,
      Wrapped<ExternalDataV1Timestamp>? updatedAt}) {
    return DataV1SmartContractInterface(
        organizationId: (organizationId != null
            ? organizationId.value
            : this.organizationId),
        smartContractInterfaceId: (smartContractInterfaceId != null
            ? smartContractInterfaceId.value
            : this.smartContractInterfaceId),
        smartContractAddress: (smartContractAddress != null
            ? smartContractAddress.value
            : this.smartContractAddress),
        smartContractInterface: (smartContractInterface != null
            ? smartContractInterface.value
            : this.smartContractInterface),
        type: (type != null ? type.value : this.type),
        label: (label != null ? label.value : this.label),
        notes: (notes != null ? notes.value : this.notes),
        createdAt: (createdAt != null ? createdAt.value : this.createdAt),
        updatedAt: (updatedAt != null ? updatedAt.value : this.updatedAt));
  }
}

@JsonSerializable(explicitToJson: true)
class ExternalDataV1Credential {
  const ExternalDataV1Credential({
    required this.publicKey,
    required this.type,
  });

  factory ExternalDataV1Credential.fromJson(Map<String, dynamic> json) =>
      _$ExternalDataV1CredentialFromJson(json);

  static const toJsonFactory = _$ExternalDataV1CredentialToJson;
  Map<String, dynamic> toJson() => _$ExternalDataV1CredentialToJson(this);

  @JsonKey(name: 'publicKey')
  final String publicKey;
  @JsonKey(
    name: 'type',
    toJson: credentialTypeToJson,
    fromJson: credentialTypeFromJson,
  )
  final enums.CredentialType type;
  static const fromJsonFactory = _$ExternalDataV1CredentialFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ExternalDataV1Credential &&
            (identical(other.publicKey, publicKey) ||
                const DeepCollectionEquality()
                    .equals(other.publicKey, publicKey)) &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(publicKey) ^
      const DeepCollectionEquality().hash(type) ^
      runtimeType.hashCode;
}

extension $ExternalDataV1CredentialExtension on ExternalDataV1Credential {
  ExternalDataV1Credential copyWith(
      {String? publicKey, enums.CredentialType? type}) {
    return ExternalDataV1Credential(
        publicKey: publicKey ?? this.publicKey, type: type ?? this.type);
  }

  ExternalDataV1Credential copyWithWrapped(
      {Wrapped<String>? publicKey, Wrapped<enums.CredentialType>? type}) {
    return ExternalDataV1Credential(
        publicKey: (publicKey != null ? publicKey.value : this.publicKey),
        type: (type != null ? type.value : this.type));
  }
}

@JsonSerializable(explicitToJson: true)
class ExternalDataV1Quorum {
  const ExternalDataV1Quorum({
    required this.threshold,
    required this.userIds,
  });

  factory ExternalDataV1Quorum.fromJson(Map<String, dynamic> json) =>
      _$ExternalDataV1QuorumFromJson(json);

  static const toJsonFactory = _$ExternalDataV1QuorumToJson;
  Map<String, dynamic> toJson() => _$ExternalDataV1QuorumToJson(this);

  @JsonKey(name: 'threshold')
  final int threshold;
  @JsonKey(name: 'userIds', defaultValue: <String>[])
  final List<String> userIds;
  static const fromJsonFactory = _$ExternalDataV1QuorumFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ExternalDataV1Quorum &&
            (identical(other.threshold, threshold) ||
                const DeepCollectionEquality()
                    .equals(other.threshold, threshold)) &&
            (identical(other.userIds, userIds) ||
                const DeepCollectionEquality().equals(other.userIds, userIds)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(threshold) ^
      const DeepCollectionEquality().hash(userIds) ^
      runtimeType.hashCode;
}

extension $ExternalDataV1QuorumExtension on ExternalDataV1Quorum {
  ExternalDataV1Quorum copyWith({int? threshold, List<String>? userIds}) {
    return ExternalDataV1Quorum(
        threshold: threshold ?? this.threshold,
        userIds: userIds ?? this.userIds);
  }

  ExternalDataV1Quorum copyWithWrapped(
      {Wrapped<int>? threshold, Wrapped<List<String>>? userIds}) {
    return ExternalDataV1Quorum(
        threshold: (threshold != null ? threshold.value : this.threshold),
        userIds: (userIds != null ? userIds.value : this.userIds));
  }
}

@JsonSerializable(explicitToJson: true)
class ExternalDataV1Timestamp {
  const ExternalDataV1Timestamp({
    required this.seconds,
    required this.nanos,
  });

  factory ExternalDataV1Timestamp.fromJson(Map<String, dynamic> json) =>
      _$ExternalDataV1TimestampFromJson(json);

  static const toJsonFactory = _$ExternalDataV1TimestampToJson;
  Map<String, dynamic> toJson() => _$ExternalDataV1TimestampToJson(this);

  @JsonKey(name: 'seconds')
  final String seconds;
  @JsonKey(name: 'nanos')
  final String nanos;
  static const fromJsonFactory = _$ExternalDataV1TimestampFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ExternalDataV1Timestamp &&
            (identical(other.seconds, seconds) ||
                const DeepCollectionEquality()
                    .equals(other.seconds, seconds)) &&
            (identical(other.nanos, nanos) ||
                const DeepCollectionEquality().equals(other.nanos, nanos)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(seconds) ^
      const DeepCollectionEquality().hash(nanos) ^
      runtimeType.hashCode;
}

extension $ExternalDataV1TimestampExtension on ExternalDataV1Timestamp {
  ExternalDataV1Timestamp copyWith({String? seconds, String? nanos}) {
    return ExternalDataV1Timestamp(
        seconds: seconds ?? this.seconds, nanos: nanos ?? this.nanos);
  }

  ExternalDataV1Timestamp copyWithWrapped(
      {Wrapped<String>? seconds, Wrapped<String>? nanos}) {
    return ExternalDataV1Timestamp(
        seconds: (seconds != null ? seconds.value : this.seconds),
        nanos: (nanos != null ? nanos.value : this.nanos));
  }
}

@JsonSerializable(explicitToJson: true)
class UmpV1PolicyEvaluation {
  const UmpV1PolicyEvaluation({
    this.policyId,
    this.outcome,
  });

  factory UmpV1PolicyEvaluation.fromJson(Map<String, dynamic> json) =>
      _$UmpV1PolicyEvaluationFromJson(json);

  static const toJsonFactory = _$UmpV1PolicyEvaluationToJson;
  Map<String, dynamic> toJson() => _$UmpV1PolicyEvaluationToJson(this);

  @JsonKey(name: 'policyId')
  final String? policyId;
  @JsonKey(
    name: 'outcome',
    toJson: outcomeNullableToJson,
    fromJson: outcomeNullableFromJson,
  )
  final enums.Outcome? outcome;
  static const fromJsonFactory = _$UmpV1PolicyEvaluationFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is UmpV1PolicyEvaluation &&
            (identical(other.policyId, policyId) ||
                const DeepCollectionEquality()
                    .equals(other.policyId, policyId)) &&
            (identical(other.outcome, outcome) ||
                const DeepCollectionEquality().equals(other.outcome, outcome)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(policyId) ^
      const DeepCollectionEquality().hash(outcome) ^
      runtimeType.hashCode;
}

extension $UmpV1PolicyEvaluationExtension on UmpV1PolicyEvaluation {
  UmpV1PolicyEvaluation copyWith({String? policyId, enums.Outcome? outcome}) {
    return UmpV1PolicyEvaluation(
        policyId: policyId ?? this.policyId, outcome: outcome ?? this.outcome);
  }

  UmpV1PolicyEvaluation copyWithWrapped(
      {Wrapped<String?>? policyId, Wrapped<enums.Outcome?>? outcome}) {
    return UmpV1PolicyEvaluation(
        policyId: (policyId != null ? policyId.value : this.policyId),
        outcome: (outcome != null ? outcome.value : this.outcome));
  }
}

@JsonSerializable(explicitToJson: true)
class V1Tag {
  const V1Tag({
    required this.tagId,
    required this.tagName,
    required this.tagType,
    required this.createdAt,
    required this.updatedAt,
  });

  factory V1Tag.fromJson(Map<String, dynamic> json) => _$V1TagFromJson(json);

  static const toJsonFactory = _$V1TagToJson;
  Map<String, dynamic> toJson() => _$V1TagToJson(this);

  @JsonKey(name: 'tagId')
  final String tagId;
  @JsonKey(name: 'tagName')
  final String tagName;
  @JsonKey(
    name: 'tagType',
    toJson: tagTypeToJson,
    fromJson: tagTypeFromJson,
  )
  final enums.TagType tagType;
  @JsonKey(name: 'createdAt')
  final ExternalDataV1Timestamp createdAt;
  @JsonKey(name: 'updatedAt')
  final ExternalDataV1Timestamp updatedAt;
  static const fromJsonFactory = _$V1TagFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is V1Tag &&
            (identical(other.tagId, tagId) ||
                const DeepCollectionEquality().equals(other.tagId, tagId)) &&
            (identical(other.tagName, tagName) ||
                const DeepCollectionEquality()
                    .equals(other.tagName, tagName)) &&
            (identical(other.tagType, tagType) ||
                const DeepCollectionEquality()
                    .equals(other.tagType, tagType)) &&
            (identical(other.createdAt, createdAt) ||
                const DeepCollectionEquality()
                    .equals(other.createdAt, createdAt)) &&
            (identical(other.updatedAt, updatedAt) ||
                const DeepCollectionEquality()
                    .equals(other.updatedAt, updatedAt)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(tagId) ^
      const DeepCollectionEquality().hash(tagName) ^
      const DeepCollectionEquality().hash(tagType) ^
      const DeepCollectionEquality().hash(createdAt) ^
      const DeepCollectionEquality().hash(updatedAt) ^
      runtimeType.hashCode;
}

extension $V1TagExtension on V1Tag {
  V1Tag copyWith(
      {String? tagId,
      String? tagName,
      enums.TagType? tagType,
      ExternalDataV1Timestamp? createdAt,
      ExternalDataV1Timestamp? updatedAt}) {
    return V1Tag(
        tagId: tagId ?? this.tagId,
        tagName: tagName ?? this.tagName,
        tagType: tagType ?? this.tagType,
        createdAt: createdAt ?? this.createdAt,
        updatedAt: updatedAt ?? this.updatedAt);
  }

  V1Tag copyWithWrapped(
      {Wrapped<String>? tagId,
      Wrapped<String>? tagName,
      Wrapped<enums.TagType>? tagType,
      Wrapped<ExternalDataV1Timestamp>? createdAt,
      Wrapped<ExternalDataV1Timestamp>? updatedAt}) {
    return V1Tag(
        tagId: (tagId != null ? tagId.value : this.tagId),
        tagName: (tagName != null ? tagName.value : this.tagName),
        tagType: (tagType != null ? tagType.value : this.tagType),
        createdAt: (createdAt != null ? createdAt.value : this.createdAt),
        updatedAt: (updatedAt != null ? updatedAt.value : this.updatedAt));
  }
}

String? accessTypeNullableToJson(enums.AccessType? accessType) {
  return accessType?.value;
}

String? accessTypeToJson(enums.AccessType accessType) {
  return accessType.value;
}

enums.AccessType accessTypeFromJson(
  Object? accessType, [
  enums.AccessType? defaultValue,
]) {
  return enums.AccessType.values
          .firstWhereOrNull((e) => e.value == accessType) ??
      defaultValue ??
      enums.AccessType.swaggerGeneratedUnknown;
}

enums.AccessType? accessTypeNullableFromJson(
  Object? accessType, [
  enums.AccessType? defaultValue,
]) {
  if (accessType == null) {
    return null;
  }
  return enums.AccessType.values
          .firstWhereOrNull((e) => e.value == accessType) ??
      defaultValue;
}

String accessTypeExplodedListToJson(List<enums.AccessType>? accessType) {
  return accessType?.map((e) => e.value!).join(',') ?? '';
}

List<String> accessTypeListToJson(List<enums.AccessType>? accessType) {
  if (accessType == null) {
    return [];
  }

  return accessType.map((e) => e.value!).toList();
}

List<enums.AccessType> accessTypeListFromJson(
  List? accessType, [
  List<enums.AccessType>? defaultValue,
]) {
  if (accessType == null) {
    return defaultValue ?? [];
  }

  return accessType.map((e) => accessTypeFromJson(e.toString())).toList();
}

List<enums.AccessType>? accessTypeNullableListFromJson(
  List? accessType, [
  List<enums.AccessType>? defaultValue,
]) {
  if (accessType == null) {
    return defaultValue;
  }

  return accessType.map((e) => accessTypeFromJson(e.toString())).toList();
}

String? activityStatusNullableToJson(enums.ActivityStatus? activityStatus) {
  return activityStatus?.value;
}

String? activityStatusToJson(enums.ActivityStatus activityStatus) {
  return activityStatus.value;
}

enums.ActivityStatus activityStatusFromJson(
  Object? activityStatus, [
  enums.ActivityStatus? defaultValue,
]) {
  return enums.ActivityStatus.values
          .firstWhereOrNull((e) => e.value == activityStatus) ??
      defaultValue ??
      enums.ActivityStatus.swaggerGeneratedUnknown;
}

enums.ActivityStatus? activityStatusNullableFromJson(
  Object? activityStatus, [
  enums.ActivityStatus? defaultValue,
]) {
  if (activityStatus == null) {
    return null;
  }
  return enums.ActivityStatus.values
          .firstWhereOrNull((e) => e.value == activityStatus) ??
      defaultValue;
}

String activityStatusExplodedListToJson(
    List<enums.ActivityStatus>? activityStatus) {
  return activityStatus?.map((e) => e.value!).join(',') ?? '';
}

List<String> activityStatusListToJson(
    List<enums.ActivityStatus>? activityStatus) {
  if (activityStatus == null) {
    return [];
  }

  return activityStatus.map((e) => e.value!).toList();
}

List<enums.ActivityStatus> activityStatusListFromJson(
  List? activityStatus, [
  List<enums.ActivityStatus>? defaultValue,
]) {
  if (activityStatus == null) {
    return defaultValue ?? [];
  }

  return activityStatus
      .map((e) => activityStatusFromJson(e.toString()))
      .toList();
}

List<enums.ActivityStatus>? activityStatusNullableListFromJson(
  List? activityStatus, [
  List<enums.ActivityStatus>? defaultValue,
]) {
  if (activityStatus == null) {
    return defaultValue;
  }

  return activityStatus
      .map((e) => activityStatusFromJson(e.toString()))
      .toList();
}

String? activityTypeNullableToJson(enums.ActivityType? activityType) {
  return activityType?.value;
}

String? activityTypeToJson(enums.ActivityType activityType) {
  return activityType.value;
}

enums.ActivityType activityTypeFromJson(
  Object? activityType, [
  enums.ActivityType? defaultValue,
]) {
  return enums.ActivityType.values
          .firstWhereOrNull((e) => e.value == activityType) ??
      defaultValue ??
      enums.ActivityType.swaggerGeneratedUnknown;
}

enums.ActivityType? activityTypeNullableFromJson(
  Object? activityType, [
  enums.ActivityType? defaultValue,
]) {
  if (activityType == null) {
    return null;
  }
  return enums.ActivityType.values
          .firstWhereOrNull((e) => e.value == activityType) ??
      defaultValue;
}

String activityTypeExplodedListToJson(List<enums.ActivityType>? activityType) {
  return activityType?.map((e) => e.value!).join(',') ?? '';
}

List<String> activityTypeListToJson(List<enums.ActivityType>? activityType) {
  if (activityType == null) {
    return [];
  }

  return activityType.map((e) => e.value!).toList();
}

List<enums.ActivityType> activityTypeListFromJson(
  List? activityType, [
  List<enums.ActivityType>? defaultValue,
]) {
  if (activityType == null) {
    return defaultValue ?? [];
  }

  return activityType.map((e) => activityTypeFromJson(e.toString())).toList();
}

List<enums.ActivityType>? activityTypeNullableListFromJson(
  List? activityType, [
  List<enums.ActivityType>? defaultValue,
]) {
  if (activityType == null) {
    return defaultValue;
  }

  return activityType.map((e) => activityTypeFromJson(e.toString())).toList();
}

String? addressFormatNullableToJson(enums.AddressFormat? addressFormat) {
  return addressFormat?.value;
}

String? addressFormatToJson(enums.AddressFormat addressFormat) {
  return addressFormat.value;
}

enums.AddressFormat addressFormatFromJson(
  Object? addressFormat, [
  enums.AddressFormat? defaultValue,
]) {
  return enums.AddressFormat.values
          .firstWhereOrNull((e) => e.value == addressFormat) ??
      defaultValue ??
      enums.AddressFormat.swaggerGeneratedUnknown;
}

enums.AddressFormat? addressFormatNullableFromJson(
  Object? addressFormat, [
  enums.AddressFormat? defaultValue,
]) {
  if (addressFormat == null) {
    return null;
  }
  return enums.AddressFormat.values
          .firstWhereOrNull((e) => e.value == addressFormat) ??
      defaultValue;
}

String addressFormatExplodedListToJson(
    List<enums.AddressFormat>? addressFormat) {
  return addressFormat?.map((e) => e.value!).join(',') ?? '';
}

List<String> addressFormatListToJson(List<enums.AddressFormat>? addressFormat) {
  if (addressFormat == null) {
    return [];
  }

  return addressFormat.map((e) => e.value!).toList();
}

List<enums.AddressFormat> addressFormatListFromJson(
  List? addressFormat, [
  List<enums.AddressFormat>? defaultValue,
]) {
  if (addressFormat == null) {
    return defaultValue ?? [];
  }

  return addressFormat.map((e) => addressFormatFromJson(e.toString())).toList();
}

List<enums.AddressFormat>? addressFormatNullableListFromJson(
  List? addressFormat, [
  List<enums.AddressFormat>? defaultValue,
]) {
  if (addressFormat == null) {
    return defaultValue;
  }

  return addressFormat.map((e) => addressFormatFromJson(e.toString())).toList();
}

String? apiKeyCurveNullableToJson(enums.ApiKeyCurve? apiKeyCurve) {
  return apiKeyCurve?.value;
}

String? apiKeyCurveToJson(enums.ApiKeyCurve apiKeyCurve) {
  return apiKeyCurve.value;
}

enums.ApiKeyCurve apiKeyCurveFromJson(
  Object? apiKeyCurve, [
  enums.ApiKeyCurve? defaultValue,
]) {
  return enums.ApiKeyCurve.values
          .firstWhereOrNull((e) => e.value == apiKeyCurve) ??
      defaultValue ??
      enums.ApiKeyCurve.swaggerGeneratedUnknown;
}

enums.ApiKeyCurve? apiKeyCurveNullableFromJson(
  Object? apiKeyCurve, [
  enums.ApiKeyCurve? defaultValue,
]) {
  if (apiKeyCurve == null) {
    return null;
  }
  return enums.ApiKeyCurve.values
          .firstWhereOrNull((e) => e.value == apiKeyCurve) ??
      defaultValue;
}

String apiKeyCurveExplodedListToJson(List<enums.ApiKeyCurve>? apiKeyCurve) {
  return apiKeyCurve?.map((e) => e.value!).join(',') ?? '';
}

List<String> apiKeyCurveListToJson(List<enums.ApiKeyCurve>? apiKeyCurve) {
  if (apiKeyCurve == null) {
    return [];
  }

  return apiKeyCurve.map((e) => e.value!).toList();
}

List<enums.ApiKeyCurve> apiKeyCurveListFromJson(
  List? apiKeyCurve, [
  List<enums.ApiKeyCurve>? defaultValue,
]) {
  if (apiKeyCurve == null) {
    return defaultValue ?? [];
  }

  return apiKeyCurve.map((e) => apiKeyCurveFromJson(e.toString())).toList();
}

List<enums.ApiKeyCurve>? apiKeyCurveNullableListFromJson(
  List? apiKeyCurve, [
  List<enums.ApiKeyCurve>? defaultValue,
]) {
  if (apiKeyCurve == null) {
    return defaultValue;
  }

  return apiKeyCurve.map((e) => apiKeyCurveFromJson(e.toString())).toList();
}

String? approveActivityRequestTypeNullableToJson(
    enums.ApproveActivityRequestType? approveActivityRequestType) {
  return approveActivityRequestType?.value;
}

String? approveActivityRequestTypeToJson(
    enums.ApproveActivityRequestType approveActivityRequestType) {
  return approveActivityRequestType.value;
}

enums.ApproveActivityRequestType approveActivityRequestTypeFromJson(
  Object? approveActivityRequestType, [
  enums.ApproveActivityRequestType? defaultValue,
]) {
  return enums.ApproveActivityRequestType.values
          .firstWhereOrNull((e) => e.value == approveActivityRequestType) ??
      defaultValue ??
      enums.ApproveActivityRequestType.swaggerGeneratedUnknown;
}

enums.ApproveActivityRequestType? approveActivityRequestTypeNullableFromJson(
  Object? approveActivityRequestType, [
  enums.ApproveActivityRequestType? defaultValue,
]) {
  if (approveActivityRequestType == null) {
    return null;
  }
  return enums.ApproveActivityRequestType.values
          .firstWhereOrNull((e) => e.value == approveActivityRequestType) ??
      defaultValue;
}

String approveActivityRequestTypeExplodedListToJson(
    List<enums.ApproveActivityRequestType>? approveActivityRequestType) {
  return approveActivityRequestType?.map((e) => e.value!).join(',') ?? '';
}

List<String> approveActivityRequestTypeListToJson(
    List<enums.ApproveActivityRequestType>? approveActivityRequestType) {
  if (approveActivityRequestType == null) {
    return [];
  }

  return approveActivityRequestType.map((e) => e.value!).toList();
}

List<enums.ApproveActivityRequestType> approveActivityRequestTypeListFromJson(
  List? approveActivityRequestType, [
  List<enums.ApproveActivityRequestType>? defaultValue,
]) {
  if (approveActivityRequestType == null) {
    return defaultValue ?? [];
  }

  return approveActivityRequestType
      .map((e) => approveActivityRequestTypeFromJson(e.toString()))
      .toList();
}

List<enums.ApproveActivityRequestType>?
    approveActivityRequestTypeNullableListFromJson(
  List? approveActivityRequestType, [
  List<enums.ApproveActivityRequestType>? defaultValue,
]) {
  if (approveActivityRequestType == null) {
    return defaultValue;
  }

  return approveActivityRequestType
      .map((e) => approveActivityRequestTypeFromJson(e.toString()))
      .toList();
}

String? authenticatorAttestationResponseAuthenticatorAttachmentNullableToJson(
    enums.AuthenticatorAttestationResponseAuthenticatorAttachment?
        authenticatorAttestationResponseAuthenticatorAttachment) {
  return authenticatorAttestationResponseAuthenticatorAttachment?.value;
}

String? authenticatorAttestationResponseAuthenticatorAttachmentToJson(
    enums.AuthenticatorAttestationResponseAuthenticatorAttachment
        authenticatorAttestationResponseAuthenticatorAttachment) {
  return authenticatorAttestationResponseAuthenticatorAttachment.value;
}

enums.AuthenticatorAttestationResponseAuthenticatorAttachment
    authenticatorAttestationResponseAuthenticatorAttachmentFromJson(
  Object? authenticatorAttestationResponseAuthenticatorAttachment, [
  enums.AuthenticatorAttestationResponseAuthenticatorAttachment? defaultValue,
]) {
  return enums.AuthenticatorAttestationResponseAuthenticatorAttachment.values
          .firstWhereOrNull((e) =>
              e.value ==
              authenticatorAttestationResponseAuthenticatorAttachment) ??
      defaultValue ??
      enums.AuthenticatorAttestationResponseAuthenticatorAttachment
          .swaggerGeneratedUnknown;
}

enums.AuthenticatorAttestationResponseAuthenticatorAttachment?
    authenticatorAttestationResponseAuthenticatorAttachmentNullableFromJson(
  Object? authenticatorAttestationResponseAuthenticatorAttachment, [
  enums.AuthenticatorAttestationResponseAuthenticatorAttachment? defaultValue,
]) {
  if (authenticatorAttestationResponseAuthenticatorAttachment == null) {
    return null;
  }
  return enums.AuthenticatorAttestationResponseAuthenticatorAttachment.values
          .firstWhereOrNull((e) =>
              e.value ==
              authenticatorAttestationResponseAuthenticatorAttachment) ??
      defaultValue;
}

String
    authenticatorAttestationResponseAuthenticatorAttachmentExplodedListToJson(
        List<enums.AuthenticatorAttestationResponseAuthenticatorAttachment>?
            authenticatorAttestationResponseAuthenticatorAttachment) {
  return authenticatorAttestationResponseAuthenticatorAttachment
          ?.map((e) => e.value!)
          .join(',') ??
      '';
}

List<String> authenticatorAttestationResponseAuthenticatorAttachmentListToJson(
    List<enums.AuthenticatorAttestationResponseAuthenticatorAttachment>?
        authenticatorAttestationResponseAuthenticatorAttachment) {
  if (authenticatorAttestationResponseAuthenticatorAttachment == null) {
    return [];
  }

  return authenticatorAttestationResponseAuthenticatorAttachment
      .map((e) => e.value!)
      .toList();
}

List<enums.AuthenticatorAttestationResponseAuthenticatorAttachment>
    authenticatorAttestationResponseAuthenticatorAttachmentListFromJson(
  List? authenticatorAttestationResponseAuthenticatorAttachment, [
  List<enums.AuthenticatorAttestationResponseAuthenticatorAttachment>?
      defaultValue,
]) {
  if (authenticatorAttestationResponseAuthenticatorAttachment == null) {
    return defaultValue ?? [];
  }

  return authenticatorAttestationResponseAuthenticatorAttachment
      .map((e) =>
          authenticatorAttestationResponseAuthenticatorAttachmentFromJson(
              e.toString()))
      .toList();
}

List<enums.AuthenticatorAttestationResponseAuthenticatorAttachment>?
    authenticatorAttestationResponseAuthenticatorAttachmentNullableListFromJson(
  List? authenticatorAttestationResponseAuthenticatorAttachment, [
  List<enums.AuthenticatorAttestationResponseAuthenticatorAttachment>?
      defaultValue,
]) {
  if (authenticatorAttestationResponseAuthenticatorAttachment == null) {
    return defaultValue;
  }

  return authenticatorAttestationResponseAuthenticatorAttachment
      .map((e) =>
          authenticatorAttestationResponseAuthenticatorAttachmentFromJson(
              e.toString()))
      .toList();
}

String? authenticatorTransportNullableToJson(
    enums.AuthenticatorTransport? authenticatorTransport) {
  return authenticatorTransport?.value;
}

String? authenticatorTransportToJson(
    enums.AuthenticatorTransport authenticatorTransport) {
  return authenticatorTransport.value;
}

enums.AuthenticatorTransport authenticatorTransportFromJson(
  Object? authenticatorTransport, [
  enums.AuthenticatorTransport? defaultValue,
]) {
  return enums.AuthenticatorTransport.values
          .firstWhereOrNull((e) => e.value == authenticatorTransport) ??
      defaultValue ??
      enums.AuthenticatorTransport.swaggerGeneratedUnknown;
}

enums.AuthenticatorTransport? authenticatorTransportNullableFromJson(
  Object? authenticatorTransport, [
  enums.AuthenticatorTransport? defaultValue,
]) {
  if (authenticatorTransport == null) {
    return null;
  }
  return enums.AuthenticatorTransport.values
          .firstWhereOrNull((e) => e.value == authenticatorTransport) ??
      defaultValue;
}

String authenticatorTransportExplodedListToJson(
    List<enums.AuthenticatorTransport>? authenticatorTransport) {
  return authenticatorTransport?.map((e) => e.value!).join(',') ?? '';
}

List<String> authenticatorTransportListToJson(
    List<enums.AuthenticatorTransport>? authenticatorTransport) {
  if (authenticatorTransport == null) {
    return [];
  }

  return authenticatorTransport.map((e) => e.value!).toList();
}

List<enums.AuthenticatorTransport> authenticatorTransportListFromJson(
  List? authenticatorTransport, [
  List<enums.AuthenticatorTransport>? defaultValue,
]) {
  if (authenticatorTransport == null) {
    return defaultValue ?? [];
  }

  return authenticatorTransport
      .map((e) => authenticatorTransportFromJson(e.toString()))
      .toList();
}

List<enums.AuthenticatorTransport>? authenticatorTransportNullableListFromJson(
  List? authenticatorTransport, [
  List<enums.AuthenticatorTransport>? defaultValue,
]) {
  if (authenticatorTransport == null) {
    return defaultValue;
  }

  return authenticatorTransport
      .map((e) => authenticatorTransportFromJson(e.toString()))
      .toList();
}

String? createApiKeysRequestTypeNullableToJson(
    enums.CreateApiKeysRequestType? createApiKeysRequestType) {
  return createApiKeysRequestType?.value;
}

String? createApiKeysRequestTypeToJson(
    enums.CreateApiKeysRequestType createApiKeysRequestType) {
  return createApiKeysRequestType.value;
}

enums.CreateApiKeysRequestType createApiKeysRequestTypeFromJson(
  Object? createApiKeysRequestType, [
  enums.CreateApiKeysRequestType? defaultValue,
]) {
  return enums.CreateApiKeysRequestType.values
          .firstWhereOrNull((e) => e.value == createApiKeysRequestType) ??
      defaultValue ??
      enums.CreateApiKeysRequestType.swaggerGeneratedUnknown;
}

enums.CreateApiKeysRequestType? createApiKeysRequestTypeNullableFromJson(
  Object? createApiKeysRequestType, [
  enums.CreateApiKeysRequestType? defaultValue,
]) {
  if (createApiKeysRequestType == null) {
    return null;
  }
  return enums.CreateApiKeysRequestType.values
          .firstWhereOrNull((e) => e.value == createApiKeysRequestType) ??
      defaultValue;
}

String createApiKeysRequestTypeExplodedListToJson(
    List<enums.CreateApiKeysRequestType>? createApiKeysRequestType) {
  return createApiKeysRequestType?.map((e) => e.value!).join(',') ?? '';
}

List<String> createApiKeysRequestTypeListToJson(
    List<enums.CreateApiKeysRequestType>? createApiKeysRequestType) {
  if (createApiKeysRequestType == null) {
    return [];
  }

  return createApiKeysRequestType.map((e) => e.value!).toList();
}

List<enums.CreateApiKeysRequestType> createApiKeysRequestTypeListFromJson(
  List? createApiKeysRequestType, [
  List<enums.CreateApiKeysRequestType>? defaultValue,
]) {
  if (createApiKeysRequestType == null) {
    return defaultValue ?? [];
  }

  return createApiKeysRequestType
      .map((e) => createApiKeysRequestTypeFromJson(e.toString()))
      .toList();
}

List<enums.CreateApiKeysRequestType>?
    createApiKeysRequestTypeNullableListFromJson(
  List? createApiKeysRequestType, [
  List<enums.CreateApiKeysRequestType>? defaultValue,
]) {
  if (createApiKeysRequestType == null) {
    return defaultValue;
  }

  return createApiKeysRequestType
      .map((e) => createApiKeysRequestTypeFromJson(e.toString()))
      .toList();
}

String? createAuthenticatorsRequestTypeNullableToJson(
    enums.CreateAuthenticatorsRequestType? createAuthenticatorsRequestType) {
  return createAuthenticatorsRequestType?.value;
}

String? createAuthenticatorsRequestTypeToJson(
    enums.CreateAuthenticatorsRequestType createAuthenticatorsRequestType) {
  return createAuthenticatorsRequestType.value;
}

enums.CreateAuthenticatorsRequestType createAuthenticatorsRequestTypeFromJson(
  Object? createAuthenticatorsRequestType, [
  enums.CreateAuthenticatorsRequestType? defaultValue,
]) {
  return enums.CreateAuthenticatorsRequestType.values.firstWhereOrNull(
          (e) => e.value == createAuthenticatorsRequestType) ??
      defaultValue ??
      enums.CreateAuthenticatorsRequestType.swaggerGeneratedUnknown;
}

enums.CreateAuthenticatorsRequestType?
    createAuthenticatorsRequestTypeNullableFromJson(
  Object? createAuthenticatorsRequestType, [
  enums.CreateAuthenticatorsRequestType? defaultValue,
]) {
  if (createAuthenticatorsRequestType == null) {
    return null;
  }
  return enums.CreateAuthenticatorsRequestType.values.firstWhereOrNull(
          (e) => e.value == createAuthenticatorsRequestType) ??
      defaultValue;
}

String createAuthenticatorsRequestTypeExplodedListToJson(
    List<enums.CreateAuthenticatorsRequestType>?
        createAuthenticatorsRequestType) {
  return createAuthenticatorsRequestType?.map((e) => e.value!).join(',') ?? '';
}

List<String> createAuthenticatorsRequestTypeListToJson(
    List<enums.CreateAuthenticatorsRequestType>?
        createAuthenticatorsRequestType) {
  if (createAuthenticatorsRequestType == null) {
    return [];
  }

  return createAuthenticatorsRequestType.map((e) => e.value!).toList();
}

List<enums.CreateAuthenticatorsRequestType>
    createAuthenticatorsRequestTypeListFromJson(
  List? createAuthenticatorsRequestType, [
  List<enums.CreateAuthenticatorsRequestType>? defaultValue,
]) {
  if (createAuthenticatorsRequestType == null) {
    return defaultValue ?? [];
  }

  return createAuthenticatorsRequestType
      .map((e) => createAuthenticatorsRequestTypeFromJson(e.toString()))
      .toList();
}

List<enums.CreateAuthenticatorsRequestType>?
    createAuthenticatorsRequestTypeNullableListFromJson(
  List? createAuthenticatorsRequestType, [
  List<enums.CreateAuthenticatorsRequestType>? defaultValue,
]) {
  if (createAuthenticatorsRequestType == null) {
    return defaultValue;
  }

  return createAuthenticatorsRequestType
      .map((e) => createAuthenticatorsRequestTypeFromJson(e.toString()))
      .toList();
}

String? createInvitationsRequestTypeNullableToJson(
    enums.CreateInvitationsRequestType? createInvitationsRequestType) {
  return createInvitationsRequestType?.value;
}

String? createInvitationsRequestTypeToJson(
    enums.CreateInvitationsRequestType createInvitationsRequestType) {
  return createInvitationsRequestType.value;
}

enums.CreateInvitationsRequestType createInvitationsRequestTypeFromJson(
  Object? createInvitationsRequestType, [
  enums.CreateInvitationsRequestType? defaultValue,
]) {
  return enums.CreateInvitationsRequestType.values
          .firstWhereOrNull((e) => e.value == createInvitationsRequestType) ??
      defaultValue ??
      enums.CreateInvitationsRequestType.swaggerGeneratedUnknown;
}

enums.CreateInvitationsRequestType?
    createInvitationsRequestTypeNullableFromJson(
  Object? createInvitationsRequestType, [
  enums.CreateInvitationsRequestType? defaultValue,
]) {
  if (createInvitationsRequestType == null) {
    return null;
  }
  return enums.CreateInvitationsRequestType.values
          .firstWhereOrNull((e) => e.value == createInvitationsRequestType) ??
      defaultValue;
}

String createInvitationsRequestTypeExplodedListToJson(
    List<enums.CreateInvitationsRequestType>? createInvitationsRequestType) {
  return createInvitationsRequestType?.map((e) => e.value!).join(',') ?? '';
}

List<String> createInvitationsRequestTypeListToJson(
    List<enums.CreateInvitationsRequestType>? createInvitationsRequestType) {
  if (createInvitationsRequestType == null) {
    return [];
  }

  return createInvitationsRequestType.map((e) => e.value!).toList();
}

List<enums.CreateInvitationsRequestType>
    createInvitationsRequestTypeListFromJson(
  List? createInvitationsRequestType, [
  List<enums.CreateInvitationsRequestType>? defaultValue,
]) {
  if (createInvitationsRequestType == null) {
    return defaultValue ?? [];
  }

  return createInvitationsRequestType
      .map((e) => createInvitationsRequestTypeFromJson(e.toString()))
      .toList();
}

List<enums.CreateInvitationsRequestType>?
    createInvitationsRequestTypeNullableListFromJson(
  List? createInvitationsRequestType, [
  List<enums.CreateInvitationsRequestType>? defaultValue,
]) {
  if (createInvitationsRequestType == null) {
    return defaultValue;
  }

  return createInvitationsRequestType
      .map((e) => createInvitationsRequestTypeFromJson(e.toString()))
      .toList();
}

String? createOauthProvidersRequestTypeNullableToJson(
    enums.CreateOauthProvidersRequestType? createOauthProvidersRequestType) {
  return createOauthProvidersRequestType?.value;
}

String? createOauthProvidersRequestTypeToJson(
    enums.CreateOauthProvidersRequestType createOauthProvidersRequestType) {
  return createOauthProvidersRequestType.value;
}

enums.CreateOauthProvidersRequestType createOauthProvidersRequestTypeFromJson(
  Object? createOauthProvidersRequestType, [
  enums.CreateOauthProvidersRequestType? defaultValue,
]) {
  return enums.CreateOauthProvidersRequestType.values.firstWhereOrNull(
          (e) => e.value == createOauthProvidersRequestType) ??
      defaultValue ??
      enums.CreateOauthProvidersRequestType.swaggerGeneratedUnknown;
}

enums.CreateOauthProvidersRequestType?
    createOauthProvidersRequestTypeNullableFromJson(
  Object? createOauthProvidersRequestType, [
  enums.CreateOauthProvidersRequestType? defaultValue,
]) {
  if (createOauthProvidersRequestType == null) {
    return null;
  }
  return enums.CreateOauthProvidersRequestType.values.firstWhereOrNull(
          (e) => e.value == createOauthProvidersRequestType) ??
      defaultValue;
}

String createOauthProvidersRequestTypeExplodedListToJson(
    List<enums.CreateOauthProvidersRequestType>?
        createOauthProvidersRequestType) {
  return createOauthProvidersRequestType?.map((e) => e.value!).join(',') ?? '';
}

List<String> createOauthProvidersRequestTypeListToJson(
    List<enums.CreateOauthProvidersRequestType>?
        createOauthProvidersRequestType) {
  if (createOauthProvidersRequestType == null) {
    return [];
  }

  return createOauthProvidersRequestType.map((e) => e.value!).toList();
}

List<enums.CreateOauthProvidersRequestType>
    createOauthProvidersRequestTypeListFromJson(
  List? createOauthProvidersRequestType, [
  List<enums.CreateOauthProvidersRequestType>? defaultValue,
]) {
  if (createOauthProvidersRequestType == null) {
    return defaultValue ?? [];
  }

  return createOauthProvidersRequestType
      .map((e) => createOauthProvidersRequestTypeFromJson(e.toString()))
      .toList();
}

List<enums.CreateOauthProvidersRequestType>?
    createOauthProvidersRequestTypeNullableListFromJson(
  List? createOauthProvidersRequestType, [
  List<enums.CreateOauthProvidersRequestType>? defaultValue,
]) {
  if (createOauthProvidersRequestType == null) {
    return defaultValue;
  }

  return createOauthProvidersRequestType
      .map((e) => createOauthProvidersRequestTypeFromJson(e.toString()))
      .toList();
}

String? createPoliciesRequestTypeNullableToJson(
    enums.CreatePoliciesRequestType? createPoliciesRequestType) {
  return createPoliciesRequestType?.value;
}

String? createPoliciesRequestTypeToJson(
    enums.CreatePoliciesRequestType createPoliciesRequestType) {
  return createPoliciesRequestType.value;
}

enums.CreatePoliciesRequestType createPoliciesRequestTypeFromJson(
  Object? createPoliciesRequestType, [
  enums.CreatePoliciesRequestType? defaultValue,
]) {
  return enums.CreatePoliciesRequestType.values
          .firstWhereOrNull((e) => e.value == createPoliciesRequestType) ??
      defaultValue ??
      enums.CreatePoliciesRequestType.swaggerGeneratedUnknown;
}

enums.CreatePoliciesRequestType? createPoliciesRequestTypeNullableFromJson(
  Object? createPoliciesRequestType, [
  enums.CreatePoliciesRequestType? defaultValue,
]) {
  if (createPoliciesRequestType == null) {
    return null;
  }
  return enums.CreatePoliciesRequestType.values
          .firstWhereOrNull((e) => e.value == createPoliciesRequestType) ??
      defaultValue;
}

String createPoliciesRequestTypeExplodedListToJson(
    List<enums.CreatePoliciesRequestType>? createPoliciesRequestType) {
  return createPoliciesRequestType?.map((e) => e.value!).join(',') ?? '';
}

List<String> createPoliciesRequestTypeListToJson(
    List<enums.CreatePoliciesRequestType>? createPoliciesRequestType) {
  if (createPoliciesRequestType == null) {
    return [];
  }

  return createPoliciesRequestType.map((e) => e.value!).toList();
}

List<enums.CreatePoliciesRequestType> createPoliciesRequestTypeListFromJson(
  List? createPoliciesRequestType, [
  List<enums.CreatePoliciesRequestType>? defaultValue,
]) {
  if (createPoliciesRequestType == null) {
    return defaultValue ?? [];
  }

  return createPoliciesRequestType
      .map((e) => createPoliciesRequestTypeFromJson(e.toString()))
      .toList();
}

List<enums.CreatePoliciesRequestType>?
    createPoliciesRequestTypeNullableListFromJson(
  List? createPoliciesRequestType, [
  List<enums.CreatePoliciesRequestType>? defaultValue,
]) {
  if (createPoliciesRequestType == null) {
    return defaultValue;
  }

  return createPoliciesRequestType
      .map((e) => createPoliciesRequestTypeFromJson(e.toString()))
      .toList();
}

String? createPolicyRequestTypeNullableToJson(
    enums.CreatePolicyRequestType? createPolicyRequestType) {
  return createPolicyRequestType?.value;
}

String? createPolicyRequestTypeToJson(
    enums.CreatePolicyRequestType createPolicyRequestType) {
  return createPolicyRequestType.value;
}

enums.CreatePolicyRequestType createPolicyRequestTypeFromJson(
  Object? createPolicyRequestType, [
  enums.CreatePolicyRequestType? defaultValue,
]) {
  return enums.CreatePolicyRequestType.values
          .firstWhereOrNull((e) => e.value == createPolicyRequestType) ??
      defaultValue ??
      enums.CreatePolicyRequestType.swaggerGeneratedUnknown;
}

enums.CreatePolicyRequestType? createPolicyRequestTypeNullableFromJson(
  Object? createPolicyRequestType, [
  enums.CreatePolicyRequestType? defaultValue,
]) {
  if (createPolicyRequestType == null) {
    return null;
  }
  return enums.CreatePolicyRequestType.values
          .firstWhereOrNull((e) => e.value == createPolicyRequestType) ??
      defaultValue;
}

String createPolicyRequestTypeExplodedListToJson(
    List<enums.CreatePolicyRequestType>? createPolicyRequestType) {
  return createPolicyRequestType?.map((e) => e.value!).join(',') ?? '';
}

List<String> createPolicyRequestTypeListToJson(
    List<enums.CreatePolicyRequestType>? createPolicyRequestType) {
  if (createPolicyRequestType == null) {
    return [];
  }

  return createPolicyRequestType.map((e) => e.value!).toList();
}

List<enums.CreatePolicyRequestType> createPolicyRequestTypeListFromJson(
  List? createPolicyRequestType, [
  List<enums.CreatePolicyRequestType>? defaultValue,
]) {
  if (createPolicyRequestType == null) {
    return defaultValue ?? [];
  }

  return createPolicyRequestType
      .map((e) => createPolicyRequestTypeFromJson(e.toString()))
      .toList();
}

List<enums.CreatePolicyRequestType>?
    createPolicyRequestTypeNullableListFromJson(
  List? createPolicyRequestType, [
  List<enums.CreatePolicyRequestType>? defaultValue,
]) {
  if (createPolicyRequestType == null) {
    return defaultValue;
  }

  return createPolicyRequestType
      .map((e) => createPolicyRequestTypeFromJson(e.toString()))
      .toList();
}

String? createPrivateKeyTagRequestTypeNullableToJson(
    enums.CreatePrivateKeyTagRequestType? createPrivateKeyTagRequestType) {
  return createPrivateKeyTagRequestType?.value;
}

String? createPrivateKeyTagRequestTypeToJson(
    enums.CreatePrivateKeyTagRequestType createPrivateKeyTagRequestType) {
  return createPrivateKeyTagRequestType.value;
}

enums.CreatePrivateKeyTagRequestType createPrivateKeyTagRequestTypeFromJson(
  Object? createPrivateKeyTagRequestType, [
  enums.CreatePrivateKeyTagRequestType? defaultValue,
]) {
  return enums.CreatePrivateKeyTagRequestType.values
          .firstWhereOrNull((e) => e.value == createPrivateKeyTagRequestType) ??
      defaultValue ??
      enums.CreatePrivateKeyTagRequestType.swaggerGeneratedUnknown;
}

enums.CreatePrivateKeyTagRequestType?
    createPrivateKeyTagRequestTypeNullableFromJson(
  Object? createPrivateKeyTagRequestType, [
  enums.CreatePrivateKeyTagRequestType? defaultValue,
]) {
  if (createPrivateKeyTagRequestType == null) {
    return null;
  }
  return enums.CreatePrivateKeyTagRequestType.values
          .firstWhereOrNull((e) => e.value == createPrivateKeyTagRequestType) ??
      defaultValue;
}

String createPrivateKeyTagRequestTypeExplodedListToJson(
    List<enums.CreatePrivateKeyTagRequestType>?
        createPrivateKeyTagRequestType) {
  return createPrivateKeyTagRequestType?.map((e) => e.value!).join(',') ?? '';
}

List<String> createPrivateKeyTagRequestTypeListToJson(
    List<enums.CreatePrivateKeyTagRequestType>?
        createPrivateKeyTagRequestType) {
  if (createPrivateKeyTagRequestType == null) {
    return [];
  }

  return createPrivateKeyTagRequestType.map((e) => e.value!).toList();
}

List<enums.CreatePrivateKeyTagRequestType>
    createPrivateKeyTagRequestTypeListFromJson(
  List? createPrivateKeyTagRequestType, [
  List<enums.CreatePrivateKeyTagRequestType>? defaultValue,
]) {
  if (createPrivateKeyTagRequestType == null) {
    return defaultValue ?? [];
  }

  return createPrivateKeyTagRequestType
      .map((e) => createPrivateKeyTagRequestTypeFromJson(e.toString()))
      .toList();
}

List<enums.CreatePrivateKeyTagRequestType>?
    createPrivateKeyTagRequestTypeNullableListFromJson(
  List? createPrivateKeyTagRequestType, [
  List<enums.CreatePrivateKeyTagRequestType>? defaultValue,
]) {
  if (createPrivateKeyTagRequestType == null) {
    return defaultValue;
  }

  return createPrivateKeyTagRequestType
      .map((e) => createPrivateKeyTagRequestTypeFromJson(e.toString()))
      .toList();
}

String? createPrivateKeysRequestTypeNullableToJson(
    enums.CreatePrivateKeysRequestType? createPrivateKeysRequestType) {
  return createPrivateKeysRequestType?.value;
}

String? createPrivateKeysRequestTypeToJson(
    enums.CreatePrivateKeysRequestType createPrivateKeysRequestType) {
  return createPrivateKeysRequestType.value;
}

enums.CreatePrivateKeysRequestType createPrivateKeysRequestTypeFromJson(
  Object? createPrivateKeysRequestType, [
  enums.CreatePrivateKeysRequestType? defaultValue,
]) {
  return enums.CreatePrivateKeysRequestType.values
          .firstWhereOrNull((e) => e.value == createPrivateKeysRequestType) ??
      defaultValue ??
      enums.CreatePrivateKeysRequestType.swaggerGeneratedUnknown;
}

enums.CreatePrivateKeysRequestType?
    createPrivateKeysRequestTypeNullableFromJson(
  Object? createPrivateKeysRequestType, [
  enums.CreatePrivateKeysRequestType? defaultValue,
]) {
  if (createPrivateKeysRequestType == null) {
    return null;
  }
  return enums.CreatePrivateKeysRequestType.values
          .firstWhereOrNull((e) => e.value == createPrivateKeysRequestType) ??
      defaultValue;
}

String createPrivateKeysRequestTypeExplodedListToJson(
    List<enums.CreatePrivateKeysRequestType>? createPrivateKeysRequestType) {
  return createPrivateKeysRequestType?.map((e) => e.value!).join(',') ?? '';
}

List<String> createPrivateKeysRequestTypeListToJson(
    List<enums.CreatePrivateKeysRequestType>? createPrivateKeysRequestType) {
  if (createPrivateKeysRequestType == null) {
    return [];
  }

  return createPrivateKeysRequestType.map((e) => e.value!).toList();
}

List<enums.CreatePrivateKeysRequestType>
    createPrivateKeysRequestTypeListFromJson(
  List? createPrivateKeysRequestType, [
  List<enums.CreatePrivateKeysRequestType>? defaultValue,
]) {
  if (createPrivateKeysRequestType == null) {
    return defaultValue ?? [];
  }

  return createPrivateKeysRequestType
      .map((e) => createPrivateKeysRequestTypeFromJson(e.toString()))
      .toList();
}

List<enums.CreatePrivateKeysRequestType>?
    createPrivateKeysRequestTypeNullableListFromJson(
  List? createPrivateKeysRequestType, [
  List<enums.CreatePrivateKeysRequestType>? defaultValue,
]) {
  if (createPrivateKeysRequestType == null) {
    return defaultValue;
  }

  return createPrivateKeysRequestType
      .map((e) => createPrivateKeysRequestTypeFromJson(e.toString()))
      .toList();
}

String? createReadOnlySessionRequestTypeNullableToJson(
    enums.CreateReadOnlySessionRequestType? createReadOnlySessionRequestType) {
  return createReadOnlySessionRequestType?.value;
}

String? createReadOnlySessionRequestTypeToJson(
    enums.CreateReadOnlySessionRequestType createReadOnlySessionRequestType) {
  return createReadOnlySessionRequestType.value;
}

enums.CreateReadOnlySessionRequestType createReadOnlySessionRequestTypeFromJson(
  Object? createReadOnlySessionRequestType, [
  enums.CreateReadOnlySessionRequestType? defaultValue,
]) {
  return enums.CreateReadOnlySessionRequestType.values.firstWhereOrNull(
          (e) => e.value == createReadOnlySessionRequestType) ??
      defaultValue ??
      enums.CreateReadOnlySessionRequestType.swaggerGeneratedUnknown;
}

enums.CreateReadOnlySessionRequestType?
    createReadOnlySessionRequestTypeNullableFromJson(
  Object? createReadOnlySessionRequestType, [
  enums.CreateReadOnlySessionRequestType? defaultValue,
]) {
  if (createReadOnlySessionRequestType == null) {
    return null;
  }
  return enums.CreateReadOnlySessionRequestType.values.firstWhereOrNull(
          (e) => e.value == createReadOnlySessionRequestType) ??
      defaultValue;
}

String createReadOnlySessionRequestTypeExplodedListToJson(
    List<enums.CreateReadOnlySessionRequestType>?
        createReadOnlySessionRequestType) {
  return createReadOnlySessionRequestType?.map((e) => e.value!).join(',') ?? '';
}

List<String> createReadOnlySessionRequestTypeListToJson(
    List<enums.CreateReadOnlySessionRequestType>?
        createReadOnlySessionRequestType) {
  if (createReadOnlySessionRequestType == null) {
    return [];
  }

  return createReadOnlySessionRequestType.map((e) => e.value!).toList();
}

List<enums.CreateReadOnlySessionRequestType>
    createReadOnlySessionRequestTypeListFromJson(
  List? createReadOnlySessionRequestType, [
  List<enums.CreateReadOnlySessionRequestType>? defaultValue,
]) {
  if (createReadOnlySessionRequestType == null) {
    return defaultValue ?? [];
  }

  return createReadOnlySessionRequestType
      .map((e) => createReadOnlySessionRequestTypeFromJson(e.toString()))
      .toList();
}

List<enums.CreateReadOnlySessionRequestType>?
    createReadOnlySessionRequestTypeNullableListFromJson(
  List? createReadOnlySessionRequestType, [
  List<enums.CreateReadOnlySessionRequestType>? defaultValue,
]) {
  if (createReadOnlySessionRequestType == null) {
    return defaultValue;
  }

  return createReadOnlySessionRequestType
      .map((e) => createReadOnlySessionRequestTypeFromJson(e.toString()))
      .toList();
}

String? createReadWriteSessionRequestTypeNullableToJson(
    enums.CreateReadWriteSessionRequestType?
        createReadWriteSessionRequestType) {
  return createReadWriteSessionRequestType?.value;
}

String? createReadWriteSessionRequestTypeToJson(
    enums.CreateReadWriteSessionRequestType createReadWriteSessionRequestType) {
  return createReadWriteSessionRequestType.value;
}

enums.CreateReadWriteSessionRequestType
    createReadWriteSessionRequestTypeFromJson(
  Object? createReadWriteSessionRequestType, [
  enums.CreateReadWriteSessionRequestType? defaultValue,
]) {
  return enums.CreateReadWriteSessionRequestType.values.firstWhereOrNull(
          (e) => e.value == createReadWriteSessionRequestType) ??
      defaultValue ??
      enums.CreateReadWriteSessionRequestType.swaggerGeneratedUnknown;
}

enums.CreateReadWriteSessionRequestType?
    createReadWriteSessionRequestTypeNullableFromJson(
  Object? createReadWriteSessionRequestType, [
  enums.CreateReadWriteSessionRequestType? defaultValue,
]) {
  if (createReadWriteSessionRequestType == null) {
    return null;
  }
  return enums.CreateReadWriteSessionRequestType.values.firstWhereOrNull(
          (e) => e.value == createReadWriteSessionRequestType) ??
      defaultValue;
}

String createReadWriteSessionRequestTypeExplodedListToJson(
    List<enums.CreateReadWriteSessionRequestType>?
        createReadWriteSessionRequestType) {
  return createReadWriteSessionRequestType?.map((e) => e.value!).join(',') ??
      '';
}

List<String> createReadWriteSessionRequestTypeListToJson(
    List<enums.CreateReadWriteSessionRequestType>?
        createReadWriteSessionRequestType) {
  if (createReadWriteSessionRequestType == null) {
    return [];
  }

  return createReadWriteSessionRequestType.map((e) => e.value!).toList();
}

List<enums.CreateReadWriteSessionRequestType>
    createReadWriteSessionRequestTypeListFromJson(
  List? createReadWriteSessionRequestType, [
  List<enums.CreateReadWriteSessionRequestType>? defaultValue,
]) {
  if (createReadWriteSessionRequestType == null) {
    return defaultValue ?? [];
  }

  return createReadWriteSessionRequestType
      .map((e) => createReadWriteSessionRequestTypeFromJson(e.toString()))
      .toList();
}

List<enums.CreateReadWriteSessionRequestType>?
    createReadWriteSessionRequestTypeNullableListFromJson(
  List? createReadWriteSessionRequestType, [
  List<enums.CreateReadWriteSessionRequestType>? defaultValue,
]) {
  if (createReadWriteSessionRequestType == null) {
    return defaultValue;
  }

  return createReadWriteSessionRequestType
      .map((e) => createReadWriteSessionRequestTypeFromJson(e.toString()))
      .toList();
}

String? createSmartContractInterfaceRequestTypeNullableToJson(
    enums.CreateSmartContractInterfaceRequestType?
        createSmartContractInterfaceRequestType) {
  return createSmartContractInterfaceRequestType?.value;
}

String? createSmartContractInterfaceRequestTypeToJson(
    enums.CreateSmartContractInterfaceRequestType
        createSmartContractInterfaceRequestType) {
  return createSmartContractInterfaceRequestType.value;
}

enums.CreateSmartContractInterfaceRequestType
    createSmartContractInterfaceRequestTypeFromJson(
  Object? createSmartContractInterfaceRequestType, [
  enums.CreateSmartContractInterfaceRequestType? defaultValue,
]) {
  return enums.CreateSmartContractInterfaceRequestType.values.firstWhereOrNull(
          (e) => e.value == createSmartContractInterfaceRequestType) ??
      defaultValue ??
      enums.CreateSmartContractInterfaceRequestType.swaggerGeneratedUnknown;
}

enums.CreateSmartContractInterfaceRequestType?
    createSmartContractInterfaceRequestTypeNullableFromJson(
  Object? createSmartContractInterfaceRequestType, [
  enums.CreateSmartContractInterfaceRequestType? defaultValue,
]) {
  if (createSmartContractInterfaceRequestType == null) {
    return null;
  }
  return enums.CreateSmartContractInterfaceRequestType.values.firstWhereOrNull(
          (e) => e.value == createSmartContractInterfaceRequestType) ??
      defaultValue;
}

String createSmartContractInterfaceRequestTypeExplodedListToJson(
    List<enums.CreateSmartContractInterfaceRequestType>?
        createSmartContractInterfaceRequestType) {
  return createSmartContractInterfaceRequestType
          ?.map((e) => e.value!)
          .join(',') ??
      '';
}

List<String> createSmartContractInterfaceRequestTypeListToJson(
    List<enums.CreateSmartContractInterfaceRequestType>?
        createSmartContractInterfaceRequestType) {
  if (createSmartContractInterfaceRequestType == null) {
    return [];
  }

  return createSmartContractInterfaceRequestType.map((e) => e.value!).toList();
}

List<enums.CreateSmartContractInterfaceRequestType>
    createSmartContractInterfaceRequestTypeListFromJson(
  List? createSmartContractInterfaceRequestType, [
  List<enums.CreateSmartContractInterfaceRequestType>? defaultValue,
]) {
  if (createSmartContractInterfaceRequestType == null) {
    return defaultValue ?? [];
  }

  return createSmartContractInterfaceRequestType
      .map((e) => createSmartContractInterfaceRequestTypeFromJson(e.toString()))
      .toList();
}

List<enums.CreateSmartContractInterfaceRequestType>?
    createSmartContractInterfaceRequestTypeNullableListFromJson(
  List? createSmartContractInterfaceRequestType, [
  List<enums.CreateSmartContractInterfaceRequestType>? defaultValue,
]) {
  if (createSmartContractInterfaceRequestType == null) {
    return defaultValue;
  }

  return createSmartContractInterfaceRequestType
      .map((e) => createSmartContractInterfaceRequestTypeFromJson(e.toString()))
      .toList();
}

String? createSubOrganizationRequestTypeNullableToJson(
    enums.CreateSubOrganizationRequestType? createSubOrganizationRequestType) {
  return createSubOrganizationRequestType?.value;
}

String? createSubOrganizationRequestTypeToJson(
    enums.CreateSubOrganizationRequestType createSubOrganizationRequestType) {
  return createSubOrganizationRequestType.value;
}

enums.CreateSubOrganizationRequestType createSubOrganizationRequestTypeFromJson(
  Object? createSubOrganizationRequestType, [
  enums.CreateSubOrganizationRequestType? defaultValue,
]) {
  return enums.CreateSubOrganizationRequestType.values.firstWhereOrNull(
          (e) => e.value == createSubOrganizationRequestType) ??
      defaultValue ??
      enums.CreateSubOrganizationRequestType.swaggerGeneratedUnknown;
}

enums.CreateSubOrganizationRequestType?
    createSubOrganizationRequestTypeNullableFromJson(
  Object? createSubOrganizationRequestType, [
  enums.CreateSubOrganizationRequestType? defaultValue,
]) {
  if (createSubOrganizationRequestType == null) {
    return null;
  }
  return enums.CreateSubOrganizationRequestType.values.firstWhereOrNull(
          (e) => e.value == createSubOrganizationRequestType) ??
      defaultValue;
}

String createSubOrganizationRequestTypeExplodedListToJson(
    List<enums.CreateSubOrganizationRequestType>?
        createSubOrganizationRequestType) {
  return createSubOrganizationRequestType?.map((e) => e.value!).join(',') ?? '';
}

List<String> createSubOrganizationRequestTypeListToJson(
    List<enums.CreateSubOrganizationRequestType>?
        createSubOrganizationRequestType) {
  if (createSubOrganizationRequestType == null) {
    return [];
  }

  return createSubOrganizationRequestType.map((e) => e.value!).toList();
}

List<enums.CreateSubOrganizationRequestType>
    createSubOrganizationRequestTypeListFromJson(
  List? createSubOrganizationRequestType, [
  List<enums.CreateSubOrganizationRequestType>? defaultValue,
]) {
  if (createSubOrganizationRequestType == null) {
    return defaultValue ?? [];
  }

  return createSubOrganizationRequestType
      .map((e) => createSubOrganizationRequestTypeFromJson(e.toString()))
      .toList();
}

List<enums.CreateSubOrganizationRequestType>?
    createSubOrganizationRequestTypeNullableListFromJson(
  List? createSubOrganizationRequestType, [
  List<enums.CreateSubOrganizationRequestType>? defaultValue,
]) {
  if (createSubOrganizationRequestType == null) {
    return defaultValue;
  }

  return createSubOrganizationRequestType
      .map((e) => createSubOrganizationRequestTypeFromJson(e.toString()))
      .toList();
}

String? createUserTagRequestTypeNullableToJson(
    enums.CreateUserTagRequestType? createUserTagRequestType) {
  return createUserTagRequestType?.value;
}

String? createUserTagRequestTypeToJson(
    enums.CreateUserTagRequestType createUserTagRequestType) {
  return createUserTagRequestType.value;
}

enums.CreateUserTagRequestType createUserTagRequestTypeFromJson(
  Object? createUserTagRequestType, [
  enums.CreateUserTagRequestType? defaultValue,
]) {
  return enums.CreateUserTagRequestType.values
          .firstWhereOrNull((e) => e.value == createUserTagRequestType) ??
      defaultValue ??
      enums.CreateUserTagRequestType.swaggerGeneratedUnknown;
}

enums.CreateUserTagRequestType? createUserTagRequestTypeNullableFromJson(
  Object? createUserTagRequestType, [
  enums.CreateUserTagRequestType? defaultValue,
]) {
  if (createUserTagRequestType == null) {
    return null;
  }
  return enums.CreateUserTagRequestType.values
          .firstWhereOrNull((e) => e.value == createUserTagRequestType) ??
      defaultValue;
}

String createUserTagRequestTypeExplodedListToJson(
    List<enums.CreateUserTagRequestType>? createUserTagRequestType) {
  return createUserTagRequestType?.map((e) => e.value!).join(',') ?? '';
}

List<String> createUserTagRequestTypeListToJson(
    List<enums.CreateUserTagRequestType>? createUserTagRequestType) {
  if (createUserTagRequestType == null) {
    return [];
  }

  return createUserTagRequestType.map((e) => e.value!).toList();
}

List<enums.CreateUserTagRequestType> createUserTagRequestTypeListFromJson(
  List? createUserTagRequestType, [
  List<enums.CreateUserTagRequestType>? defaultValue,
]) {
  if (createUserTagRequestType == null) {
    return defaultValue ?? [];
  }

  return createUserTagRequestType
      .map((e) => createUserTagRequestTypeFromJson(e.toString()))
      .toList();
}

List<enums.CreateUserTagRequestType>?
    createUserTagRequestTypeNullableListFromJson(
  List? createUserTagRequestType, [
  List<enums.CreateUserTagRequestType>? defaultValue,
]) {
  if (createUserTagRequestType == null) {
    return defaultValue;
  }

  return createUserTagRequestType
      .map((e) => createUserTagRequestTypeFromJson(e.toString()))
      .toList();
}

String? createUsersRequestTypeNullableToJson(
    enums.CreateUsersRequestType? createUsersRequestType) {
  return createUsersRequestType?.value;
}

String? createUsersRequestTypeToJson(
    enums.CreateUsersRequestType createUsersRequestType) {
  return createUsersRequestType.value;
}

enums.CreateUsersRequestType createUsersRequestTypeFromJson(
  Object? createUsersRequestType, [
  enums.CreateUsersRequestType? defaultValue,
]) {
  return enums.CreateUsersRequestType.values
          .firstWhereOrNull((e) => e.value == createUsersRequestType) ??
      defaultValue ??
      enums.CreateUsersRequestType.swaggerGeneratedUnknown;
}

enums.CreateUsersRequestType? createUsersRequestTypeNullableFromJson(
  Object? createUsersRequestType, [
  enums.CreateUsersRequestType? defaultValue,
]) {
  if (createUsersRequestType == null) {
    return null;
  }
  return enums.CreateUsersRequestType.values
          .firstWhereOrNull((e) => e.value == createUsersRequestType) ??
      defaultValue;
}

String createUsersRequestTypeExplodedListToJson(
    List<enums.CreateUsersRequestType>? createUsersRequestType) {
  return createUsersRequestType?.map((e) => e.value!).join(',') ?? '';
}

List<String> createUsersRequestTypeListToJson(
    List<enums.CreateUsersRequestType>? createUsersRequestType) {
  if (createUsersRequestType == null) {
    return [];
  }

  return createUsersRequestType.map((e) => e.value!).toList();
}

List<enums.CreateUsersRequestType> createUsersRequestTypeListFromJson(
  List? createUsersRequestType, [
  List<enums.CreateUsersRequestType>? defaultValue,
]) {
  if (createUsersRequestType == null) {
    return defaultValue ?? [];
  }

  return createUsersRequestType
      .map((e) => createUsersRequestTypeFromJson(e.toString()))
      .toList();
}

List<enums.CreateUsersRequestType>? createUsersRequestTypeNullableListFromJson(
  List? createUsersRequestType, [
  List<enums.CreateUsersRequestType>? defaultValue,
]) {
  if (createUsersRequestType == null) {
    return defaultValue;
  }

  return createUsersRequestType
      .map((e) => createUsersRequestTypeFromJson(e.toString()))
      .toList();
}

String? createWalletAccountsRequestTypeNullableToJson(
    enums.CreateWalletAccountsRequestType? createWalletAccountsRequestType) {
  return createWalletAccountsRequestType?.value;
}

String? createWalletAccountsRequestTypeToJson(
    enums.CreateWalletAccountsRequestType createWalletAccountsRequestType) {
  return createWalletAccountsRequestType.value;
}

enums.CreateWalletAccountsRequestType createWalletAccountsRequestTypeFromJson(
  Object? createWalletAccountsRequestType, [
  enums.CreateWalletAccountsRequestType? defaultValue,
]) {
  return enums.CreateWalletAccountsRequestType.values.firstWhereOrNull(
          (e) => e.value == createWalletAccountsRequestType) ??
      defaultValue ??
      enums.CreateWalletAccountsRequestType.swaggerGeneratedUnknown;
}

enums.CreateWalletAccountsRequestType?
    createWalletAccountsRequestTypeNullableFromJson(
  Object? createWalletAccountsRequestType, [
  enums.CreateWalletAccountsRequestType? defaultValue,
]) {
  if (createWalletAccountsRequestType == null) {
    return null;
  }
  return enums.CreateWalletAccountsRequestType.values.firstWhereOrNull(
          (e) => e.value == createWalletAccountsRequestType) ??
      defaultValue;
}

String createWalletAccountsRequestTypeExplodedListToJson(
    List<enums.CreateWalletAccountsRequestType>?
        createWalletAccountsRequestType) {
  return createWalletAccountsRequestType?.map((e) => e.value!).join(',') ?? '';
}

List<String> createWalletAccountsRequestTypeListToJson(
    List<enums.CreateWalletAccountsRequestType>?
        createWalletAccountsRequestType) {
  if (createWalletAccountsRequestType == null) {
    return [];
  }

  return createWalletAccountsRequestType.map((e) => e.value!).toList();
}

List<enums.CreateWalletAccountsRequestType>
    createWalletAccountsRequestTypeListFromJson(
  List? createWalletAccountsRequestType, [
  List<enums.CreateWalletAccountsRequestType>? defaultValue,
]) {
  if (createWalletAccountsRequestType == null) {
    return defaultValue ?? [];
  }

  return createWalletAccountsRequestType
      .map((e) => createWalletAccountsRequestTypeFromJson(e.toString()))
      .toList();
}

List<enums.CreateWalletAccountsRequestType>?
    createWalletAccountsRequestTypeNullableListFromJson(
  List? createWalletAccountsRequestType, [
  List<enums.CreateWalletAccountsRequestType>? defaultValue,
]) {
  if (createWalletAccountsRequestType == null) {
    return defaultValue;
  }

  return createWalletAccountsRequestType
      .map((e) => createWalletAccountsRequestTypeFromJson(e.toString()))
      .toList();
}

String? createWalletRequestTypeNullableToJson(
    enums.CreateWalletRequestType? createWalletRequestType) {
  return createWalletRequestType?.value;
}

String? createWalletRequestTypeToJson(
    enums.CreateWalletRequestType createWalletRequestType) {
  return createWalletRequestType.value;
}

enums.CreateWalletRequestType createWalletRequestTypeFromJson(
  Object? createWalletRequestType, [
  enums.CreateWalletRequestType? defaultValue,
]) {
  return enums.CreateWalletRequestType.values
          .firstWhereOrNull((e) => e.value == createWalletRequestType) ??
      defaultValue ??
      enums.CreateWalletRequestType.swaggerGeneratedUnknown;
}

enums.CreateWalletRequestType? createWalletRequestTypeNullableFromJson(
  Object? createWalletRequestType, [
  enums.CreateWalletRequestType? defaultValue,
]) {
  if (createWalletRequestType == null) {
    return null;
  }
  return enums.CreateWalletRequestType.values
          .firstWhereOrNull((e) => e.value == createWalletRequestType) ??
      defaultValue;
}

String createWalletRequestTypeExplodedListToJson(
    List<enums.CreateWalletRequestType>? createWalletRequestType) {
  return createWalletRequestType?.map((e) => e.value!).join(',') ?? '';
}

List<String> createWalletRequestTypeListToJson(
    List<enums.CreateWalletRequestType>? createWalletRequestType) {
  if (createWalletRequestType == null) {
    return [];
  }

  return createWalletRequestType.map((e) => e.value!).toList();
}

List<enums.CreateWalletRequestType> createWalletRequestTypeListFromJson(
  List? createWalletRequestType, [
  List<enums.CreateWalletRequestType>? defaultValue,
]) {
  if (createWalletRequestType == null) {
    return defaultValue ?? [];
  }

  return createWalletRequestType
      .map((e) => createWalletRequestTypeFromJson(e.toString()))
      .toList();
}

List<enums.CreateWalletRequestType>?
    createWalletRequestTypeNullableListFromJson(
  List? createWalletRequestType, [
  List<enums.CreateWalletRequestType>? defaultValue,
]) {
  if (createWalletRequestType == null) {
    return defaultValue;
  }

  return createWalletRequestType
      .map((e) => createWalletRequestTypeFromJson(e.toString()))
      .toList();
}

String? credentialTypeNullableToJson(enums.CredentialType? credentialType) {
  return credentialType?.value;
}

String? credentialTypeToJson(enums.CredentialType credentialType) {
  return credentialType.value;
}

enums.CredentialType credentialTypeFromJson(
  Object? credentialType, [
  enums.CredentialType? defaultValue,
]) {
  return enums.CredentialType.values
          .firstWhereOrNull((e) => e.value == credentialType) ??
      defaultValue ??
      enums.CredentialType.swaggerGeneratedUnknown;
}

enums.CredentialType? credentialTypeNullableFromJson(
  Object? credentialType, [
  enums.CredentialType? defaultValue,
]) {
  if (credentialType == null) {
    return null;
  }
  return enums.CredentialType.values
          .firstWhereOrNull((e) => e.value == credentialType) ??
      defaultValue;
}

String credentialTypeExplodedListToJson(
    List<enums.CredentialType>? credentialType) {
  return credentialType?.map((e) => e.value!).join(',') ?? '';
}

List<String> credentialTypeListToJson(
    List<enums.CredentialType>? credentialType) {
  if (credentialType == null) {
    return [];
  }

  return credentialType.map((e) => e.value!).toList();
}

List<enums.CredentialType> credentialTypeListFromJson(
  List? credentialType, [
  List<enums.CredentialType>? defaultValue,
]) {
  if (credentialType == null) {
    return defaultValue ?? [];
  }

  return credentialType
      .map((e) => credentialTypeFromJson(e.toString()))
      .toList();
}

List<enums.CredentialType>? credentialTypeNullableListFromJson(
  List? credentialType, [
  List<enums.CredentialType>? defaultValue,
]) {
  if (credentialType == null) {
    return defaultValue;
  }

  return credentialType
      .map((e) => credentialTypeFromJson(e.toString()))
      .toList();
}

String? curveNullableToJson(enums.Curve? curve) {
  return curve?.value;
}

String? curveToJson(enums.Curve curve) {
  return curve.value;
}

enums.Curve curveFromJson(
  Object? curve, [
  enums.Curve? defaultValue,
]) {
  return enums.Curve.values.firstWhereOrNull((e) => e.value == curve) ??
      defaultValue ??
      enums.Curve.swaggerGeneratedUnknown;
}

enums.Curve? curveNullableFromJson(
  Object? curve, [
  enums.Curve? defaultValue,
]) {
  if (curve == null) {
    return null;
  }
  return enums.Curve.values.firstWhereOrNull((e) => e.value == curve) ??
      defaultValue;
}

String curveExplodedListToJson(List<enums.Curve>? curve) {
  return curve?.map((e) => e.value!).join(',') ?? '';
}

List<String> curveListToJson(List<enums.Curve>? curve) {
  if (curve == null) {
    return [];
  }

  return curve.map((e) => e.value!).toList();
}

List<enums.Curve> curveListFromJson(
  List? curve, [
  List<enums.Curve>? defaultValue,
]) {
  if (curve == null) {
    return defaultValue ?? [];
  }

  return curve.map((e) => curveFromJson(e.toString())).toList();
}

List<enums.Curve>? curveNullableListFromJson(
  List? curve, [
  List<enums.Curve>? defaultValue,
]) {
  if (curve == null) {
    return defaultValue;
  }

  return curve.map((e) => curveFromJson(e.toString())).toList();
}

String? deleteApiKeysRequestTypeNullableToJson(
    enums.DeleteApiKeysRequestType? deleteApiKeysRequestType) {
  return deleteApiKeysRequestType?.value;
}

String? deleteApiKeysRequestTypeToJson(
    enums.DeleteApiKeysRequestType deleteApiKeysRequestType) {
  return deleteApiKeysRequestType.value;
}

enums.DeleteApiKeysRequestType deleteApiKeysRequestTypeFromJson(
  Object? deleteApiKeysRequestType, [
  enums.DeleteApiKeysRequestType? defaultValue,
]) {
  return enums.DeleteApiKeysRequestType.values
          .firstWhereOrNull((e) => e.value == deleteApiKeysRequestType) ??
      defaultValue ??
      enums.DeleteApiKeysRequestType.swaggerGeneratedUnknown;
}

enums.DeleteApiKeysRequestType? deleteApiKeysRequestTypeNullableFromJson(
  Object? deleteApiKeysRequestType, [
  enums.DeleteApiKeysRequestType? defaultValue,
]) {
  if (deleteApiKeysRequestType == null) {
    return null;
  }
  return enums.DeleteApiKeysRequestType.values
          .firstWhereOrNull((e) => e.value == deleteApiKeysRequestType) ??
      defaultValue;
}

String deleteApiKeysRequestTypeExplodedListToJson(
    List<enums.DeleteApiKeysRequestType>? deleteApiKeysRequestType) {
  return deleteApiKeysRequestType?.map((e) => e.value!).join(',') ?? '';
}

List<String> deleteApiKeysRequestTypeListToJson(
    List<enums.DeleteApiKeysRequestType>? deleteApiKeysRequestType) {
  if (deleteApiKeysRequestType == null) {
    return [];
  }

  return deleteApiKeysRequestType.map((e) => e.value!).toList();
}

List<enums.DeleteApiKeysRequestType> deleteApiKeysRequestTypeListFromJson(
  List? deleteApiKeysRequestType, [
  List<enums.DeleteApiKeysRequestType>? defaultValue,
]) {
  if (deleteApiKeysRequestType == null) {
    return defaultValue ?? [];
  }

  return deleteApiKeysRequestType
      .map((e) => deleteApiKeysRequestTypeFromJson(e.toString()))
      .toList();
}

List<enums.DeleteApiKeysRequestType>?
    deleteApiKeysRequestTypeNullableListFromJson(
  List? deleteApiKeysRequestType, [
  List<enums.DeleteApiKeysRequestType>? defaultValue,
]) {
  if (deleteApiKeysRequestType == null) {
    return defaultValue;
  }

  return deleteApiKeysRequestType
      .map((e) => deleteApiKeysRequestTypeFromJson(e.toString()))
      .toList();
}

String? deleteAuthenticatorsRequestTypeNullableToJson(
    enums.DeleteAuthenticatorsRequestType? deleteAuthenticatorsRequestType) {
  return deleteAuthenticatorsRequestType?.value;
}

String? deleteAuthenticatorsRequestTypeToJson(
    enums.DeleteAuthenticatorsRequestType deleteAuthenticatorsRequestType) {
  return deleteAuthenticatorsRequestType.value;
}

enums.DeleteAuthenticatorsRequestType deleteAuthenticatorsRequestTypeFromJson(
  Object? deleteAuthenticatorsRequestType, [
  enums.DeleteAuthenticatorsRequestType? defaultValue,
]) {
  return enums.DeleteAuthenticatorsRequestType.values.firstWhereOrNull(
          (e) => e.value == deleteAuthenticatorsRequestType) ??
      defaultValue ??
      enums.DeleteAuthenticatorsRequestType.swaggerGeneratedUnknown;
}

enums.DeleteAuthenticatorsRequestType?
    deleteAuthenticatorsRequestTypeNullableFromJson(
  Object? deleteAuthenticatorsRequestType, [
  enums.DeleteAuthenticatorsRequestType? defaultValue,
]) {
  if (deleteAuthenticatorsRequestType == null) {
    return null;
  }
  return enums.DeleteAuthenticatorsRequestType.values.firstWhereOrNull(
          (e) => e.value == deleteAuthenticatorsRequestType) ??
      defaultValue;
}

String deleteAuthenticatorsRequestTypeExplodedListToJson(
    List<enums.DeleteAuthenticatorsRequestType>?
        deleteAuthenticatorsRequestType) {
  return deleteAuthenticatorsRequestType?.map((e) => e.value!).join(',') ?? '';
}

List<String> deleteAuthenticatorsRequestTypeListToJson(
    List<enums.DeleteAuthenticatorsRequestType>?
        deleteAuthenticatorsRequestType) {
  if (deleteAuthenticatorsRequestType == null) {
    return [];
  }

  return deleteAuthenticatorsRequestType.map((e) => e.value!).toList();
}

List<enums.DeleteAuthenticatorsRequestType>
    deleteAuthenticatorsRequestTypeListFromJson(
  List? deleteAuthenticatorsRequestType, [
  List<enums.DeleteAuthenticatorsRequestType>? defaultValue,
]) {
  if (deleteAuthenticatorsRequestType == null) {
    return defaultValue ?? [];
  }

  return deleteAuthenticatorsRequestType
      .map((e) => deleteAuthenticatorsRequestTypeFromJson(e.toString()))
      .toList();
}

List<enums.DeleteAuthenticatorsRequestType>?
    deleteAuthenticatorsRequestTypeNullableListFromJson(
  List? deleteAuthenticatorsRequestType, [
  List<enums.DeleteAuthenticatorsRequestType>? defaultValue,
]) {
  if (deleteAuthenticatorsRequestType == null) {
    return defaultValue;
  }

  return deleteAuthenticatorsRequestType
      .map((e) => deleteAuthenticatorsRequestTypeFromJson(e.toString()))
      .toList();
}

String? deleteInvitationRequestTypeNullableToJson(
    enums.DeleteInvitationRequestType? deleteInvitationRequestType) {
  return deleteInvitationRequestType?.value;
}

String? deleteInvitationRequestTypeToJson(
    enums.DeleteInvitationRequestType deleteInvitationRequestType) {
  return deleteInvitationRequestType.value;
}

enums.DeleteInvitationRequestType deleteInvitationRequestTypeFromJson(
  Object? deleteInvitationRequestType, [
  enums.DeleteInvitationRequestType? defaultValue,
]) {
  return enums.DeleteInvitationRequestType.values
          .firstWhereOrNull((e) => e.value == deleteInvitationRequestType) ??
      defaultValue ??
      enums.DeleteInvitationRequestType.swaggerGeneratedUnknown;
}

enums.DeleteInvitationRequestType? deleteInvitationRequestTypeNullableFromJson(
  Object? deleteInvitationRequestType, [
  enums.DeleteInvitationRequestType? defaultValue,
]) {
  if (deleteInvitationRequestType == null) {
    return null;
  }
  return enums.DeleteInvitationRequestType.values
          .firstWhereOrNull((e) => e.value == deleteInvitationRequestType) ??
      defaultValue;
}

String deleteInvitationRequestTypeExplodedListToJson(
    List<enums.DeleteInvitationRequestType>? deleteInvitationRequestType) {
  return deleteInvitationRequestType?.map((e) => e.value!).join(',') ?? '';
}

List<String> deleteInvitationRequestTypeListToJson(
    List<enums.DeleteInvitationRequestType>? deleteInvitationRequestType) {
  if (deleteInvitationRequestType == null) {
    return [];
  }

  return deleteInvitationRequestType.map((e) => e.value!).toList();
}

List<enums.DeleteInvitationRequestType> deleteInvitationRequestTypeListFromJson(
  List? deleteInvitationRequestType, [
  List<enums.DeleteInvitationRequestType>? defaultValue,
]) {
  if (deleteInvitationRequestType == null) {
    return defaultValue ?? [];
  }

  return deleteInvitationRequestType
      .map((e) => deleteInvitationRequestTypeFromJson(e.toString()))
      .toList();
}

List<enums.DeleteInvitationRequestType>?
    deleteInvitationRequestTypeNullableListFromJson(
  List? deleteInvitationRequestType, [
  List<enums.DeleteInvitationRequestType>? defaultValue,
]) {
  if (deleteInvitationRequestType == null) {
    return defaultValue;
  }

  return deleteInvitationRequestType
      .map((e) => deleteInvitationRequestTypeFromJson(e.toString()))
      .toList();
}

String? deleteOauthProvidersRequestTypeNullableToJson(
    enums.DeleteOauthProvidersRequestType? deleteOauthProvidersRequestType) {
  return deleteOauthProvidersRequestType?.value;
}

String? deleteOauthProvidersRequestTypeToJson(
    enums.DeleteOauthProvidersRequestType deleteOauthProvidersRequestType) {
  return deleteOauthProvidersRequestType.value;
}

enums.DeleteOauthProvidersRequestType deleteOauthProvidersRequestTypeFromJson(
  Object? deleteOauthProvidersRequestType, [
  enums.DeleteOauthProvidersRequestType? defaultValue,
]) {
  return enums.DeleteOauthProvidersRequestType.values.firstWhereOrNull(
          (e) => e.value == deleteOauthProvidersRequestType) ??
      defaultValue ??
      enums.DeleteOauthProvidersRequestType.swaggerGeneratedUnknown;
}

enums.DeleteOauthProvidersRequestType?
    deleteOauthProvidersRequestTypeNullableFromJson(
  Object? deleteOauthProvidersRequestType, [
  enums.DeleteOauthProvidersRequestType? defaultValue,
]) {
  if (deleteOauthProvidersRequestType == null) {
    return null;
  }
  return enums.DeleteOauthProvidersRequestType.values.firstWhereOrNull(
          (e) => e.value == deleteOauthProvidersRequestType) ??
      defaultValue;
}

String deleteOauthProvidersRequestTypeExplodedListToJson(
    List<enums.DeleteOauthProvidersRequestType>?
        deleteOauthProvidersRequestType) {
  return deleteOauthProvidersRequestType?.map((e) => e.value!).join(',') ?? '';
}

List<String> deleteOauthProvidersRequestTypeListToJson(
    List<enums.DeleteOauthProvidersRequestType>?
        deleteOauthProvidersRequestType) {
  if (deleteOauthProvidersRequestType == null) {
    return [];
  }

  return deleteOauthProvidersRequestType.map((e) => e.value!).toList();
}

List<enums.DeleteOauthProvidersRequestType>
    deleteOauthProvidersRequestTypeListFromJson(
  List? deleteOauthProvidersRequestType, [
  List<enums.DeleteOauthProvidersRequestType>? defaultValue,
]) {
  if (deleteOauthProvidersRequestType == null) {
    return defaultValue ?? [];
  }

  return deleteOauthProvidersRequestType
      .map((e) => deleteOauthProvidersRequestTypeFromJson(e.toString()))
      .toList();
}

List<enums.DeleteOauthProvidersRequestType>?
    deleteOauthProvidersRequestTypeNullableListFromJson(
  List? deleteOauthProvidersRequestType, [
  List<enums.DeleteOauthProvidersRequestType>? defaultValue,
]) {
  if (deleteOauthProvidersRequestType == null) {
    return defaultValue;
  }

  return deleteOauthProvidersRequestType
      .map((e) => deleteOauthProvidersRequestTypeFromJson(e.toString()))
      .toList();
}

String? deletePolicyRequestTypeNullableToJson(
    enums.DeletePolicyRequestType? deletePolicyRequestType) {
  return deletePolicyRequestType?.value;
}

String? deletePolicyRequestTypeToJson(
    enums.DeletePolicyRequestType deletePolicyRequestType) {
  return deletePolicyRequestType.value;
}

enums.DeletePolicyRequestType deletePolicyRequestTypeFromJson(
  Object? deletePolicyRequestType, [
  enums.DeletePolicyRequestType? defaultValue,
]) {
  return enums.DeletePolicyRequestType.values
          .firstWhereOrNull((e) => e.value == deletePolicyRequestType) ??
      defaultValue ??
      enums.DeletePolicyRequestType.swaggerGeneratedUnknown;
}

enums.DeletePolicyRequestType? deletePolicyRequestTypeNullableFromJson(
  Object? deletePolicyRequestType, [
  enums.DeletePolicyRequestType? defaultValue,
]) {
  if (deletePolicyRequestType == null) {
    return null;
  }
  return enums.DeletePolicyRequestType.values
          .firstWhereOrNull((e) => e.value == deletePolicyRequestType) ??
      defaultValue;
}

String deletePolicyRequestTypeExplodedListToJson(
    List<enums.DeletePolicyRequestType>? deletePolicyRequestType) {
  return deletePolicyRequestType?.map((e) => e.value!).join(',') ?? '';
}

List<String> deletePolicyRequestTypeListToJson(
    List<enums.DeletePolicyRequestType>? deletePolicyRequestType) {
  if (deletePolicyRequestType == null) {
    return [];
  }

  return deletePolicyRequestType.map((e) => e.value!).toList();
}

List<enums.DeletePolicyRequestType> deletePolicyRequestTypeListFromJson(
  List? deletePolicyRequestType, [
  List<enums.DeletePolicyRequestType>? defaultValue,
]) {
  if (deletePolicyRequestType == null) {
    return defaultValue ?? [];
  }

  return deletePolicyRequestType
      .map((e) => deletePolicyRequestTypeFromJson(e.toString()))
      .toList();
}

List<enums.DeletePolicyRequestType>?
    deletePolicyRequestTypeNullableListFromJson(
  List? deletePolicyRequestType, [
  List<enums.DeletePolicyRequestType>? defaultValue,
]) {
  if (deletePolicyRequestType == null) {
    return defaultValue;
  }

  return deletePolicyRequestType
      .map((e) => deletePolicyRequestTypeFromJson(e.toString()))
      .toList();
}

String? deletePrivateKeyTagsRequestTypeNullableToJson(
    enums.DeletePrivateKeyTagsRequestType? deletePrivateKeyTagsRequestType) {
  return deletePrivateKeyTagsRequestType?.value;
}

String? deletePrivateKeyTagsRequestTypeToJson(
    enums.DeletePrivateKeyTagsRequestType deletePrivateKeyTagsRequestType) {
  return deletePrivateKeyTagsRequestType.value;
}

enums.DeletePrivateKeyTagsRequestType deletePrivateKeyTagsRequestTypeFromJson(
  Object? deletePrivateKeyTagsRequestType, [
  enums.DeletePrivateKeyTagsRequestType? defaultValue,
]) {
  return enums.DeletePrivateKeyTagsRequestType.values.firstWhereOrNull(
          (e) => e.value == deletePrivateKeyTagsRequestType) ??
      defaultValue ??
      enums.DeletePrivateKeyTagsRequestType.swaggerGeneratedUnknown;
}

enums.DeletePrivateKeyTagsRequestType?
    deletePrivateKeyTagsRequestTypeNullableFromJson(
  Object? deletePrivateKeyTagsRequestType, [
  enums.DeletePrivateKeyTagsRequestType? defaultValue,
]) {
  if (deletePrivateKeyTagsRequestType == null) {
    return null;
  }
  return enums.DeletePrivateKeyTagsRequestType.values.firstWhereOrNull(
          (e) => e.value == deletePrivateKeyTagsRequestType) ??
      defaultValue;
}

String deletePrivateKeyTagsRequestTypeExplodedListToJson(
    List<enums.DeletePrivateKeyTagsRequestType>?
        deletePrivateKeyTagsRequestType) {
  return deletePrivateKeyTagsRequestType?.map((e) => e.value!).join(',') ?? '';
}

List<String> deletePrivateKeyTagsRequestTypeListToJson(
    List<enums.DeletePrivateKeyTagsRequestType>?
        deletePrivateKeyTagsRequestType) {
  if (deletePrivateKeyTagsRequestType == null) {
    return [];
  }

  return deletePrivateKeyTagsRequestType.map((e) => e.value!).toList();
}

List<enums.DeletePrivateKeyTagsRequestType>
    deletePrivateKeyTagsRequestTypeListFromJson(
  List? deletePrivateKeyTagsRequestType, [
  List<enums.DeletePrivateKeyTagsRequestType>? defaultValue,
]) {
  if (deletePrivateKeyTagsRequestType == null) {
    return defaultValue ?? [];
  }

  return deletePrivateKeyTagsRequestType
      .map((e) => deletePrivateKeyTagsRequestTypeFromJson(e.toString()))
      .toList();
}

List<enums.DeletePrivateKeyTagsRequestType>?
    deletePrivateKeyTagsRequestTypeNullableListFromJson(
  List? deletePrivateKeyTagsRequestType, [
  List<enums.DeletePrivateKeyTagsRequestType>? defaultValue,
]) {
  if (deletePrivateKeyTagsRequestType == null) {
    return defaultValue;
  }

  return deletePrivateKeyTagsRequestType
      .map((e) => deletePrivateKeyTagsRequestTypeFromJson(e.toString()))
      .toList();
}

String? deletePrivateKeysRequestTypeNullableToJson(
    enums.DeletePrivateKeysRequestType? deletePrivateKeysRequestType) {
  return deletePrivateKeysRequestType?.value;
}

String? deletePrivateKeysRequestTypeToJson(
    enums.DeletePrivateKeysRequestType deletePrivateKeysRequestType) {
  return deletePrivateKeysRequestType.value;
}

enums.DeletePrivateKeysRequestType deletePrivateKeysRequestTypeFromJson(
  Object? deletePrivateKeysRequestType, [
  enums.DeletePrivateKeysRequestType? defaultValue,
]) {
  return enums.DeletePrivateKeysRequestType.values
          .firstWhereOrNull((e) => e.value == deletePrivateKeysRequestType) ??
      defaultValue ??
      enums.DeletePrivateKeysRequestType.swaggerGeneratedUnknown;
}

enums.DeletePrivateKeysRequestType?
    deletePrivateKeysRequestTypeNullableFromJson(
  Object? deletePrivateKeysRequestType, [
  enums.DeletePrivateKeysRequestType? defaultValue,
]) {
  if (deletePrivateKeysRequestType == null) {
    return null;
  }
  return enums.DeletePrivateKeysRequestType.values
          .firstWhereOrNull((e) => e.value == deletePrivateKeysRequestType) ??
      defaultValue;
}

String deletePrivateKeysRequestTypeExplodedListToJson(
    List<enums.DeletePrivateKeysRequestType>? deletePrivateKeysRequestType) {
  return deletePrivateKeysRequestType?.map((e) => e.value!).join(',') ?? '';
}

List<String> deletePrivateKeysRequestTypeListToJson(
    List<enums.DeletePrivateKeysRequestType>? deletePrivateKeysRequestType) {
  if (deletePrivateKeysRequestType == null) {
    return [];
  }

  return deletePrivateKeysRequestType.map((e) => e.value!).toList();
}

List<enums.DeletePrivateKeysRequestType>
    deletePrivateKeysRequestTypeListFromJson(
  List? deletePrivateKeysRequestType, [
  List<enums.DeletePrivateKeysRequestType>? defaultValue,
]) {
  if (deletePrivateKeysRequestType == null) {
    return defaultValue ?? [];
  }

  return deletePrivateKeysRequestType
      .map((e) => deletePrivateKeysRequestTypeFromJson(e.toString()))
      .toList();
}

List<enums.DeletePrivateKeysRequestType>?
    deletePrivateKeysRequestTypeNullableListFromJson(
  List? deletePrivateKeysRequestType, [
  List<enums.DeletePrivateKeysRequestType>? defaultValue,
]) {
  if (deletePrivateKeysRequestType == null) {
    return defaultValue;
  }

  return deletePrivateKeysRequestType
      .map((e) => deletePrivateKeysRequestTypeFromJson(e.toString()))
      .toList();
}

String? deleteSmartContractInterfaceRequestTypeNullableToJson(
    enums.DeleteSmartContractInterfaceRequestType?
        deleteSmartContractInterfaceRequestType) {
  return deleteSmartContractInterfaceRequestType?.value;
}

String? deleteSmartContractInterfaceRequestTypeToJson(
    enums.DeleteSmartContractInterfaceRequestType
        deleteSmartContractInterfaceRequestType) {
  return deleteSmartContractInterfaceRequestType.value;
}

enums.DeleteSmartContractInterfaceRequestType
    deleteSmartContractInterfaceRequestTypeFromJson(
  Object? deleteSmartContractInterfaceRequestType, [
  enums.DeleteSmartContractInterfaceRequestType? defaultValue,
]) {
  return enums.DeleteSmartContractInterfaceRequestType.values.firstWhereOrNull(
          (e) => e.value == deleteSmartContractInterfaceRequestType) ??
      defaultValue ??
      enums.DeleteSmartContractInterfaceRequestType.swaggerGeneratedUnknown;
}

enums.DeleteSmartContractInterfaceRequestType?
    deleteSmartContractInterfaceRequestTypeNullableFromJson(
  Object? deleteSmartContractInterfaceRequestType, [
  enums.DeleteSmartContractInterfaceRequestType? defaultValue,
]) {
  if (deleteSmartContractInterfaceRequestType == null) {
    return null;
  }
  return enums.DeleteSmartContractInterfaceRequestType.values.firstWhereOrNull(
          (e) => e.value == deleteSmartContractInterfaceRequestType) ??
      defaultValue;
}

String deleteSmartContractInterfaceRequestTypeExplodedListToJson(
    List<enums.DeleteSmartContractInterfaceRequestType>?
        deleteSmartContractInterfaceRequestType) {
  return deleteSmartContractInterfaceRequestType
          ?.map((e) => e.value!)
          .join(',') ??
      '';
}

List<String> deleteSmartContractInterfaceRequestTypeListToJson(
    List<enums.DeleteSmartContractInterfaceRequestType>?
        deleteSmartContractInterfaceRequestType) {
  if (deleteSmartContractInterfaceRequestType == null) {
    return [];
  }

  return deleteSmartContractInterfaceRequestType.map((e) => e.value!).toList();
}

List<enums.DeleteSmartContractInterfaceRequestType>
    deleteSmartContractInterfaceRequestTypeListFromJson(
  List? deleteSmartContractInterfaceRequestType, [
  List<enums.DeleteSmartContractInterfaceRequestType>? defaultValue,
]) {
  if (deleteSmartContractInterfaceRequestType == null) {
    return defaultValue ?? [];
  }

  return deleteSmartContractInterfaceRequestType
      .map((e) => deleteSmartContractInterfaceRequestTypeFromJson(e.toString()))
      .toList();
}

List<enums.DeleteSmartContractInterfaceRequestType>?
    deleteSmartContractInterfaceRequestTypeNullableListFromJson(
  List? deleteSmartContractInterfaceRequestType, [
  List<enums.DeleteSmartContractInterfaceRequestType>? defaultValue,
]) {
  if (deleteSmartContractInterfaceRequestType == null) {
    return defaultValue;
  }

  return deleteSmartContractInterfaceRequestType
      .map((e) => deleteSmartContractInterfaceRequestTypeFromJson(e.toString()))
      .toList();
}

String? deleteSubOrganizationRequestTypeNullableToJson(
    enums.DeleteSubOrganizationRequestType? deleteSubOrganizationRequestType) {
  return deleteSubOrganizationRequestType?.value;
}

String? deleteSubOrganizationRequestTypeToJson(
    enums.DeleteSubOrganizationRequestType deleteSubOrganizationRequestType) {
  return deleteSubOrganizationRequestType.value;
}

enums.DeleteSubOrganizationRequestType deleteSubOrganizationRequestTypeFromJson(
  Object? deleteSubOrganizationRequestType, [
  enums.DeleteSubOrganizationRequestType? defaultValue,
]) {
  return enums.DeleteSubOrganizationRequestType.values.firstWhereOrNull(
          (e) => e.value == deleteSubOrganizationRequestType) ??
      defaultValue ??
      enums.DeleteSubOrganizationRequestType.swaggerGeneratedUnknown;
}

enums.DeleteSubOrganizationRequestType?
    deleteSubOrganizationRequestTypeNullableFromJson(
  Object? deleteSubOrganizationRequestType, [
  enums.DeleteSubOrganizationRequestType? defaultValue,
]) {
  if (deleteSubOrganizationRequestType == null) {
    return null;
  }
  return enums.DeleteSubOrganizationRequestType.values.firstWhereOrNull(
          (e) => e.value == deleteSubOrganizationRequestType) ??
      defaultValue;
}

String deleteSubOrganizationRequestTypeExplodedListToJson(
    List<enums.DeleteSubOrganizationRequestType>?
        deleteSubOrganizationRequestType) {
  return deleteSubOrganizationRequestType?.map((e) => e.value!).join(',') ?? '';
}

List<String> deleteSubOrganizationRequestTypeListToJson(
    List<enums.DeleteSubOrganizationRequestType>?
        deleteSubOrganizationRequestType) {
  if (deleteSubOrganizationRequestType == null) {
    return [];
  }

  return deleteSubOrganizationRequestType.map((e) => e.value!).toList();
}

List<enums.DeleteSubOrganizationRequestType>
    deleteSubOrganizationRequestTypeListFromJson(
  List? deleteSubOrganizationRequestType, [
  List<enums.DeleteSubOrganizationRequestType>? defaultValue,
]) {
  if (deleteSubOrganizationRequestType == null) {
    return defaultValue ?? [];
  }

  return deleteSubOrganizationRequestType
      .map((e) => deleteSubOrganizationRequestTypeFromJson(e.toString()))
      .toList();
}

List<enums.DeleteSubOrganizationRequestType>?
    deleteSubOrganizationRequestTypeNullableListFromJson(
  List? deleteSubOrganizationRequestType, [
  List<enums.DeleteSubOrganizationRequestType>? defaultValue,
]) {
  if (deleteSubOrganizationRequestType == null) {
    return defaultValue;
  }

  return deleteSubOrganizationRequestType
      .map((e) => deleteSubOrganizationRequestTypeFromJson(e.toString()))
      .toList();
}

String? deleteUserTagsRequestTypeNullableToJson(
    enums.DeleteUserTagsRequestType? deleteUserTagsRequestType) {
  return deleteUserTagsRequestType?.value;
}

String? deleteUserTagsRequestTypeToJson(
    enums.DeleteUserTagsRequestType deleteUserTagsRequestType) {
  return deleteUserTagsRequestType.value;
}

enums.DeleteUserTagsRequestType deleteUserTagsRequestTypeFromJson(
  Object? deleteUserTagsRequestType, [
  enums.DeleteUserTagsRequestType? defaultValue,
]) {
  return enums.DeleteUserTagsRequestType.values
          .firstWhereOrNull((e) => e.value == deleteUserTagsRequestType) ??
      defaultValue ??
      enums.DeleteUserTagsRequestType.swaggerGeneratedUnknown;
}

enums.DeleteUserTagsRequestType? deleteUserTagsRequestTypeNullableFromJson(
  Object? deleteUserTagsRequestType, [
  enums.DeleteUserTagsRequestType? defaultValue,
]) {
  if (deleteUserTagsRequestType == null) {
    return null;
  }
  return enums.DeleteUserTagsRequestType.values
          .firstWhereOrNull((e) => e.value == deleteUserTagsRequestType) ??
      defaultValue;
}

String deleteUserTagsRequestTypeExplodedListToJson(
    List<enums.DeleteUserTagsRequestType>? deleteUserTagsRequestType) {
  return deleteUserTagsRequestType?.map((e) => e.value!).join(',') ?? '';
}

List<String> deleteUserTagsRequestTypeListToJson(
    List<enums.DeleteUserTagsRequestType>? deleteUserTagsRequestType) {
  if (deleteUserTagsRequestType == null) {
    return [];
  }

  return deleteUserTagsRequestType.map((e) => e.value!).toList();
}

List<enums.DeleteUserTagsRequestType> deleteUserTagsRequestTypeListFromJson(
  List? deleteUserTagsRequestType, [
  List<enums.DeleteUserTagsRequestType>? defaultValue,
]) {
  if (deleteUserTagsRequestType == null) {
    return defaultValue ?? [];
  }

  return deleteUserTagsRequestType
      .map((e) => deleteUserTagsRequestTypeFromJson(e.toString()))
      .toList();
}

List<enums.DeleteUserTagsRequestType>?
    deleteUserTagsRequestTypeNullableListFromJson(
  List? deleteUserTagsRequestType, [
  List<enums.DeleteUserTagsRequestType>? defaultValue,
]) {
  if (deleteUserTagsRequestType == null) {
    return defaultValue;
  }

  return deleteUserTagsRequestType
      .map((e) => deleteUserTagsRequestTypeFromJson(e.toString()))
      .toList();
}

String? deleteUsersRequestTypeNullableToJson(
    enums.DeleteUsersRequestType? deleteUsersRequestType) {
  return deleteUsersRequestType?.value;
}

String? deleteUsersRequestTypeToJson(
    enums.DeleteUsersRequestType deleteUsersRequestType) {
  return deleteUsersRequestType.value;
}

enums.DeleteUsersRequestType deleteUsersRequestTypeFromJson(
  Object? deleteUsersRequestType, [
  enums.DeleteUsersRequestType? defaultValue,
]) {
  return enums.DeleteUsersRequestType.values
          .firstWhereOrNull((e) => e.value == deleteUsersRequestType) ??
      defaultValue ??
      enums.DeleteUsersRequestType.swaggerGeneratedUnknown;
}

enums.DeleteUsersRequestType? deleteUsersRequestTypeNullableFromJson(
  Object? deleteUsersRequestType, [
  enums.DeleteUsersRequestType? defaultValue,
]) {
  if (deleteUsersRequestType == null) {
    return null;
  }
  return enums.DeleteUsersRequestType.values
          .firstWhereOrNull((e) => e.value == deleteUsersRequestType) ??
      defaultValue;
}

String deleteUsersRequestTypeExplodedListToJson(
    List<enums.DeleteUsersRequestType>? deleteUsersRequestType) {
  return deleteUsersRequestType?.map((e) => e.value!).join(',') ?? '';
}

List<String> deleteUsersRequestTypeListToJson(
    List<enums.DeleteUsersRequestType>? deleteUsersRequestType) {
  if (deleteUsersRequestType == null) {
    return [];
  }

  return deleteUsersRequestType.map((e) => e.value!).toList();
}

List<enums.DeleteUsersRequestType> deleteUsersRequestTypeListFromJson(
  List? deleteUsersRequestType, [
  List<enums.DeleteUsersRequestType>? defaultValue,
]) {
  if (deleteUsersRequestType == null) {
    return defaultValue ?? [];
  }

  return deleteUsersRequestType
      .map((e) => deleteUsersRequestTypeFromJson(e.toString()))
      .toList();
}

List<enums.DeleteUsersRequestType>? deleteUsersRequestTypeNullableListFromJson(
  List? deleteUsersRequestType, [
  List<enums.DeleteUsersRequestType>? defaultValue,
]) {
  if (deleteUsersRequestType == null) {
    return defaultValue;
  }

  return deleteUsersRequestType
      .map((e) => deleteUsersRequestTypeFromJson(e.toString()))
      .toList();
}

String? deleteWalletsRequestTypeNullableToJson(
    enums.DeleteWalletsRequestType? deleteWalletsRequestType) {
  return deleteWalletsRequestType?.value;
}

String? deleteWalletsRequestTypeToJson(
    enums.DeleteWalletsRequestType deleteWalletsRequestType) {
  return deleteWalletsRequestType.value;
}

enums.DeleteWalletsRequestType deleteWalletsRequestTypeFromJson(
  Object? deleteWalletsRequestType, [
  enums.DeleteWalletsRequestType? defaultValue,
]) {
  return enums.DeleteWalletsRequestType.values
          .firstWhereOrNull((e) => e.value == deleteWalletsRequestType) ??
      defaultValue ??
      enums.DeleteWalletsRequestType.swaggerGeneratedUnknown;
}

enums.DeleteWalletsRequestType? deleteWalletsRequestTypeNullableFromJson(
  Object? deleteWalletsRequestType, [
  enums.DeleteWalletsRequestType? defaultValue,
]) {
  if (deleteWalletsRequestType == null) {
    return null;
  }
  return enums.DeleteWalletsRequestType.values
          .firstWhereOrNull((e) => e.value == deleteWalletsRequestType) ??
      defaultValue;
}

String deleteWalletsRequestTypeExplodedListToJson(
    List<enums.DeleteWalletsRequestType>? deleteWalletsRequestType) {
  return deleteWalletsRequestType?.map((e) => e.value!).join(',') ?? '';
}

List<String> deleteWalletsRequestTypeListToJson(
    List<enums.DeleteWalletsRequestType>? deleteWalletsRequestType) {
  if (deleteWalletsRequestType == null) {
    return [];
  }

  return deleteWalletsRequestType.map((e) => e.value!).toList();
}

List<enums.DeleteWalletsRequestType> deleteWalletsRequestTypeListFromJson(
  List? deleteWalletsRequestType, [
  List<enums.DeleteWalletsRequestType>? defaultValue,
]) {
  if (deleteWalletsRequestType == null) {
    return defaultValue ?? [];
  }

  return deleteWalletsRequestType
      .map((e) => deleteWalletsRequestTypeFromJson(e.toString()))
      .toList();
}

List<enums.DeleteWalletsRequestType>?
    deleteWalletsRequestTypeNullableListFromJson(
  List? deleteWalletsRequestType, [
  List<enums.DeleteWalletsRequestType>? defaultValue,
]) {
  if (deleteWalletsRequestType == null) {
    return defaultValue;
  }

  return deleteWalletsRequestType
      .map((e) => deleteWalletsRequestTypeFromJson(e.toString()))
      .toList();
}

String? effectNullableToJson(enums.Effect? effect) {
  return effect?.value;
}

String? effectToJson(enums.Effect effect) {
  return effect.value;
}

enums.Effect effectFromJson(
  Object? effect, [
  enums.Effect? defaultValue,
]) {
  return enums.Effect.values.firstWhereOrNull((e) => e.value == effect) ??
      defaultValue ??
      enums.Effect.swaggerGeneratedUnknown;
}

enums.Effect? effectNullableFromJson(
  Object? effect, [
  enums.Effect? defaultValue,
]) {
  if (effect == null) {
    return null;
  }
  return enums.Effect.values.firstWhereOrNull((e) => e.value == effect) ??
      defaultValue;
}

String effectExplodedListToJson(List<enums.Effect>? effect) {
  return effect?.map((e) => e.value!).join(',') ?? '';
}

List<String> effectListToJson(List<enums.Effect>? effect) {
  if (effect == null) {
    return [];
  }

  return effect.map((e) => e.value!).toList();
}

List<enums.Effect> effectListFromJson(
  List? effect, [
  List<enums.Effect>? defaultValue,
]) {
  if (effect == null) {
    return defaultValue ?? [];
  }

  return effect.map((e) => effectFromJson(e.toString())).toList();
}

List<enums.Effect>? effectNullableListFromJson(
  List? effect, [
  List<enums.Effect>? defaultValue,
]) {
  if (effect == null) {
    return defaultValue;
  }

  return effect.map((e) => effectFromJson(e.toString())).toList();
}

String? emailAuthRequestTypeNullableToJson(
    enums.EmailAuthRequestType? emailAuthRequestType) {
  return emailAuthRequestType?.value;
}

String? emailAuthRequestTypeToJson(
    enums.EmailAuthRequestType emailAuthRequestType) {
  return emailAuthRequestType.value;
}

enums.EmailAuthRequestType emailAuthRequestTypeFromJson(
  Object? emailAuthRequestType, [
  enums.EmailAuthRequestType? defaultValue,
]) {
  return enums.EmailAuthRequestType.values
          .firstWhereOrNull((e) => e.value == emailAuthRequestType) ??
      defaultValue ??
      enums.EmailAuthRequestType.swaggerGeneratedUnknown;
}

enums.EmailAuthRequestType? emailAuthRequestTypeNullableFromJson(
  Object? emailAuthRequestType, [
  enums.EmailAuthRequestType? defaultValue,
]) {
  if (emailAuthRequestType == null) {
    return null;
  }
  return enums.EmailAuthRequestType.values
          .firstWhereOrNull((e) => e.value == emailAuthRequestType) ??
      defaultValue;
}

String emailAuthRequestTypeExplodedListToJson(
    List<enums.EmailAuthRequestType>? emailAuthRequestType) {
  return emailAuthRequestType?.map((e) => e.value!).join(',') ?? '';
}

List<String> emailAuthRequestTypeListToJson(
    List<enums.EmailAuthRequestType>? emailAuthRequestType) {
  if (emailAuthRequestType == null) {
    return [];
  }

  return emailAuthRequestType.map((e) => e.value!).toList();
}

List<enums.EmailAuthRequestType> emailAuthRequestTypeListFromJson(
  List? emailAuthRequestType, [
  List<enums.EmailAuthRequestType>? defaultValue,
]) {
  if (emailAuthRequestType == null) {
    return defaultValue ?? [];
  }

  return emailAuthRequestType
      .map((e) => emailAuthRequestTypeFromJson(e.toString()))
      .toList();
}

List<enums.EmailAuthRequestType>? emailAuthRequestTypeNullableListFromJson(
  List? emailAuthRequestType, [
  List<enums.EmailAuthRequestType>? defaultValue,
]) {
  if (emailAuthRequestType == null) {
    return defaultValue;
  }

  return emailAuthRequestType
      .map((e) => emailAuthRequestTypeFromJson(e.toString()))
      .toList();
}

String? exportPrivateKeyRequestTypeNullableToJson(
    enums.ExportPrivateKeyRequestType? exportPrivateKeyRequestType) {
  return exportPrivateKeyRequestType?.value;
}

String? exportPrivateKeyRequestTypeToJson(
    enums.ExportPrivateKeyRequestType exportPrivateKeyRequestType) {
  return exportPrivateKeyRequestType.value;
}

enums.ExportPrivateKeyRequestType exportPrivateKeyRequestTypeFromJson(
  Object? exportPrivateKeyRequestType, [
  enums.ExportPrivateKeyRequestType? defaultValue,
]) {
  return enums.ExportPrivateKeyRequestType.values
          .firstWhereOrNull((e) => e.value == exportPrivateKeyRequestType) ??
      defaultValue ??
      enums.ExportPrivateKeyRequestType.swaggerGeneratedUnknown;
}

enums.ExportPrivateKeyRequestType? exportPrivateKeyRequestTypeNullableFromJson(
  Object? exportPrivateKeyRequestType, [
  enums.ExportPrivateKeyRequestType? defaultValue,
]) {
  if (exportPrivateKeyRequestType == null) {
    return null;
  }
  return enums.ExportPrivateKeyRequestType.values
          .firstWhereOrNull((e) => e.value == exportPrivateKeyRequestType) ??
      defaultValue;
}

String exportPrivateKeyRequestTypeExplodedListToJson(
    List<enums.ExportPrivateKeyRequestType>? exportPrivateKeyRequestType) {
  return exportPrivateKeyRequestType?.map((e) => e.value!).join(',') ?? '';
}

List<String> exportPrivateKeyRequestTypeListToJson(
    List<enums.ExportPrivateKeyRequestType>? exportPrivateKeyRequestType) {
  if (exportPrivateKeyRequestType == null) {
    return [];
  }

  return exportPrivateKeyRequestType.map((e) => e.value!).toList();
}

List<enums.ExportPrivateKeyRequestType> exportPrivateKeyRequestTypeListFromJson(
  List? exportPrivateKeyRequestType, [
  List<enums.ExportPrivateKeyRequestType>? defaultValue,
]) {
  if (exportPrivateKeyRequestType == null) {
    return defaultValue ?? [];
  }

  return exportPrivateKeyRequestType
      .map((e) => exportPrivateKeyRequestTypeFromJson(e.toString()))
      .toList();
}

List<enums.ExportPrivateKeyRequestType>?
    exportPrivateKeyRequestTypeNullableListFromJson(
  List? exportPrivateKeyRequestType, [
  List<enums.ExportPrivateKeyRequestType>? defaultValue,
]) {
  if (exportPrivateKeyRequestType == null) {
    return defaultValue;
  }

  return exportPrivateKeyRequestType
      .map((e) => exportPrivateKeyRequestTypeFromJson(e.toString()))
      .toList();
}

String? exportWalletAccountRequestTypeNullableToJson(
    enums.ExportWalletAccountRequestType? exportWalletAccountRequestType) {
  return exportWalletAccountRequestType?.value;
}

String? exportWalletAccountRequestTypeToJson(
    enums.ExportWalletAccountRequestType exportWalletAccountRequestType) {
  return exportWalletAccountRequestType.value;
}

enums.ExportWalletAccountRequestType exportWalletAccountRequestTypeFromJson(
  Object? exportWalletAccountRequestType, [
  enums.ExportWalletAccountRequestType? defaultValue,
]) {
  return enums.ExportWalletAccountRequestType.values
          .firstWhereOrNull((e) => e.value == exportWalletAccountRequestType) ??
      defaultValue ??
      enums.ExportWalletAccountRequestType.swaggerGeneratedUnknown;
}

enums.ExportWalletAccountRequestType?
    exportWalletAccountRequestTypeNullableFromJson(
  Object? exportWalletAccountRequestType, [
  enums.ExportWalletAccountRequestType? defaultValue,
]) {
  if (exportWalletAccountRequestType == null) {
    return null;
  }
  return enums.ExportWalletAccountRequestType.values
          .firstWhereOrNull((e) => e.value == exportWalletAccountRequestType) ??
      defaultValue;
}

String exportWalletAccountRequestTypeExplodedListToJson(
    List<enums.ExportWalletAccountRequestType>?
        exportWalletAccountRequestType) {
  return exportWalletAccountRequestType?.map((e) => e.value!).join(',') ?? '';
}

List<String> exportWalletAccountRequestTypeListToJson(
    List<enums.ExportWalletAccountRequestType>?
        exportWalletAccountRequestType) {
  if (exportWalletAccountRequestType == null) {
    return [];
  }

  return exportWalletAccountRequestType.map((e) => e.value!).toList();
}

List<enums.ExportWalletAccountRequestType>
    exportWalletAccountRequestTypeListFromJson(
  List? exportWalletAccountRequestType, [
  List<enums.ExportWalletAccountRequestType>? defaultValue,
]) {
  if (exportWalletAccountRequestType == null) {
    return defaultValue ?? [];
  }

  return exportWalletAccountRequestType
      .map((e) => exportWalletAccountRequestTypeFromJson(e.toString()))
      .toList();
}

List<enums.ExportWalletAccountRequestType>?
    exportWalletAccountRequestTypeNullableListFromJson(
  List? exportWalletAccountRequestType, [
  List<enums.ExportWalletAccountRequestType>? defaultValue,
]) {
  if (exportWalletAccountRequestType == null) {
    return defaultValue;
  }

  return exportWalletAccountRequestType
      .map((e) => exportWalletAccountRequestTypeFromJson(e.toString()))
      .toList();
}

String? exportWalletRequestTypeNullableToJson(
    enums.ExportWalletRequestType? exportWalletRequestType) {
  return exportWalletRequestType?.value;
}

String? exportWalletRequestTypeToJson(
    enums.ExportWalletRequestType exportWalletRequestType) {
  return exportWalletRequestType.value;
}

enums.ExportWalletRequestType exportWalletRequestTypeFromJson(
  Object? exportWalletRequestType, [
  enums.ExportWalletRequestType? defaultValue,
]) {
  return enums.ExportWalletRequestType.values
          .firstWhereOrNull((e) => e.value == exportWalletRequestType) ??
      defaultValue ??
      enums.ExportWalletRequestType.swaggerGeneratedUnknown;
}

enums.ExportWalletRequestType? exportWalletRequestTypeNullableFromJson(
  Object? exportWalletRequestType, [
  enums.ExportWalletRequestType? defaultValue,
]) {
  if (exportWalletRequestType == null) {
    return null;
  }
  return enums.ExportWalletRequestType.values
          .firstWhereOrNull((e) => e.value == exportWalletRequestType) ??
      defaultValue;
}

String exportWalletRequestTypeExplodedListToJson(
    List<enums.ExportWalletRequestType>? exportWalletRequestType) {
  return exportWalletRequestType?.map((e) => e.value!).join(',') ?? '';
}

List<String> exportWalletRequestTypeListToJson(
    List<enums.ExportWalletRequestType>? exportWalletRequestType) {
  if (exportWalletRequestType == null) {
    return [];
  }

  return exportWalletRequestType.map((e) => e.value!).toList();
}

List<enums.ExportWalletRequestType> exportWalletRequestTypeListFromJson(
  List? exportWalletRequestType, [
  List<enums.ExportWalletRequestType>? defaultValue,
]) {
  if (exportWalletRequestType == null) {
    return defaultValue ?? [];
  }

  return exportWalletRequestType
      .map((e) => exportWalletRequestTypeFromJson(e.toString()))
      .toList();
}

List<enums.ExportWalletRequestType>?
    exportWalletRequestTypeNullableListFromJson(
  List? exportWalletRequestType, [
  List<enums.ExportWalletRequestType>? defaultValue,
]) {
  if (exportWalletRequestType == null) {
    return defaultValue;
  }

  return exportWalletRequestType
      .map((e) => exportWalletRequestTypeFromJson(e.toString()))
      .toList();
}

String? featureNameNullableToJson(enums.FeatureName? featureName) {
  return featureName?.value;
}

String? featureNameToJson(enums.FeatureName featureName) {
  return featureName.value;
}

enums.FeatureName featureNameFromJson(
  Object? featureName, [
  enums.FeatureName? defaultValue,
]) {
  return enums.FeatureName.values
          .firstWhereOrNull((e) => e.value == featureName) ??
      defaultValue ??
      enums.FeatureName.swaggerGeneratedUnknown;
}

enums.FeatureName? featureNameNullableFromJson(
  Object? featureName, [
  enums.FeatureName? defaultValue,
]) {
  if (featureName == null) {
    return null;
  }
  return enums.FeatureName.values
          .firstWhereOrNull((e) => e.value == featureName) ??
      defaultValue;
}

String featureNameExplodedListToJson(List<enums.FeatureName>? featureName) {
  return featureName?.map((e) => e.value!).join(',') ?? '';
}

List<String> featureNameListToJson(List<enums.FeatureName>? featureName) {
  if (featureName == null) {
    return [];
  }

  return featureName.map((e) => e.value!).toList();
}

List<enums.FeatureName> featureNameListFromJson(
  List? featureName, [
  List<enums.FeatureName>? defaultValue,
]) {
  if (featureName == null) {
    return defaultValue ?? [];
  }

  return featureName.map((e) => featureNameFromJson(e.toString())).toList();
}

List<enums.FeatureName>? featureNameNullableListFromJson(
  List? featureName, [
  List<enums.FeatureName>? defaultValue,
]) {
  if (featureName == null) {
    return defaultValue;
  }

  return featureName.map((e) => featureNameFromJson(e.toString())).toList();
}

String? fiatOnRampBlockchainNetworkNullableToJson(
    enums.FiatOnRampBlockchainNetwork? fiatOnRampBlockchainNetwork) {
  return fiatOnRampBlockchainNetwork?.value;
}

String? fiatOnRampBlockchainNetworkToJson(
    enums.FiatOnRampBlockchainNetwork fiatOnRampBlockchainNetwork) {
  return fiatOnRampBlockchainNetwork.value;
}

enums.FiatOnRampBlockchainNetwork fiatOnRampBlockchainNetworkFromJson(
  Object? fiatOnRampBlockchainNetwork, [
  enums.FiatOnRampBlockchainNetwork? defaultValue,
]) {
  return enums.FiatOnRampBlockchainNetwork.values
          .firstWhereOrNull((e) => e.value == fiatOnRampBlockchainNetwork) ??
      defaultValue ??
      enums.FiatOnRampBlockchainNetwork.swaggerGeneratedUnknown;
}

enums.FiatOnRampBlockchainNetwork? fiatOnRampBlockchainNetworkNullableFromJson(
  Object? fiatOnRampBlockchainNetwork, [
  enums.FiatOnRampBlockchainNetwork? defaultValue,
]) {
  if (fiatOnRampBlockchainNetwork == null) {
    return null;
  }
  return enums.FiatOnRampBlockchainNetwork.values
          .firstWhereOrNull((e) => e.value == fiatOnRampBlockchainNetwork) ??
      defaultValue;
}

String fiatOnRampBlockchainNetworkExplodedListToJson(
    List<enums.FiatOnRampBlockchainNetwork>? fiatOnRampBlockchainNetwork) {
  return fiatOnRampBlockchainNetwork?.map((e) => e.value!).join(',') ?? '';
}

List<String> fiatOnRampBlockchainNetworkListToJson(
    List<enums.FiatOnRampBlockchainNetwork>? fiatOnRampBlockchainNetwork) {
  if (fiatOnRampBlockchainNetwork == null) {
    return [];
  }

  return fiatOnRampBlockchainNetwork.map((e) => e.value!).toList();
}

List<enums.FiatOnRampBlockchainNetwork> fiatOnRampBlockchainNetworkListFromJson(
  List? fiatOnRampBlockchainNetwork, [
  List<enums.FiatOnRampBlockchainNetwork>? defaultValue,
]) {
  if (fiatOnRampBlockchainNetwork == null) {
    return defaultValue ?? [];
  }

  return fiatOnRampBlockchainNetwork
      .map((e) => fiatOnRampBlockchainNetworkFromJson(e.toString()))
      .toList();
}

List<enums.FiatOnRampBlockchainNetwork>?
    fiatOnRampBlockchainNetworkNullableListFromJson(
  List? fiatOnRampBlockchainNetwork, [
  List<enums.FiatOnRampBlockchainNetwork>? defaultValue,
]) {
  if (fiatOnRampBlockchainNetwork == null) {
    return defaultValue;
  }

  return fiatOnRampBlockchainNetwork
      .map((e) => fiatOnRampBlockchainNetworkFromJson(e.toString()))
      .toList();
}

String? fiatOnRampCryptoCurrencyNullableToJson(
    enums.FiatOnRampCryptoCurrency? fiatOnRampCryptoCurrency) {
  return fiatOnRampCryptoCurrency?.value;
}

String? fiatOnRampCryptoCurrencyToJson(
    enums.FiatOnRampCryptoCurrency fiatOnRampCryptoCurrency) {
  return fiatOnRampCryptoCurrency.value;
}

enums.FiatOnRampCryptoCurrency fiatOnRampCryptoCurrencyFromJson(
  Object? fiatOnRampCryptoCurrency, [
  enums.FiatOnRampCryptoCurrency? defaultValue,
]) {
  return enums.FiatOnRampCryptoCurrency.values
          .firstWhereOrNull((e) => e.value == fiatOnRampCryptoCurrency) ??
      defaultValue ??
      enums.FiatOnRampCryptoCurrency.swaggerGeneratedUnknown;
}

enums.FiatOnRampCryptoCurrency? fiatOnRampCryptoCurrencyNullableFromJson(
  Object? fiatOnRampCryptoCurrency, [
  enums.FiatOnRampCryptoCurrency? defaultValue,
]) {
  if (fiatOnRampCryptoCurrency == null) {
    return null;
  }
  return enums.FiatOnRampCryptoCurrency.values
          .firstWhereOrNull((e) => e.value == fiatOnRampCryptoCurrency) ??
      defaultValue;
}

String fiatOnRampCryptoCurrencyExplodedListToJson(
    List<enums.FiatOnRampCryptoCurrency>? fiatOnRampCryptoCurrency) {
  return fiatOnRampCryptoCurrency?.map((e) => e.value!).join(',') ?? '';
}

List<String> fiatOnRampCryptoCurrencyListToJson(
    List<enums.FiatOnRampCryptoCurrency>? fiatOnRampCryptoCurrency) {
  if (fiatOnRampCryptoCurrency == null) {
    return [];
  }

  return fiatOnRampCryptoCurrency.map((e) => e.value!).toList();
}

List<enums.FiatOnRampCryptoCurrency> fiatOnRampCryptoCurrencyListFromJson(
  List? fiatOnRampCryptoCurrency, [
  List<enums.FiatOnRampCryptoCurrency>? defaultValue,
]) {
  if (fiatOnRampCryptoCurrency == null) {
    return defaultValue ?? [];
  }

  return fiatOnRampCryptoCurrency
      .map((e) => fiatOnRampCryptoCurrencyFromJson(e.toString()))
      .toList();
}

List<enums.FiatOnRampCryptoCurrency>?
    fiatOnRampCryptoCurrencyNullableListFromJson(
  List? fiatOnRampCryptoCurrency, [
  List<enums.FiatOnRampCryptoCurrency>? defaultValue,
]) {
  if (fiatOnRampCryptoCurrency == null) {
    return defaultValue;
  }

  return fiatOnRampCryptoCurrency
      .map((e) => fiatOnRampCryptoCurrencyFromJson(e.toString()))
      .toList();
}

String? fiatOnRampCurrencyNullableToJson(
    enums.FiatOnRampCurrency? fiatOnRampCurrency) {
  return fiatOnRampCurrency?.value;
}

String? fiatOnRampCurrencyToJson(enums.FiatOnRampCurrency fiatOnRampCurrency) {
  return fiatOnRampCurrency.value;
}

enums.FiatOnRampCurrency fiatOnRampCurrencyFromJson(
  Object? fiatOnRampCurrency, [
  enums.FiatOnRampCurrency? defaultValue,
]) {
  return enums.FiatOnRampCurrency.values
          .firstWhereOrNull((e) => e.value == fiatOnRampCurrency) ??
      defaultValue ??
      enums.FiatOnRampCurrency.swaggerGeneratedUnknown;
}

enums.FiatOnRampCurrency? fiatOnRampCurrencyNullableFromJson(
  Object? fiatOnRampCurrency, [
  enums.FiatOnRampCurrency? defaultValue,
]) {
  if (fiatOnRampCurrency == null) {
    return null;
  }
  return enums.FiatOnRampCurrency.values
          .firstWhereOrNull((e) => e.value == fiatOnRampCurrency) ??
      defaultValue;
}

String fiatOnRampCurrencyExplodedListToJson(
    List<enums.FiatOnRampCurrency>? fiatOnRampCurrency) {
  return fiatOnRampCurrency?.map((e) => e.value!).join(',') ?? '';
}

List<String> fiatOnRampCurrencyListToJson(
    List<enums.FiatOnRampCurrency>? fiatOnRampCurrency) {
  if (fiatOnRampCurrency == null) {
    return [];
  }

  return fiatOnRampCurrency.map((e) => e.value!).toList();
}

List<enums.FiatOnRampCurrency> fiatOnRampCurrencyListFromJson(
  List? fiatOnRampCurrency, [
  List<enums.FiatOnRampCurrency>? defaultValue,
]) {
  if (fiatOnRampCurrency == null) {
    return defaultValue ?? [];
  }

  return fiatOnRampCurrency
      .map((e) => fiatOnRampCurrencyFromJson(e.toString()))
      .toList();
}

List<enums.FiatOnRampCurrency>? fiatOnRampCurrencyNullableListFromJson(
  List? fiatOnRampCurrency, [
  List<enums.FiatOnRampCurrency>? defaultValue,
]) {
  if (fiatOnRampCurrency == null) {
    return defaultValue;
  }

  return fiatOnRampCurrency
      .map((e) => fiatOnRampCurrencyFromJson(e.toString()))
      .toList();
}

String? fiatOnRampPaymentMethodNullableToJson(
    enums.FiatOnRampPaymentMethod? fiatOnRampPaymentMethod) {
  return fiatOnRampPaymentMethod?.value;
}

String? fiatOnRampPaymentMethodToJson(
    enums.FiatOnRampPaymentMethod fiatOnRampPaymentMethod) {
  return fiatOnRampPaymentMethod.value;
}

enums.FiatOnRampPaymentMethod fiatOnRampPaymentMethodFromJson(
  Object? fiatOnRampPaymentMethod, [
  enums.FiatOnRampPaymentMethod? defaultValue,
]) {
  return enums.FiatOnRampPaymentMethod.values
          .firstWhereOrNull((e) => e.value == fiatOnRampPaymentMethod) ??
      defaultValue ??
      enums.FiatOnRampPaymentMethod.swaggerGeneratedUnknown;
}

enums.FiatOnRampPaymentMethod? fiatOnRampPaymentMethodNullableFromJson(
  Object? fiatOnRampPaymentMethod, [
  enums.FiatOnRampPaymentMethod? defaultValue,
]) {
  if (fiatOnRampPaymentMethod == null) {
    return null;
  }
  return enums.FiatOnRampPaymentMethod.values
          .firstWhereOrNull((e) => e.value == fiatOnRampPaymentMethod) ??
      defaultValue;
}

String fiatOnRampPaymentMethodExplodedListToJson(
    List<enums.FiatOnRampPaymentMethod>? fiatOnRampPaymentMethod) {
  return fiatOnRampPaymentMethod?.map((e) => e.value!).join(',') ?? '';
}

List<String> fiatOnRampPaymentMethodListToJson(
    List<enums.FiatOnRampPaymentMethod>? fiatOnRampPaymentMethod) {
  if (fiatOnRampPaymentMethod == null) {
    return [];
  }

  return fiatOnRampPaymentMethod.map((e) => e.value!).toList();
}

List<enums.FiatOnRampPaymentMethod> fiatOnRampPaymentMethodListFromJson(
  List? fiatOnRampPaymentMethod, [
  List<enums.FiatOnRampPaymentMethod>? defaultValue,
]) {
  if (fiatOnRampPaymentMethod == null) {
    return defaultValue ?? [];
  }

  return fiatOnRampPaymentMethod
      .map((e) => fiatOnRampPaymentMethodFromJson(e.toString()))
      .toList();
}

List<enums.FiatOnRampPaymentMethod>?
    fiatOnRampPaymentMethodNullableListFromJson(
  List? fiatOnRampPaymentMethod, [
  List<enums.FiatOnRampPaymentMethod>? defaultValue,
]) {
  if (fiatOnRampPaymentMethod == null) {
    return defaultValue;
  }

  return fiatOnRampPaymentMethod
      .map((e) => fiatOnRampPaymentMethodFromJson(e.toString()))
      .toList();
}

String? fiatOnRampProviderNullableToJson(
    enums.FiatOnRampProvider? fiatOnRampProvider) {
  return fiatOnRampProvider?.value;
}

String? fiatOnRampProviderToJson(enums.FiatOnRampProvider fiatOnRampProvider) {
  return fiatOnRampProvider.value;
}

enums.FiatOnRampProvider fiatOnRampProviderFromJson(
  Object? fiatOnRampProvider, [
  enums.FiatOnRampProvider? defaultValue,
]) {
  return enums.FiatOnRampProvider.values
          .firstWhereOrNull((e) => e.value == fiatOnRampProvider) ??
      defaultValue ??
      enums.FiatOnRampProvider.swaggerGeneratedUnknown;
}

enums.FiatOnRampProvider? fiatOnRampProviderNullableFromJson(
  Object? fiatOnRampProvider, [
  enums.FiatOnRampProvider? defaultValue,
]) {
  if (fiatOnRampProvider == null) {
    return null;
  }
  return enums.FiatOnRampProvider.values
          .firstWhereOrNull((e) => e.value == fiatOnRampProvider) ??
      defaultValue;
}

String fiatOnRampProviderExplodedListToJson(
    List<enums.FiatOnRampProvider>? fiatOnRampProvider) {
  return fiatOnRampProvider?.map((e) => e.value!).join(',') ?? '';
}

List<String> fiatOnRampProviderListToJson(
    List<enums.FiatOnRampProvider>? fiatOnRampProvider) {
  if (fiatOnRampProvider == null) {
    return [];
  }

  return fiatOnRampProvider.map((e) => e.value!).toList();
}

List<enums.FiatOnRampProvider> fiatOnRampProviderListFromJson(
  List? fiatOnRampProvider, [
  List<enums.FiatOnRampProvider>? defaultValue,
]) {
  if (fiatOnRampProvider == null) {
    return defaultValue ?? [];
  }

  return fiatOnRampProvider
      .map((e) => fiatOnRampProviderFromJson(e.toString()))
      .toList();
}

List<enums.FiatOnRampProvider>? fiatOnRampProviderNullableListFromJson(
  List? fiatOnRampProvider, [
  List<enums.FiatOnRampProvider>? defaultValue,
]) {
  if (fiatOnRampProvider == null) {
    return defaultValue;
  }

  return fiatOnRampProvider
      .map((e) => fiatOnRampProviderFromJson(e.toString()))
      .toList();
}

String? hashFunctionNullableToJson(enums.HashFunction? hashFunction) {
  return hashFunction?.value;
}

String? hashFunctionToJson(enums.HashFunction hashFunction) {
  return hashFunction.value;
}

enums.HashFunction hashFunctionFromJson(
  Object? hashFunction, [
  enums.HashFunction? defaultValue,
]) {
  return enums.HashFunction.values
          .firstWhereOrNull((e) => e.value == hashFunction) ??
      defaultValue ??
      enums.HashFunction.swaggerGeneratedUnknown;
}

enums.HashFunction? hashFunctionNullableFromJson(
  Object? hashFunction, [
  enums.HashFunction? defaultValue,
]) {
  if (hashFunction == null) {
    return null;
  }
  return enums.HashFunction.values
          .firstWhereOrNull((e) => e.value == hashFunction) ??
      defaultValue;
}

String hashFunctionExplodedListToJson(List<enums.HashFunction>? hashFunction) {
  return hashFunction?.map((e) => e.value!).join(',') ?? '';
}

List<String> hashFunctionListToJson(List<enums.HashFunction>? hashFunction) {
  if (hashFunction == null) {
    return [];
  }

  return hashFunction.map((e) => e.value!).toList();
}

List<enums.HashFunction> hashFunctionListFromJson(
  List? hashFunction, [
  List<enums.HashFunction>? defaultValue,
]) {
  if (hashFunction == null) {
    return defaultValue ?? [];
  }

  return hashFunction.map((e) => hashFunctionFromJson(e.toString())).toList();
}

List<enums.HashFunction>? hashFunctionNullableListFromJson(
  List? hashFunction, [
  List<enums.HashFunction>? defaultValue,
]) {
  if (hashFunction == null) {
    return defaultValue;
  }

  return hashFunction.map((e) => hashFunctionFromJson(e.toString())).toList();
}

String? importPrivateKeyRequestTypeNullableToJson(
    enums.ImportPrivateKeyRequestType? importPrivateKeyRequestType) {
  return importPrivateKeyRequestType?.value;
}

String? importPrivateKeyRequestTypeToJson(
    enums.ImportPrivateKeyRequestType importPrivateKeyRequestType) {
  return importPrivateKeyRequestType.value;
}

enums.ImportPrivateKeyRequestType importPrivateKeyRequestTypeFromJson(
  Object? importPrivateKeyRequestType, [
  enums.ImportPrivateKeyRequestType? defaultValue,
]) {
  return enums.ImportPrivateKeyRequestType.values
          .firstWhereOrNull((e) => e.value == importPrivateKeyRequestType) ??
      defaultValue ??
      enums.ImportPrivateKeyRequestType.swaggerGeneratedUnknown;
}

enums.ImportPrivateKeyRequestType? importPrivateKeyRequestTypeNullableFromJson(
  Object? importPrivateKeyRequestType, [
  enums.ImportPrivateKeyRequestType? defaultValue,
]) {
  if (importPrivateKeyRequestType == null) {
    return null;
  }
  return enums.ImportPrivateKeyRequestType.values
          .firstWhereOrNull((e) => e.value == importPrivateKeyRequestType) ??
      defaultValue;
}

String importPrivateKeyRequestTypeExplodedListToJson(
    List<enums.ImportPrivateKeyRequestType>? importPrivateKeyRequestType) {
  return importPrivateKeyRequestType?.map((e) => e.value!).join(',') ?? '';
}

List<String> importPrivateKeyRequestTypeListToJson(
    List<enums.ImportPrivateKeyRequestType>? importPrivateKeyRequestType) {
  if (importPrivateKeyRequestType == null) {
    return [];
  }

  return importPrivateKeyRequestType.map((e) => e.value!).toList();
}

List<enums.ImportPrivateKeyRequestType> importPrivateKeyRequestTypeListFromJson(
  List? importPrivateKeyRequestType, [
  List<enums.ImportPrivateKeyRequestType>? defaultValue,
]) {
  if (importPrivateKeyRequestType == null) {
    return defaultValue ?? [];
  }

  return importPrivateKeyRequestType
      .map((e) => importPrivateKeyRequestTypeFromJson(e.toString()))
      .toList();
}

List<enums.ImportPrivateKeyRequestType>?
    importPrivateKeyRequestTypeNullableListFromJson(
  List? importPrivateKeyRequestType, [
  List<enums.ImportPrivateKeyRequestType>? defaultValue,
]) {
  if (importPrivateKeyRequestType == null) {
    return defaultValue;
  }

  return importPrivateKeyRequestType
      .map((e) => importPrivateKeyRequestTypeFromJson(e.toString()))
      .toList();
}

String? importWalletRequestTypeNullableToJson(
    enums.ImportWalletRequestType? importWalletRequestType) {
  return importWalletRequestType?.value;
}

String? importWalletRequestTypeToJson(
    enums.ImportWalletRequestType importWalletRequestType) {
  return importWalletRequestType.value;
}

enums.ImportWalletRequestType importWalletRequestTypeFromJson(
  Object? importWalletRequestType, [
  enums.ImportWalletRequestType? defaultValue,
]) {
  return enums.ImportWalletRequestType.values
          .firstWhereOrNull((e) => e.value == importWalletRequestType) ??
      defaultValue ??
      enums.ImportWalletRequestType.swaggerGeneratedUnknown;
}

enums.ImportWalletRequestType? importWalletRequestTypeNullableFromJson(
  Object? importWalletRequestType, [
  enums.ImportWalletRequestType? defaultValue,
]) {
  if (importWalletRequestType == null) {
    return null;
  }
  return enums.ImportWalletRequestType.values
          .firstWhereOrNull((e) => e.value == importWalletRequestType) ??
      defaultValue;
}

String importWalletRequestTypeExplodedListToJson(
    List<enums.ImportWalletRequestType>? importWalletRequestType) {
  return importWalletRequestType?.map((e) => e.value!).join(',') ?? '';
}

List<String> importWalletRequestTypeListToJson(
    List<enums.ImportWalletRequestType>? importWalletRequestType) {
  if (importWalletRequestType == null) {
    return [];
  }

  return importWalletRequestType.map((e) => e.value!).toList();
}

List<enums.ImportWalletRequestType> importWalletRequestTypeListFromJson(
  List? importWalletRequestType, [
  List<enums.ImportWalletRequestType>? defaultValue,
]) {
  if (importWalletRequestType == null) {
    return defaultValue ?? [];
  }

  return importWalletRequestType
      .map((e) => importWalletRequestTypeFromJson(e.toString()))
      .toList();
}

List<enums.ImportWalletRequestType>?
    importWalletRequestTypeNullableListFromJson(
  List? importWalletRequestType, [
  List<enums.ImportWalletRequestType>? defaultValue,
]) {
  if (importWalletRequestType == null) {
    return defaultValue;
  }

  return importWalletRequestType
      .map((e) => importWalletRequestTypeFromJson(e.toString()))
      .toList();
}

String? initFiatOnRampRequestTypeNullableToJson(
    enums.InitFiatOnRampRequestType? initFiatOnRampRequestType) {
  return initFiatOnRampRequestType?.value;
}

String? initFiatOnRampRequestTypeToJson(
    enums.InitFiatOnRampRequestType initFiatOnRampRequestType) {
  return initFiatOnRampRequestType.value;
}

enums.InitFiatOnRampRequestType initFiatOnRampRequestTypeFromJson(
  Object? initFiatOnRampRequestType, [
  enums.InitFiatOnRampRequestType? defaultValue,
]) {
  return enums.InitFiatOnRampRequestType.values
          .firstWhereOrNull((e) => e.value == initFiatOnRampRequestType) ??
      defaultValue ??
      enums.InitFiatOnRampRequestType.swaggerGeneratedUnknown;
}

enums.InitFiatOnRampRequestType? initFiatOnRampRequestTypeNullableFromJson(
  Object? initFiatOnRampRequestType, [
  enums.InitFiatOnRampRequestType? defaultValue,
]) {
  if (initFiatOnRampRequestType == null) {
    return null;
  }
  return enums.InitFiatOnRampRequestType.values
          .firstWhereOrNull((e) => e.value == initFiatOnRampRequestType) ??
      defaultValue;
}

String initFiatOnRampRequestTypeExplodedListToJson(
    List<enums.InitFiatOnRampRequestType>? initFiatOnRampRequestType) {
  return initFiatOnRampRequestType?.map((e) => e.value!).join(',') ?? '';
}

List<String> initFiatOnRampRequestTypeListToJson(
    List<enums.InitFiatOnRampRequestType>? initFiatOnRampRequestType) {
  if (initFiatOnRampRequestType == null) {
    return [];
  }

  return initFiatOnRampRequestType.map((e) => e.value!).toList();
}

List<enums.InitFiatOnRampRequestType> initFiatOnRampRequestTypeListFromJson(
  List? initFiatOnRampRequestType, [
  List<enums.InitFiatOnRampRequestType>? defaultValue,
]) {
  if (initFiatOnRampRequestType == null) {
    return defaultValue ?? [];
  }

  return initFiatOnRampRequestType
      .map((e) => initFiatOnRampRequestTypeFromJson(e.toString()))
      .toList();
}

List<enums.InitFiatOnRampRequestType>?
    initFiatOnRampRequestTypeNullableListFromJson(
  List? initFiatOnRampRequestType, [
  List<enums.InitFiatOnRampRequestType>? defaultValue,
]) {
  if (initFiatOnRampRequestType == null) {
    return defaultValue;
  }

  return initFiatOnRampRequestType
      .map((e) => initFiatOnRampRequestTypeFromJson(e.toString()))
      .toList();
}

String? initImportPrivateKeyRequestTypeNullableToJson(
    enums.InitImportPrivateKeyRequestType? initImportPrivateKeyRequestType) {
  return initImportPrivateKeyRequestType?.value;
}

String? initImportPrivateKeyRequestTypeToJson(
    enums.InitImportPrivateKeyRequestType initImportPrivateKeyRequestType) {
  return initImportPrivateKeyRequestType.value;
}

enums.InitImportPrivateKeyRequestType initImportPrivateKeyRequestTypeFromJson(
  Object? initImportPrivateKeyRequestType, [
  enums.InitImportPrivateKeyRequestType? defaultValue,
]) {
  return enums.InitImportPrivateKeyRequestType.values.firstWhereOrNull(
          (e) => e.value == initImportPrivateKeyRequestType) ??
      defaultValue ??
      enums.InitImportPrivateKeyRequestType.swaggerGeneratedUnknown;
}

enums.InitImportPrivateKeyRequestType?
    initImportPrivateKeyRequestTypeNullableFromJson(
  Object? initImportPrivateKeyRequestType, [
  enums.InitImportPrivateKeyRequestType? defaultValue,
]) {
  if (initImportPrivateKeyRequestType == null) {
    return null;
  }
  return enums.InitImportPrivateKeyRequestType.values.firstWhereOrNull(
          (e) => e.value == initImportPrivateKeyRequestType) ??
      defaultValue;
}

String initImportPrivateKeyRequestTypeExplodedListToJson(
    List<enums.InitImportPrivateKeyRequestType>?
        initImportPrivateKeyRequestType) {
  return initImportPrivateKeyRequestType?.map((e) => e.value!).join(',') ?? '';
}

List<String> initImportPrivateKeyRequestTypeListToJson(
    List<enums.InitImportPrivateKeyRequestType>?
        initImportPrivateKeyRequestType) {
  if (initImportPrivateKeyRequestType == null) {
    return [];
  }

  return initImportPrivateKeyRequestType.map((e) => e.value!).toList();
}

List<enums.InitImportPrivateKeyRequestType>
    initImportPrivateKeyRequestTypeListFromJson(
  List? initImportPrivateKeyRequestType, [
  List<enums.InitImportPrivateKeyRequestType>? defaultValue,
]) {
  if (initImportPrivateKeyRequestType == null) {
    return defaultValue ?? [];
  }

  return initImportPrivateKeyRequestType
      .map((e) => initImportPrivateKeyRequestTypeFromJson(e.toString()))
      .toList();
}

List<enums.InitImportPrivateKeyRequestType>?
    initImportPrivateKeyRequestTypeNullableListFromJson(
  List? initImportPrivateKeyRequestType, [
  List<enums.InitImportPrivateKeyRequestType>? defaultValue,
]) {
  if (initImportPrivateKeyRequestType == null) {
    return defaultValue;
  }

  return initImportPrivateKeyRequestType
      .map((e) => initImportPrivateKeyRequestTypeFromJson(e.toString()))
      .toList();
}

String? initImportWalletRequestTypeNullableToJson(
    enums.InitImportWalletRequestType? initImportWalletRequestType) {
  return initImportWalletRequestType?.value;
}

String? initImportWalletRequestTypeToJson(
    enums.InitImportWalletRequestType initImportWalletRequestType) {
  return initImportWalletRequestType.value;
}

enums.InitImportWalletRequestType initImportWalletRequestTypeFromJson(
  Object? initImportWalletRequestType, [
  enums.InitImportWalletRequestType? defaultValue,
]) {
  return enums.InitImportWalletRequestType.values
          .firstWhereOrNull((e) => e.value == initImportWalletRequestType) ??
      defaultValue ??
      enums.InitImportWalletRequestType.swaggerGeneratedUnknown;
}

enums.InitImportWalletRequestType? initImportWalletRequestTypeNullableFromJson(
  Object? initImportWalletRequestType, [
  enums.InitImportWalletRequestType? defaultValue,
]) {
  if (initImportWalletRequestType == null) {
    return null;
  }
  return enums.InitImportWalletRequestType.values
          .firstWhereOrNull((e) => e.value == initImportWalletRequestType) ??
      defaultValue;
}

String initImportWalletRequestTypeExplodedListToJson(
    List<enums.InitImportWalletRequestType>? initImportWalletRequestType) {
  return initImportWalletRequestType?.map((e) => e.value!).join(',') ?? '';
}

List<String> initImportWalletRequestTypeListToJson(
    List<enums.InitImportWalletRequestType>? initImportWalletRequestType) {
  if (initImportWalletRequestType == null) {
    return [];
  }

  return initImportWalletRequestType.map((e) => e.value!).toList();
}

List<enums.InitImportWalletRequestType> initImportWalletRequestTypeListFromJson(
  List? initImportWalletRequestType, [
  List<enums.InitImportWalletRequestType>? defaultValue,
]) {
  if (initImportWalletRequestType == null) {
    return defaultValue ?? [];
  }

  return initImportWalletRequestType
      .map((e) => initImportWalletRequestTypeFromJson(e.toString()))
      .toList();
}

List<enums.InitImportWalletRequestType>?
    initImportWalletRequestTypeNullableListFromJson(
  List? initImportWalletRequestType, [
  List<enums.InitImportWalletRequestType>? defaultValue,
]) {
  if (initImportWalletRequestType == null) {
    return defaultValue;
  }

  return initImportWalletRequestType
      .map((e) => initImportWalletRequestTypeFromJson(e.toString()))
      .toList();
}

String? initOtpAuthRequestTypeNullableToJson(
    enums.InitOtpAuthRequestType? initOtpAuthRequestType) {
  return initOtpAuthRequestType?.value;
}

String? initOtpAuthRequestTypeToJson(
    enums.InitOtpAuthRequestType initOtpAuthRequestType) {
  return initOtpAuthRequestType.value;
}

enums.InitOtpAuthRequestType initOtpAuthRequestTypeFromJson(
  Object? initOtpAuthRequestType, [
  enums.InitOtpAuthRequestType? defaultValue,
]) {
  return enums.InitOtpAuthRequestType.values
          .firstWhereOrNull((e) => e.value == initOtpAuthRequestType) ??
      defaultValue ??
      enums.InitOtpAuthRequestType.swaggerGeneratedUnknown;
}

enums.InitOtpAuthRequestType? initOtpAuthRequestTypeNullableFromJson(
  Object? initOtpAuthRequestType, [
  enums.InitOtpAuthRequestType? defaultValue,
]) {
  if (initOtpAuthRequestType == null) {
    return null;
  }
  return enums.InitOtpAuthRequestType.values
          .firstWhereOrNull((e) => e.value == initOtpAuthRequestType) ??
      defaultValue;
}

String initOtpAuthRequestTypeExplodedListToJson(
    List<enums.InitOtpAuthRequestType>? initOtpAuthRequestType) {
  return initOtpAuthRequestType?.map((e) => e.value!).join(',') ?? '';
}

List<String> initOtpAuthRequestTypeListToJson(
    List<enums.InitOtpAuthRequestType>? initOtpAuthRequestType) {
  if (initOtpAuthRequestType == null) {
    return [];
  }

  return initOtpAuthRequestType.map((e) => e.value!).toList();
}

List<enums.InitOtpAuthRequestType> initOtpAuthRequestTypeListFromJson(
  List? initOtpAuthRequestType, [
  List<enums.InitOtpAuthRequestType>? defaultValue,
]) {
  if (initOtpAuthRequestType == null) {
    return defaultValue ?? [];
  }

  return initOtpAuthRequestType
      .map((e) => initOtpAuthRequestTypeFromJson(e.toString()))
      .toList();
}

List<enums.InitOtpAuthRequestType>? initOtpAuthRequestTypeNullableListFromJson(
  List? initOtpAuthRequestType, [
  List<enums.InitOtpAuthRequestType>? defaultValue,
]) {
  if (initOtpAuthRequestType == null) {
    return defaultValue;
  }

  return initOtpAuthRequestType
      .map((e) => initOtpAuthRequestTypeFromJson(e.toString()))
      .toList();
}

String? initOtpRequestTypeNullableToJson(
    enums.InitOtpRequestType? initOtpRequestType) {
  return initOtpRequestType?.value;
}

String? initOtpRequestTypeToJson(enums.InitOtpRequestType initOtpRequestType) {
  return initOtpRequestType.value;
}

enums.InitOtpRequestType initOtpRequestTypeFromJson(
  Object? initOtpRequestType, [
  enums.InitOtpRequestType? defaultValue,
]) {
  return enums.InitOtpRequestType.values
          .firstWhereOrNull((e) => e.value == initOtpRequestType) ??
      defaultValue ??
      enums.InitOtpRequestType.swaggerGeneratedUnknown;
}

enums.InitOtpRequestType? initOtpRequestTypeNullableFromJson(
  Object? initOtpRequestType, [
  enums.InitOtpRequestType? defaultValue,
]) {
  if (initOtpRequestType == null) {
    return null;
  }
  return enums.InitOtpRequestType.values
          .firstWhereOrNull((e) => e.value == initOtpRequestType) ??
      defaultValue;
}

String initOtpRequestTypeExplodedListToJson(
    List<enums.InitOtpRequestType>? initOtpRequestType) {
  return initOtpRequestType?.map((e) => e.value!).join(',') ?? '';
}

List<String> initOtpRequestTypeListToJson(
    List<enums.InitOtpRequestType>? initOtpRequestType) {
  if (initOtpRequestType == null) {
    return [];
  }

  return initOtpRequestType.map((e) => e.value!).toList();
}

List<enums.InitOtpRequestType> initOtpRequestTypeListFromJson(
  List? initOtpRequestType, [
  List<enums.InitOtpRequestType>? defaultValue,
]) {
  if (initOtpRequestType == null) {
    return defaultValue ?? [];
  }

  return initOtpRequestType
      .map((e) => initOtpRequestTypeFromJson(e.toString()))
      .toList();
}

List<enums.InitOtpRequestType>? initOtpRequestTypeNullableListFromJson(
  List? initOtpRequestType, [
  List<enums.InitOtpRequestType>? defaultValue,
]) {
  if (initOtpRequestType == null) {
    return defaultValue;
  }

  return initOtpRequestType
      .map((e) => initOtpRequestTypeFromJson(e.toString()))
      .toList();
}

String? initUserEmailRecoveryRequestTypeNullableToJson(
    enums.InitUserEmailRecoveryRequestType? initUserEmailRecoveryRequestType) {
  return initUserEmailRecoveryRequestType?.value;
}

String? initUserEmailRecoveryRequestTypeToJson(
    enums.InitUserEmailRecoveryRequestType initUserEmailRecoveryRequestType) {
  return initUserEmailRecoveryRequestType.value;
}

enums.InitUserEmailRecoveryRequestType initUserEmailRecoveryRequestTypeFromJson(
  Object? initUserEmailRecoveryRequestType, [
  enums.InitUserEmailRecoveryRequestType? defaultValue,
]) {
  return enums.InitUserEmailRecoveryRequestType.values.firstWhereOrNull(
          (e) => e.value == initUserEmailRecoveryRequestType) ??
      defaultValue ??
      enums.InitUserEmailRecoveryRequestType.swaggerGeneratedUnknown;
}

enums.InitUserEmailRecoveryRequestType?
    initUserEmailRecoveryRequestTypeNullableFromJson(
  Object? initUserEmailRecoveryRequestType, [
  enums.InitUserEmailRecoveryRequestType? defaultValue,
]) {
  if (initUserEmailRecoveryRequestType == null) {
    return null;
  }
  return enums.InitUserEmailRecoveryRequestType.values.firstWhereOrNull(
          (e) => e.value == initUserEmailRecoveryRequestType) ??
      defaultValue;
}

String initUserEmailRecoveryRequestTypeExplodedListToJson(
    List<enums.InitUserEmailRecoveryRequestType>?
        initUserEmailRecoveryRequestType) {
  return initUserEmailRecoveryRequestType?.map((e) => e.value!).join(',') ?? '';
}

List<String> initUserEmailRecoveryRequestTypeListToJson(
    List<enums.InitUserEmailRecoveryRequestType>?
        initUserEmailRecoveryRequestType) {
  if (initUserEmailRecoveryRequestType == null) {
    return [];
  }

  return initUserEmailRecoveryRequestType.map((e) => e.value!).toList();
}

List<enums.InitUserEmailRecoveryRequestType>
    initUserEmailRecoveryRequestTypeListFromJson(
  List? initUserEmailRecoveryRequestType, [
  List<enums.InitUserEmailRecoveryRequestType>? defaultValue,
]) {
  if (initUserEmailRecoveryRequestType == null) {
    return defaultValue ?? [];
  }

  return initUserEmailRecoveryRequestType
      .map((e) => initUserEmailRecoveryRequestTypeFromJson(e.toString()))
      .toList();
}

List<enums.InitUserEmailRecoveryRequestType>?
    initUserEmailRecoveryRequestTypeNullableListFromJson(
  List? initUserEmailRecoveryRequestType, [
  List<enums.InitUserEmailRecoveryRequestType>? defaultValue,
]) {
  if (initUserEmailRecoveryRequestType == null) {
    return defaultValue;
  }

  return initUserEmailRecoveryRequestType
      .map((e) => initUserEmailRecoveryRequestTypeFromJson(e.toString()))
      .toList();
}

String? mnemonicLanguageNullableToJson(
    enums.MnemonicLanguage? mnemonicLanguage) {
  return mnemonicLanguage?.value;
}

String? mnemonicLanguageToJson(enums.MnemonicLanguage mnemonicLanguage) {
  return mnemonicLanguage.value;
}

enums.MnemonicLanguage mnemonicLanguageFromJson(
  Object? mnemonicLanguage, [
  enums.MnemonicLanguage? defaultValue,
]) {
  return enums.MnemonicLanguage.values
          .firstWhereOrNull((e) => e.value == mnemonicLanguage) ??
      defaultValue ??
      enums.MnemonicLanguage.swaggerGeneratedUnknown;
}

enums.MnemonicLanguage? mnemonicLanguageNullableFromJson(
  Object? mnemonicLanguage, [
  enums.MnemonicLanguage? defaultValue,
]) {
  if (mnemonicLanguage == null) {
    return null;
  }
  return enums.MnemonicLanguage.values
          .firstWhereOrNull((e) => e.value == mnemonicLanguage) ??
      defaultValue;
}

String mnemonicLanguageExplodedListToJson(
    List<enums.MnemonicLanguage>? mnemonicLanguage) {
  return mnemonicLanguage?.map((e) => e.value!).join(',') ?? '';
}

List<String> mnemonicLanguageListToJson(
    List<enums.MnemonicLanguage>? mnemonicLanguage) {
  if (mnemonicLanguage == null) {
    return [];
  }

  return mnemonicLanguage.map((e) => e.value!).toList();
}

List<enums.MnemonicLanguage> mnemonicLanguageListFromJson(
  List? mnemonicLanguage, [
  List<enums.MnemonicLanguage>? defaultValue,
]) {
  if (mnemonicLanguage == null) {
    return defaultValue ?? [];
  }

  return mnemonicLanguage
      .map((e) => mnemonicLanguageFromJson(e.toString()))
      .toList();
}

List<enums.MnemonicLanguage>? mnemonicLanguageNullableListFromJson(
  List? mnemonicLanguage, [
  List<enums.MnemonicLanguage>? defaultValue,
]) {
  if (mnemonicLanguage == null) {
    return defaultValue;
  }

  return mnemonicLanguage
      .map((e) => mnemonicLanguageFromJson(e.toString()))
      .toList();
}

String? oauthLoginRequestTypeNullableToJson(
    enums.OauthLoginRequestType? oauthLoginRequestType) {
  return oauthLoginRequestType?.value;
}

String? oauthLoginRequestTypeToJson(
    enums.OauthLoginRequestType oauthLoginRequestType) {
  return oauthLoginRequestType.value;
}

enums.OauthLoginRequestType oauthLoginRequestTypeFromJson(
  Object? oauthLoginRequestType, [
  enums.OauthLoginRequestType? defaultValue,
]) {
  return enums.OauthLoginRequestType.values
          .firstWhereOrNull((e) => e.value == oauthLoginRequestType) ??
      defaultValue ??
      enums.OauthLoginRequestType.swaggerGeneratedUnknown;
}

enums.OauthLoginRequestType? oauthLoginRequestTypeNullableFromJson(
  Object? oauthLoginRequestType, [
  enums.OauthLoginRequestType? defaultValue,
]) {
  if (oauthLoginRequestType == null) {
    return null;
  }
  return enums.OauthLoginRequestType.values
          .firstWhereOrNull((e) => e.value == oauthLoginRequestType) ??
      defaultValue;
}

String oauthLoginRequestTypeExplodedListToJson(
    List<enums.OauthLoginRequestType>? oauthLoginRequestType) {
  return oauthLoginRequestType?.map((e) => e.value!).join(',') ?? '';
}

List<String> oauthLoginRequestTypeListToJson(
    List<enums.OauthLoginRequestType>? oauthLoginRequestType) {
  if (oauthLoginRequestType == null) {
    return [];
  }

  return oauthLoginRequestType.map((e) => e.value!).toList();
}

List<enums.OauthLoginRequestType> oauthLoginRequestTypeListFromJson(
  List? oauthLoginRequestType, [
  List<enums.OauthLoginRequestType>? defaultValue,
]) {
  if (oauthLoginRequestType == null) {
    return defaultValue ?? [];
  }

  return oauthLoginRequestType
      .map((e) => oauthLoginRequestTypeFromJson(e.toString()))
      .toList();
}

List<enums.OauthLoginRequestType>? oauthLoginRequestTypeNullableListFromJson(
  List? oauthLoginRequestType, [
  List<enums.OauthLoginRequestType>? defaultValue,
]) {
  if (oauthLoginRequestType == null) {
    return defaultValue;
  }

  return oauthLoginRequestType
      .map((e) => oauthLoginRequestTypeFromJson(e.toString()))
      .toList();
}

String? oauthRequestTypeNullableToJson(
    enums.OauthRequestType? oauthRequestType) {
  return oauthRequestType?.value;
}

String? oauthRequestTypeToJson(enums.OauthRequestType oauthRequestType) {
  return oauthRequestType.value;
}

enums.OauthRequestType oauthRequestTypeFromJson(
  Object? oauthRequestType, [
  enums.OauthRequestType? defaultValue,
]) {
  return enums.OauthRequestType.values
          .firstWhereOrNull((e) => e.value == oauthRequestType) ??
      defaultValue ??
      enums.OauthRequestType.swaggerGeneratedUnknown;
}

enums.OauthRequestType? oauthRequestTypeNullableFromJson(
  Object? oauthRequestType, [
  enums.OauthRequestType? defaultValue,
]) {
  if (oauthRequestType == null) {
    return null;
  }
  return enums.OauthRequestType.values
          .firstWhereOrNull((e) => e.value == oauthRequestType) ??
      defaultValue;
}

String oauthRequestTypeExplodedListToJson(
    List<enums.OauthRequestType>? oauthRequestType) {
  return oauthRequestType?.map((e) => e.value!).join(',') ?? '';
}

List<String> oauthRequestTypeListToJson(
    List<enums.OauthRequestType>? oauthRequestType) {
  if (oauthRequestType == null) {
    return [];
  }

  return oauthRequestType.map((e) => e.value!).toList();
}

List<enums.OauthRequestType> oauthRequestTypeListFromJson(
  List? oauthRequestType, [
  List<enums.OauthRequestType>? defaultValue,
]) {
  if (oauthRequestType == null) {
    return defaultValue ?? [];
  }

  return oauthRequestType
      .map((e) => oauthRequestTypeFromJson(e.toString()))
      .toList();
}

List<enums.OauthRequestType>? oauthRequestTypeNullableListFromJson(
  List? oauthRequestType, [
  List<enums.OauthRequestType>? defaultValue,
]) {
  if (oauthRequestType == null) {
    return defaultValue;
  }

  return oauthRequestType
      .map((e) => oauthRequestTypeFromJson(e.toString()))
      .toList();
}

String? operatorNullableToJson(enums.Operator? operator) {
  return operator?.value;
}

String? operatorToJson(enums.Operator operator) {
  return operator.value;
}

enums.Operator operatorFromJson(
  Object? operator, [
  enums.Operator? defaultValue,
]) {
  return enums.Operator.values.firstWhereOrNull((e) => e.value == operator) ??
      defaultValue ??
      enums.Operator.swaggerGeneratedUnknown;
}

enums.Operator? operatorNullableFromJson(
  Object? operator, [
  enums.Operator? defaultValue,
]) {
  if (operator == null) {
    return null;
  }
  return enums.Operator.values.firstWhereOrNull((e) => e.value == operator) ??
      defaultValue;
}

String operatorExplodedListToJson(List<enums.Operator>? operator) {
  return operator?.map((e) => e.value!).join(',') ?? '';
}

List<String> operatorListToJson(List<enums.Operator>? operator) {
  if (operator == null) {
    return [];
  }

  return operator.map((e) => e.value!).toList();
}

List<enums.Operator> operatorListFromJson(
  List? operator, [
  List<enums.Operator>? defaultValue,
]) {
  if (operator == null) {
    return defaultValue ?? [];
  }

  return operator.map((e) => operatorFromJson(e.toString())).toList();
}

List<enums.Operator>? operatorNullableListFromJson(
  List? operator, [
  List<enums.Operator>? defaultValue,
]) {
  if (operator == null) {
    return defaultValue;
  }

  return operator.map((e) => operatorFromJson(e.toString())).toList();
}

String? otpAuthRequestTypeNullableToJson(
    enums.OtpAuthRequestType? otpAuthRequestType) {
  return otpAuthRequestType?.value;
}

String? otpAuthRequestTypeToJson(enums.OtpAuthRequestType otpAuthRequestType) {
  return otpAuthRequestType.value;
}

enums.OtpAuthRequestType otpAuthRequestTypeFromJson(
  Object? otpAuthRequestType, [
  enums.OtpAuthRequestType? defaultValue,
]) {
  return enums.OtpAuthRequestType.values
          .firstWhereOrNull((e) => e.value == otpAuthRequestType) ??
      defaultValue ??
      enums.OtpAuthRequestType.swaggerGeneratedUnknown;
}

enums.OtpAuthRequestType? otpAuthRequestTypeNullableFromJson(
  Object? otpAuthRequestType, [
  enums.OtpAuthRequestType? defaultValue,
]) {
  if (otpAuthRequestType == null) {
    return null;
  }
  return enums.OtpAuthRequestType.values
          .firstWhereOrNull((e) => e.value == otpAuthRequestType) ??
      defaultValue;
}

String otpAuthRequestTypeExplodedListToJson(
    List<enums.OtpAuthRequestType>? otpAuthRequestType) {
  return otpAuthRequestType?.map((e) => e.value!).join(',') ?? '';
}

List<String> otpAuthRequestTypeListToJson(
    List<enums.OtpAuthRequestType>? otpAuthRequestType) {
  if (otpAuthRequestType == null) {
    return [];
  }

  return otpAuthRequestType.map((e) => e.value!).toList();
}

List<enums.OtpAuthRequestType> otpAuthRequestTypeListFromJson(
  List? otpAuthRequestType, [
  List<enums.OtpAuthRequestType>? defaultValue,
]) {
  if (otpAuthRequestType == null) {
    return defaultValue ?? [];
  }

  return otpAuthRequestType
      .map((e) => otpAuthRequestTypeFromJson(e.toString()))
      .toList();
}

List<enums.OtpAuthRequestType>? otpAuthRequestTypeNullableListFromJson(
  List? otpAuthRequestType, [
  List<enums.OtpAuthRequestType>? defaultValue,
]) {
  if (otpAuthRequestType == null) {
    return defaultValue;
  }

  return otpAuthRequestType
      .map((e) => otpAuthRequestTypeFromJson(e.toString()))
      .toList();
}

String? otpLoginRequestTypeNullableToJson(
    enums.OtpLoginRequestType? otpLoginRequestType) {
  return otpLoginRequestType?.value;
}

String? otpLoginRequestTypeToJson(
    enums.OtpLoginRequestType otpLoginRequestType) {
  return otpLoginRequestType.value;
}

enums.OtpLoginRequestType otpLoginRequestTypeFromJson(
  Object? otpLoginRequestType, [
  enums.OtpLoginRequestType? defaultValue,
]) {
  return enums.OtpLoginRequestType.values
          .firstWhereOrNull((e) => e.value == otpLoginRequestType) ??
      defaultValue ??
      enums.OtpLoginRequestType.swaggerGeneratedUnknown;
}

enums.OtpLoginRequestType? otpLoginRequestTypeNullableFromJson(
  Object? otpLoginRequestType, [
  enums.OtpLoginRequestType? defaultValue,
]) {
  if (otpLoginRequestType == null) {
    return null;
  }
  return enums.OtpLoginRequestType.values
          .firstWhereOrNull((e) => e.value == otpLoginRequestType) ??
      defaultValue;
}

String otpLoginRequestTypeExplodedListToJson(
    List<enums.OtpLoginRequestType>? otpLoginRequestType) {
  return otpLoginRequestType?.map((e) => e.value!).join(',') ?? '';
}

List<String> otpLoginRequestTypeListToJson(
    List<enums.OtpLoginRequestType>? otpLoginRequestType) {
  if (otpLoginRequestType == null) {
    return [];
  }

  return otpLoginRequestType.map((e) => e.value!).toList();
}

List<enums.OtpLoginRequestType> otpLoginRequestTypeListFromJson(
  List? otpLoginRequestType, [
  List<enums.OtpLoginRequestType>? defaultValue,
]) {
  if (otpLoginRequestType == null) {
    return defaultValue ?? [];
  }

  return otpLoginRequestType
      .map((e) => otpLoginRequestTypeFromJson(e.toString()))
      .toList();
}

List<enums.OtpLoginRequestType>? otpLoginRequestTypeNullableListFromJson(
  List? otpLoginRequestType, [
  List<enums.OtpLoginRequestType>? defaultValue,
]) {
  if (otpLoginRequestType == null) {
    return defaultValue;
  }

  return otpLoginRequestType
      .map((e) => otpLoginRequestTypeFromJson(e.toString()))
      .toList();
}

String? outcomeNullableToJson(enums.Outcome? outcome) {
  return outcome?.value;
}

String? outcomeToJson(enums.Outcome outcome) {
  return outcome.value;
}

enums.Outcome outcomeFromJson(
  Object? outcome, [
  enums.Outcome? defaultValue,
]) {
  return enums.Outcome.values.firstWhereOrNull((e) => e.value == outcome) ??
      defaultValue ??
      enums.Outcome.swaggerGeneratedUnknown;
}

enums.Outcome? outcomeNullableFromJson(
  Object? outcome, [
  enums.Outcome? defaultValue,
]) {
  if (outcome == null) {
    return null;
  }
  return enums.Outcome.values.firstWhereOrNull((e) => e.value == outcome) ??
      defaultValue;
}

String outcomeExplodedListToJson(List<enums.Outcome>? outcome) {
  return outcome?.map((e) => e.value!).join(',') ?? '';
}

List<String> outcomeListToJson(List<enums.Outcome>? outcome) {
  if (outcome == null) {
    return [];
  }

  return outcome.map((e) => e.value!).toList();
}

List<enums.Outcome> outcomeListFromJson(
  List? outcome, [
  List<enums.Outcome>? defaultValue,
]) {
  if (outcome == null) {
    return defaultValue ?? [];
  }

  return outcome.map((e) => outcomeFromJson(e.toString())).toList();
}

List<enums.Outcome>? outcomeNullableListFromJson(
  List? outcome, [
  List<enums.Outcome>? defaultValue,
]) {
  if (outcome == null) {
    return defaultValue;
  }

  return outcome.map((e) => outcomeFromJson(e.toString())).toList();
}

String? pathFormatNullableToJson(enums.PathFormat? pathFormat) {
  return pathFormat?.value;
}

String? pathFormatToJson(enums.PathFormat pathFormat) {
  return pathFormat.value;
}

enums.PathFormat pathFormatFromJson(
  Object? pathFormat, [
  enums.PathFormat? defaultValue,
]) {
  return enums.PathFormat.values
          .firstWhereOrNull((e) => e.value == pathFormat) ??
      defaultValue ??
      enums.PathFormat.swaggerGeneratedUnknown;
}

enums.PathFormat? pathFormatNullableFromJson(
  Object? pathFormat, [
  enums.PathFormat? defaultValue,
]) {
  if (pathFormat == null) {
    return null;
  }
  return enums.PathFormat.values
          .firstWhereOrNull((e) => e.value == pathFormat) ??
      defaultValue;
}

String pathFormatExplodedListToJson(List<enums.PathFormat>? pathFormat) {
  return pathFormat?.map((e) => e.value!).join(',') ?? '';
}

List<String> pathFormatListToJson(List<enums.PathFormat>? pathFormat) {
  if (pathFormat == null) {
    return [];
  }

  return pathFormat.map((e) => e.value!).toList();
}

List<enums.PathFormat> pathFormatListFromJson(
  List? pathFormat, [
  List<enums.PathFormat>? defaultValue,
]) {
  if (pathFormat == null) {
    return defaultValue ?? [];
  }

  return pathFormat.map((e) => pathFormatFromJson(e.toString())).toList();
}

List<enums.PathFormat>? pathFormatNullableListFromJson(
  List? pathFormat, [
  List<enums.PathFormat>? defaultValue,
]) {
  if (pathFormat == null) {
    return defaultValue;
  }

  return pathFormat.map((e) => pathFormatFromJson(e.toString())).toList();
}

String? payloadEncodingNullableToJson(enums.PayloadEncoding? payloadEncoding) {
  return payloadEncoding?.value;
}

String? payloadEncodingToJson(enums.PayloadEncoding payloadEncoding) {
  return payloadEncoding.value;
}

enums.PayloadEncoding payloadEncodingFromJson(
  Object? payloadEncoding, [
  enums.PayloadEncoding? defaultValue,
]) {
  return enums.PayloadEncoding.values
          .firstWhereOrNull((e) => e.value == payloadEncoding) ??
      defaultValue ??
      enums.PayloadEncoding.swaggerGeneratedUnknown;
}

enums.PayloadEncoding? payloadEncodingNullableFromJson(
  Object? payloadEncoding, [
  enums.PayloadEncoding? defaultValue,
]) {
  if (payloadEncoding == null) {
    return null;
  }
  return enums.PayloadEncoding.values
          .firstWhereOrNull((e) => e.value == payloadEncoding) ??
      defaultValue;
}

String payloadEncodingExplodedListToJson(
    List<enums.PayloadEncoding>? payloadEncoding) {
  return payloadEncoding?.map((e) => e.value!).join(',') ?? '';
}

List<String> payloadEncodingListToJson(
    List<enums.PayloadEncoding>? payloadEncoding) {
  if (payloadEncoding == null) {
    return [];
  }

  return payloadEncoding.map((e) => e.value!).toList();
}

List<enums.PayloadEncoding> payloadEncodingListFromJson(
  List? payloadEncoding, [
  List<enums.PayloadEncoding>? defaultValue,
]) {
  if (payloadEncoding == null) {
    return defaultValue ?? [];
  }

  return payloadEncoding
      .map((e) => payloadEncodingFromJson(e.toString()))
      .toList();
}

List<enums.PayloadEncoding>? payloadEncodingNullableListFromJson(
  List? payloadEncoding, [
  List<enums.PayloadEncoding>? defaultValue,
]) {
  if (payloadEncoding == null) {
    return defaultValue;
  }

  return payloadEncoding
      .map((e) => payloadEncodingFromJson(e.toString()))
      .toList();
}

String? publicKeyCredentialWithAttestationTypeNullableToJson(
    enums.PublicKeyCredentialWithAttestationType?
        publicKeyCredentialWithAttestationType) {
  return publicKeyCredentialWithAttestationType?.value;
}

String? publicKeyCredentialWithAttestationTypeToJson(
    enums.PublicKeyCredentialWithAttestationType
        publicKeyCredentialWithAttestationType) {
  return publicKeyCredentialWithAttestationType.value;
}

enums.PublicKeyCredentialWithAttestationType
    publicKeyCredentialWithAttestationTypeFromJson(
  Object? publicKeyCredentialWithAttestationType, [
  enums.PublicKeyCredentialWithAttestationType? defaultValue,
]) {
  return enums.PublicKeyCredentialWithAttestationType.values.firstWhereOrNull(
          (e) => e.value == publicKeyCredentialWithAttestationType) ??
      defaultValue ??
      enums.PublicKeyCredentialWithAttestationType.swaggerGeneratedUnknown;
}

enums.PublicKeyCredentialWithAttestationType?
    publicKeyCredentialWithAttestationTypeNullableFromJson(
  Object? publicKeyCredentialWithAttestationType, [
  enums.PublicKeyCredentialWithAttestationType? defaultValue,
]) {
  if (publicKeyCredentialWithAttestationType == null) {
    return null;
  }
  return enums.PublicKeyCredentialWithAttestationType.values.firstWhereOrNull(
          (e) => e.value == publicKeyCredentialWithAttestationType) ??
      defaultValue;
}

String publicKeyCredentialWithAttestationTypeExplodedListToJson(
    List<enums.PublicKeyCredentialWithAttestationType>?
        publicKeyCredentialWithAttestationType) {
  return publicKeyCredentialWithAttestationType
          ?.map((e) => e.value!)
          .join(',') ??
      '';
}

List<String> publicKeyCredentialWithAttestationTypeListToJson(
    List<enums.PublicKeyCredentialWithAttestationType>?
        publicKeyCredentialWithAttestationType) {
  if (publicKeyCredentialWithAttestationType == null) {
    return [];
  }

  return publicKeyCredentialWithAttestationType.map((e) => e.value!).toList();
}

List<enums.PublicKeyCredentialWithAttestationType>
    publicKeyCredentialWithAttestationTypeListFromJson(
  List? publicKeyCredentialWithAttestationType, [
  List<enums.PublicKeyCredentialWithAttestationType>? defaultValue,
]) {
  if (publicKeyCredentialWithAttestationType == null) {
    return defaultValue ?? [];
  }

  return publicKeyCredentialWithAttestationType
      .map((e) => publicKeyCredentialWithAttestationTypeFromJson(e.toString()))
      .toList();
}

List<enums.PublicKeyCredentialWithAttestationType>?
    publicKeyCredentialWithAttestationTypeNullableListFromJson(
  List? publicKeyCredentialWithAttestationType, [
  List<enums.PublicKeyCredentialWithAttestationType>? defaultValue,
]) {
  if (publicKeyCredentialWithAttestationType == null) {
    return defaultValue;
  }

  return publicKeyCredentialWithAttestationType
      .map((e) => publicKeyCredentialWithAttestationTypeFromJson(e.toString()))
      .toList();
}

String? publicKeyCredentialWithAttestationAuthenticatorAttachmentNullableToJson(
    enums.PublicKeyCredentialWithAttestationAuthenticatorAttachment?
        publicKeyCredentialWithAttestationAuthenticatorAttachment) {
  return publicKeyCredentialWithAttestationAuthenticatorAttachment?.value;
}

String? publicKeyCredentialWithAttestationAuthenticatorAttachmentToJson(
    enums.PublicKeyCredentialWithAttestationAuthenticatorAttachment
        publicKeyCredentialWithAttestationAuthenticatorAttachment) {
  return publicKeyCredentialWithAttestationAuthenticatorAttachment.value;
}

enums.PublicKeyCredentialWithAttestationAuthenticatorAttachment
    publicKeyCredentialWithAttestationAuthenticatorAttachmentFromJson(
  Object? publicKeyCredentialWithAttestationAuthenticatorAttachment, [
  enums.PublicKeyCredentialWithAttestationAuthenticatorAttachment? defaultValue,
]) {
  return enums.PublicKeyCredentialWithAttestationAuthenticatorAttachment.values
          .firstWhereOrNull((e) =>
              e.value ==
              publicKeyCredentialWithAttestationAuthenticatorAttachment) ??
      defaultValue ??
      enums.PublicKeyCredentialWithAttestationAuthenticatorAttachment
          .swaggerGeneratedUnknown;
}

enums.PublicKeyCredentialWithAttestationAuthenticatorAttachment?
    publicKeyCredentialWithAttestationAuthenticatorAttachmentNullableFromJson(
  Object? publicKeyCredentialWithAttestationAuthenticatorAttachment, [
  enums.PublicKeyCredentialWithAttestationAuthenticatorAttachment? defaultValue,
]) {
  if (publicKeyCredentialWithAttestationAuthenticatorAttachment == null) {
    return null;
  }
  return enums.PublicKeyCredentialWithAttestationAuthenticatorAttachment.values
          .firstWhereOrNull((e) =>
              e.value ==
              publicKeyCredentialWithAttestationAuthenticatorAttachment) ??
      defaultValue;
}

String
    publicKeyCredentialWithAttestationAuthenticatorAttachmentExplodedListToJson(
        List<enums.PublicKeyCredentialWithAttestationAuthenticatorAttachment>?
            publicKeyCredentialWithAttestationAuthenticatorAttachment) {
  return publicKeyCredentialWithAttestationAuthenticatorAttachment
          ?.map((e) => e.value!)
          .join(',') ??
      '';
}

List<String>
    publicKeyCredentialWithAttestationAuthenticatorAttachmentListToJson(
        List<enums.PublicKeyCredentialWithAttestationAuthenticatorAttachment>?
            publicKeyCredentialWithAttestationAuthenticatorAttachment) {
  if (publicKeyCredentialWithAttestationAuthenticatorAttachment == null) {
    return [];
  }

  return publicKeyCredentialWithAttestationAuthenticatorAttachment
      .map((e) => e.value!)
      .toList();
}

List<enums.PublicKeyCredentialWithAttestationAuthenticatorAttachment>
    publicKeyCredentialWithAttestationAuthenticatorAttachmentListFromJson(
  List? publicKeyCredentialWithAttestationAuthenticatorAttachment, [
  List<enums.PublicKeyCredentialWithAttestationAuthenticatorAttachment>?
      defaultValue,
]) {
  if (publicKeyCredentialWithAttestationAuthenticatorAttachment == null) {
    return defaultValue ?? [];
  }

  return publicKeyCredentialWithAttestationAuthenticatorAttachment
      .map((e) =>
          publicKeyCredentialWithAttestationAuthenticatorAttachmentFromJson(
              e.toString()))
      .toList();
}

List<enums.PublicKeyCredentialWithAttestationAuthenticatorAttachment>?
    publicKeyCredentialWithAttestationAuthenticatorAttachmentNullableListFromJson(
  List? publicKeyCredentialWithAttestationAuthenticatorAttachment, [
  List<enums.PublicKeyCredentialWithAttestationAuthenticatorAttachment>?
      defaultValue,
]) {
  if (publicKeyCredentialWithAttestationAuthenticatorAttachment == null) {
    return defaultValue;
  }

  return publicKeyCredentialWithAttestationAuthenticatorAttachment
      .map((e) =>
          publicKeyCredentialWithAttestationAuthenticatorAttachmentFromJson(
              e.toString()))
      .toList();
}

String? recoverUserRequestTypeNullableToJson(
    enums.RecoverUserRequestType? recoverUserRequestType) {
  return recoverUserRequestType?.value;
}

String? recoverUserRequestTypeToJson(
    enums.RecoverUserRequestType recoverUserRequestType) {
  return recoverUserRequestType.value;
}

enums.RecoverUserRequestType recoverUserRequestTypeFromJson(
  Object? recoverUserRequestType, [
  enums.RecoverUserRequestType? defaultValue,
]) {
  return enums.RecoverUserRequestType.values
          .firstWhereOrNull((e) => e.value == recoverUserRequestType) ??
      defaultValue ??
      enums.RecoverUserRequestType.swaggerGeneratedUnknown;
}

enums.RecoverUserRequestType? recoverUserRequestTypeNullableFromJson(
  Object? recoverUserRequestType, [
  enums.RecoverUserRequestType? defaultValue,
]) {
  if (recoverUserRequestType == null) {
    return null;
  }
  return enums.RecoverUserRequestType.values
          .firstWhereOrNull((e) => e.value == recoverUserRequestType) ??
      defaultValue;
}

String recoverUserRequestTypeExplodedListToJson(
    List<enums.RecoverUserRequestType>? recoverUserRequestType) {
  return recoverUserRequestType?.map((e) => e.value!).join(',') ?? '';
}

List<String> recoverUserRequestTypeListToJson(
    List<enums.RecoverUserRequestType>? recoverUserRequestType) {
  if (recoverUserRequestType == null) {
    return [];
  }

  return recoverUserRequestType.map((e) => e.value!).toList();
}

List<enums.RecoverUserRequestType> recoverUserRequestTypeListFromJson(
  List? recoverUserRequestType, [
  List<enums.RecoverUserRequestType>? defaultValue,
]) {
  if (recoverUserRequestType == null) {
    return defaultValue ?? [];
  }

  return recoverUserRequestType
      .map((e) => recoverUserRequestTypeFromJson(e.toString()))
      .toList();
}

List<enums.RecoverUserRequestType>? recoverUserRequestTypeNullableListFromJson(
  List? recoverUserRequestType, [
  List<enums.RecoverUserRequestType>? defaultValue,
]) {
  if (recoverUserRequestType == null) {
    return defaultValue;
  }

  return recoverUserRequestType
      .map((e) => recoverUserRequestTypeFromJson(e.toString()))
      .toList();
}

String? rejectActivityRequestTypeNullableToJson(
    enums.RejectActivityRequestType? rejectActivityRequestType) {
  return rejectActivityRequestType?.value;
}

String? rejectActivityRequestTypeToJson(
    enums.RejectActivityRequestType rejectActivityRequestType) {
  return rejectActivityRequestType.value;
}

enums.RejectActivityRequestType rejectActivityRequestTypeFromJson(
  Object? rejectActivityRequestType, [
  enums.RejectActivityRequestType? defaultValue,
]) {
  return enums.RejectActivityRequestType.values
          .firstWhereOrNull((e) => e.value == rejectActivityRequestType) ??
      defaultValue ??
      enums.RejectActivityRequestType.swaggerGeneratedUnknown;
}

enums.RejectActivityRequestType? rejectActivityRequestTypeNullableFromJson(
  Object? rejectActivityRequestType, [
  enums.RejectActivityRequestType? defaultValue,
]) {
  if (rejectActivityRequestType == null) {
    return null;
  }
  return enums.RejectActivityRequestType.values
          .firstWhereOrNull((e) => e.value == rejectActivityRequestType) ??
      defaultValue;
}

String rejectActivityRequestTypeExplodedListToJson(
    List<enums.RejectActivityRequestType>? rejectActivityRequestType) {
  return rejectActivityRequestType?.map((e) => e.value!).join(',') ?? '';
}

List<String> rejectActivityRequestTypeListToJson(
    List<enums.RejectActivityRequestType>? rejectActivityRequestType) {
  if (rejectActivityRequestType == null) {
    return [];
  }

  return rejectActivityRequestType.map((e) => e.value!).toList();
}

List<enums.RejectActivityRequestType> rejectActivityRequestTypeListFromJson(
  List? rejectActivityRequestType, [
  List<enums.RejectActivityRequestType>? defaultValue,
]) {
  if (rejectActivityRequestType == null) {
    return defaultValue ?? [];
  }

  return rejectActivityRequestType
      .map((e) => rejectActivityRequestTypeFromJson(e.toString()))
      .toList();
}

List<enums.RejectActivityRequestType>?
    rejectActivityRequestTypeNullableListFromJson(
  List? rejectActivityRequestType, [
  List<enums.RejectActivityRequestType>? defaultValue,
]) {
  if (rejectActivityRequestType == null) {
    return defaultValue;
  }

  return rejectActivityRequestType
      .map((e) => rejectActivityRequestTypeFromJson(e.toString()))
      .toList();
}

String? removeOrganizationFeatureRequestTypeNullableToJson(
    enums.RemoveOrganizationFeatureRequestType?
        removeOrganizationFeatureRequestType) {
  return removeOrganizationFeatureRequestType?.value;
}

String? removeOrganizationFeatureRequestTypeToJson(
    enums.RemoveOrganizationFeatureRequestType
        removeOrganizationFeatureRequestType) {
  return removeOrganizationFeatureRequestType.value;
}

enums.RemoveOrganizationFeatureRequestType
    removeOrganizationFeatureRequestTypeFromJson(
  Object? removeOrganizationFeatureRequestType, [
  enums.RemoveOrganizationFeatureRequestType? defaultValue,
]) {
  return enums.RemoveOrganizationFeatureRequestType.values.firstWhereOrNull(
          (e) => e.value == removeOrganizationFeatureRequestType) ??
      defaultValue ??
      enums.RemoveOrganizationFeatureRequestType.swaggerGeneratedUnknown;
}

enums.RemoveOrganizationFeatureRequestType?
    removeOrganizationFeatureRequestTypeNullableFromJson(
  Object? removeOrganizationFeatureRequestType, [
  enums.RemoveOrganizationFeatureRequestType? defaultValue,
]) {
  if (removeOrganizationFeatureRequestType == null) {
    return null;
  }
  return enums.RemoveOrganizationFeatureRequestType.values.firstWhereOrNull(
          (e) => e.value == removeOrganizationFeatureRequestType) ??
      defaultValue;
}

String removeOrganizationFeatureRequestTypeExplodedListToJson(
    List<enums.RemoveOrganizationFeatureRequestType>?
        removeOrganizationFeatureRequestType) {
  return removeOrganizationFeatureRequestType?.map((e) => e.value!).join(',') ??
      '';
}

List<String> removeOrganizationFeatureRequestTypeListToJson(
    List<enums.RemoveOrganizationFeatureRequestType>?
        removeOrganizationFeatureRequestType) {
  if (removeOrganizationFeatureRequestType == null) {
    return [];
  }

  return removeOrganizationFeatureRequestType.map((e) => e.value!).toList();
}

List<enums.RemoveOrganizationFeatureRequestType>
    removeOrganizationFeatureRequestTypeListFromJson(
  List? removeOrganizationFeatureRequestType, [
  List<enums.RemoveOrganizationFeatureRequestType>? defaultValue,
]) {
  if (removeOrganizationFeatureRequestType == null) {
    return defaultValue ?? [];
  }

  return removeOrganizationFeatureRequestType
      .map((e) => removeOrganizationFeatureRequestTypeFromJson(e.toString()))
      .toList();
}

List<enums.RemoveOrganizationFeatureRequestType>?
    removeOrganizationFeatureRequestTypeNullableListFromJson(
  List? removeOrganizationFeatureRequestType, [
  List<enums.RemoveOrganizationFeatureRequestType>? defaultValue,
]) {
  if (removeOrganizationFeatureRequestType == null) {
    return defaultValue;
  }

  return removeOrganizationFeatureRequestType
      .map((e) => removeOrganizationFeatureRequestTypeFromJson(e.toString()))
      .toList();
}

String? setOrganizationFeatureRequestTypeNullableToJson(
    enums.SetOrganizationFeatureRequestType?
        setOrganizationFeatureRequestType) {
  return setOrganizationFeatureRequestType?.value;
}

String? setOrganizationFeatureRequestTypeToJson(
    enums.SetOrganizationFeatureRequestType setOrganizationFeatureRequestType) {
  return setOrganizationFeatureRequestType.value;
}

enums.SetOrganizationFeatureRequestType
    setOrganizationFeatureRequestTypeFromJson(
  Object? setOrganizationFeatureRequestType, [
  enums.SetOrganizationFeatureRequestType? defaultValue,
]) {
  return enums.SetOrganizationFeatureRequestType.values.firstWhereOrNull(
          (e) => e.value == setOrganizationFeatureRequestType) ??
      defaultValue ??
      enums.SetOrganizationFeatureRequestType.swaggerGeneratedUnknown;
}

enums.SetOrganizationFeatureRequestType?
    setOrganizationFeatureRequestTypeNullableFromJson(
  Object? setOrganizationFeatureRequestType, [
  enums.SetOrganizationFeatureRequestType? defaultValue,
]) {
  if (setOrganizationFeatureRequestType == null) {
    return null;
  }
  return enums.SetOrganizationFeatureRequestType.values.firstWhereOrNull(
          (e) => e.value == setOrganizationFeatureRequestType) ??
      defaultValue;
}

String setOrganizationFeatureRequestTypeExplodedListToJson(
    List<enums.SetOrganizationFeatureRequestType>?
        setOrganizationFeatureRequestType) {
  return setOrganizationFeatureRequestType?.map((e) => e.value!).join(',') ??
      '';
}

List<String> setOrganizationFeatureRequestTypeListToJson(
    List<enums.SetOrganizationFeatureRequestType>?
        setOrganizationFeatureRequestType) {
  if (setOrganizationFeatureRequestType == null) {
    return [];
  }

  return setOrganizationFeatureRequestType.map((e) => e.value!).toList();
}

List<enums.SetOrganizationFeatureRequestType>
    setOrganizationFeatureRequestTypeListFromJson(
  List? setOrganizationFeatureRequestType, [
  List<enums.SetOrganizationFeatureRequestType>? defaultValue,
]) {
  if (setOrganizationFeatureRequestType == null) {
    return defaultValue ?? [];
  }

  return setOrganizationFeatureRequestType
      .map((e) => setOrganizationFeatureRequestTypeFromJson(e.toString()))
      .toList();
}

List<enums.SetOrganizationFeatureRequestType>?
    setOrganizationFeatureRequestTypeNullableListFromJson(
  List? setOrganizationFeatureRequestType, [
  List<enums.SetOrganizationFeatureRequestType>? defaultValue,
]) {
  if (setOrganizationFeatureRequestType == null) {
    return defaultValue;
  }

  return setOrganizationFeatureRequestType
      .map((e) => setOrganizationFeatureRequestTypeFromJson(e.toString()))
      .toList();
}

String? signRawPayloadRequestTypeNullableToJson(
    enums.SignRawPayloadRequestType? signRawPayloadRequestType) {
  return signRawPayloadRequestType?.value;
}

String? signRawPayloadRequestTypeToJson(
    enums.SignRawPayloadRequestType signRawPayloadRequestType) {
  return signRawPayloadRequestType.value;
}

enums.SignRawPayloadRequestType signRawPayloadRequestTypeFromJson(
  Object? signRawPayloadRequestType, [
  enums.SignRawPayloadRequestType? defaultValue,
]) {
  return enums.SignRawPayloadRequestType.values
          .firstWhereOrNull((e) => e.value == signRawPayloadRequestType) ??
      defaultValue ??
      enums.SignRawPayloadRequestType.swaggerGeneratedUnknown;
}

enums.SignRawPayloadRequestType? signRawPayloadRequestTypeNullableFromJson(
  Object? signRawPayloadRequestType, [
  enums.SignRawPayloadRequestType? defaultValue,
]) {
  if (signRawPayloadRequestType == null) {
    return null;
  }
  return enums.SignRawPayloadRequestType.values
          .firstWhereOrNull((e) => e.value == signRawPayloadRequestType) ??
      defaultValue;
}

String signRawPayloadRequestTypeExplodedListToJson(
    List<enums.SignRawPayloadRequestType>? signRawPayloadRequestType) {
  return signRawPayloadRequestType?.map((e) => e.value!).join(',') ?? '';
}

List<String> signRawPayloadRequestTypeListToJson(
    List<enums.SignRawPayloadRequestType>? signRawPayloadRequestType) {
  if (signRawPayloadRequestType == null) {
    return [];
  }

  return signRawPayloadRequestType.map((e) => e.value!).toList();
}

List<enums.SignRawPayloadRequestType> signRawPayloadRequestTypeListFromJson(
  List? signRawPayloadRequestType, [
  List<enums.SignRawPayloadRequestType>? defaultValue,
]) {
  if (signRawPayloadRequestType == null) {
    return defaultValue ?? [];
  }

  return signRawPayloadRequestType
      .map((e) => signRawPayloadRequestTypeFromJson(e.toString()))
      .toList();
}

List<enums.SignRawPayloadRequestType>?
    signRawPayloadRequestTypeNullableListFromJson(
  List? signRawPayloadRequestType, [
  List<enums.SignRawPayloadRequestType>? defaultValue,
]) {
  if (signRawPayloadRequestType == null) {
    return defaultValue;
  }

  return signRawPayloadRequestType
      .map((e) => signRawPayloadRequestTypeFromJson(e.toString()))
      .toList();
}

String? signRawPayloadsRequestTypeNullableToJson(
    enums.SignRawPayloadsRequestType? signRawPayloadsRequestType) {
  return signRawPayloadsRequestType?.value;
}

String? signRawPayloadsRequestTypeToJson(
    enums.SignRawPayloadsRequestType signRawPayloadsRequestType) {
  return signRawPayloadsRequestType.value;
}

enums.SignRawPayloadsRequestType signRawPayloadsRequestTypeFromJson(
  Object? signRawPayloadsRequestType, [
  enums.SignRawPayloadsRequestType? defaultValue,
]) {
  return enums.SignRawPayloadsRequestType.values
          .firstWhereOrNull((e) => e.value == signRawPayloadsRequestType) ??
      defaultValue ??
      enums.SignRawPayloadsRequestType.swaggerGeneratedUnknown;
}

enums.SignRawPayloadsRequestType? signRawPayloadsRequestTypeNullableFromJson(
  Object? signRawPayloadsRequestType, [
  enums.SignRawPayloadsRequestType? defaultValue,
]) {
  if (signRawPayloadsRequestType == null) {
    return null;
  }
  return enums.SignRawPayloadsRequestType.values
          .firstWhereOrNull((e) => e.value == signRawPayloadsRequestType) ??
      defaultValue;
}

String signRawPayloadsRequestTypeExplodedListToJson(
    List<enums.SignRawPayloadsRequestType>? signRawPayloadsRequestType) {
  return signRawPayloadsRequestType?.map((e) => e.value!).join(',') ?? '';
}

List<String> signRawPayloadsRequestTypeListToJson(
    List<enums.SignRawPayloadsRequestType>? signRawPayloadsRequestType) {
  if (signRawPayloadsRequestType == null) {
    return [];
  }

  return signRawPayloadsRequestType.map((e) => e.value!).toList();
}

List<enums.SignRawPayloadsRequestType> signRawPayloadsRequestTypeListFromJson(
  List? signRawPayloadsRequestType, [
  List<enums.SignRawPayloadsRequestType>? defaultValue,
]) {
  if (signRawPayloadsRequestType == null) {
    return defaultValue ?? [];
  }

  return signRawPayloadsRequestType
      .map((e) => signRawPayloadsRequestTypeFromJson(e.toString()))
      .toList();
}

List<enums.SignRawPayloadsRequestType>?
    signRawPayloadsRequestTypeNullableListFromJson(
  List? signRawPayloadsRequestType, [
  List<enums.SignRawPayloadsRequestType>? defaultValue,
]) {
  if (signRawPayloadsRequestType == null) {
    return defaultValue;
  }

  return signRawPayloadsRequestType
      .map((e) => signRawPayloadsRequestTypeFromJson(e.toString()))
      .toList();
}

String? signTransactionRequestTypeNullableToJson(
    enums.SignTransactionRequestType? signTransactionRequestType) {
  return signTransactionRequestType?.value;
}

String? signTransactionRequestTypeToJson(
    enums.SignTransactionRequestType signTransactionRequestType) {
  return signTransactionRequestType.value;
}

enums.SignTransactionRequestType signTransactionRequestTypeFromJson(
  Object? signTransactionRequestType, [
  enums.SignTransactionRequestType? defaultValue,
]) {
  return enums.SignTransactionRequestType.values
          .firstWhereOrNull((e) => e.value == signTransactionRequestType) ??
      defaultValue ??
      enums.SignTransactionRequestType.swaggerGeneratedUnknown;
}

enums.SignTransactionRequestType? signTransactionRequestTypeNullableFromJson(
  Object? signTransactionRequestType, [
  enums.SignTransactionRequestType? defaultValue,
]) {
  if (signTransactionRequestType == null) {
    return null;
  }
  return enums.SignTransactionRequestType.values
          .firstWhereOrNull((e) => e.value == signTransactionRequestType) ??
      defaultValue;
}

String signTransactionRequestTypeExplodedListToJson(
    List<enums.SignTransactionRequestType>? signTransactionRequestType) {
  return signTransactionRequestType?.map((e) => e.value!).join(',') ?? '';
}

List<String> signTransactionRequestTypeListToJson(
    List<enums.SignTransactionRequestType>? signTransactionRequestType) {
  if (signTransactionRequestType == null) {
    return [];
  }

  return signTransactionRequestType.map((e) => e.value!).toList();
}

List<enums.SignTransactionRequestType> signTransactionRequestTypeListFromJson(
  List? signTransactionRequestType, [
  List<enums.SignTransactionRequestType>? defaultValue,
]) {
  if (signTransactionRequestType == null) {
    return defaultValue ?? [];
  }

  return signTransactionRequestType
      .map((e) => signTransactionRequestTypeFromJson(e.toString()))
      .toList();
}

List<enums.SignTransactionRequestType>?
    signTransactionRequestTypeNullableListFromJson(
  List? signTransactionRequestType, [
  List<enums.SignTransactionRequestType>? defaultValue,
]) {
  if (signTransactionRequestType == null) {
    return defaultValue;
  }

  return signTransactionRequestType
      .map((e) => signTransactionRequestTypeFromJson(e.toString()))
      .toList();
}

String? smartContractInterfaceTypeNullableToJson(
    enums.SmartContractInterfaceType? smartContractInterfaceType) {
  return smartContractInterfaceType?.value;
}

String? smartContractInterfaceTypeToJson(
    enums.SmartContractInterfaceType smartContractInterfaceType) {
  return smartContractInterfaceType.value;
}

enums.SmartContractInterfaceType smartContractInterfaceTypeFromJson(
  Object? smartContractInterfaceType, [
  enums.SmartContractInterfaceType? defaultValue,
]) {
  return enums.SmartContractInterfaceType.values
          .firstWhereOrNull((e) => e.value == smartContractInterfaceType) ??
      defaultValue ??
      enums.SmartContractInterfaceType.swaggerGeneratedUnknown;
}

enums.SmartContractInterfaceType? smartContractInterfaceTypeNullableFromJson(
  Object? smartContractInterfaceType, [
  enums.SmartContractInterfaceType? defaultValue,
]) {
  if (smartContractInterfaceType == null) {
    return null;
  }
  return enums.SmartContractInterfaceType.values
          .firstWhereOrNull((e) => e.value == smartContractInterfaceType) ??
      defaultValue;
}

String smartContractInterfaceTypeExplodedListToJson(
    List<enums.SmartContractInterfaceType>? smartContractInterfaceType) {
  return smartContractInterfaceType?.map((e) => e.value!).join(',') ?? '';
}

List<String> smartContractInterfaceTypeListToJson(
    List<enums.SmartContractInterfaceType>? smartContractInterfaceType) {
  if (smartContractInterfaceType == null) {
    return [];
  }

  return smartContractInterfaceType.map((e) => e.value!).toList();
}

List<enums.SmartContractInterfaceType> smartContractInterfaceTypeListFromJson(
  List? smartContractInterfaceType, [
  List<enums.SmartContractInterfaceType>? defaultValue,
]) {
  if (smartContractInterfaceType == null) {
    return defaultValue ?? [];
  }

  return smartContractInterfaceType
      .map((e) => smartContractInterfaceTypeFromJson(e.toString()))
      .toList();
}

List<enums.SmartContractInterfaceType>?
    smartContractInterfaceTypeNullableListFromJson(
  List? smartContractInterfaceType, [
  List<enums.SmartContractInterfaceType>? defaultValue,
]) {
  if (smartContractInterfaceType == null) {
    return defaultValue;
  }

  return smartContractInterfaceType
      .map((e) => smartContractInterfaceTypeFromJson(e.toString()))
      .toList();
}

String? stampLoginRequestTypeNullableToJson(
    enums.StampLoginRequestType? stampLoginRequestType) {
  return stampLoginRequestType?.value;
}

String? stampLoginRequestTypeToJson(
    enums.StampLoginRequestType stampLoginRequestType) {
  return stampLoginRequestType.value;
}

enums.StampLoginRequestType stampLoginRequestTypeFromJson(
  Object? stampLoginRequestType, [
  enums.StampLoginRequestType? defaultValue,
]) {
  return enums.StampLoginRequestType.values
          .firstWhereOrNull((e) => e.value == stampLoginRequestType) ??
      defaultValue ??
      enums.StampLoginRequestType.swaggerGeneratedUnknown;
}

enums.StampLoginRequestType? stampLoginRequestTypeNullableFromJson(
  Object? stampLoginRequestType, [
  enums.StampLoginRequestType? defaultValue,
]) {
  if (stampLoginRequestType == null) {
    return null;
  }
  return enums.StampLoginRequestType.values
          .firstWhereOrNull((e) => e.value == stampLoginRequestType) ??
      defaultValue;
}

String stampLoginRequestTypeExplodedListToJson(
    List<enums.StampLoginRequestType>? stampLoginRequestType) {
  return stampLoginRequestType?.map((e) => e.value!).join(',') ?? '';
}

List<String> stampLoginRequestTypeListToJson(
    List<enums.StampLoginRequestType>? stampLoginRequestType) {
  if (stampLoginRequestType == null) {
    return [];
  }

  return stampLoginRequestType.map((e) => e.value!).toList();
}

List<enums.StampLoginRequestType> stampLoginRequestTypeListFromJson(
  List? stampLoginRequestType, [
  List<enums.StampLoginRequestType>? defaultValue,
]) {
  if (stampLoginRequestType == null) {
    return defaultValue ?? [];
  }

  return stampLoginRequestType
      .map((e) => stampLoginRequestTypeFromJson(e.toString()))
      .toList();
}

List<enums.StampLoginRequestType>? stampLoginRequestTypeNullableListFromJson(
  List? stampLoginRequestType, [
  List<enums.StampLoginRequestType>? defaultValue,
]) {
  if (stampLoginRequestType == null) {
    return defaultValue;
  }

  return stampLoginRequestType
      .map((e) => stampLoginRequestTypeFromJson(e.toString()))
      .toList();
}

String? tagTypeNullableToJson(enums.TagType? tagType) {
  return tagType?.value;
}

String? tagTypeToJson(enums.TagType tagType) {
  return tagType.value;
}

enums.TagType tagTypeFromJson(
  Object? tagType, [
  enums.TagType? defaultValue,
]) {
  return enums.TagType.values.firstWhereOrNull((e) => e.value == tagType) ??
      defaultValue ??
      enums.TagType.swaggerGeneratedUnknown;
}

enums.TagType? tagTypeNullableFromJson(
  Object? tagType, [
  enums.TagType? defaultValue,
]) {
  if (tagType == null) {
    return null;
  }
  return enums.TagType.values.firstWhereOrNull((e) => e.value == tagType) ??
      defaultValue;
}

String tagTypeExplodedListToJson(List<enums.TagType>? tagType) {
  return tagType?.map((e) => e.value!).join(',') ?? '';
}

List<String> tagTypeListToJson(List<enums.TagType>? tagType) {
  if (tagType == null) {
    return [];
  }

  return tagType.map((e) => e.value!).toList();
}

List<enums.TagType> tagTypeListFromJson(
  List? tagType, [
  List<enums.TagType>? defaultValue,
]) {
  if (tagType == null) {
    return defaultValue ?? [];
  }

  return tagType.map((e) => tagTypeFromJson(e.toString())).toList();
}

List<enums.TagType>? tagTypeNullableListFromJson(
  List? tagType, [
  List<enums.TagType>? defaultValue,
]) {
  if (tagType == null) {
    return defaultValue;
  }

  return tagType.map((e) => tagTypeFromJson(e.toString())).toList();
}

String? transactionTypeNullableToJson(enums.TransactionType? transactionType) {
  return transactionType?.value;
}

String? transactionTypeToJson(enums.TransactionType transactionType) {
  return transactionType.value;
}

enums.TransactionType transactionTypeFromJson(
  Object? transactionType, [
  enums.TransactionType? defaultValue,
]) {
  return enums.TransactionType.values
          .firstWhereOrNull((e) => e.value == transactionType) ??
      defaultValue ??
      enums.TransactionType.swaggerGeneratedUnknown;
}

enums.TransactionType? transactionTypeNullableFromJson(
  Object? transactionType, [
  enums.TransactionType? defaultValue,
]) {
  if (transactionType == null) {
    return null;
  }
  return enums.TransactionType.values
          .firstWhereOrNull((e) => e.value == transactionType) ??
      defaultValue;
}

String transactionTypeExplodedListToJson(
    List<enums.TransactionType>? transactionType) {
  return transactionType?.map((e) => e.value!).join(',') ?? '';
}

List<String> transactionTypeListToJson(
    List<enums.TransactionType>? transactionType) {
  if (transactionType == null) {
    return [];
  }

  return transactionType.map((e) => e.value!).toList();
}

List<enums.TransactionType> transactionTypeListFromJson(
  List? transactionType, [
  List<enums.TransactionType>? defaultValue,
]) {
  if (transactionType == null) {
    return defaultValue ?? [];
  }

  return transactionType
      .map((e) => transactionTypeFromJson(e.toString()))
      .toList();
}

List<enums.TransactionType>? transactionTypeNullableListFromJson(
  List? transactionType, [
  List<enums.TransactionType>? defaultValue,
]) {
  if (transactionType == null) {
    return defaultValue;
  }

  return transactionType
      .map((e) => transactionTypeFromJson(e.toString()))
      .toList();
}

String? updatePolicyRequestTypeNullableToJson(
    enums.UpdatePolicyRequestType? updatePolicyRequestType) {
  return updatePolicyRequestType?.value;
}

String? updatePolicyRequestTypeToJson(
    enums.UpdatePolicyRequestType updatePolicyRequestType) {
  return updatePolicyRequestType.value;
}

enums.UpdatePolicyRequestType updatePolicyRequestTypeFromJson(
  Object? updatePolicyRequestType, [
  enums.UpdatePolicyRequestType? defaultValue,
]) {
  return enums.UpdatePolicyRequestType.values
          .firstWhereOrNull((e) => e.value == updatePolicyRequestType) ??
      defaultValue ??
      enums.UpdatePolicyRequestType.swaggerGeneratedUnknown;
}

enums.UpdatePolicyRequestType? updatePolicyRequestTypeNullableFromJson(
  Object? updatePolicyRequestType, [
  enums.UpdatePolicyRequestType? defaultValue,
]) {
  if (updatePolicyRequestType == null) {
    return null;
  }
  return enums.UpdatePolicyRequestType.values
          .firstWhereOrNull((e) => e.value == updatePolicyRequestType) ??
      defaultValue;
}

String updatePolicyRequestTypeExplodedListToJson(
    List<enums.UpdatePolicyRequestType>? updatePolicyRequestType) {
  return updatePolicyRequestType?.map((e) => e.value!).join(',') ?? '';
}

List<String> updatePolicyRequestTypeListToJson(
    List<enums.UpdatePolicyRequestType>? updatePolicyRequestType) {
  if (updatePolicyRequestType == null) {
    return [];
  }

  return updatePolicyRequestType.map((e) => e.value!).toList();
}

List<enums.UpdatePolicyRequestType> updatePolicyRequestTypeListFromJson(
  List? updatePolicyRequestType, [
  List<enums.UpdatePolicyRequestType>? defaultValue,
]) {
  if (updatePolicyRequestType == null) {
    return defaultValue ?? [];
  }

  return updatePolicyRequestType
      .map((e) => updatePolicyRequestTypeFromJson(e.toString()))
      .toList();
}

List<enums.UpdatePolicyRequestType>?
    updatePolicyRequestTypeNullableListFromJson(
  List? updatePolicyRequestType, [
  List<enums.UpdatePolicyRequestType>? defaultValue,
]) {
  if (updatePolicyRequestType == null) {
    return defaultValue;
  }

  return updatePolicyRequestType
      .map((e) => updatePolicyRequestTypeFromJson(e.toString()))
      .toList();
}

String? updatePrivateKeyTagRequestTypeNullableToJson(
    enums.UpdatePrivateKeyTagRequestType? updatePrivateKeyTagRequestType) {
  return updatePrivateKeyTagRequestType?.value;
}

String? updatePrivateKeyTagRequestTypeToJson(
    enums.UpdatePrivateKeyTagRequestType updatePrivateKeyTagRequestType) {
  return updatePrivateKeyTagRequestType.value;
}

enums.UpdatePrivateKeyTagRequestType updatePrivateKeyTagRequestTypeFromJson(
  Object? updatePrivateKeyTagRequestType, [
  enums.UpdatePrivateKeyTagRequestType? defaultValue,
]) {
  return enums.UpdatePrivateKeyTagRequestType.values
          .firstWhereOrNull((e) => e.value == updatePrivateKeyTagRequestType) ??
      defaultValue ??
      enums.UpdatePrivateKeyTagRequestType.swaggerGeneratedUnknown;
}

enums.UpdatePrivateKeyTagRequestType?
    updatePrivateKeyTagRequestTypeNullableFromJson(
  Object? updatePrivateKeyTagRequestType, [
  enums.UpdatePrivateKeyTagRequestType? defaultValue,
]) {
  if (updatePrivateKeyTagRequestType == null) {
    return null;
  }
  return enums.UpdatePrivateKeyTagRequestType.values
          .firstWhereOrNull((e) => e.value == updatePrivateKeyTagRequestType) ??
      defaultValue;
}

String updatePrivateKeyTagRequestTypeExplodedListToJson(
    List<enums.UpdatePrivateKeyTagRequestType>?
        updatePrivateKeyTagRequestType) {
  return updatePrivateKeyTagRequestType?.map((e) => e.value!).join(',') ?? '';
}

List<String> updatePrivateKeyTagRequestTypeListToJson(
    List<enums.UpdatePrivateKeyTagRequestType>?
        updatePrivateKeyTagRequestType) {
  if (updatePrivateKeyTagRequestType == null) {
    return [];
  }

  return updatePrivateKeyTagRequestType.map((e) => e.value!).toList();
}

List<enums.UpdatePrivateKeyTagRequestType>
    updatePrivateKeyTagRequestTypeListFromJson(
  List? updatePrivateKeyTagRequestType, [
  List<enums.UpdatePrivateKeyTagRequestType>? defaultValue,
]) {
  if (updatePrivateKeyTagRequestType == null) {
    return defaultValue ?? [];
  }

  return updatePrivateKeyTagRequestType
      .map((e) => updatePrivateKeyTagRequestTypeFromJson(e.toString()))
      .toList();
}

List<enums.UpdatePrivateKeyTagRequestType>?
    updatePrivateKeyTagRequestTypeNullableListFromJson(
  List? updatePrivateKeyTagRequestType, [
  List<enums.UpdatePrivateKeyTagRequestType>? defaultValue,
]) {
  if (updatePrivateKeyTagRequestType == null) {
    return defaultValue;
  }

  return updatePrivateKeyTagRequestType
      .map((e) => updatePrivateKeyTagRequestTypeFromJson(e.toString()))
      .toList();
}

String? updateRootQuorumRequestTypeNullableToJson(
    enums.UpdateRootQuorumRequestType? updateRootQuorumRequestType) {
  return updateRootQuorumRequestType?.value;
}

String? updateRootQuorumRequestTypeToJson(
    enums.UpdateRootQuorumRequestType updateRootQuorumRequestType) {
  return updateRootQuorumRequestType.value;
}

enums.UpdateRootQuorumRequestType updateRootQuorumRequestTypeFromJson(
  Object? updateRootQuorumRequestType, [
  enums.UpdateRootQuorumRequestType? defaultValue,
]) {
  return enums.UpdateRootQuorumRequestType.values
          .firstWhereOrNull((e) => e.value == updateRootQuorumRequestType) ??
      defaultValue ??
      enums.UpdateRootQuorumRequestType.swaggerGeneratedUnknown;
}

enums.UpdateRootQuorumRequestType? updateRootQuorumRequestTypeNullableFromJson(
  Object? updateRootQuorumRequestType, [
  enums.UpdateRootQuorumRequestType? defaultValue,
]) {
  if (updateRootQuorumRequestType == null) {
    return null;
  }
  return enums.UpdateRootQuorumRequestType.values
          .firstWhereOrNull((e) => e.value == updateRootQuorumRequestType) ??
      defaultValue;
}

String updateRootQuorumRequestTypeExplodedListToJson(
    List<enums.UpdateRootQuorumRequestType>? updateRootQuorumRequestType) {
  return updateRootQuorumRequestType?.map((e) => e.value!).join(',') ?? '';
}

List<String> updateRootQuorumRequestTypeListToJson(
    List<enums.UpdateRootQuorumRequestType>? updateRootQuorumRequestType) {
  if (updateRootQuorumRequestType == null) {
    return [];
  }

  return updateRootQuorumRequestType.map((e) => e.value!).toList();
}

List<enums.UpdateRootQuorumRequestType> updateRootQuorumRequestTypeListFromJson(
  List? updateRootQuorumRequestType, [
  List<enums.UpdateRootQuorumRequestType>? defaultValue,
]) {
  if (updateRootQuorumRequestType == null) {
    return defaultValue ?? [];
  }

  return updateRootQuorumRequestType
      .map((e) => updateRootQuorumRequestTypeFromJson(e.toString()))
      .toList();
}

List<enums.UpdateRootQuorumRequestType>?
    updateRootQuorumRequestTypeNullableListFromJson(
  List? updateRootQuorumRequestType, [
  List<enums.UpdateRootQuorumRequestType>? defaultValue,
]) {
  if (updateRootQuorumRequestType == null) {
    return defaultValue;
  }

  return updateRootQuorumRequestType
      .map((e) => updateRootQuorumRequestTypeFromJson(e.toString()))
      .toList();
}

String? updateUserEmailRequestTypeNullableToJson(
    enums.UpdateUserEmailRequestType? updateUserEmailRequestType) {
  return updateUserEmailRequestType?.value;
}

String? updateUserEmailRequestTypeToJson(
    enums.UpdateUserEmailRequestType updateUserEmailRequestType) {
  return updateUserEmailRequestType.value;
}

enums.UpdateUserEmailRequestType updateUserEmailRequestTypeFromJson(
  Object? updateUserEmailRequestType, [
  enums.UpdateUserEmailRequestType? defaultValue,
]) {
  return enums.UpdateUserEmailRequestType.values
          .firstWhereOrNull((e) => e.value == updateUserEmailRequestType) ??
      defaultValue ??
      enums.UpdateUserEmailRequestType.swaggerGeneratedUnknown;
}

enums.UpdateUserEmailRequestType? updateUserEmailRequestTypeNullableFromJson(
  Object? updateUserEmailRequestType, [
  enums.UpdateUserEmailRequestType? defaultValue,
]) {
  if (updateUserEmailRequestType == null) {
    return null;
  }
  return enums.UpdateUserEmailRequestType.values
          .firstWhereOrNull((e) => e.value == updateUserEmailRequestType) ??
      defaultValue;
}

String updateUserEmailRequestTypeExplodedListToJson(
    List<enums.UpdateUserEmailRequestType>? updateUserEmailRequestType) {
  return updateUserEmailRequestType?.map((e) => e.value!).join(',') ?? '';
}

List<String> updateUserEmailRequestTypeListToJson(
    List<enums.UpdateUserEmailRequestType>? updateUserEmailRequestType) {
  if (updateUserEmailRequestType == null) {
    return [];
  }

  return updateUserEmailRequestType.map((e) => e.value!).toList();
}

List<enums.UpdateUserEmailRequestType> updateUserEmailRequestTypeListFromJson(
  List? updateUserEmailRequestType, [
  List<enums.UpdateUserEmailRequestType>? defaultValue,
]) {
  if (updateUserEmailRequestType == null) {
    return defaultValue ?? [];
  }

  return updateUserEmailRequestType
      .map((e) => updateUserEmailRequestTypeFromJson(e.toString()))
      .toList();
}

List<enums.UpdateUserEmailRequestType>?
    updateUserEmailRequestTypeNullableListFromJson(
  List? updateUserEmailRequestType, [
  List<enums.UpdateUserEmailRequestType>? defaultValue,
]) {
  if (updateUserEmailRequestType == null) {
    return defaultValue;
  }

  return updateUserEmailRequestType
      .map((e) => updateUserEmailRequestTypeFromJson(e.toString()))
      .toList();
}

String? updateUserNameRequestTypeNullableToJson(
    enums.UpdateUserNameRequestType? updateUserNameRequestType) {
  return updateUserNameRequestType?.value;
}

String? updateUserNameRequestTypeToJson(
    enums.UpdateUserNameRequestType updateUserNameRequestType) {
  return updateUserNameRequestType.value;
}

enums.UpdateUserNameRequestType updateUserNameRequestTypeFromJson(
  Object? updateUserNameRequestType, [
  enums.UpdateUserNameRequestType? defaultValue,
]) {
  return enums.UpdateUserNameRequestType.values
          .firstWhereOrNull((e) => e.value == updateUserNameRequestType) ??
      defaultValue ??
      enums.UpdateUserNameRequestType.swaggerGeneratedUnknown;
}

enums.UpdateUserNameRequestType? updateUserNameRequestTypeNullableFromJson(
  Object? updateUserNameRequestType, [
  enums.UpdateUserNameRequestType? defaultValue,
]) {
  if (updateUserNameRequestType == null) {
    return null;
  }
  return enums.UpdateUserNameRequestType.values
          .firstWhereOrNull((e) => e.value == updateUserNameRequestType) ??
      defaultValue;
}

String updateUserNameRequestTypeExplodedListToJson(
    List<enums.UpdateUserNameRequestType>? updateUserNameRequestType) {
  return updateUserNameRequestType?.map((e) => e.value!).join(',') ?? '';
}

List<String> updateUserNameRequestTypeListToJson(
    List<enums.UpdateUserNameRequestType>? updateUserNameRequestType) {
  if (updateUserNameRequestType == null) {
    return [];
  }

  return updateUserNameRequestType.map((e) => e.value!).toList();
}

List<enums.UpdateUserNameRequestType> updateUserNameRequestTypeListFromJson(
  List? updateUserNameRequestType, [
  List<enums.UpdateUserNameRequestType>? defaultValue,
]) {
  if (updateUserNameRequestType == null) {
    return defaultValue ?? [];
  }

  return updateUserNameRequestType
      .map((e) => updateUserNameRequestTypeFromJson(e.toString()))
      .toList();
}

List<enums.UpdateUserNameRequestType>?
    updateUserNameRequestTypeNullableListFromJson(
  List? updateUserNameRequestType, [
  List<enums.UpdateUserNameRequestType>? defaultValue,
]) {
  if (updateUserNameRequestType == null) {
    return defaultValue;
  }

  return updateUserNameRequestType
      .map((e) => updateUserNameRequestTypeFromJson(e.toString()))
      .toList();
}

String? updateUserPhoneNumberRequestTypeNullableToJson(
    enums.UpdateUserPhoneNumberRequestType? updateUserPhoneNumberRequestType) {
  return updateUserPhoneNumberRequestType?.value;
}

String? updateUserPhoneNumberRequestTypeToJson(
    enums.UpdateUserPhoneNumberRequestType updateUserPhoneNumberRequestType) {
  return updateUserPhoneNumberRequestType.value;
}

enums.UpdateUserPhoneNumberRequestType updateUserPhoneNumberRequestTypeFromJson(
  Object? updateUserPhoneNumberRequestType, [
  enums.UpdateUserPhoneNumberRequestType? defaultValue,
]) {
  return enums.UpdateUserPhoneNumberRequestType.values.firstWhereOrNull(
          (e) => e.value == updateUserPhoneNumberRequestType) ??
      defaultValue ??
      enums.UpdateUserPhoneNumberRequestType.swaggerGeneratedUnknown;
}

enums.UpdateUserPhoneNumberRequestType?
    updateUserPhoneNumberRequestTypeNullableFromJson(
  Object? updateUserPhoneNumberRequestType, [
  enums.UpdateUserPhoneNumberRequestType? defaultValue,
]) {
  if (updateUserPhoneNumberRequestType == null) {
    return null;
  }
  return enums.UpdateUserPhoneNumberRequestType.values.firstWhereOrNull(
          (e) => e.value == updateUserPhoneNumberRequestType) ??
      defaultValue;
}

String updateUserPhoneNumberRequestTypeExplodedListToJson(
    List<enums.UpdateUserPhoneNumberRequestType>?
        updateUserPhoneNumberRequestType) {
  return updateUserPhoneNumberRequestType?.map((e) => e.value!).join(',') ?? '';
}

List<String> updateUserPhoneNumberRequestTypeListToJson(
    List<enums.UpdateUserPhoneNumberRequestType>?
        updateUserPhoneNumberRequestType) {
  if (updateUserPhoneNumberRequestType == null) {
    return [];
  }

  return updateUserPhoneNumberRequestType.map((e) => e.value!).toList();
}

List<enums.UpdateUserPhoneNumberRequestType>
    updateUserPhoneNumberRequestTypeListFromJson(
  List? updateUserPhoneNumberRequestType, [
  List<enums.UpdateUserPhoneNumberRequestType>? defaultValue,
]) {
  if (updateUserPhoneNumberRequestType == null) {
    return defaultValue ?? [];
  }

  return updateUserPhoneNumberRequestType
      .map((e) => updateUserPhoneNumberRequestTypeFromJson(e.toString()))
      .toList();
}

List<enums.UpdateUserPhoneNumberRequestType>?
    updateUserPhoneNumberRequestTypeNullableListFromJson(
  List? updateUserPhoneNumberRequestType, [
  List<enums.UpdateUserPhoneNumberRequestType>? defaultValue,
]) {
  if (updateUserPhoneNumberRequestType == null) {
    return defaultValue;
  }

  return updateUserPhoneNumberRequestType
      .map((e) => updateUserPhoneNumberRequestTypeFromJson(e.toString()))
      .toList();
}

String? updateUserRequestTypeNullableToJson(
    enums.UpdateUserRequestType? updateUserRequestType) {
  return updateUserRequestType?.value;
}

String? updateUserRequestTypeToJson(
    enums.UpdateUserRequestType updateUserRequestType) {
  return updateUserRequestType.value;
}

enums.UpdateUserRequestType updateUserRequestTypeFromJson(
  Object? updateUserRequestType, [
  enums.UpdateUserRequestType? defaultValue,
]) {
  return enums.UpdateUserRequestType.values
          .firstWhereOrNull((e) => e.value == updateUserRequestType) ??
      defaultValue ??
      enums.UpdateUserRequestType.swaggerGeneratedUnknown;
}

enums.UpdateUserRequestType? updateUserRequestTypeNullableFromJson(
  Object? updateUserRequestType, [
  enums.UpdateUserRequestType? defaultValue,
]) {
  if (updateUserRequestType == null) {
    return null;
  }
  return enums.UpdateUserRequestType.values
          .firstWhereOrNull((e) => e.value == updateUserRequestType) ??
      defaultValue;
}

String updateUserRequestTypeExplodedListToJson(
    List<enums.UpdateUserRequestType>? updateUserRequestType) {
  return updateUserRequestType?.map((e) => e.value!).join(',') ?? '';
}

List<String> updateUserRequestTypeListToJson(
    List<enums.UpdateUserRequestType>? updateUserRequestType) {
  if (updateUserRequestType == null) {
    return [];
  }

  return updateUserRequestType.map((e) => e.value!).toList();
}

List<enums.UpdateUserRequestType> updateUserRequestTypeListFromJson(
  List? updateUserRequestType, [
  List<enums.UpdateUserRequestType>? defaultValue,
]) {
  if (updateUserRequestType == null) {
    return defaultValue ?? [];
  }

  return updateUserRequestType
      .map((e) => updateUserRequestTypeFromJson(e.toString()))
      .toList();
}

List<enums.UpdateUserRequestType>? updateUserRequestTypeNullableListFromJson(
  List? updateUserRequestType, [
  List<enums.UpdateUserRequestType>? defaultValue,
]) {
  if (updateUserRequestType == null) {
    return defaultValue;
  }

  return updateUserRequestType
      .map((e) => updateUserRequestTypeFromJson(e.toString()))
      .toList();
}

String? updateUserTagRequestTypeNullableToJson(
    enums.UpdateUserTagRequestType? updateUserTagRequestType) {
  return updateUserTagRequestType?.value;
}

String? updateUserTagRequestTypeToJson(
    enums.UpdateUserTagRequestType updateUserTagRequestType) {
  return updateUserTagRequestType.value;
}

enums.UpdateUserTagRequestType updateUserTagRequestTypeFromJson(
  Object? updateUserTagRequestType, [
  enums.UpdateUserTagRequestType? defaultValue,
]) {
  return enums.UpdateUserTagRequestType.values
          .firstWhereOrNull((e) => e.value == updateUserTagRequestType) ??
      defaultValue ??
      enums.UpdateUserTagRequestType.swaggerGeneratedUnknown;
}

enums.UpdateUserTagRequestType? updateUserTagRequestTypeNullableFromJson(
  Object? updateUserTagRequestType, [
  enums.UpdateUserTagRequestType? defaultValue,
]) {
  if (updateUserTagRequestType == null) {
    return null;
  }
  return enums.UpdateUserTagRequestType.values
          .firstWhereOrNull((e) => e.value == updateUserTagRequestType) ??
      defaultValue;
}

String updateUserTagRequestTypeExplodedListToJson(
    List<enums.UpdateUserTagRequestType>? updateUserTagRequestType) {
  return updateUserTagRequestType?.map((e) => e.value!).join(',') ?? '';
}

List<String> updateUserTagRequestTypeListToJson(
    List<enums.UpdateUserTagRequestType>? updateUserTagRequestType) {
  if (updateUserTagRequestType == null) {
    return [];
  }

  return updateUserTagRequestType.map((e) => e.value!).toList();
}

List<enums.UpdateUserTagRequestType> updateUserTagRequestTypeListFromJson(
  List? updateUserTagRequestType, [
  List<enums.UpdateUserTagRequestType>? defaultValue,
]) {
  if (updateUserTagRequestType == null) {
    return defaultValue ?? [];
  }

  return updateUserTagRequestType
      .map((e) => updateUserTagRequestTypeFromJson(e.toString()))
      .toList();
}

List<enums.UpdateUserTagRequestType>?
    updateUserTagRequestTypeNullableListFromJson(
  List? updateUserTagRequestType, [
  List<enums.UpdateUserTagRequestType>? defaultValue,
]) {
  if (updateUserTagRequestType == null) {
    return defaultValue;
  }

  return updateUserTagRequestType
      .map((e) => updateUserTagRequestTypeFromJson(e.toString()))
      .toList();
}

String? updateWalletRequestTypeNullableToJson(
    enums.UpdateWalletRequestType? updateWalletRequestType) {
  return updateWalletRequestType?.value;
}

String? updateWalletRequestTypeToJson(
    enums.UpdateWalletRequestType updateWalletRequestType) {
  return updateWalletRequestType.value;
}

enums.UpdateWalletRequestType updateWalletRequestTypeFromJson(
  Object? updateWalletRequestType, [
  enums.UpdateWalletRequestType? defaultValue,
]) {
  return enums.UpdateWalletRequestType.values
          .firstWhereOrNull((e) => e.value == updateWalletRequestType) ??
      defaultValue ??
      enums.UpdateWalletRequestType.swaggerGeneratedUnknown;
}

enums.UpdateWalletRequestType? updateWalletRequestTypeNullableFromJson(
  Object? updateWalletRequestType, [
  enums.UpdateWalletRequestType? defaultValue,
]) {
  if (updateWalletRequestType == null) {
    return null;
  }
  return enums.UpdateWalletRequestType.values
          .firstWhereOrNull((e) => e.value == updateWalletRequestType) ??
      defaultValue;
}

String updateWalletRequestTypeExplodedListToJson(
    List<enums.UpdateWalletRequestType>? updateWalletRequestType) {
  return updateWalletRequestType?.map((e) => e.value!).join(',') ?? '';
}

List<String> updateWalletRequestTypeListToJson(
    List<enums.UpdateWalletRequestType>? updateWalletRequestType) {
  if (updateWalletRequestType == null) {
    return [];
  }

  return updateWalletRequestType.map((e) => e.value!).toList();
}

List<enums.UpdateWalletRequestType> updateWalletRequestTypeListFromJson(
  List? updateWalletRequestType, [
  List<enums.UpdateWalletRequestType>? defaultValue,
]) {
  if (updateWalletRequestType == null) {
    return defaultValue ?? [];
  }

  return updateWalletRequestType
      .map((e) => updateWalletRequestTypeFromJson(e.toString()))
      .toList();
}

List<enums.UpdateWalletRequestType>?
    updateWalletRequestTypeNullableListFromJson(
  List? updateWalletRequestType, [
  List<enums.UpdateWalletRequestType>? defaultValue,
]) {
  if (updateWalletRequestType == null) {
    return defaultValue;
  }

  return updateWalletRequestType
      .map((e) => updateWalletRequestTypeFromJson(e.toString()))
      .toList();
}

String? verifyOtpRequestTypeNullableToJson(
    enums.VerifyOtpRequestType? verifyOtpRequestType) {
  return verifyOtpRequestType?.value;
}

String? verifyOtpRequestTypeToJson(
    enums.VerifyOtpRequestType verifyOtpRequestType) {
  return verifyOtpRequestType.value;
}

enums.VerifyOtpRequestType verifyOtpRequestTypeFromJson(
  Object? verifyOtpRequestType, [
  enums.VerifyOtpRequestType? defaultValue,
]) {
  return enums.VerifyOtpRequestType.values
          .firstWhereOrNull((e) => e.value == verifyOtpRequestType) ??
      defaultValue ??
      enums.VerifyOtpRequestType.swaggerGeneratedUnknown;
}

enums.VerifyOtpRequestType? verifyOtpRequestTypeNullableFromJson(
  Object? verifyOtpRequestType, [
  enums.VerifyOtpRequestType? defaultValue,
]) {
  if (verifyOtpRequestType == null) {
    return null;
  }
  return enums.VerifyOtpRequestType.values
          .firstWhereOrNull((e) => e.value == verifyOtpRequestType) ??
      defaultValue;
}

String verifyOtpRequestTypeExplodedListToJson(
    List<enums.VerifyOtpRequestType>? verifyOtpRequestType) {
  return verifyOtpRequestType?.map((e) => e.value!).join(',') ?? '';
}

List<String> verifyOtpRequestTypeListToJson(
    List<enums.VerifyOtpRequestType>? verifyOtpRequestType) {
  if (verifyOtpRequestType == null) {
    return [];
  }

  return verifyOtpRequestType.map((e) => e.value!).toList();
}

List<enums.VerifyOtpRequestType> verifyOtpRequestTypeListFromJson(
  List? verifyOtpRequestType, [
  List<enums.VerifyOtpRequestType>? defaultValue,
]) {
  if (verifyOtpRequestType == null) {
    return defaultValue ?? [];
  }

  return verifyOtpRequestType
      .map((e) => verifyOtpRequestTypeFromJson(e.toString()))
      .toList();
}

List<enums.VerifyOtpRequestType>? verifyOtpRequestTypeNullableListFromJson(
  List? verifyOtpRequestType, [
  List<enums.VerifyOtpRequestType>? defaultValue,
]) {
  if (verifyOtpRequestType == null) {
    return defaultValue;
  }

  return verifyOtpRequestType
      .map((e) => verifyOtpRequestTypeFromJson(e.toString()))
      .toList();
}

String? voteSelectionNullableToJson(enums.VoteSelection? voteSelection) {
  return voteSelection?.value;
}

String? voteSelectionToJson(enums.VoteSelection voteSelection) {
  return voteSelection.value;
}

enums.VoteSelection voteSelectionFromJson(
  Object? voteSelection, [
  enums.VoteSelection? defaultValue,
]) {
  return enums.VoteSelection.values
          .firstWhereOrNull((e) => e.value == voteSelection) ??
      defaultValue ??
      enums.VoteSelection.swaggerGeneratedUnknown;
}

enums.VoteSelection? voteSelectionNullableFromJson(
  Object? voteSelection, [
  enums.VoteSelection? defaultValue,
]) {
  if (voteSelection == null) {
    return null;
  }
  return enums.VoteSelection.values
          .firstWhereOrNull((e) => e.value == voteSelection) ??
      defaultValue;
}

String voteSelectionExplodedListToJson(
    List<enums.VoteSelection>? voteSelection) {
  return voteSelection?.map((e) => e.value!).join(',') ?? '';
}

List<String> voteSelectionListToJson(List<enums.VoteSelection>? voteSelection) {
  if (voteSelection == null) {
    return [];
  }

  return voteSelection.map((e) => e.value!).toList();
}

List<enums.VoteSelection> voteSelectionListFromJson(
  List? voteSelection, [
  List<enums.VoteSelection>? defaultValue,
]) {
  if (voteSelection == null) {
    return defaultValue ?? [];
  }

  return voteSelection.map((e) => voteSelectionFromJson(e.toString())).toList();
}

List<enums.VoteSelection>? voteSelectionNullableListFromJson(
  List? voteSelection, [
  List<enums.VoteSelection>? defaultValue,
]) {
  if (voteSelection == null) {
    return defaultValue;
  }

  return voteSelection.map((e) => voteSelectionFromJson(e.toString())).toList();
}

// ignore: unused_element
String? _dateToJson(DateTime? date) {
  if (date == null) {
    return null;
  }

  final year = date.year.toString();
  final month = date.month < 10 ? '0${date.month}' : date.month.toString();
  final day = date.day < 10 ? '0${date.day}' : date.day.toString();

  return '$year-$month-$day';
}

class Wrapped<T> {
  final T value;
  const Wrapped.value(this.value);
}
