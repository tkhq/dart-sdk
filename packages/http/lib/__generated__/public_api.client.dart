/* @generated by `turnkey_codegen`. DO NOT EDIT BY HAND */

import "models.dart";
import "../base.dart";
import "../version.dart";
import "dart:convert";
import "dart:async";
import "dart:io";

/// HTTP Client for interacting with Turnkey API
class TurnkeyClient {
  final THttpConfig config;
  final TStamper stamper;

  TurnkeyClient({required this.config, required this.stamper}) {
    if (config.baseUrl.isEmpty) {
      throw Exception('Missing base URL. Please verify environment variables.');
    }
  }

  Future<TResponseType> request<TBodyType, TResponseType>(
    String url,
    TBodyType body,
    TResponseType Function(Map<String, dynamic>) fromJson,
  ) async {
    final fullUrl = '${config.baseUrl}$url';
    final stringifiedBody = jsonEncode(body);
    final stamp = await stamper.stamp(stringifiedBody);

    final client = HttpClient();
    try {
      final request = await client.postUrl(Uri.parse(fullUrl));
      request.headers.set(stamp.stampHeaderName, stamp.stampHeaderValue);
      request.headers.set('X-Client-Version', VERSION);
      request.headers.contentType = ContentType.json;
      request.write(stringifiedBody);

      final response = await request.close();

      if (response.statusCode != 200) {
        final errorBody = await response.transform(utf8.decoder).join();
        throw TurnkeyRequestError(
          GrpcStatus.fromJson(jsonDecode(errorBody)),
        );
      }

      final responseBody = await response.transform(utf8.decoder).join();
      final decodedJson = jsonDecode(responseBody) as Map<String, dynamic>;

      return fromJson(decodedJson);
    } finally {
      client.close();
    }
  }

  Future<TResponseType> authProxyRequest<TBodyType, TResponseType>(
    String url,
    TBodyType body,
    TResponseType Function(Map<String, dynamic>) fromJson,
  ) async {
    if (config.authProxyConfigId == null || config.authProxyConfigId!.isEmpty) {
      throw Exception(
          'Missing Auth Proxy config ID. Please verify environment variables.');
    }
    final fullUrl = '${config.authProxyBaseUrl}$url';
    final stringifiedBody = jsonEncode(body);

    final client = HttpClient();
    try {
      final request = await client.postUrl(Uri.parse(fullUrl));
      request.headers.set("X-Auth-Proxy-Config-ID", config.authProxyConfigId!);
      request.headers.set('X-Client-Version', VERSION);
      request.headers.contentType = ContentType.json;
      request.write(stringifiedBody);

      final response = await request.close();

      if (response.statusCode != 200) {
        final errorBody = await response.transform(utf8.decoder).join();
        throw TurnkeyRequestError(
          GrpcStatus.fromJson(jsonDecode(errorBody)),
        );
      }

      final responseBody = await response.transform(utf8.decoder).join();
      final decodedJson = jsonDecode(responseBody) as Map<String, dynamic>;

      return fromJson(decodedJson);
    } finally {
      client.close();
    }
  }

  /// Build the server envelope.
  Map<String, dynamic> makeEnvelope({
    required String type,
    required String organizationId,
    String? timestampMs,
    required Map<String, dynamic> parameters,
  }) {
    return {
      'type': type,
      'organizationId': organizationId,
      'timestampMs':
          timestampMs ?? DateTime.now().millisecondsSinceEpoch.toString(),
      'parameters': parameters,
    };
  }

  /// Build `parameters` by taking everything from [src] except the keys in [exclude].
  /// Null values are dropped by default to keep payloads lean.
  Map<String, dynamic> paramsFromBody(
    Map<String, dynamic> src, {
    Iterable<String> exclude = const [],
    bool dropNulls = true,
  }) {
    final out = Map<String, dynamic>.from(src);
    for (final k in exclude) {
      out.remove(k);
    }
    // Optionally drop nulls
    if (dropNulls) {
      out.removeWhere((_, v) => v == null);
    }
    return out;
  }

  /// For command/activityDecision bodies generated by codegen:
  Map<String, dynamic> packActivityBody({
    required Map<String, dynamic> bodyJson,
    required String fallbackOrganizationId,
    required String activityType,
  }) {
    final orgId =
        (bodyJson['organizationId'] as String?) ?? fallbackOrganizationId;
    final ts = bodyJson['timestampMs'] as String?;

    // Exclude envelope keys (and guard against accidental nesting)
    final params = paramsFromBody(
      bodyJson,
      exclude: const ['organizationId', 'timestampMs', 'parameters', 'type'],
    );

    return makeEnvelope(
      type: activityType,
      organizationId: orgId,
      timestampMs: ts,
      parameters: params,
    );
  }

  /// Transforms activity response to flatten specific result from activity.result.{specificResult} to top-level result
  Map<String, dynamic> transformActivityResponse(
      Map<String, dynamic> json, String operationId) {
    // Convert operationId to the expected result field name (e.g., "StampLogin" -> "stampLoginResult")
    final resultFieldName =
        '${operationId[0].toLowerCase()}${operationId.substring(1)}Result';

    final result = <String, dynamic>{
      'activity': json['activity'],
    };

    // Extract specific result from activity.result.{specificResult} and flatten to top level
    if (json['activity'] != null &&
        json['activity']['result'] != null &&
        json['activity']['result'][resultFieldName] != null) {
      result['result'] = json['activity']['result'][resultFieldName];
    }

    return result;
  }

  /// Get details about an activity.
  ///
  /// Sign the provided `TGetActivityBody` with the client's `stamp` function and submit the request (POST /public/v1/query/get_activity).
  ///
  /// See also: `stampGetActivity`.

  Future<TGetActivityResponse> getActivity({
    required TGetActivityBody input,
  }) async {
    return await request<TGetActivityBody, TGetActivityResponse>(
        "/public/v1/query/get_activity",
        input,
        (json) => TGetActivityResponse.fromJson(json));
  }

  /// Produce a `SignedRequest` from `TGetActivityBody` by using the client's `stamp` function.
  ///
  /// See also: `GetActivity`.

  Future<TSignedRequest> stampGetActivity({
    required TGetActivityBody input,
  }) async {
    final fullUrl = '${config.baseUrl}/public/v1/query/get_activity';
    final body = jsonEncode(input);
    final stamp = await stamper.stamp(body);

    return TSignedRequest(
      body: body,
      stamp: stamp,
      url: fullUrl,
    );
  }

  /// Get details about an API key.
  ///
  /// Sign the provided `TGetApiKeyBody` with the client's `stamp` function and submit the request (POST /public/v1/query/get_api_key).
  ///
  /// See also: `stampGetApiKey`.

  Future<TGetApiKeyResponse> getApiKey({
    required TGetApiKeyBody input,
  }) async {
    return await request<TGetApiKeyBody, TGetApiKeyResponse>(
        "/public/v1/query/get_api_key",
        input,
        (json) => TGetApiKeyResponse.fromJson(json));
  }

  /// Produce a `SignedRequest` from `TGetApiKeyBody` by using the client's `stamp` function.
  ///
  /// See also: `GetApiKey`.

  Future<TSignedRequest> stampGetApiKey({
    required TGetApiKeyBody input,
  }) async {
    final fullUrl = '${config.baseUrl}/public/v1/query/get_api_key';
    final body = jsonEncode(input);
    final stamp = await stamper.stamp(body);

    return TSignedRequest(
      body: body,
      stamp: stamp,
      url: fullUrl,
    );
  }

  /// Get details about API keys for a user.
  ///
  /// Sign the provided `TGetApiKeysBody` with the client's `stamp` function and submit the request (POST /public/v1/query/get_api_keys).
  ///
  /// See also: `stampGetApiKeys`.

  Future<TGetApiKeysResponse> getApiKeys({
    required TGetApiKeysBody input,
  }) async {
    return await request<TGetApiKeysBody, TGetApiKeysResponse>(
        "/public/v1/query/get_api_keys",
        input,
        (json) => TGetApiKeysResponse.fromJson(json));
  }

  /// Produce a `SignedRequest` from `TGetApiKeysBody` by using the client's `stamp` function.
  ///
  /// See also: `GetApiKeys`.

  Future<TSignedRequest> stampGetApiKeys({
    required TGetApiKeysBody input,
  }) async {
    final fullUrl = '${config.baseUrl}/public/v1/query/get_api_keys';
    final body = jsonEncode(input);
    final stamp = await stamper.stamp(body);

    return TSignedRequest(
      body: body,
      stamp: stamp,
      url: fullUrl,
    );
  }

  /// Get the attestation document corresponding to an enclave.
  ///
  /// Sign the provided `TGetAttestationDocumentBody` with the client's `stamp` function and submit the request (POST /public/v1/query/get_attestation).
  ///
  /// See also: `stampGetAttestationDocument`.

  Future<TGetAttestationDocumentResponse> getAttestationDocument({
    required TGetAttestationDocumentBody input,
  }) async {
    return await request<TGetAttestationDocumentBody,
            TGetAttestationDocumentResponse>("/public/v1/query/get_attestation",
        input, (json) => TGetAttestationDocumentResponse.fromJson(json));
  }

  /// Produce a `SignedRequest` from `TGetAttestationDocumentBody` by using the client's `stamp` function.
  ///
  /// See also: `GetAttestationDocument`.

  Future<TSignedRequest> stampGetAttestationDocument({
    required TGetAttestationDocumentBody input,
  }) async {
    final fullUrl = '${config.baseUrl}/public/v1/query/get_attestation';
    final body = jsonEncode(input);
    final stamp = await stamper.stamp(body);

    return TSignedRequest(
      body: body,
      stamp: stamp,
      url: fullUrl,
    );
  }

  /// Get details about an authenticator.
  ///
  /// Sign the provided `TGetAuthenticatorBody` with the client's `stamp` function and submit the request (POST /public/v1/query/get_authenticator).
  ///
  /// See also: `stampGetAuthenticator`.

  Future<TGetAuthenticatorResponse> getAuthenticator({
    required TGetAuthenticatorBody input,
  }) async {
    return await request<TGetAuthenticatorBody, TGetAuthenticatorResponse>(
        "/public/v1/query/get_authenticator",
        input,
        (json) => TGetAuthenticatorResponse.fromJson(json));
  }

  /// Produce a `SignedRequest` from `TGetAuthenticatorBody` by using the client's `stamp` function.
  ///
  /// See also: `GetAuthenticator`.

  Future<TSignedRequest> stampGetAuthenticator({
    required TGetAuthenticatorBody input,
  }) async {
    final fullUrl = '${config.baseUrl}/public/v1/query/get_authenticator';
    final body = jsonEncode(input);
    final stamp = await stamper.stamp(body);

    return TSignedRequest(
      body: body,
      stamp: stamp,
      url: fullUrl,
    );
  }

  /// Get details about authenticators for a user.
  ///
  /// Sign the provided `TGetAuthenticatorsBody` with the client's `stamp` function and submit the request (POST /public/v1/query/get_authenticators).
  ///
  /// See also: `stampGetAuthenticators`.

  Future<TGetAuthenticatorsResponse> getAuthenticators({
    required TGetAuthenticatorsBody input,
  }) async {
    return await request<TGetAuthenticatorsBody, TGetAuthenticatorsResponse>(
        "/public/v1/query/get_authenticators",
        input,
        (json) => TGetAuthenticatorsResponse.fromJson(json));
  }

  /// Produce a `SignedRequest` from `TGetAuthenticatorsBody` by using the client's `stamp` function.
  ///
  /// See also: `GetAuthenticators`.

  Future<TSignedRequest> stampGetAuthenticators({
    required TGetAuthenticatorsBody input,
  }) async {
    final fullUrl = '${config.baseUrl}/public/v1/query/get_authenticators';
    final body = jsonEncode(input);
    final stamp = await stamper.stamp(body);

    return TSignedRequest(
      body: body,
      stamp: stamp,
      url: fullUrl,
    );
  }

  /// Get the boot proof for a given ephemeral key.
  ///
  /// Sign the provided `TGetBootProofBody` with the client's `stamp` function and submit the request (POST /public/v1/query/get_boot_proof).
  ///
  /// See also: `stampGetBootProof`.

  Future<TGetBootProofResponse> getBootProof({
    required TGetBootProofBody input,
  }) async {
    return await request<TGetBootProofBody, TGetBootProofResponse>(
        "/public/v1/query/get_boot_proof",
        input,
        (json) => TGetBootProofResponse.fromJson(json));
  }

  /// Produce a `SignedRequest` from `TGetBootProofBody` by using the client's `stamp` function.
  ///
  /// See also: `GetBootProof`.

  Future<TSignedRequest> stampGetBootProof({
    required TGetBootProofBody input,
  }) async {
    final fullUrl = '${config.baseUrl}/public/v1/query/get_boot_proof';
    final body = jsonEncode(input);
    final stamp = await stamper.stamp(body);

    return TSignedRequest(
      body: body,
      stamp: stamp,
      url: fullUrl,
    );
  }

  /// Get the latest boot proof for a given enclave app name.
  ///
  /// Sign the provided `TGetLatestBootProofBody` with the client's `stamp` function and submit the request (POST /public/v1/query/get_latest_boot_proof).
  ///
  /// See also: `stampGetLatestBootProof`.

  Future<TGetLatestBootProofResponse> getLatestBootProof({
    required TGetLatestBootProofBody input,
  }) async {
    return await request<TGetLatestBootProofBody, TGetLatestBootProofResponse>(
        "/public/v1/query/get_latest_boot_proof",
        input,
        (json) => TGetLatestBootProofResponse.fromJson(json));
  }

  /// Produce a `SignedRequest` from `TGetLatestBootProofBody` by using the client's `stamp` function.
  ///
  /// See also: `GetLatestBootProof`.

  Future<TSignedRequest> stampGetLatestBootProof({
    required TGetLatestBootProofBody input,
  }) async {
    final fullUrl = '${config.baseUrl}/public/v1/query/get_latest_boot_proof';
    final body = jsonEncode(input);
    final stamp = await stamper.stamp(body);

    return TSignedRequest(
      body: body,
      stamp: stamp,
      url: fullUrl,
    );
  }

  /// Get details about an OAuth 2.0 credential.
  ///
  /// Sign the provided `TGetOauth2CredentialBody` with the client's `stamp` function and submit the request (POST /public/v1/query/get_oauth2_credential).
  ///
  /// See also: `stampGetOauth2Credential`.

  Future<TGetOauth2CredentialResponse> getOauth2Credential({
    required TGetOauth2CredentialBody input,
  }) async {
    return await request<TGetOauth2CredentialBody,
            TGetOauth2CredentialResponse>(
        "/public/v1/query/get_oauth2_credential",
        input,
        (json) => TGetOauth2CredentialResponse.fromJson(json));
  }

  /// Produce a `SignedRequest` from `TGetOauth2CredentialBody` by using the client's `stamp` function.
  ///
  /// See also: `GetOauth2Credential`.

  Future<TSignedRequest> stampGetOauth2Credential({
    required TGetOauth2CredentialBody input,
  }) async {
    final fullUrl = '${config.baseUrl}/public/v1/query/get_oauth2_credential';
    final body = jsonEncode(input);
    final stamp = await stamper.stamp(body);

    return TSignedRequest(
      body: body,
      stamp: stamp,
      url: fullUrl,
    );
  }

  /// Get details about Oauth providers for a user.
  ///
  /// Sign the provided `TGetOauthProvidersBody` with the client's `stamp` function and submit the request (POST /public/v1/query/get_oauth_providers).
  ///
  /// See also: `stampGetOauthProviders`.

  Future<TGetOauthProvidersResponse> getOauthProviders({
    required TGetOauthProvidersBody input,
  }) async {
    return await request<TGetOauthProvidersBody, TGetOauthProvidersResponse>(
        "/public/v1/query/get_oauth_providers",
        input,
        (json) => TGetOauthProvidersResponse.fromJson(json));
  }

  /// Produce a `SignedRequest` from `TGetOauthProvidersBody` by using the client's `stamp` function.
  ///
  /// See also: `GetOauthProviders`.

  Future<TSignedRequest> stampGetOauthProviders({
    required TGetOauthProvidersBody input,
  }) async {
    final fullUrl = '${config.baseUrl}/public/v1/query/get_oauth_providers';
    final body = jsonEncode(input);
    final stamp = await stamper.stamp(body);

    return TSignedRequest(
      body: body,
      stamp: stamp,
      url: fullUrl,
    );
  }

  /// Get details about an organization.
  ///
  /// Sign the provided `TGetOrganizationBody` with the client's `stamp` function and submit the request (POST /public/v1/query/get_organization).
  ///
  /// See also: `stampGetOrganization`.

  Future<TGetOrganizationResponse> getOrganization({
    required TGetOrganizationBody input,
  }) async {
    return await request<TGetOrganizationBody, TGetOrganizationResponse>(
        "/public/v1/query/get_organization",
        input,
        (json) => TGetOrganizationResponse.fromJson(json));
  }

  /// Produce a `SignedRequest` from `TGetOrganizationBody` by using the client's `stamp` function.
  ///
  /// See also: `GetOrganization`.

  Future<TSignedRequest> stampGetOrganization({
    required TGetOrganizationBody input,
  }) async {
    final fullUrl = '${config.baseUrl}/public/v1/query/get_organization';
    final body = jsonEncode(input);
    final stamp = await stamper.stamp(body);

    return TSignedRequest(
      body: body,
      stamp: stamp,
      url: fullUrl,
    );
  }

  /// Get quorum settings and features for an organization.
  ///
  /// Sign the provided `TGetOrganizationConfigsBody` with the client's `stamp` function and submit the request (POST /public/v1/query/get_organization_configs).
  ///
  /// See also: `stampGetOrganizationConfigs`.

  Future<TGetOrganizationConfigsResponse> getOrganizationConfigs({
    required TGetOrganizationConfigsBody input,
  }) async {
    return await request<TGetOrganizationConfigsBody,
            TGetOrganizationConfigsResponse>(
        "/public/v1/query/get_organization_configs",
        input,
        (json) => TGetOrganizationConfigsResponse.fromJson(json));
  }

  /// Produce a `SignedRequest` from `TGetOrganizationConfigsBody` by using the client's `stamp` function.
  ///
  /// See also: `GetOrganizationConfigs`.

  Future<TSignedRequest> stampGetOrganizationConfigs({
    required TGetOrganizationConfigsBody input,
  }) async {
    final fullUrl =
        '${config.baseUrl}/public/v1/query/get_organization_configs';
    final body = jsonEncode(input);
    final stamp = await stamper.stamp(body);

    return TSignedRequest(
      body: body,
      stamp: stamp,
      url: fullUrl,
    );
  }

  /// Get details about a policy.
  ///
  /// Sign the provided `TGetPolicyBody` with the client's `stamp` function and submit the request (POST /public/v1/query/get_policy).
  ///
  /// See also: `stampGetPolicy`.

  Future<TGetPolicyResponse> getPolicy({
    required TGetPolicyBody input,
  }) async {
    return await request<TGetPolicyBody, TGetPolicyResponse>(
        "/public/v1/query/get_policy",
        input,
        (json) => TGetPolicyResponse.fromJson(json));
  }

  /// Produce a `SignedRequest` from `TGetPolicyBody` by using the client's `stamp` function.
  ///
  /// See also: `GetPolicy`.

  Future<TSignedRequest> stampGetPolicy({
    required TGetPolicyBody input,
  }) async {
    final fullUrl = '${config.baseUrl}/public/v1/query/get_policy';
    final body = jsonEncode(input);
    final stamp = await stamper.stamp(body);

    return TSignedRequest(
      body: body,
      stamp: stamp,
      url: fullUrl,
    );
  }

  /// Get the policy evaluations for an activity.
  ///
  /// Sign the provided `TGetPolicyEvaluationsBody` with the client's `stamp` function and submit the request (POST /public/v1/query/get_policy_evaluations).
  ///
  /// See also: `stampGetPolicyEvaluations`.

  Future<TGetPolicyEvaluationsResponse> getPolicyEvaluations({
    required TGetPolicyEvaluationsBody input,
  }) async {
    return await request<TGetPolicyEvaluationsBody,
            TGetPolicyEvaluationsResponse>(
        "/public/v1/query/get_policy_evaluations",
        input,
        (json) => TGetPolicyEvaluationsResponse.fromJson(json));
  }

  /// Produce a `SignedRequest` from `TGetPolicyEvaluationsBody` by using the client's `stamp` function.
  ///
  /// See also: `GetPolicyEvaluations`.

  Future<TSignedRequest> stampGetPolicyEvaluations({
    required TGetPolicyEvaluationsBody input,
  }) async {
    final fullUrl = '${config.baseUrl}/public/v1/query/get_policy_evaluations';
    final body = jsonEncode(input);
    final stamp = await stamper.stamp(body);

    return TSignedRequest(
      body: body,
      stamp: stamp,
      url: fullUrl,
    );
  }

  /// Get details about a private key.
  ///
  /// Sign the provided `TGetPrivateKeyBody` with the client's `stamp` function and submit the request (POST /public/v1/query/get_private_key).
  ///
  /// See also: `stampGetPrivateKey`.

  Future<TGetPrivateKeyResponse> getPrivateKey({
    required TGetPrivateKeyBody input,
  }) async {
    return await request<TGetPrivateKeyBody, TGetPrivateKeyResponse>(
        "/public/v1/query/get_private_key",
        input,
        (json) => TGetPrivateKeyResponse.fromJson(json));
  }

  /// Produce a `SignedRequest` from `TGetPrivateKeyBody` by using the client's `stamp` function.
  ///
  /// See also: `GetPrivateKey`.

  Future<TSignedRequest> stampGetPrivateKey({
    required TGetPrivateKeyBody input,
  }) async {
    final fullUrl = '${config.baseUrl}/public/v1/query/get_private_key';
    final body = jsonEncode(input);
    final stamp = await stamper.stamp(body);

    return TSignedRequest(
      body: body,
      stamp: stamp,
      url: fullUrl,
    );
  }

  /// Get details about a smart contract interface.
  ///
  /// Sign the provided `TGetSmartContractInterfaceBody` with the client's `stamp` function and submit the request (POST /public/v1/query/get_smart_contract_interface).
  ///
  /// See also: `stampGetSmartContractInterface`.

  Future<TGetSmartContractInterfaceResponse> getSmartContractInterface({
    required TGetSmartContractInterfaceBody input,
  }) async {
    return await request<TGetSmartContractInterfaceBody,
            TGetSmartContractInterfaceResponse>(
        "/public/v1/query/get_smart_contract_interface",
        input,
        (json) => TGetSmartContractInterfaceResponse.fromJson(json));
  }

  /// Produce a `SignedRequest` from `TGetSmartContractInterfaceBody` by using the client's `stamp` function.
  ///
  /// See also: `GetSmartContractInterface`.

  Future<TSignedRequest> stampGetSmartContractInterface({
    required TGetSmartContractInterfaceBody input,
  }) async {
    final fullUrl =
        '${config.baseUrl}/public/v1/query/get_smart_contract_interface';
    final body = jsonEncode(input);
    final stamp = await stamper.stamp(body);

    return TSignedRequest(
      body: body,
      stamp: stamp,
      url: fullUrl,
    );
  }

  /// Get details about a user.
  ///
  /// Sign the provided `TGetUserBody` with the client's `stamp` function and submit the request (POST /public/v1/query/get_user).
  ///
  /// See also: `stampGetUser`.

  Future<TGetUserResponse> getUser({
    required TGetUserBody input,
  }) async {
    return await request<TGetUserBody, TGetUserResponse>(
        "/public/v1/query/get_user",
        input,
        (json) => TGetUserResponse.fromJson(json));
  }

  /// Produce a `SignedRequest` from `TGetUserBody` by using the client's `stamp` function.
  ///
  /// See also: `GetUser`.

  Future<TSignedRequest> stampGetUser({
    required TGetUserBody input,
  }) async {
    final fullUrl = '${config.baseUrl}/public/v1/query/get_user';
    final body = jsonEncode(input);
    final stamp = await stamper.stamp(body);

    return TSignedRequest(
      body: body,
      stamp: stamp,
      url: fullUrl,
    );
  }

  /// Get details about a wallet.
  ///
  /// Sign the provided `TGetWalletBody` with the client's `stamp` function and submit the request (POST /public/v1/query/get_wallet).
  ///
  /// See also: `stampGetWallet`.

  Future<TGetWalletResponse> getWallet({
    required TGetWalletBody input,
  }) async {
    return await request<TGetWalletBody, TGetWalletResponse>(
        "/public/v1/query/get_wallet",
        input,
        (json) => TGetWalletResponse.fromJson(json));
  }

  /// Produce a `SignedRequest` from `TGetWalletBody` by using the client's `stamp` function.
  ///
  /// See also: `GetWallet`.

  Future<TSignedRequest> stampGetWallet({
    required TGetWalletBody input,
  }) async {
    final fullUrl = '${config.baseUrl}/public/v1/query/get_wallet';
    final body = jsonEncode(input);
    final stamp = await stamper.stamp(body);

    return TSignedRequest(
      body: body,
      stamp: stamp,
      url: fullUrl,
    );
  }

  /// Get a single wallet account.
  ///
  /// Sign the provided `TGetWalletAccountBody` with the client's `stamp` function and submit the request (POST /public/v1/query/get_wallet_account).
  ///
  /// See also: `stampGetWalletAccount`.

  Future<TGetWalletAccountResponse> getWalletAccount({
    required TGetWalletAccountBody input,
  }) async {
    return await request<TGetWalletAccountBody, TGetWalletAccountResponse>(
        "/public/v1/query/get_wallet_account",
        input,
        (json) => TGetWalletAccountResponse.fromJson(json));
  }

  /// Produce a `SignedRequest` from `TGetWalletAccountBody` by using the client's `stamp` function.
  ///
  /// See also: `GetWalletAccount`.

  Future<TSignedRequest> stampGetWalletAccount({
    required TGetWalletAccountBody input,
  }) async {
    final fullUrl = '${config.baseUrl}/public/v1/query/get_wallet_account';
    final body = jsonEncode(input);
    final stamp = await stamper.stamp(body);

    return TSignedRequest(
      body: body,
      stamp: stamp,
      url: fullUrl,
    );
  }

  /// List all activities within an organization.
  ///
  /// Sign the provided `TGetActivitiesBody` with the client's `stamp` function and submit the request (POST /public/v1/query/list_activities).
  ///
  /// See also: `stampGetActivities`.

  Future<TGetActivitiesResponse> getActivities({
    required TGetActivitiesBody input,
  }) async {
    return await request<TGetActivitiesBody, TGetActivitiesResponse>(
        "/public/v1/query/list_activities",
        input,
        (json) => TGetActivitiesResponse.fromJson(json));
  }

  /// Produce a `SignedRequest` from `TGetActivitiesBody` by using the client's `stamp` function.
  ///
  /// See also: `GetActivities`.

  Future<TSignedRequest> stampGetActivities({
    required TGetActivitiesBody input,
  }) async {
    final fullUrl = '${config.baseUrl}/public/v1/query/list_activities';
    final body = jsonEncode(input);
    final stamp = await stamper.stamp(body);

    return TSignedRequest(
      body: body,
      stamp: stamp,
      url: fullUrl,
    );
  }

  /// List the app proofs for the given activity.
  ///
  /// Sign the provided `TGetAppProofsBody` with the client's `stamp` function and submit the request (POST /public/v1/query/list_app_proofs).
  ///
  /// See also: `stampGetAppProofs`.

  Future<TGetAppProofsResponse> getAppProofs({
    required TGetAppProofsBody input,
  }) async {
    return await request<TGetAppProofsBody, TGetAppProofsResponse>(
        "/public/v1/query/list_app_proofs",
        input,
        (json) => TGetAppProofsResponse.fromJson(json));
  }

  /// Produce a `SignedRequest` from `TGetAppProofsBody` by using the client's `stamp` function.
  ///
  /// See also: `GetAppProofs`.

  Future<TSignedRequest> stampGetAppProofs({
    required TGetAppProofsBody input,
  }) async {
    final fullUrl = '${config.baseUrl}/public/v1/query/list_app_proofs';
    final body = jsonEncode(input);
    final stamp = await stamper.stamp(body);

    return TSignedRequest(
      body: body,
      stamp: stamp,
      url: fullUrl,
    );
  }

  /// List all OAuth 2.0 credentials within an organization.
  ///
  /// Sign the provided `TListOauth2CredentialsBody` with the client's `stamp` function and submit the request (POST /public/v1/query/list_oauth2_credentials).
  ///
  /// See also: `stampListOauth2Credentials`.

  Future<TListOauth2CredentialsResponse> listOauth2Credentials({
    required TListOauth2CredentialsBody input,
  }) async {
    return await request<TListOauth2CredentialsBody,
            TListOauth2CredentialsResponse>(
        "/public/v1/query/list_oauth2_credentials",
        input,
        (json) => TListOauth2CredentialsResponse.fromJson(json));
  }

  /// Produce a `SignedRequest` from `TListOauth2CredentialsBody` by using the client's `stamp` function.
  ///
  /// See also: `ListOauth2Credentials`.

  Future<TSignedRequest> stampListOauth2Credentials({
    required TListOauth2CredentialsBody input,
  }) async {
    final fullUrl = '${config.baseUrl}/public/v1/query/list_oauth2_credentials';
    final body = jsonEncode(input);
    final stamp = await stamper.stamp(body);

    return TSignedRequest(
      body: body,
      stamp: stamp,
      url: fullUrl,
    );
  }

  /// List all policies within an organization.
  ///
  /// Sign the provided `TGetPoliciesBody` with the client's `stamp` function and submit the request (POST /public/v1/query/list_policies).
  ///
  /// See also: `stampGetPolicies`.

  Future<TGetPoliciesResponse> getPolicies({
    required TGetPoliciesBody input,
  }) async {
    return await request<TGetPoliciesBody, TGetPoliciesResponse>(
        "/public/v1/query/list_policies",
        input,
        (json) => TGetPoliciesResponse.fromJson(json));
  }

  /// Produce a `SignedRequest` from `TGetPoliciesBody` by using the client's `stamp` function.
  ///
  /// See also: `GetPolicies`.

  Future<TSignedRequest> stampGetPolicies({
    required TGetPoliciesBody input,
  }) async {
    final fullUrl = '${config.baseUrl}/public/v1/query/list_policies';
    final body = jsonEncode(input);
    final stamp = await stamper.stamp(body);

    return TSignedRequest(
      body: body,
      stamp: stamp,
      url: fullUrl,
    );
  }

  /// List all private key tags within an organization.
  ///
  /// Sign the provided `TListPrivateKeyTagsBody` with the client's `stamp` function and submit the request (POST /public/v1/query/list_private_key_tags).
  ///
  /// See also: `stampListPrivateKeyTags`.

  Future<TListPrivateKeyTagsResponse> listPrivateKeyTags({
    required TListPrivateKeyTagsBody input,
  }) async {
    return await request<TListPrivateKeyTagsBody, TListPrivateKeyTagsResponse>(
        "/public/v1/query/list_private_key_tags",
        input,
        (json) => TListPrivateKeyTagsResponse.fromJson(json));
  }

  /// Produce a `SignedRequest` from `TListPrivateKeyTagsBody` by using the client's `stamp` function.
  ///
  /// See also: `ListPrivateKeyTags`.

  Future<TSignedRequest> stampListPrivateKeyTags({
    required TListPrivateKeyTagsBody input,
  }) async {
    final fullUrl = '${config.baseUrl}/public/v1/query/list_private_key_tags';
    final body = jsonEncode(input);
    final stamp = await stamper.stamp(body);

    return TSignedRequest(
      body: body,
      stamp: stamp,
      url: fullUrl,
    );
  }

  /// List all private keys within an organization.
  ///
  /// Sign the provided `TGetPrivateKeysBody` with the client's `stamp` function and submit the request (POST /public/v1/query/list_private_keys).
  ///
  /// See also: `stampGetPrivateKeys`.

  Future<TGetPrivateKeysResponse> getPrivateKeys({
    required TGetPrivateKeysBody input,
  }) async {
    return await request<TGetPrivateKeysBody, TGetPrivateKeysResponse>(
        "/public/v1/query/list_private_keys",
        input,
        (json) => TGetPrivateKeysResponse.fromJson(json));
  }

  /// Produce a `SignedRequest` from `TGetPrivateKeysBody` by using the client's `stamp` function.
  ///
  /// See also: `GetPrivateKeys`.

  Future<TSignedRequest> stampGetPrivateKeys({
    required TGetPrivateKeysBody input,
  }) async {
    final fullUrl = '${config.baseUrl}/public/v1/query/list_private_keys';
    final body = jsonEncode(input);
    final stamp = await stamper.stamp(body);

    return TSignedRequest(
      body: body,
      stamp: stamp,
      url: fullUrl,
    );
  }

  /// List all smart contract interfaces within an organization.
  ///
  /// Sign the provided `TGetSmartContractInterfacesBody` with the client's `stamp` function and submit the request (POST /public/v1/query/list_smart_contract_interfaces).
  ///
  /// See also: `stampGetSmartContractInterfaces`.

  Future<TGetSmartContractInterfacesResponse> getSmartContractInterfaces({
    required TGetSmartContractInterfacesBody input,
  }) async {
    return await request<TGetSmartContractInterfacesBody,
            TGetSmartContractInterfacesResponse>(
        "/public/v1/query/list_smart_contract_interfaces",
        input,
        (json) => TGetSmartContractInterfacesResponse.fromJson(json));
  }

  /// Produce a `SignedRequest` from `TGetSmartContractInterfacesBody` by using the client's `stamp` function.
  ///
  /// See also: `GetSmartContractInterfaces`.

  Future<TSignedRequest> stampGetSmartContractInterfaces({
    required TGetSmartContractInterfacesBody input,
  }) async {
    final fullUrl =
        '${config.baseUrl}/public/v1/query/list_smart_contract_interfaces';
    final body = jsonEncode(input);
    final stamp = await stamper.stamp(body);

    return TSignedRequest(
      body: body,
      stamp: stamp,
      url: fullUrl,
    );
  }

  /// Get all suborg IDs associated given a parent org ID and an optional filter.
  ///
  /// Sign the provided `TGetSubOrgIdsBody` with the client's `stamp` function and submit the request (POST /public/v1/query/list_suborgs).
  ///
  /// See also: `stampGetSubOrgIds`.

  Future<TGetSubOrgIdsResponse> getSubOrgIds({
    required TGetSubOrgIdsBody input,
  }) async {
    return await request<TGetSubOrgIdsBody, TGetSubOrgIdsResponse>(
        "/public/v1/query/list_suborgs",
        input,
        (json) => TGetSubOrgIdsResponse.fromJson(json));
  }

  /// Produce a `SignedRequest` from `TGetSubOrgIdsBody` by using the client's `stamp` function.
  ///
  /// See also: `GetSubOrgIds`.

  Future<TSignedRequest> stampGetSubOrgIds({
    required TGetSubOrgIdsBody input,
  }) async {
    final fullUrl = '${config.baseUrl}/public/v1/query/list_suborgs';
    final body = jsonEncode(input);
    final stamp = await stamper.stamp(body);

    return TSignedRequest(
      body: body,
      stamp: stamp,
      url: fullUrl,
    );
  }

  /// List all user tags within an organization.
  ///
  /// Sign the provided `TListUserTagsBody` with the client's `stamp` function and submit the request (POST /public/v1/query/list_user_tags).
  ///
  /// See also: `stampListUserTags`.

  Future<TListUserTagsResponse> listUserTags({
    required TListUserTagsBody input,
  }) async {
    return await request<TListUserTagsBody, TListUserTagsResponse>(
        "/public/v1/query/list_user_tags",
        input,
        (json) => TListUserTagsResponse.fromJson(json));
  }

  /// Produce a `SignedRequest` from `TListUserTagsBody` by using the client's `stamp` function.
  ///
  /// See also: `ListUserTags`.

  Future<TSignedRequest> stampListUserTags({
    required TListUserTagsBody input,
  }) async {
    final fullUrl = '${config.baseUrl}/public/v1/query/list_user_tags';
    final body = jsonEncode(input);
    final stamp = await stamper.stamp(body);

    return TSignedRequest(
      body: body,
      stamp: stamp,
      url: fullUrl,
    );
  }

  /// List all users within an organization.
  ///
  /// Sign the provided `TGetUsersBody` with the client's `stamp` function and submit the request (POST /public/v1/query/list_users).
  ///
  /// See also: `stampGetUsers`.

  Future<TGetUsersResponse> getUsers({
    required TGetUsersBody input,
  }) async {
    return await request<TGetUsersBody, TGetUsersResponse>(
        "/public/v1/query/list_users",
        input,
        (json) => TGetUsersResponse.fromJson(json));
  }

  /// Produce a `SignedRequest` from `TGetUsersBody` by using the client's `stamp` function.
  ///
  /// See also: `GetUsers`.

  Future<TSignedRequest> stampGetUsers({
    required TGetUsersBody input,
  }) async {
    final fullUrl = '${config.baseUrl}/public/v1/query/list_users';
    final body = jsonEncode(input);
    final stamp = await stamper.stamp(body);

    return TSignedRequest(
      body: body,
      stamp: stamp,
      url: fullUrl,
    );
  }

  /// Get all email or phone verified suborg IDs associated given a parent org ID.
  ///
  /// Sign the provided `TGetVerifiedSubOrgIdsBody` with the client's `stamp` function and submit the request (POST /public/v1/query/list_verified_suborgs).
  ///
  /// See also: `stampGetVerifiedSubOrgIds`.

  Future<TGetVerifiedSubOrgIdsResponse> getVerifiedSubOrgIds({
    required TGetVerifiedSubOrgIdsBody input,
  }) async {
    return await request<TGetVerifiedSubOrgIdsBody,
            TGetVerifiedSubOrgIdsResponse>(
        "/public/v1/query/list_verified_suborgs",
        input,
        (json) => TGetVerifiedSubOrgIdsResponse.fromJson(json));
  }

  /// Produce a `SignedRequest` from `TGetVerifiedSubOrgIdsBody` by using the client's `stamp` function.
  ///
  /// See also: `GetVerifiedSubOrgIds`.

  Future<TSignedRequest> stampGetVerifiedSubOrgIds({
    required TGetVerifiedSubOrgIdsBody input,
  }) async {
    final fullUrl = '${config.baseUrl}/public/v1/query/list_verified_suborgs';
    final body = jsonEncode(input);
    final stamp = await stamper.stamp(body);

    return TSignedRequest(
      body: body,
      stamp: stamp,
      url: fullUrl,
    );
  }

  /// List all accounts within a wallet.
  ///
  /// Sign the provided `TGetWalletAccountsBody` with the client's `stamp` function and submit the request (POST /public/v1/query/list_wallet_accounts).
  ///
  /// See also: `stampGetWalletAccounts`.

  Future<TGetWalletAccountsResponse> getWalletAccounts({
    required TGetWalletAccountsBody input,
  }) async {
    return await request<TGetWalletAccountsBody, TGetWalletAccountsResponse>(
        "/public/v1/query/list_wallet_accounts",
        input,
        (json) => TGetWalletAccountsResponse.fromJson(json));
  }

  /// Produce a `SignedRequest` from `TGetWalletAccountsBody` by using the client's `stamp` function.
  ///
  /// See also: `GetWalletAccounts`.

  Future<TSignedRequest> stampGetWalletAccounts({
    required TGetWalletAccountsBody input,
  }) async {
    final fullUrl = '${config.baseUrl}/public/v1/query/list_wallet_accounts';
    final body = jsonEncode(input);
    final stamp = await stamper.stamp(body);

    return TSignedRequest(
      body: body,
      stamp: stamp,
      url: fullUrl,
    );
  }

  /// List all wallets within an organization.
  ///
  /// Sign the provided `TGetWalletsBody` with the client's `stamp` function and submit the request (POST /public/v1/query/list_wallets).
  ///
  /// See also: `stampGetWallets`.

  Future<TGetWalletsResponse> getWallets({
    required TGetWalletsBody input,
  }) async {
    return await request<TGetWalletsBody, TGetWalletsResponse>(
        "/public/v1/query/list_wallets",
        input,
        (json) => TGetWalletsResponse.fromJson(json));
  }

  /// Produce a `SignedRequest` from `TGetWalletsBody` by using the client's `stamp` function.
  ///
  /// See also: `GetWallets`.

  Future<TSignedRequest> stampGetWallets({
    required TGetWalletsBody input,
  }) async {
    final fullUrl = '${config.baseUrl}/public/v1/query/list_wallets';
    final body = jsonEncode(input);
    final stamp = await stamper.stamp(body);

    return TSignedRequest(
      body: body,
      stamp: stamp,
      url: fullUrl,
    );
  }

  /// Get basic information about your current API or WebAuthN user and their organization. Affords sub-organization look ups via parent organization for WebAuthN or API key users.
  ///
  /// Sign the provided `TGetWhoamiBody` with the client's `stamp` function and submit the request (POST /public/v1/query/whoami).
  ///
  /// See also: `stampGetWhoami`.

  Future<TGetWhoamiResponse> getWhoami({
    required TGetWhoamiBody input,
  }) async {
    return await request<TGetWhoamiBody, TGetWhoamiResponse>(
        "/public/v1/query/whoami",
        input,
        (json) => TGetWhoamiResponse.fromJson(json));
  }

  /// Produce a `SignedRequest` from `TGetWhoamiBody` by using the client's `stamp` function.
  ///
  /// See also: `GetWhoami`.

  Future<TSignedRequest> stampGetWhoami({
    required TGetWhoamiBody input,
  }) async {
    final fullUrl = '${config.baseUrl}/public/v1/query/whoami';
    final body = jsonEncode(input);
    final stamp = await stamper.stamp(body);

    return TSignedRequest(
      body: body,
      stamp: stamp,
      url: fullUrl,
    );
  }

  /// Approve an activity.
  ///
  /// Sign the provided `TApproveActivityBody` with the client's `stamp` function and submit the request (POST /public/v1/submit/approve_activity).
  ///
  /// See also: `stampApproveActivity`.

  Future<TApproveActivityResponse> approveActivity({
    required TApproveActivityBody input,
  }) async {
    final body = packActivityBody(
      bodyJson: input.toJson(),
      fallbackOrganizationId: input.organizationId ??
          config.organizationId ??
          (throw Exception(
              "Missing organization ID, please pass in a sub-organizationId or instantiate the client with one.")),
      activityType: 'ACTIVITY_TYPE_APPROVE_ACTIVITY',
    );
    return await request<Map<String, dynamic>, TApproveActivityResponse>(
        "/public/v1/submit/approve_activity",
        body,
        (json) => TApproveActivityResponse.fromJson(
            transformActivityResponse(json, 'ApproveActivity')));
  }

  /// Produce a `SignedRequest` from `TApproveActivityBody` by using the client's `stamp` function.
  ///
  /// See also: `ApproveActivity`.

  Future<TSignedRequest> stampApproveActivity({
    required TApproveActivityBody input,
  }) async {
    final fullUrl = '${config.baseUrl}/public/v1/submit/approve_activity';
    final body = packActivityBody(
      bodyJson: input.toJson(),
      fallbackOrganizationId: input.organizationId ??
          config.organizationId ??
          (throw Exception(
              "Missing organization ID, please pass in a sub-organizationId or instantiate the client with one.")),
      activityType: 'ACTIVITY_TYPE_APPROVE_ACTIVITY',
    );
    final bodyJson = jsonEncode(body);
    final stamp = await stamper.stamp(bodyJson);

    return TSignedRequest(
      body: bodyJson,
      stamp: stamp,
      url: fullUrl,
    );
  }

  /// Add API keys to an existing user.
  ///
  /// Sign the provided `TCreateApiKeysBody` with the client's `stamp` function and submit the request (POST /public/v1/submit/create_api_keys).
  ///
  /// See also: `stampCreateApiKeys`.

  Future<TCreateApiKeysResponse> createApiKeys({
    required TCreateApiKeysBody input,
  }) async {
    final body = packActivityBody(
      bodyJson: input.toJson(),
      fallbackOrganizationId: input.organizationId ??
          config.organizationId ??
          (throw Exception(
              "Missing organization ID, please pass in a sub-organizationId or instantiate the client with one.")),
      activityType: 'ACTIVITY_TYPE_CREATE_API_KEYS_V2',
    );
    return await request<Map<String, dynamic>, TCreateApiKeysResponse>(
        "/public/v1/submit/create_api_keys",
        body,
        (json) => TCreateApiKeysResponse.fromJson(
            transformActivityResponse(json, 'CreateApiKeys')));
  }

  /// Produce a `SignedRequest` from `TCreateApiKeysBody` by using the client's `stamp` function.
  ///
  /// See also: `CreateApiKeys`.

  Future<TSignedRequest> stampCreateApiKeys({
    required TCreateApiKeysBody input,
  }) async {
    final fullUrl = '${config.baseUrl}/public/v1/submit/create_api_keys';
    final body = packActivityBody(
      bodyJson: input.toJson(),
      fallbackOrganizationId: input.organizationId ??
          config.organizationId ??
          (throw Exception(
              "Missing organization ID, please pass in a sub-organizationId or instantiate the client with one.")),
      activityType: 'ACTIVITY_TYPE_CREATE_API_KEYS_V2',
    );
    final bodyJson = jsonEncode(body);
    final stamp = await stamper.stamp(bodyJson);

    return TSignedRequest(
      body: bodyJson,
      stamp: stamp,
      url: fullUrl,
    );
  }

  /// Create API-only users in an existing organization.
  ///
  /// Sign the provided `TCreateApiOnlyUsersBody` with the client's `stamp` function and submit the request (POST /public/v1/submit/create_api_only_users).
  ///
  /// See also: `stampCreateApiOnlyUsers`.

  Future<TCreateApiOnlyUsersResponse> createApiOnlyUsers({
    required TCreateApiOnlyUsersBody input,
  }) async {
    final body = packActivityBody(
      bodyJson: input.toJson(),
      fallbackOrganizationId: input.organizationId ??
          config.organizationId ??
          (throw Exception(
              "Missing organization ID, please pass in a sub-organizationId or instantiate the client with one.")),
      activityType: 'ACTIVITY_TYPE_CREATE_API_ONLY_USERS',
    );
    return await request<Map<String, dynamic>, TCreateApiOnlyUsersResponse>(
        "/public/v1/submit/create_api_only_users",
        body,
        (json) => TCreateApiOnlyUsersResponse.fromJson(
            transformActivityResponse(json, 'CreateApiOnlyUsers')));
  }

  /// Produce a `SignedRequest` from `TCreateApiOnlyUsersBody` by using the client's `stamp` function.
  ///
  /// See also: `CreateApiOnlyUsers`.

  Future<TSignedRequest> stampCreateApiOnlyUsers({
    required TCreateApiOnlyUsersBody input,
  }) async {
    final fullUrl = '${config.baseUrl}/public/v1/submit/create_api_only_users';
    final body = packActivityBody(
      bodyJson: input.toJson(),
      fallbackOrganizationId: input.organizationId ??
          config.organizationId ??
          (throw Exception(
              "Missing organization ID, please pass in a sub-organizationId or instantiate the client with one.")),
      activityType: 'ACTIVITY_TYPE_CREATE_API_ONLY_USERS',
    );
    final bodyJson = jsonEncode(body);
    final stamp = await stamper.stamp(bodyJson);

    return TSignedRequest(
      body: bodyJson,
      stamp: stamp,
      url: fullUrl,
    );
  }

  /// Create authenticators to authenticate requests to Turnkey.
  ///
  /// Sign the provided `TCreateAuthenticatorsBody` with the client's `stamp` function and submit the request (POST /public/v1/submit/create_authenticators).
  ///
  /// See also: `stampCreateAuthenticators`.

  Future<TCreateAuthenticatorsResponse> createAuthenticators({
    required TCreateAuthenticatorsBody input,
  }) async {
    final body = packActivityBody(
      bodyJson: input.toJson(),
      fallbackOrganizationId: input.organizationId ??
          config.organizationId ??
          (throw Exception(
              "Missing organization ID, please pass in a sub-organizationId or instantiate the client with one.")),
      activityType: 'ACTIVITY_TYPE_CREATE_AUTHENTICATORS_V2',
    );
    return await request<Map<String, dynamic>, TCreateAuthenticatorsResponse>(
        "/public/v1/submit/create_authenticators",
        body,
        (json) => TCreateAuthenticatorsResponse.fromJson(
            transformActivityResponse(json, 'CreateAuthenticators')));
  }

  /// Produce a `SignedRequest` from `TCreateAuthenticatorsBody` by using the client's `stamp` function.
  ///
  /// See also: `CreateAuthenticators`.

  Future<TSignedRequest> stampCreateAuthenticators({
    required TCreateAuthenticatorsBody input,
  }) async {
    final fullUrl = '${config.baseUrl}/public/v1/submit/create_authenticators';
    final body = packActivityBody(
      bodyJson: input.toJson(),
      fallbackOrganizationId: input.organizationId ??
          config.organizationId ??
          (throw Exception(
              "Missing organization ID, please pass in a sub-organizationId or instantiate the client with one.")),
      activityType: 'ACTIVITY_TYPE_CREATE_AUTHENTICATORS_V2',
    );
    final bodyJson = jsonEncode(body);
    final stamp = await stamper.stamp(bodyJson);

    return TSignedRequest(
      body: bodyJson,
      stamp: stamp,
      url: fullUrl,
    );
  }

  /// Create invitations to join an existing organization.
  ///
  /// Sign the provided `TCreateInvitationsBody` with the client's `stamp` function and submit the request (POST /public/v1/submit/create_invitations).
  ///
  /// See also: `stampCreateInvitations`.

  Future<TCreateInvitationsResponse> createInvitations({
    required TCreateInvitationsBody input,
  }) async {
    final body = packActivityBody(
      bodyJson: input.toJson(),
      fallbackOrganizationId: input.organizationId ??
          config.organizationId ??
          (throw Exception(
              "Missing organization ID, please pass in a sub-organizationId or instantiate the client with one.")),
      activityType: 'ACTIVITY_TYPE_CREATE_INVITATIONS',
    );
    return await request<Map<String, dynamic>, TCreateInvitationsResponse>(
        "/public/v1/submit/create_invitations",
        body,
        (json) => TCreateInvitationsResponse.fromJson(
            transformActivityResponse(json, 'CreateInvitations')));
  }

  /// Produce a `SignedRequest` from `TCreateInvitationsBody` by using the client's `stamp` function.
  ///
  /// See also: `CreateInvitations`.

  Future<TSignedRequest> stampCreateInvitations({
    required TCreateInvitationsBody input,
  }) async {
    final fullUrl = '${config.baseUrl}/public/v1/submit/create_invitations';
    final body = packActivityBody(
      bodyJson: input.toJson(),
      fallbackOrganizationId: input.organizationId ??
          config.organizationId ??
          (throw Exception(
              "Missing organization ID, please pass in a sub-organizationId or instantiate the client with one.")),
      activityType: 'ACTIVITY_TYPE_CREATE_INVITATIONS',
    );
    final bodyJson = jsonEncode(body);
    final stamp = await stamper.stamp(bodyJson);

    return TSignedRequest(
      body: bodyJson,
      stamp: stamp,
      url: fullUrl,
    );
  }

  /// Enable authentication for end users with an OAuth 2.0 provider
  ///
  /// Sign the provided `TCreateOauth2CredentialBody` with the client's `stamp` function and submit the request (POST /public/v1/submit/create_oauth2_credential).
  ///
  /// See also: `stampCreateOauth2Credential`.

  Future<TCreateOauth2CredentialResponse> createOauth2Credential({
    required TCreateOauth2CredentialBody input,
  }) async {
    final body = packActivityBody(
      bodyJson: input.toJson(),
      fallbackOrganizationId: input.organizationId ??
          config.organizationId ??
          (throw Exception(
              "Missing organization ID, please pass in a sub-organizationId or instantiate the client with one.")),
      activityType: 'ACTIVITY_TYPE_CREATE_OAUTH2_CREDENTIAL',
    );
    return await request<Map<String, dynamic>, TCreateOauth2CredentialResponse>(
        "/public/v1/submit/create_oauth2_credential",
        body,
        (json) => TCreateOauth2CredentialResponse.fromJson(
            transformActivityResponse(json, 'CreateOauth2Credential')));
  }

  /// Produce a `SignedRequest` from `TCreateOauth2CredentialBody` by using the client's `stamp` function.
  ///
  /// See also: `CreateOauth2Credential`.

  Future<TSignedRequest> stampCreateOauth2Credential({
    required TCreateOauth2CredentialBody input,
  }) async {
    final fullUrl =
        '${config.baseUrl}/public/v1/submit/create_oauth2_credential';
    final body = packActivityBody(
      bodyJson: input.toJson(),
      fallbackOrganizationId: input.organizationId ??
          config.organizationId ??
          (throw Exception(
              "Missing organization ID, please pass in a sub-organizationId or instantiate the client with one.")),
      activityType: 'ACTIVITY_TYPE_CREATE_OAUTH2_CREDENTIAL',
    );
    final bodyJson = jsonEncode(body);
    final stamp = await stamper.stamp(bodyJson);

    return TSignedRequest(
      body: bodyJson,
      stamp: stamp,
      url: fullUrl,
    );
  }

  /// Create Oauth providers for a specified user.
  ///
  /// Sign the provided `TCreateOauthProvidersBody` with the client's `stamp` function and submit the request (POST /public/v1/submit/create_oauth_providers).
  ///
  /// See also: `stampCreateOauthProviders`.

  Future<TCreateOauthProvidersResponse> createOauthProviders({
    required TCreateOauthProvidersBody input,
  }) async {
    final body = packActivityBody(
      bodyJson: input.toJson(),
      fallbackOrganizationId: input.organizationId ??
          config.organizationId ??
          (throw Exception(
              "Missing organization ID, please pass in a sub-organizationId or instantiate the client with one.")),
      activityType: 'ACTIVITY_TYPE_CREATE_OAUTH_PROVIDERS',
    );
    return await request<Map<String, dynamic>, TCreateOauthProvidersResponse>(
        "/public/v1/submit/create_oauth_providers",
        body,
        (json) => TCreateOauthProvidersResponse.fromJson(
            transformActivityResponse(json, 'CreateOauthProviders')));
  }

  /// Produce a `SignedRequest` from `TCreateOauthProvidersBody` by using the client's `stamp` function.
  ///
  /// See also: `CreateOauthProviders`.

  Future<TSignedRequest> stampCreateOauthProviders({
    required TCreateOauthProvidersBody input,
  }) async {
    final fullUrl = '${config.baseUrl}/public/v1/submit/create_oauth_providers';
    final body = packActivityBody(
      bodyJson: input.toJson(),
      fallbackOrganizationId: input.organizationId ??
          config.organizationId ??
          (throw Exception(
              "Missing organization ID, please pass in a sub-organizationId or instantiate the client with one.")),
      activityType: 'ACTIVITY_TYPE_CREATE_OAUTH_PROVIDERS',
    );
    final bodyJson = jsonEncode(body);
    final stamp = await stamper.stamp(bodyJson);

    return TSignedRequest(
      body: bodyJson,
      stamp: stamp,
      url: fullUrl,
    );
  }

  /// Create new policies.
  ///
  /// Sign the provided `TCreatePoliciesBody` with the client's `stamp` function and submit the request (POST /public/v1/submit/create_policies).
  ///
  /// See also: `stampCreatePolicies`.

  Future<TCreatePoliciesResponse> createPolicies({
    required TCreatePoliciesBody input,
  }) async {
    final body = packActivityBody(
      bodyJson: input.toJson(),
      fallbackOrganizationId: input.organizationId ??
          config.organizationId ??
          (throw Exception(
              "Missing organization ID, please pass in a sub-organizationId or instantiate the client with one.")),
      activityType: 'ACTIVITY_TYPE_CREATE_POLICIES',
    );
    return await request<Map<String, dynamic>, TCreatePoliciesResponse>(
        "/public/v1/submit/create_policies",
        body,
        (json) => TCreatePoliciesResponse.fromJson(
            transformActivityResponse(json, 'CreatePolicies')));
  }

  /// Produce a `SignedRequest` from `TCreatePoliciesBody` by using the client's `stamp` function.
  ///
  /// See also: `CreatePolicies`.

  Future<TSignedRequest> stampCreatePolicies({
    required TCreatePoliciesBody input,
  }) async {
    final fullUrl = '${config.baseUrl}/public/v1/submit/create_policies';
    final body = packActivityBody(
      bodyJson: input.toJson(),
      fallbackOrganizationId: input.organizationId ??
          config.organizationId ??
          (throw Exception(
              "Missing organization ID, please pass in a sub-organizationId or instantiate the client with one.")),
      activityType: 'ACTIVITY_TYPE_CREATE_POLICIES',
    );
    final bodyJson = jsonEncode(body);
    final stamp = await stamper.stamp(bodyJson);

    return TSignedRequest(
      body: bodyJson,
      stamp: stamp,
      url: fullUrl,
    );
  }

  /// Create a new policy.
  ///
  /// Sign the provided `TCreatePolicyBody` with the client's `stamp` function and submit the request (POST /public/v1/submit/create_policy).
  ///
  /// See also: `stampCreatePolicy`.

  Future<TCreatePolicyResponse> createPolicy({
    required TCreatePolicyBody input,
  }) async {
    final body = packActivityBody(
      bodyJson: input.toJson(),
      fallbackOrganizationId: input.organizationId ??
          config.organizationId ??
          (throw Exception(
              "Missing organization ID, please pass in a sub-organizationId or instantiate the client with one.")),
      activityType: 'ACTIVITY_TYPE_CREATE_POLICY_V3',
    );
    return await request<Map<String, dynamic>, TCreatePolicyResponse>(
        "/public/v1/submit/create_policy",
        body,
        (json) => TCreatePolicyResponse.fromJson(
            transformActivityResponse(json, 'CreatePolicy')));
  }

  /// Produce a `SignedRequest` from `TCreatePolicyBody` by using the client's `stamp` function.
  ///
  /// See also: `CreatePolicy`.

  Future<TSignedRequest> stampCreatePolicy({
    required TCreatePolicyBody input,
  }) async {
    final fullUrl = '${config.baseUrl}/public/v1/submit/create_policy';
    final body = packActivityBody(
      bodyJson: input.toJson(),
      fallbackOrganizationId: input.organizationId ??
          config.organizationId ??
          (throw Exception(
              "Missing organization ID, please pass in a sub-organizationId or instantiate the client with one.")),
      activityType: 'ACTIVITY_TYPE_CREATE_POLICY_V3',
    );
    final bodyJson = jsonEncode(body);
    final stamp = await stamper.stamp(bodyJson);

    return TSignedRequest(
      body: bodyJson,
      stamp: stamp,
      url: fullUrl,
    );
  }

  /// Create a private key tag and add it to private keys.
  ///
  /// Sign the provided `TCreatePrivateKeyTagBody` with the client's `stamp` function and submit the request (POST /public/v1/submit/create_private_key_tag).
  ///
  /// See also: `stampCreatePrivateKeyTag`.

  Future<TCreatePrivateKeyTagResponse> createPrivateKeyTag({
    required TCreatePrivateKeyTagBody input,
  }) async {
    final body = packActivityBody(
      bodyJson: input.toJson(),
      fallbackOrganizationId: input.organizationId ??
          config.organizationId ??
          (throw Exception(
              "Missing organization ID, please pass in a sub-organizationId or instantiate the client with one.")),
      activityType: 'ACTIVITY_TYPE_CREATE_PRIVATE_KEY_TAG',
    );
    return await request<Map<String, dynamic>, TCreatePrivateKeyTagResponse>(
        "/public/v1/submit/create_private_key_tag",
        body,
        (json) => TCreatePrivateKeyTagResponse.fromJson(
            transformActivityResponse(json, 'CreatePrivateKeyTag')));
  }

  /// Produce a `SignedRequest` from `TCreatePrivateKeyTagBody` by using the client's `stamp` function.
  ///
  /// See also: `CreatePrivateKeyTag`.

  Future<TSignedRequest> stampCreatePrivateKeyTag({
    required TCreatePrivateKeyTagBody input,
  }) async {
    final fullUrl = '${config.baseUrl}/public/v1/submit/create_private_key_tag';
    final body = packActivityBody(
      bodyJson: input.toJson(),
      fallbackOrganizationId: input.organizationId ??
          config.organizationId ??
          (throw Exception(
              "Missing organization ID, please pass in a sub-organizationId or instantiate the client with one.")),
      activityType: 'ACTIVITY_TYPE_CREATE_PRIVATE_KEY_TAG',
    );
    final bodyJson = jsonEncode(body);
    final stamp = await stamper.stamp(bodyJson);

    return TSignedRequest(
      body: bodyJson,
      stamp: stamp,
      url: fullUrl,
    );
  }

  /// Create new private keys.
  ///
  /// Sign the provided `TCreatePrivateKeysBody` with the client's `stamp` function and submit the request (POST /public/v1/submit/create_private_keys).
  ///
  /// See also: `stampCreatePrivateKeys`.

  Future<TCreatePrivateKeysResponse> createPrivateKeys({
    required TCreatePrivateKeysBody input,
  }) async {
    final body = packActivityBody(
      bodyJson: input.toJson(),
      fallbackOrganizationId: input.organizationId ??
          config.organizationId ??
          (throw Exception(
              "Missing organization ID, please pass in a sub-organizationId or instantiate the client with one.")),
      activityType: 'ACTIVITY_TYPE_CREATE_PRIVATE_KEYS_V2',
    );
    return await request<Map<String, dynamic>, TCreatePrivateKeysResponse>(
        "/public/v1/submit/create_private_keys",
        body,
        (json) => TCreatePrivateKeysResponse.fromJson(
            transformActivityResponse(json, 'CreatePrivateKeys')));
  }

  /// Produce a `SignedRequest` from `TCreatePrivateKeysBody` by using the client's `stamp` function.
  ///
  /// See also: `CreatePrivateKeys`.

  Future<TSignedRequest> stampCreatePrivateKeys({
    required TCreatePrivateKeysBody input,
  }) async {
    final fullUrl = '${config.baseUrl}/public/v1/submit/create_private_keys';
    final body = packActivityBody(
      bodyJson: input.toJson(),
      fallbackOrganizationId: input.organizationId ??
          config.organizationId ??
          (throw Exception(
              "Missing organization ID, please pass in a sub-organizationId or instantiate the client with one.")),
      activityType: 'ACTIVITY_TYPE_CREATE_PRIVATE_KEYS_V2',
    );
    final bodyJson = jsonEncode(body);
    final stamp = await stamper.stamp(bodyJson);

    return TSignedRequest(
      body: bodyJson,
      stamp: stamp,
      url: fullUrl,
    );
  }

  /// Create a read only session for a user (valid for 1 hour).
  ///
  /// Sign the provided `TCreateReadOnlySessionBody` with the client's `stamp` function and submit the request (POST /public/v1/submit/create_read_only_session).
  ///
  /// See also: `stampCreateReadOnlySession`.

  Future<TCreateReadOnlySessionResponse> createReadOnlySession({
    required TCreateReadOnlySessionBody input,
  }) async {
    final body = packActivityBody(
      bodyJson: input.toJson(),
      fallbackOrganizationId: input.organizationId ??
          config.organizationId ??
          (throw Exception(
              "Missing organization ID, please pass in a sub-organizationId or instantiate the client with one.")),
      activityType: 'ACTIVITY_TYPE_CREATE_READ_ONLY_SESSION',
    );
    return await request<Map<String, dynamic>, TCreateReadOnlySessionResponse>(
        "/public/v1/submit/create_read_only_session",
        body,
        (json) => TCreateReadOnlySessionResponse.fromJson(
            transformActivityResponse(json, 'CreateReadOnlySession')));
  }

  /// Produce a `SignedRequest` from `TCreateReadOnlySessionBody` by using the client's `stamp` function.
  ///
  /// See also: `CreateReadOnlySession`.

  Future<TSignedRequest> stampCreateReadOnlySession({
    required TCreateReadOnlySessionBody input,
  }) async {
    final fullUrl =
        '${config.baseUrl}/public/v1/submit/create_read_only_session';
    final body = packActivityBody(
      bodyJson: input.toJson(),
      fallbackOrganizationId: input.organizationId ??
          config.organizationId ??
          (throw Exception(
              "Missing organization ID, please pass in a sub-organizationId or instantiate the client with one.")),
      activityType: 'ACTIVITY_TYPE_CREATE_READ_ONLY_SESSION',
    );
    final bodyJson = jsonEncode(body);
    final stamp = await stamper.stamp(bodyJson);

    return TSignedRequest(
      body: bodyJson,
      stamp: stamp,
      url: fullUrl,
    );
  }

  /// Create a read write session for a user.
  ///
  /// Sign the provided `TCreateReadWriteSessionBody` with the client's `stamp` function and submit the request (POST /public/v1/submit/create_read_write_session).
  ///
  /// See also: `stampCreateReadWriteSession`.

  Future<TCreateReadWriteSessionResponse> createReadWriteSession({
    required TCreateReadWriteSessionBody input,
  }) async {
    final body = packActivityBody(
      bodyJson: input.toJson(),
      fallbackOrganizationId: input.organizationId ??
          config.organizationId ??
          (throw Exception(
              "Missing organization ID, please pass in a sub-organizationId or instantiate the client with one.")),
      activityType: 'ACTIVITY_TYPE_CREATE_READ_WRITE_SESSION_V2',
    );
    return await request<Map<String, dynamic>, TCreateReadWriteSessionResponse>(
        "/public/v1/submit/create_read_write_session",
        body,
        (json) => TCreateReadWriteSessionResponse.fromJson(
            transformActivityResponse(json, 'CreateReadWriteSession')));
  }

  /// Produce a `SignedRequest` from `TCreateReadWriteSessionBody` by using the client's `stamp` function.
  ///
  /// See also: `CreateReadWriteSession`.

  Future<TSignedRequest> stampCreateReadWriteSession({
    required TCreateReadWriteSessionBody input,
  }) async {
    final fullUrl =
        '${config.baseUrl}/public/v1/submit/create_read_write_session';
    final body = packActivityBody(
      bodyJson: input.toJson(),
      fallbackOrganizationId: input.organizationId ??
          config.organizationId ??
          (throw Exception(
              "Missing organization ID, please pass in a sub-organizationId or instantiate the client with one.")),
      activityType: 'ACTIVITY_TYPE_CREATE_READ_WRITE_SESSION_V2',
    );
    final bodyJson = jsonEncode(body);
    final stamp = await stamper.stamp(bodyJson);

    return TSignedRequest(
      body: bodyJson,
      stamp: stamp,
      url: fullUrl,
    );
  }

  /// Create an ABI/IDL in JSON.
  ///
  /// Sign the provided `TCreateSmartContractInterfaceBody` with the client's `stamp` function and submit the request (POST /public/v1/submit/create_smart_contract_interface).
  ///
  /// See also: `stampCreateSmartContractInterface`.

  Future<TCreateSmartContractInterfaceResponse> createSmartContractInterface({
    required TCreateSmartContractInterfaceBody input,
  }) async {
    final body = packActivityBody(
      bodyJson: input.toJson(),
      fallbackOrganizationId: input.organizationId ??
          config.organizationId ??
          (throw Exception(
              "Missing organization ID, please pass in a sub-organizationId or instantiate the client with one.")),
      activityType: 'ACTIVITY_TYPE_CREATE_SMART_CONTRACT_INTERFACE',
    );
    return await request<Map<String, dynamic>,
            TCreateSmartContractInterfaceResponse>(
        "/public/v1/submit/create_smart_contract_interface",
        body,
        (json) => TCreateSmartContractInterfaceResponse.fromJson(
            transformActivityResponse(json, 'CreateSmartContractInterface')));
  }

  /// Produce a `SignedRequest` from `TCreateSmartContractInterfaceBody` by using the client's `stamp` function.
  ///
  /// See also: `CreateSmartContractInterface`.

  Future<TSignedRequest> stampCreateSmartContractInterface({
    required TCreateSmartContractInterfaceBody input,
  }) async {
    final fullUrl =
        '${config.baseUrl}/public/v1/submit/create_smart_contract_interface';
    final body = packActivityBody(
      bodyJson: input.toJson(),
      fallbackOrganizationId: input.organizationId ??
          config.organizationId ??
          (throw Exception(
              "Missing organization ID, please pass in a sub-organizationId or instantiate the client with one.")),
      activityType: 'ACTIVITY_TYPE_CREATE_SMART_CONTRACT_INTERFACE',
    );
    final bodyJson = jsonEncode(body);
    final stamp = await stamper.stamp(bodyJson);

    return TSignedRequest(
      body: bodyJson,
      stamp: stamp,
      url: fullUrl,
    );
  }

  /// Create a new sub-organization.
  ///
  /// Sign the provided `TCreateSubOrganizationBody` with the client's `stamp` function and submit the request (POST /public/v1/submit/create_sub_organization).
  ///
  /// See also: `stampCreateSubOrganization`.

  Future<TCreateSubOrganizationResponse> createSubOrganization({
    required TCreateSubOrganizationBody input,
  }) async {
    final body = packActivityBody(
      bodyJson: input.toJson(),
      fallbackOrganizationId: input.organizationId ??
          config.organizationId ??
          (throw Exception(
              "Missing organization ID, please pass in a sub-organizationId or instantiate the client with one.")),
      activityType: 'ACTIVITY_TYPE_CREATE_SUB_ORGANIZATION_V7',
    );
    return await request<Map<String, dynamic>, TCreateSubOrganizationResponse>(
        "/public/v1/submit/create_sub_organization",
        body,
        (json) => TCreateSubOrganizationResponse.fromJson(
            transformActivityResponse(json, 'CreateSubOrganization')));
  }

  /// Produce a `SignedRequest` from `TCreateSubOrganizationBody` by using the client's `stamp` function.
  ///
  /// See also: `CreateSubOrganization`.

  Future<TSignedRequest> stampCreateSubOrganization({
    required TCreateSubOrganizationBody input,
  }) async {
    final fullUrl =
        '${config.baseUrl}/public/v1/submit/create_sub_organization';
    final body = packActivityBody(
      bodyJson: input.toJson(),
      fallbackOrganizationId: input.organizationId ??
          config.organizationId ??
          (throw Exception(
              "Missing organization ID, please pass in a sub-organizationId or instantiate the client with one.")),
      activityType: 'ACTIVITY_TYPE_CREATE_SUB_ORGANIZATION_V7',
    );
    final bodyJson = jsonEncode(body);
    final stamp = await stamper.stamp(bodyJson);

    return TSignedRequest(
      body: bodyJson,
      stamp: stamp,
      url: fullUrl,
    );
  }

  /// Create a user tag and add it to users.
  ///
  /// Sign the provided `TCreateUserTagBody` with the client's `stamp` function and submit the request (POST /public/v1/submit/create_user_tag).
  ///
  /// See also: `stampCreateUserTag`.

  Future<TCreateUserTagResponse> createUserTag({
    required TCreateUserTagBody input,
  }) async {
    final body = packActivityBody(
      bodyJson: input.toJson(),
      fallbackOrganizationId: input.organizationId ??
          config.organizationId ??
          (throw Exception(
              "Missing organization ID, please pass in a sub-organizationId or instantiate the client with one.")),
      activityType: 'ACTIVITY_TYPE_CREATE_USER_TAG',
    );
    return await request<Map<String, dynamic>, TCreateUserTagResponse>(
        "/public/v1/submit/create_user_tag",
        body,
        (json) => TCreateUserTagResponse.fromJson(
            transformActivityResponse(json, 'CreateUserTag')));
  }

  /// Produce a `SignedRequest` from `TCreateUserTagBody` by using the client's `stamp` function.
  ///
  /// See also: `CreateUserTag`.

  Future<TSignedRequest> stampCreateUserTag({
    required TCreateUserTagBody input,
  }) async {
    final fullUrl = '${config.baseUrl}/public/v1/submit/create_user_tag';
    final body = packActivityBody(
      bodyJson: input.toJson(),
      fallbackOrganizationId: input.organizationId ??
          config.organizationId ??
          (throw Exception(
              "Missing organization ID, please pass in a sub-organizationId or instantiate the client with one.")),
      activityType: 'ACTIVITY_TYPE_CREATE_USER_TAG',
    );
    final bodyJson = jsonEncode(body);
    final stamp = await stamper.stamp(bodyJson);

    return TSignedRequest(
      body: bodyJson,
      stamp: stamp,
      url: fullUrl,
    );
  }

  /// Create users in an existing organization.
  ///
  /// Sign the provided `TCreateUsersBody` with the client's `stamp` function and submit the request (POST /public/v1/submit/create_users).
  ///
  /// See also: `stampCreateUsers`.

  Future<TCreateUsersResponse> createUsers({
    required TCreateUsersBody input,
  }) async {
    final body = packActivityBody(
      bodyJson: input.toJson(),
      fallbackOrganizationId: input.organizationId ??
          config.organizationId ??
          (throw Exception(
              "Missing organization ID, please pass in a sub-organizationId or instantiate the client with one.")),
      activityType: 'ACTIVITY_TYPE_CREATE_USERS_V3',
    );
    return await request<Map<String, dynamic>, TCreateUsersResponse>(
        "/public/v1/submit/create_users",
        body,
        (json) => TCreateUsersResponse.fromJson(
            transformActivityResponse(json, 'CreateUsers')));
  }

  /// Produce a `SignedRequest` from `TCreateUsersBody` by using the client's `stamp` function.
  ///
  /// See also: `CreateUsers`.

  Future<TSignedRequest> stampCreateUsers({
    required TCreateUsersBody input,
  }) async {
    final fullUrl = '${config.baseUrl}/public/v1/submit/create_users';
    final body = packActivityBody(
      bodyJson: input.toJson(),
      fallbackOrganizationId: input.organizationId ??
          config.organizationId ??
          (throw Exception(
              "Missing organization ID, please pass in a sub-organizationId or instantiate the client with one.")),
      activityType: 'ACTIVITY_TYPE_CREATE_USERS_V3',
    );
    final bodyJson = jsonEncode(body);
    final stamp = await stamper.stamp(bodyJson);

    return TSignedRequest(
      body: bodyJson,
      stamp: stamp,
      url: fullUrl,
    );
  }

  /// Create a wallet and derive addresses.
  ///
  /// Sign the provided `TCreateWalletBody` with the client's `stamp` function and submit the request (POST /public/v1/submit/create_wallet).
  ///
  /// See also: `stampCreateWallet`.

  Future<TCreateWalletResponse> createWallet({
    required TCreateWalletBody input,
  }) async {
    final body = packActivityBody(
      bodyJson: input.toJson(),
      fallbackOrganizationId: input.organizationId ??
          config.organizationId ??
          (throw Exception(
              "Missing organization ID, please pass in a sub-organizationId or instantiate the client with one.")),
      activityType: 'ACTIVITY_TYPE_CREATE_WALLET',
    );
    return await request<Map<String, dynamic>, TCreateWalletResponse>(
        "/public/v1/submit/create_wallet",
        body,
        (json) => TCreateWalletResponse.fromJson(
            transformActivityResponse(json, 'CreateWallet')));
  }

  /// Produce a `SignedRequest` from `TCreateWalletBody` by using the client's `stamp` function.
  ///
  /// See also: `CreateWallet`.

  Future<TSignedRequest> stampCreateWallet({
    required TCreateWalletBody input,
  }) async {
    final fullUrl = '${config.baseUrl}/public/v1/submit/create_wallet';
    final body = packActivityBody(
      bodyJson: input.toJson(),
      fallbackOrganizationId: input.organizationId ??
          config.organizationId ??
          (throw Exception(
              "Missing organization ID, please pass in a sub-organizationId or instantiate the client with one.")),
      activityType: 'ACTIVITY_TYPE_CREATE_WALLET',
    );
    final bodyJson = jsonEncode(body);
    final stamp = await stamper.stamp(bodyJson);

    return TSignedRequest(
      body: bodyJson,
      stamp: stamp,
      url: fullUrl,
    );
  }

  /// Derive additional addresses using an existing wallet.
  ///
  /// Sign the provided `TCreateWalletAccountsBody` with the client's `stamp` function and submit the request (POST /public/v1/submit/create_wallet_accounts).
  ///
  /// See also: `stampCreateWalletAccounts`.

  Future<TCreateWalletAccountsResponse> createWalletAccounts({
    required TCreateWalletAccountsBody input,
  }) async {
    final body = packActivityBody(
      bodyJson: input.toJson(),
      fallbackOrganizationId: input.organizationId ??
          config.organizationId ??
          (throw Exception(
              "Missing organization ID, please pass in a sub-organizationId or instantiate the client with one.")),
      activityType: 'ACTIVITY_TYPE_CREATE_WALLET_ACCOUNTS',
    );
    return await request<Map<String, dynamic>, TCreateWalletAccountsResponse>(
        "/public/v1/submit/create_wallet_accounts",
        body,
        (json) => TCreateWalletAccountsResponse.fromJson(
            transformActivityResponse(json, 'CreateWalletAccounts')));
  }

  /// Produce a `SignedRequest` from `TCreateWalletAccountsBody` by using the client's `stamp` function.
  ///
  /// See also: `CreateWalletAccounts`.

  Future<TSignedRequest> stampCreateWalletAccounts({
    required TCreateWalletAccountsBody input,
  }) async {
    final fullUrl = '${config.baseUrl}/public/v1/submit/create_wallet_accounts';
    final body = packActivityBody(
      bodyJson: input.toJson(),
      fallbackOrganizationId: input.organizationId ??
          config.organizationId ??
          (throw Exception(
              "Missing organization ID, please pass in a sub-organizationId or instantiate the client with one.")),
      activityType: 'ACTIVITY_TYPE_CREATE_WALLET_ACCOUNTS',
    );
    final bodyJson = jsonEncode(body);
    final stamp = await stamper.stamp(bodyJson);

    return TSignedRequest(
      body: bodyJson,
      stamp: stamp,
      url: fullUrl,
    );
  }

  /// Remove api keys from a user.
  ///
  /// Sign the provided `TDeleteApiKeysBody` with the client's `stamp` function and submit the request (POST /public/v1/submit/delete_api_keys).
  ///
  /// See also: `stampDeleteApiKeys`.

  Future<TDeleteApiKeysResponse> deleteApiKeys({
    required TDeleteApiKeysBody input,
  }) async {
    final body = packActivityBody(
      bodyJson: input.toJson(),
      fallbackOrganizationId: input.organizationId ??
          config.organizationId ??
          (throw Exception(
              "Missing organization ID, please pass in a sub-organizationId or instantiate the client with one.")),
      activityType: 'ACTIVITY_TYPE_DELETE_API_KEYS',
    );
    return await request<Map<String, dynamic>, TDeleteApiKeysResponse>(
        "/public/v1/submit/delete_api_keys",
        body,
        (json) => TDeleteApiKeysResponse.fromJson(
            transformActivityResponse(json, 'DeleteApiKeys')));
  }

  /// Produce a `SignedRequest` from `TDeleteApiKeysBody` by using the client's `stamp` function.
  ///
  /// See also: `DeleteApiKeys`.

  Future<TSignedRequest> stampDeleteApiKeys({
    required TDeleteApiKeysBody input,
  }) async {
    final fullUrl = '${config.baseUrl}/public/v1/submit/delete_api_keys';
    final body = packActivityBody(
      bodyJson: input.toJson(),
      fallbackOrganizationId: input.organizationId ??
          config.organizationId ??
          (throw Exception(
              "Missing organization ID, please pass in a sub-organizationId or instantiate the client with one.")),
      activityType: 'ACTIVITY_TYPE_DELETE_API_KEYS',
    );
    final bodyJson = jsonEncode(body);
    final stamp = await stamper.stamp(bodyJson);

    return TSignedRequest(
      body: bodyJson,
      stamp: stamp,
      url: fullUrl,
    );
  }

  /// Remove authenticators from a user.
  ///
  /// Sign the provided `TDeleteAuthenticatorsBody` with the client's `stamp` function and submit the request (POST /public/v1/submit/delete_authenticators).
  ///
  /// See also: `stampDeleteAuthenticators`.

  Future<TDeleteAuthenticatorsResponse> deleteAuthenticators({
    required TDeleteAuthenticatorsBody input,
  }) async {
    final body = packActivityBody(
      bodyJson: input.toJson(),
      fallbackOrganizationId: input.organizationId ??
          config.organizationId ??
          (throw Exception(
              "Missing organization ID, please pass in a sub-organizationId or instantiate the client with one.")),
      activityType: 'ACTIVITY_TYPE_DELETE_AUTHENTICATORS',
    );
    return await request<Map<String, dynamic>, TDeleteAuthenticatorsResponse>(
        "/public/v1/submit/delete_authenticators",
        body,
        (json) => TDeleteAuthenticatorsResponse.fromJson(
            transformActivityResponse(json, 'DeleteAuthenticators')));
  }

  /// Produce a `SignedRequest` from `TDeleteAuthenticatorsBody` by using the client's `stamp` function.
  ///
  /// See also: `DeleteAuthenticators`.

  Future<TSignedRequest> stampDeleteAuthenticators({
    required TDeleteAuthenticatorsBody input,
  }) async {
    final fullUrl = '${config.baseUrl}/public/v1/submit/delete_authenticators';
    final body = packActivityBody(
      bodyJson: input.toJson(),
      fallbackOrganizationId: input.organizationId ??
          config.organizationId ??
          (throw Exception(
              "Missing organization ID, please pass in a sub-organizationId or instantiate the client with one.")),
      activityType: 'ACTIVITY_TYPE_DELETE_AUTHENTICATORS',
    );
    final bodyJson = jsonEncode(body);
    final stamp = await stamper.stamp(bodyJson);

    return TSignedRequest(
      body: bodyJson,
      stamp: stamp,
      url: fullUrl,
    );
  }

  /// Delete an existing invitation.
  ///
  /// Sign the provided `TDeleteInvitationBody` with the client's `stamp` function and submit the request (POST /public/v1/submit/delete_invitation).
  ///
  /// See also: `stampDeleteInvitation`.

  Future<TDeleteInvitationResponse> deleteInvitation({
    required TDeleteInvitationBody input,
  }) async {
    final body = packActivityBody(
      bodyJson: input.toJson(),
      fallbackOrganizationId: input.organizationId ??
          config.organizationId ??
          (throw Exception(
              "Missing organization ID, please pass in a sub-organizationId or instantiate the client with one.")),
      activityType: 'ACTIVITY_TYPE_DELETE_INVITATION',
    );
    return await request<Map<String, dynamic>, TDeleteInvitationResponse>(
        "/public/v1/submit/delete_invitation",
        body,
        (json) => TDeleteInvitationResponse.fromJson(
            transformActivityResponse(json, 'DeleteInvitation')));
  }

  /// Produce a `SignedRequest` from `TDeleteInvitationBody` by using the client's `stamp` function.
  ///
  /// See also: `DeleteInvitation`.

  Future<TSignedRequest> stampDeleteInvitation({
    required TDeleteInvitationBody input,
  }) async {
    final fullUrl = '${config.baseUrl}/public/v1/submit/delete_invitation';
    final body = packActivityBody(
      bodyJson: input.toJson(),
      fallbackOrganizationId: input.organizationId ??
          config.organizationId ??
          (throw Exception(
              "Missing organization ID, please pass in a sub-organizationId or instantiate the client with one.")),
      activityType: 'ACTIVITY_TYPE_DELETE_INVITATION',
    );
    final bodyJson = jsonEncode(body);
    final stamp = await stamper.stamp(bodyJson);

    return TSignedRequest(
      body: bodyJson,
      stamp: stamp,
      url: fullUrl,
    );
  }

  /// Disable authentication for end users with an OAuth 2.0 provider
  ///
  /// Sign the provided `TDeleteOauth2CredentialBody` with the client's `stamp` function and submit the request (POST /public/v1/submit/delete_oauth2_credential).
  ///
  /// See also: `stampDeleteOauth2Credential`.

  Future<TDeleteOauth2CredentialResponse> deleteOauth2Credential({
    required TDeleteOauth2CredentialBody input,
  }) async {
    final body = packActivityBody(
      bodyJson: input.toJson(),
      fallbackOrganizationId: input.organizationId ??
          config.organizationId ??
          (throw Exception(
              "Missing organization ID, please pass in a sub-organizationId or instantiate the client with one.")),
      activityType: 'ACTIVITY_TYPE_DELETE_OAUTH2_CREDENTIAL',
    );
    return await request<Map<String, dynamic>, TDeleteOauth2CredentialResponse>(
        "/public/v1/submit/delete_oauth2_credential",
        body,
        (json) => TDeleteOauth2CredentialResponse.fromJson(
            transformActivityResponse(json, 'DeleteOauth2Credential')));
  }

  /// Produce a `SignedRequest` from `TDeleteOauth2CredentialBody` by using the client's `stamp` function.
  ///
  /// See also: `DeleteOauth2Credential`.

  Future<TSignedRequest> stampDeleteOauth2Credential({
    required TDeleteOauth2CredentialBody input,
  }) async {
    final fullUrl =
        '${config.baseUrl}/public/v1/submit/delete_oauth2_credential';
    final body = packActivityBody(
      bodyJson: input.toJson(),
      fallbackOrganizationId: input.organizationId ??
          config.organizationId ??
          (throw Exception(
              "Missing organization ID, please pass in a sub-organizationId or instantiate the client with one.")),
      activityType: 'ACTIVITY_TYPE_DELETE_OAUTH2_CREDENTIAL',
    );
    final bodyJson = jsonEncode(body);
    final stamp = await stamper.stamp(bodyJson);

    return TSignedRequest(
      body: bodyJson,
      stamp: stamp,
      url: fullUrl,
    );
  }

  /// Remove Oauth providers for a specified user.
  ///
  /// Sign the provided `TDeleteOauthProvidersBody` with the client's `stamp` function and submit the request (POST /public/v1/submit/delete_oauth_providers).
  ///
  /// See also: `stampDeleteOauthProviders`.

  Future<TDeleteOauthProvidersResponse> deleteOauthProviders({
    required TDeleteOauthProvidersBody input,
  }) async {
    final body = packActivityBody(
      bodyJson: input.toJson(),
      fallbackOrganizationId: input.organizationId ??
          config.organizationId ??
          (throw Exception(
              "Missing organization ID, please pass in a sub-organizationId or instantiate the client with one.")),
      activityType: 'ACTIVITY_TYPE_DELETE_OAUTH_PROVIDERS',
    );
    return await request<Map<String, dynamic>, TDeleteOauthProvidersResponse>(
        "/public/v1/submit/delete_oauth_providers",
        body,
        (json) => TDeleteOauthProvidersResponse.fromJson(
            transformActivityResponse(json, 'DeleteOauthProviders')));
  }

  /// Produce a `SignedRequest` from `TDeleteOauthProvidersBody` by using the client's `stamp` function.
  ///
  /// See also: `DeleteOauthProviders`.

  Future<TSignedRequest> stampDeleteOauthProviders({
    required TDeleteOauthProvidersBody input,
  }) async {
    final fullUrl = '${config.baseUrl}/public/v1/submit/delete_oauth_providers';
    final body = packActivityBody(
      bodyJson: input.toJson(),
      fallbackOrganizationId: input.organizationId ??
          config.organizationId ??
          (throw Exception(
              "Missing organization ID, please pass in a sub-organizationId or instantiate the client with one.")),
      activityType: 'ACTIVITY_TYPE_DELETE_OAUTH_PROVIDERS',
    );
    final bodyJson = jsonEncode(body);
    final stamp = await stamper.stamp(bodyJson);

    return TSignedRequest(
      body: bodyJson,
      stamp: stamp,
      url: fullUrl,
    );
  }

  /// Delete existing policies.
  ///
  /// Sign the provided `TDeletePoliciesBody` with the client's `stamp` function and submit the request (POST /public/v1/submit/delete_policies).
  ///
  /// See also: `stampDeletePolicies`.

  Future<TDeletePoliciesResponse> deletePolicies({
    required TDeletePoliciesBody input,
  }) async {
    final body = packActivityBody(
      bodyJson: input.toJson(),
      fallbackOrganizationId: input.organizationId ??
          config.organizationId ??
          (throw Exception(
              "Missing organization ID, please pass in a sub-organizationId or instantiate the client with one.")),
      activityType: 'ACTIVITY_TYPE_DELETE_POLICIES',
    );
    return await request<Map<String, dynamic>, TDeletePoliciesResponse>(
        "/public/v1/submit/delete_policies",
        body,
        (json) => TDeletePoliciesResponse.fromJson(
            transformActivityResponse(json, 'DeletePolicies')));
  }

  /// Produce a `SignedRequest` from `TDeletePoliciesBody` by using the client's `stamp` function.
  ///
  /// See also: `DeletePolicies`.

  Future<TSignedRequest> stampDeletePolicies({
    required TDeletePoliciesBody input,
  }) async {
    final fullUrl = '${config.baseUrl}/public/v1/submit/delete_policies';
    final body = packActivityBody(
      bodyJson: input.toJson(),
      fallbackOrganizationId: input.organizationId ??
          config.organizationId ??
          (throw Exception(
              "Missing organization ID, please pass in a sub-organizationId or instantiate the client with one.")),
      activityType: 'ACTIVITY_TYPE_DELETE_POLICIES',
    );
    final bodyJson = jsonEncode(body);
    final stamp = await stamper.stamp(bodyJson);

    return TSignedRequest(
      body: bodyJson,
      stamp: stamp,
      url: fullUrl,
    );
  }

  /// Delete an existing policy.
  ///
  /// Sign the provided `TDeletePolicyBody` with the client's `stamp` function and submit the request (POST /public/v1/submit/delete_policy).
  ///
  /// See also: `stampDeletePolicy`.

  Future<TDeletePolicyResponse> deletePolicy({
    required TDeletePolicyBody input,
  }) async {
    final body = packActivityBody(
      bodyJson: input.toJson(),
      fallbackOrganizationId: input.organizationId ??
          config.organizationId ??
          (throw Exception(
              "Missing organization ID, please pass in a sub-organizationId or instantiate the client with one.")),
      activityType: 'ACTIVITY_TYPE_DELETE_POLICY',
    );
    return await request<Map<String, dynamic>, TDeletePolicyResponse>(
        "/public/v1/submit/delete_policy",
        body,
        (json) => TDeletePolicyResponse.fromJson(
            transformActivityResponse(json, 'DeletePolicy')));
  }

  /// Produce a `SignedRequest` from `TDeletePolicyBody` by using the client's `stamp` function.
  ///
  /// See also: `DeletePolicy`.

  Future<TSignedRequest> stampDeletePolicy({
    required TDeletePolicyBody input,
  }) async {
    final fullUrl = '${config.baseUrl}/public/v1/submit/delete_policy';
    final body = packActivityBody(
      bodyJson: input.toJson(),
      fallbackOrganizationId: input.organizationId ??
          config.organizationId ??
          (throw Exception(
              "Missing organization ID, please pass in a sub-organizationId or instantiate the client with one.")),
      activityType: 'ACTIVITY_TYPE_DELETE_POLICY',
    );
    final bodyJson = jsonEncode(body);
    final stamp = await stamper.stamp(bodyJson);

    return TSignedRequest(
      body: bodyJson,
      stamp: stamp,
      url: fullUrl,
    );
  }

  /// Delete private key tags within an organization.
  ///
  /// Sign the provided `TDeletePrivateKeyTagsBody` with the client's `stamp` function and submit the request (POST /public/v1/submit/delete_private_key_tags).
  ///
  /// See also: `stampDeletePrivateKeyTags`.

  Future<TDeletePrivateKeyTagsResponse> deletePrivateKeyTags({
    required TDeletePrivateKeyTagsBody input,
  }) async {
    final body = packActivityBody(
      bodyJson: input.toJson(),
      fallbackOrganizationId: input.organizationId ??
          config.organizationId ??
          (throw Exception(
              "Missing organization ID, please pass in a sub-organizationId or instantiate the client with one.")),
      activityType: 'ACTIVITY_TYPE_DELETE_PRIVATE_KEY_TAGS',
    );
    return await request<Map<String, dynamic>, TDeletePrivateKeyTagsResponse>(
        "/public/v1/submit/delete_private_key_tags",
        body,
        (json) => TDeletePrivateKeyTagsResponse.fromJson(
            transformActivityResponse(json, 'DeletePrivateKeyTags')));
  }

  /// Produce a `SignedRequest` from `TDeletePrivateKeyTagsBody` by using the client's `stamp` function.
  ///
  /// See also: `DeletePrivateKeyTags`.

  Future<TSignedRequest> stampDeletePrivateKeyTags({
    required TDeletePrivateKeyTagsBody input,
  }) async {
    final fullUrl =
        '${config.baseUrl}/public/v1/submit/delete_private_key_tags';
    final body = packActivityBody(
      bodyJson: input.toJson(),
      fallbackOrganizationId: input.organizationId ??
          config.organizationId ??
          (throw Exception(
              "Missing organization ID, please pass in a sub-organizationId or instantiate the client with one.")),
      activityType: 'ACTIVITY_TYPE_DELETE_PRIVATE_KEY_TAGS',
    );
    final bodyJson = jsonEncode(body);
    final stamp = await stamper.stamp(bodyJson);

    return TSignedRequest(
      body: bodyJson,
      stamp: stamp,
      url: fullUrl,
    );
  }

  /// Delete private keys for an organization.
  ///
  /// Sign the provided `TDeletePrivateKeysBody` with the client's `stamp` function and submit the request (POST /public/v1/submit/delete_private_keys).
  ///
  /// See also: `stampDeletePrivateKeys`.

  Future<TDeletePrivateKeysResponse> deletePrivateKeys({
    required TDeletePrivateKeysBody input,
  }) async {
    final body = packActivityBody(
      bodyJson: input.toJson(),
      fallbackOrganizationId: input.organizationId ??
          config.organizationId ??
          (throw Exception(
              "Missing organization ID, please pass in a sub-organizationId or instantiate the client with one.")),
      activityType: 'ACTIVITY_TYPE_DELETE_PRIVATE_KEYS',
    );
    return await request<Map<String, dynamic>, TDeletePrivateKeysResponse>(
        "/public/v1/submit/delete_private_keys",
        body,
        (json) => TDeletePrivateKeysResponse.fromJson(
            transformActivityResponse(json, 'DeletePrivateKeys')));
  }

  /// Produce a `SignedRequest` from `TDeletePrivateKeysBody` by using the client's `stamp` function.
  ///
  /// See also: `DeletePrivateKeys`.

  Future<TSignedRequest> stampDeletePrivateKeys({
    required TDeletePrivateKeysBody input,
  }) async {
    final fullUrl = '${config.baseUrl}/public/v1/submit/delete_private_keys';
    final body = packActivityBody(
      bodyJson: input.toJson(),
      fallbackOrganizationId: input.organizationId ??
          config.organizationId ??
          (throw Exception(
              "Missing organization ID, please pass in a sub-organizationId or instantiate the client with one.")),
      activityType: 'ACTIVITY_TYPE_DELETE_PRIVATE_KEYS',
    );
    final bodyJson = jsonEncode(body);
    final stamp = await stamper.stamp(bodyJson);

    return TSignedRequest(
      body: bodyJson,
      stamp: stamp,
      url: fullUrl,
    );
  }

  /// Delete a smart contract interface.
  ///
  /// Sign the provided `TDeleteSmartContractInterfaceBody` with the client's `stamp` function and submit the request (POST /public/v1/submit/delete_smart_contract_interface).
  ///
  /// See also: `stampDeleteSmartContractInterface`.

  Future<TDeleteSmartContractInterfaceResponse> deleteSmartContractInterface({
    required TDeleteSmartContractInterfaceBody input,
  }) async {
    final body = packActivityBody(
      bodyJson: input.toJson(),
      fallbackOrganizationId: input.organizationId ??
          config.organizationId ??
          (throw Exception(
              "Missing organization ID, please pass in a sub-organizationId or instantiate the client with one.")),
      activityType: 'ACTIVITY_TYPE_DELETE_SMART_CONTRACT_INTERFACE',
    );
    return await request<Map<String, dynamic>,
            TDeleteSmartContractInterfaceResponse>(
        "/public/v1/submit/delete_smart_contract_interface",
        body,
        (json) => TDeleteSmartContractInterfaceResponse.fromJson(
            transformActivityResponse(json, 'DeleteSmartContractInterface')));
  }

  /// Produce a `SignedRequest` from `TDeleteSmartContractInterfaceBody` by using the client's `stamp` function.
  ///
  /// See also: `DeleteSmartContractInterface`.

  Future<TSignedRequest> stampDeleteSmartContractInterface({
    required TDeleteSmartContractInterfaceBody input,
  }) async {
    final fullUrl =
        '${config.baseUrl}/public/v1/submit/delete_smart_contract_interface';
    final body = packActivityBody(
      bodyJson: input.toJson(),
      fallbackOrganizationId: input.organizationId ??
          config.organizationId ??
          (throw Exception(
              "Missing organization ID, please pass in a sub-organizationId or instantiate the client with one.")),
      activityType: 'ACTIVITY_TYPE_DELETE_SMART_CONTRACT_INTERFACE',
    );
    final bodyJson = jsonEncode(body);
    final stamp = await stamper.stamp(bodyJson);

    return TSignedRequest(
      body: bodyJson,
      stamp: stamp,
      url: fullUrl,
    );
  }

  /// Delete a sub-organization.
  ///
  /// Sign the provided `TDeleteSubOrganizationBody` with the client's `stamp` function and submit the request (POST /public/v1/submit/delete_sub_organization).
  ///
  /// See also: `stampDeleteSubOrganization`.

  Future<TDeleteSubOrganizationResponse> deleteSubOrganization({
    required TDeleteSubOrganizationBody input,
  }) async {
    final body = packActivityBody(
      bodyJson: input.toJson(),
      fallbackOrganizationId: input.organizationId ??
          config.organizationId ??
          (throw Exception(
              "Missing organization ID, please pass in a sub-organizationId or instantiate the client with one.")),
      activityType: 'ACTIVITY_TYPE_DELETE_SUB_ORGANIZATION',
    );
    return await request<Map<String, dynamic>, TDeleteSubOrganizationResponse>(
        "/public/v1/submit/delete_sub_organization",
        body,
        (json) => TDeleteSubOrganizationResponse.fromJson(
            transformActivityResponse(json, 'DeleteSubOrganization')));
  }

  /// Produce a `SignedRequest` from `TDeleteSubOrganizationBody` by using the client's `stamp` function.
  ///
  /// See also: `DeleteSubOrganization`.

  Future<TSignedRequest> stampDeleteSubOrganization({
    required TDeleteSubOrganizationBody input,
  }) async {
    final fullUrl =
        '${config.baseUrl}/public/v1/submit/delete_sub_organization';
    final body = packActivityBody(
      bodyJson: input.toJson(),
      fallbackOrganizationId: input.organizationId ??
          config.organizationId ??
          (throw Exception(
              "Missing organization ID, please pass in a sub-organizationId or instantiate the client with one.")),
      activityType: 'ACTIVITY_TYPE_DELETE_SUB_ORGANIZATION',
    );
    final bodyJson = jsonEncode(body);
    final stamp = await stamper.stamp(bodyJson);

    return TSignedRequest(
      body: bodyJson,
      stamp: stamp,
      url: fullUrl,
    );
  }

  /// Delete user tags within an organization.
  ///
  /// Sign the provided `TDeleteUserTagsBody` with the client's `stamp` function and submit the request (POST /public/v1/submit/delete_user_tags).
  ///
  /// See also: `stampDeleteUserTags`.

  Future<TDeleteUserTagsResponse> deleteUserTags({
    required TDeleteUserTagsBody input,
  }) async {
    final body = packActivityBody(
      bodyJson: input.toJson(),
      fallbackOrganizationId: input.organizationId ??
          config.organizationId ??
          (throw Exception(
              "Missing organization ID, please pass in a sub-organizationId or instantiate the client with one.")),
      activityType: 'ACTIVITY_TYPE_DELETE_USER_TAGS',
    );
    return await request<Map<String, dynamic>, TDeleteUserTagsResponse>(
        "/public/v1/submit/delete_user_tags",
        body,
        (json) => TDeleteUserTagsResponse.fromJson(
            transformActivityResponse(json, 'DeleteUserTags')));
  }

  /// Produce a `SignedRequest` from `TDeleteUserTagsBody` by using the client's `stamp` function.
  ///
  /// See also: `DeleteUserTags`.

  Future<TSignedRequest> stampDeleteUserTags({
    required TDeleteUserTagsBody input,
  }) async {
    final fullUrl = '${config.baseUrl}/public/v1/submit/delete_user_tags';
    final body = packActivityBody(
      bodyJson: input.toJson(),
      fallbackOrganizationId: input.organizationId ??
          config.organizationId ??
          (throw Exception(
              "Missing organization ID, please pass in a sub-organizationId or instantiate the client with one.")),
      activityType: 'ACTIVITY_TYPE_DELETE_USER_TAGS',
    );
    final bodyJson = jsonEncode(body);
    final stamp = await stamper.stamp(bodyJson);

    return TSignedRequest(
      body: bodyJson,
      stamp: stamp,
      url: fullUrl,
    );
  }

  /// Delete users within an organization.
  ///
  /// Sign the provided `TDeleteUsersBody` with the client's `stamp` function and submit the request (POST /public/v1/submit/delete_users).
  ///
  /// See also: `stampDeleteUsers`.

  Future<TDeleteUsersResponse> deleteUsers({
    required TDeleteUsersBody input,
  }) async {
    final body = packActivityBody(
      bodyJson: input.toJson(),
      fallbackOrganizationId: input.organizationId ??
          config.organizationId ??
          (throw Exception(
              "Missing organization ID, please pass in a sub-organizationId or instantiate the client with one.")),
      activityType: 'ACTIVITY_TYPE_DELETE_USERS',
    );
    return await request<Map<String, dynamic>, TDeleteUsersResponse>(
        "/public/v1/submit/delete_users",
        body,
        (json) => TDeleteUsersResponse.fromJson(
            transformActivityResponse(json, 'DeleteUsers')));
  }

  /// Produce a `SignedRequest` from `TDeleteUsersBody` by using the client's `stamp` function.
  ///
  /// See also: `DeleteUsers`.

  Future<TSignedRequest> stampDeleteUsers({
    required TDeleteUsersBody input,
  }) async {
    final fullUrl = '${config.baseUrl}/public/v1/submit/delete_users';
    final body = packActivityBody(
      bodyJson: input.toJson(),
      fallbackOrganizationId: input.organizationId ??
          config.organizationId ??
          (throw Exception(
              "Missing organization ID, please pass in a sub-organizationId or instantiate the client with one.")),
      activityType: 'ACTIVITY_TYPE_DELETE_USERS',
    );
    final bodyJson = jsonEncode(body);
    final stamp = await stamper.stamp(bodyJson);

    return TSignedRequest(
      body: bodyJson,
      stamp: stamp,
      url: fullUrl,
    );
  }

  /// Delete wallet accounts for an organization.
  ///
  /// Sign the provided `TDeleteWalletAccountsBody` with the client's `stamp` function and submit the request (POST /public/v1/submit/delete_wallet_accounts).
  ///
  /// See also: `stampDeleteWalletAccounts`.

  Future<TDeleteWalletAccountsResponse> deleteWalletAccounts({
    required TDeleteWalletAccountsBody input,
  }) async {
    final body = packActivityBody(
      bodyJson: input.toJson(),
      fallbackOrganizationId: input.organizationId ??
          config.organizationId ??
          (throw Exception(
              "Missing organization ID, please pass in a sub-organizationId or instantiate the client with one.")),
      activityType: 'ACTIVITY_TYPE_DELETE_WALLET_ACCOUNTS',
    );
    return await request<Map<String, dynamic>, TDeleteWalletAccountsResponse>(
        "/public/v1/submit/delete_wallet_accounts",
        body,
        (json) => TDeleteWalletAccountsResponse.fromJson(
            transformActivityResponse(json, 'DeleteWalletAccounts')));
  }

  /// Produce a `SignedRequest` from `TDeleteWalletAccountsBody` by using the client's `stamp` function.
  ///
  /// See also: `DeleteWalletAccounts`.

  Future<TSignedRequest> stampDeleteWalletAccounts({
    required TDeleteWalletAccountsBody input,
  }) async {
    final fullUrl = '${config.baseUrl}/public/v1/submit/delete_wallet_accounts';
    final body = packActivityBody(
      bodyJson: input.toJson(),
      fallbackOrganizationId: input.organizationId ??
          config.organizationId ??
          (throw Exception(
              "Missing organization ID, please pass in a sub-organizationId or instantiate the client with one.")),
      activityType: 'ACTIVITY_TYPE_DELETE_WALLET_ACCOUNTS',
    );
    final bodyJson = jsonEncode(body);
    final stamp = await stamper.stamp(bodyJson);

    return TSignedRequest(
      body: bodyJson,
      stamp: stamp,
      url: fullUrl,
    );
  }

  /// Delete wallets for an organization.
  ///
  /// Sign the provided `TDeleteWalletsBody` with the client's `stamp` function and submit the request (POST /public/v1/submit/delete_wallets).
  ///
  /// See also: `stampDeleteWallets`.

  Future<TDeleteWalletsResponse> deleteWallets({
    required TDeleteWalletsBody input,
  }) async {
    final body = packActivityBody(
      bodyJson: input.toJson(),
      fallbackOrganizationId: input.organizationId ??
          config.organizationId ??
          (throw Exception(
              "Missing organization ID, please pass in a sub-organizationId or instantiate the client with one.")),
      activityType: 'ACTIVITY_TYPE_DELETE_WALLETS',
    );
    return await request<Map<String, dynamic>, TDeleteWalletsResponse>(
        "/public/v1/submit/delete_wallets",
        body,
        (json) => TDeleteWalletsResponse.fromJson(
            transformActivityResponse(json, 'DeleteWallets')));
  }

  /// Produce a `SignedRequest` from `TDeleteWalletsBody` by using the client's `stamp` function.
  ///
  /// See also: `DeleteWallets`.

  Future<TSignedRequest> stampDeleteWallets({
    required TDeleteWalletsBody input,
  }) async {
    final fullUrl = '${config.baseUrl}/public/v1/submit/delete_wallets';
    final body = packActivityBody(
      bodyJson: input.toJson(),
      fallbackOrganizationId: input.organizationId ??
          config.organizationId ??
          (throw Exception(
              "Missing organization ID, please pass in a sub-organizationId or instantiate the client with one.")),
      activityType: 'ACTIVITY_TYPE_DELETE_WALLETS',
    );
    final bodyJson = jsonEncode(body);
    final stamp = await stamper.stamp(bodyJson);

    return TSignedRequest(
      body: bodyJson,
      stamp: stamp,
      url: fullUrl,
    );
  }

  /// Authenticate a user via email.
  ///
  /// Sign the provided `TEmailAuthBody` with the client's `stamp` function and submit the request (POST /public/v1/submit/email_auth).
  ///
  /// See also: `stampEmailAuth`.

  Future<TEmailAuthResponse> emailAuth({
    required TEmailAuthBody input,
  }) async {
    final body = packActivityBody(
      bodyJson: input.toJson(),
      fallbackOrganizationId: input.organizationId ??
          config.organizationId ??
          (throw Exception(
              "Missing organization ID, please pass in a sub-organizationId or instantiate the client with one.")),
      activityType: 'ACTIVITY_TYPE_EMAIL_AUTH_V2',
    );
    return await request<Map<String, dynamic>, TEmailAuthResponse>(
        "/public/v1/submit/email_auth",
        body,
        (json) => TEmailAuthResponse.fromJson(
            transformActivityResponse(json, 'EmailAuth')));
  }

  /// Produce a `SignedRequest` from `TEmailAuthBody` by using the client's `stamp` function.
  ///
  /// See also: `EmailAuth`.

  Future<TSignedRequest> stampEmailAuth({
    required TEmailAuthBody input,
  }) async {
    final fullUrl = '${config.baseUrl}/public/v1/submit/email_auth';
    final body = packActivityBody(
      bodyJson: input.toJson(),
      fallbackOrganizationId: input.organizationId ??
          config.organizationId ??
          (throw Exception(
              "Missing organization ID, please pass in a sub-organizationId or instantiate the client with one.")),
      activityType: 'ACTIVITY_TYPE_EMAIL_AUTH_V2',
    );
    final bodyJson = jsonEncode(body);
    final stamp = await stamper.stamp(bodyJson);

    return TSignedRequest(
      body: bodyJson,
      stamp: stamp,
      url: fullUrl,
    );
  }

  /// Export a private key.
  ///
  /// Sign the provided `TExportPrivateKeyBody` with the client's `stamp` function and submit the request (POST /public/v1/submit/export_private_key).
  ///
  /// See also: `stampExportPrivateKey`.

  Future<TExportPrivateKeyResponse> exportPrivateKey({
    required TExportPrivateKeyBody input,
  }) async {
    final body = packActivityBody(
      bodyJson: input.toJson(),
      fallbackOrganizationId: input.organizationId ??
          config.organizationId ??
          (throw Exception(
              "Missing organization ID, please pass in a sub-organizationId or instantiate the client with one.")),
      activityType: 'ACTIVITY_TYPE_EXPORT_PRIVATE_KEY',
    );
    return await request<Map<String, dynamic>, TExportPrivateKeyResponse>(
        "/public/v1/submit/export_private_key",
        body,
        (json) => TExportPrivateKeyResponse.fromJson(
            transformActivityResponse(json, 'ExportPrivateKey')));
  }

  /// Produce a `SignedRequest` from `TExportPrivateKeyBody` by using the client's `stamp` function.
  ///
  /// See also: `ExportPrivateKey`.

  Future<TSignedRequest> stampExportPrivateKey({
    required TExportPrivateKeyBody input,
  }) async {
    final fullUrl = '${config.baseUrl}/public/v1/submit/export_private_key';
    final body = packActivityBody(
      bodyJson: input.toJson(),
      fallbackOrganizationId: input.organizationId ??
          config.organizationId ??
          (throw Exception(
              "Missing organization ID, please pass in a sub-organizationId or instantiate the client with one.")),
      activityType: 'ACTIVITY_TYPE_EXPORT_PRIVATE_KEY',
    );
    final bodyJson = jsonEncode(body);
    final stamp = await stamper.stamp(bodyJson);

    return TSignedRequest(
      body: bodyJson,
      stamp: stamp,
      url: fullUrl,
    );
  }

  /// Export a wallet.
  ///
  /// Sign the provided `TExportWalletBody` with the client's `stamp` function and submit the request (POST /public/v1/submit/export_wallet).
  ///
  /// See also: `stampExportWallet`.

  Future<TExportWalletResponse> exportWallet({
    required TExportWalletBody input,
  }) async {
    final body = packActivityBody(
      bodyJson: input.toJson(),
      fallbackOrganizationId: input.organizationId ??
          config.organizationId ??
          (throw Exception(
              "Missing organization ID, please pass in a sub-organizationId or instantiate the client with one.")),
      activityType: 'ACTIVITY_TYPE_EXPORT_WALLET',
    );
    return await request<Map<String, dynamic>, TExportWalletResponse>(
        "/public/v1/submit/export_wallet",
        body,
        (json) => TExportWalletResponse.fromJson(
            transformActivityResponse(json, 'ExportWallet')));
  }

  /// Produce a `SignedRequest` from `TExportWalletBody` by using the client's `stamp` function.
  ///
  /// See also: `ExportWallet`.

  Future<TSignedRequest> stampExportWallet({
    required TExportWalletBody input,
  }) async {
    final fullUrl = '${config.baseUrl}/public/v1/submit/export_wallet';
    final body = packActivityBody(
      bodyJson: input.toJson(),
      fallbackOrganizationId: input.organizationId ??
          config.organizationId ??
          (throw Exception(
              "Missing organization ID, please pass in a sub-organizationId or instantiate the client with one.")),
      activityType: 'ACTIVITY_TYPE_EXPORT_WALLET',
    );
    final bodyJson = jsonEncode(body);
    final stamp = await stamper.stamp(bodyJson);

    return TSignedRequest(
      body: bodyJson,
      stamp: stamp,
      url: fullUrl,
    );
  }

  /// Export a wallet account.
  ///
  /// Sign the provided `TExportWalletAccountBody` with the client's `stamp` function and submit the request (POST /public/v1/submit/export_wallet_account).
  ///
  /// See also: `stampExportWalletAccount`.

  Future<TExportWalletAccountResponse> exportWalletAccount({
    required TExportWalletAccountBody input,
  }) async {
    final body = packActivityBody(
      bodyJson: input.toJson(),
      fallbackOrganizationId: input.organizationId ??
          config.organizationId ??
          (throw Exception(
              "Missing organization ID, please pass in a sub-organizationId or instantiate the client with one.")),
      activityType: 'ACTIVITY_TYPE_EXPORT_WALLET_ACCOUNT',
    );
    return await request<Map<String, dynamic>, TExportWalletAccountResponse>(
        "/public/v1/submit/export_wallet_account",
        body,
        (json) => TExportWalletAccountResponse.fromJson(
            transformActivityResponse(json, 'ExportWalletAccount')));
  }

  /// Produce a `SignedRequest` from `TExportWalletAccountBody` by using the client's `stamp` function.
  ///
  /// See also: `ExportWalletAccount`.

  Future<TSignedRequest> stampExportWalletAccount({
    required TExportWalletAccountBody input,
  }) async {
    final fullUrl = '${config.baseUrl}/public/v1/submit/export_wallet_account';
    final body = packActivityBody(
      bodyJson: input.toJson(),
      fallbackOrganizationId: input.organizationId ??
          config.organizationId ??
          (throw Exception(
              "Missing organization ID, please pass in a sub-organizationId or instantiate the client with one.")),
      activityType: 'ACTIVITY_TYPE_EXPORT_WALLET_ACCOUNT',
    );
    final bodyJson = jsonEncode(body);
    final stamp = await stamper.stamp(bodyJson);

    return TSignedRequest(
      body: bodyJson,
      stamp: stamp,
      url: fullUrl,
    );
  }

  /// Import a private key.
  ///
  /// Sign the provided `TImportPrivateKeyBody` with the client's `stamp` function and submit the request (POST /public/v1/submit/import_private_key).
  ///
  /// See also: `stampImportPrivateKey`.

  Future<TImportPrivateKeyResponse> importPrivateKey({
    required TImportPrivateKeyBody input,
  }) async {
    final body = packActivityBody(
      bodyJson: input.toJson(),
      fallbackOrganizationId: input.organizationId ??
          config.organizationId ??
          (throw Exception(
              "Missing organization ID, please pass in a sub-organizationId or instantiate the client with one.")),
      activityType: 'ACTIVITY_TYPE_IMPORT_PRIVATE_KEY',
    );
    return await request<Map<String, dynamic>, TImportPrivateKeyResponse>(
        "/public/v1/submit/import_private_key",
        body,
        (json) => TImportPrivateKeyResponse.fromJson(
            transformActivityResponse(json, 'ImportPrivateKey')));
  }

  /// Produce a `SignedRequest` from `TImportPrivateKeyBody` by using the client's `stamp` function.
  ///
  /// See also: `ImportPrivateKey`.

  Future<TSignedRequest> stampImportPrivateKey({
    required TImportPrivateKeyBody input,
  }) async {
    final fullUrl = '${config.baseUrl}/public/v1/submit/import_private_key';
    final body = packActivityBody(
      bodyJson: input.toJson(),
      fallbackOrganizationId: input.organizationId ??
          config.organizationId ??
          (throw Exception(
              "Missing organization ID, please pass in a sub-organizationId or instantiate the client with one.")),
      activityType: 'ACTIVITY_TYPE_IMPORT_PRIVATE_KEY',
    );
    final bodyJson = jsonEncode(body);
    final stamp = await stamper.stamp(bodyJson);

    return TSignedRequest(
      body: bodyJson,
      stamp: stamp,
      url: fullUrl,
    );
  }

  /// Import a wallet.
  ///
  /// Sign the provided `TImportWalletBody` with the client's `stamp` function and submit the request (POST /public/v1/submit/import_wallet).
  ///
  /// See also: `stampImportWallet`.

  Future<TImportWalletResponse> importWallet({
    required TImportWalletBody input,
  }) async {
    final body = packActivityBody(
      bodyJson: input.toJson(),
      fallbackOrganizationId: input.organizationId ??
          config.organizationId ??
          (throw Exception(
              "Missing organization ID, please pass in a sub-organizationId or instantiate the client with one.")),
      activityType: 'ACTIVITY_TYPE_IMPORT_WALLET',
    );
    return await request<Map<String, dynamic>, TImportWalletResponse>(
        "/public/v1/submit/import_wallet",
        body,
        (json) => TImportWalletResponse.fromJson(
            transformActivityResponse(json, 'ImportWallet')));
  }

  /// Produce a `SignedRequest` from `TImportWalletBody` by using the client's `stamp` function.
  ///
  /// See also: `ImportWallet`.

  Future<TSignedRequest> stampImportWallet({
    required TImportWalletBody input,
  }) async {
    final fullUrl = '${config.baseUrl}/public/v1/submit/import_wallet';
    final body = packActivityBody(
      bodyJson: input.toJson(),
      fallbackOrganizationId: input.organizationId ??
          config.organizationId ??
          (throw Exception(
              "Missing organization ID, please pass in a sub-organizationId or instantiate the client with one.")),
      activityType: 'ACTIVITY_TYPE_IMPORT_WALLET',
    );
    final bodyJson = jsonEncode(body);
    final stamp = await stamper.stamp(bodyJson);

    return TSignedRequest(
      body: bodyJson,
      stamp: stamp,
      url: fullUrl,
    );
  }

  /// Initiate a fiat on ramp flow.
  ///
  /// Sign the provided `TInitFiatOnRampBody` with the client's `stamp` function and submit the request (POST /public/v1/submit/init_fiat_on_ramp).
  ///
  /// See also: `stampInitFiatOnRamp`.

  Future<TInitFiatOnRampResponse> initFiatOnRamp({
    required TInitFiatOnRampBody input,
  }) async {
    final body = packActivityBody(
      bodyJson: input.toJson(),
      fallbackOrganizationId: input.organizationId ??
          config.organizationId ??
          (throw Exception(
              "Missing organization ID, please pass in a sub-organizationId or instantiate the client with one.")),
      activityType: 'ACTIVITY_TYPE_INIT_FIAT_ON_RAMP',
    );
    return await request<Map<String, dynamic>, TInitFiatOnRampResponse>(
        "/public/v1/submit/init_fiat_on_ramp",
        body,
        (json) => TInitFiatOnRampResponse.fromJson(
            transformActivityResponse(json, 'InitFiatOnRamp')));
  }

  /// Produce a `SignedRequest` from `TInitFiatOnRampBody` by using the client's `stamp` function.
  ///
  /// See also: `InitFiatOnRamp`.

  Future<TSignedRequest> stampInitFiatOnRamp({
    required TInitFiatOnRampBody input,
  }) async {
    final fullUrl = '${config.baseUrl}/public/v1/submit/init_fiat_on_ramp';
    final body = packActivityBody(
      bodyJson: input.toJson(),
      fallbackOrganizationId: input.organizationId ??
          config.organizationId ??
          (throw Exception(
              "Missing organization ID, please pass in a sub-organizationId or instantiate the client with one.")),
      activityType: 'ACTIVITY_TYPE_INIT_FIAT_ON_RAMP',
    );
    final bodyJson = jsonEncode(body);
    final stamp = await stamper.stamp(bodyJson);

    return TSignedRequest(
      body: bodyJson,
      stamp: stamp,
      url: fullUrl,
    );
  }

  /// Initialize a new private key import.
  ///
  /// Sign the provided `TInitImportPrivateKeyBody` with the client's `stamp` function and submit the request (POST /public/v1/submit/init_import_private_key).
  ///
  /// See also: `stampInitImportPrivateKey`.

  Future<TInitImportPrivateKeyResponse> initImportPrivateKey({
    required TInitImportPrivateKeyBody input,
  }) async {
    final body = packActivityBody(
      bodyJson: input.toJson(),
      fallbackOrganizationId: input.organizationId ??
          config.organizationId ??
          (throw Exception(
              "Missing organization ID, please pass in a sub-organizationId or instantiate the client with one.")),
      activityType: 'ACTIVITY_TYPE_INIT_IMPORT_PRIVATE_KEY',
    );
    return await request<Map<String, dynamic>, TInitImportPrivateKeyResponse>(
        "/public/v1/submit/init_import_private_key",
        body,
        (json) => TInitImportPrivateKeyResponse.fromJson(
            transformActivityResponse(json, 'InitImportPrivateKey')));
  }

  /// Produce a `SignedRequest` from `TInitImportPrivateKeyBody` by using the client's `stamp` function.
  ///
  /// See also: `InitImportPrivateKey`.

  Future<TSignedRequest> stampInitImportPrivateKey({
    required TInitImportPrivateKeyBody input,
  }) async {
    final fullUrl =
        '${config.baseUrl}/public/v1/submit/init_import_private_key';
    final body = packActivityBody(
      bodyJson: input.toJson(),
      fallbackOrganizationId: input.organizationId ??
          config.organizationId ??
          (throw Exception(
              "Missing organization ID, please pass in a sub-organizationId or instantiate the client with one.")),
      activityType: 'ACTIVITY_TYPE_INIT_IMPORT_PRIVATE_KEY',
    );
    final bodyJson = jsonEncode(body);
    final stamp = await stamper.stamp(bodyJson);

    return TSignedRequest(
      body: bodyJson,
      stamp: stamp,
      url: fullUrl,
    );
  }

  /// Initialize a new wallet import.
  ///
  /// Sign the provided `TInitImportWalletBody` with the client's `stamp` function and submit the request (POST /public/v1/submit/init_import_wallet).
  ///
  /// See also: `stampInitImportWallet`.

  Future<TInitImportWalletResponse> initImportWallet({
    required TInitImportWalletBody input,
  }) async {
    final body = packActivityBody(
      bodyJson: input.toJson(),
      fallbackOrganizationId: input.organizationId ??
          config.organizationId ??
          (throw Exception(
              "Missing organization ID, please pass in a sub-organizationId or instantiate the client with one.")),
      activityType: 'ACTIVITY_TYPE_INIT_IMPORT_WALLET',
    );
    return await request<Map<String, dynamic>, TInitImportWalletResponse>(
        "/public/v1/submit/init_import_wallet",
        body,
        (json) => TInitImportWalletResponse.fromJson(
            transformActivityResponse(json, 'InitImportWallet')));
  }

  /// Produce a `SignedRequest` from `TInitImportWalletBody` by using the client's `stamp` function.
  ///
  /// See also: `InitImportWallet`.

  Future<TSignedRequest> stampInitImportWallet({
    required TInitImportWalletBody input,
  }) async {
    final fullUrl = '${config.baseUrl}/public/v1/submit/init_import_wallet';
    final body = packActivityBody(
      bodyJson: input.toJson(),
      fallbackOrganizationId: input.organizationId ??
          config.organizationId ??
          (throw Exception(
              "Missing organization ID, please pass in a sub-organizationId or instantiate the client with one.")),
      activityType: 'ACTIVITY_TYPE_INIT_IMPORT_WALLET',
    );
    final bodyJson = jsonEncode(body);
    final stamp = await stamper.stamp(bodyJson);

    return TSignedRequest(
      body: bodyJson,
      stamp: stamp,
      url: fullUrl,
    );
  }

  /// Initiate a generic OTP activity.
  ///
  /// Sign the provided `TInitOtpBody` with the client's `stamp` function and submit the request (POST /public/v1/submit/init_otp).
  ///
  /// See also: `stampInitOtp`.

  Future<TInitOtpResponse> initOtp({
    required TInitOtpBody input,
  }) async {
    final body = packActivityBody(
      bodyJson: input.toJson(),
      fallbackOrganizationId: input.organizationId ??
          config.organizationId ??
          (throw Exception(
              "Missing organization ID, please pass in a sub-organizationId or instantiate the client with one.")),
      activityType: 'ACTIVITY_TYPE_INIT_OTP',
    );
    return await request<Map<String, dynamic>, TInitOtpResponse>(
        "/public/v1/submit/init_otp",
        body,
        (json) => TInitOtpResponse.fromJson(
            transformActivityResponse(json, 'InitOtp')));
  }

  /// Produce a `SignedRequest` from `TInitOtpBody` by using the client's `stamp` function.
  ///
  /// See also: `InitOtp`.

  Future<TSignedRequest> stampInitOtp({
    required TInitOtpBody input,
  }) async {
    final fullUrl = '${config.baseUrl}/public/v1/submit/init_otp';
    final body = packActivityBody(
      bodyJson: input.toJson(),
      fallbackOrganizationId: input.organizationId ??
          config.organizationId ??
          (throw Exception(
              "Missing organization ID, please pass in a sub-organizationId or instantiate the client with one.")),
      activityType: 'ACTIVITY_TYPE_INIT_OTP',
    );
    final bodyJson = jsonEncode(body);
    final stamp = await stamper.stamp(bodyJson);

    return TSignedRequest(
      body: bodyJson,
      stamp: stamp,
      url: fullUrl,
    );
  }

  /// Initiate an OTP auth activity.
  ///
  /// Sign the provided `TInitOtpAuthBody` with the client's `stamp` function and submit the request (POST /public/v1/submit/init_otp_auth).
  ///
  /// See also: `stampInitOtpAuth`.

  Future<TInitOtpAuthResponse> initOtpAuth({
    required TInitOtpAuthBody input,
  }) async {
    final body = packActivityBody(
      bodyJson: input.toJson(),
      fallbackOrganizationId: input.organizationId ??
          config.organizationId ??
          (throw Exception(
              "Missing organization ID, please pass in a sub-organizationId or instantiate the client with one.")),
      activityType: 'ACTIVITY_TYPE_INIT_OTP_AUTH_V2',
    );
    return await request<Map<String, dynamic>, TInitOtpAuthResponse>(
        "/public/v1/submit/init_otp_auth",
        body,
        (json) => TInitOtpAuthResponse.fromJson(
            transformActivityResponse(json, 'InitOtpAuth')));
  }

  /// Produce a `SignedRequest` from `TInitOtpAuthBody` by using the client's `stamp` function.
  ///
  /// See also: `InitOtpAuth`.

  Future<TSignedRequest> stampInitOtpAuth({
    required TInitOtpAuthBody input,
  }) async {
    final fullUrl = '${config.baseUrl}/public/v1/submit/init_otp_auth';
    final body = packActivityBody(
      bodyJson: input.toJson(),
      fallbackOrganizationId: input.organizationId ??
          config.organizationId ??
          (throw Exception(
              "Missing organization ID, please pass in a sub-organizationId or instantiate the client with one.")),
      activityType: 'ACTIVITY_TYPE_INIT_OTP_AUTH_V2',
    );
    final bodyJson = jsonEncode(body);
    final stamp = await stamper.stamp(bodyJson);

    return TSignedRequest(
      body: bodyJson,
      stamp: stamp,
      url: fullUrl,
    );
  }

  /// Initialize a new email recovery.
  ///
  /// Sign the provided `TInitUserEmailRecoveryBody` with the client's `stamp` function and submit the request (POST /public/v1/submit/init_user_email_recovery).
  ///
  /// See also: `stampInitUserEmailRecovery`.

  Future<TInitUserEmailRecoveryResponse> initUserEmailRecovery({
    required TInitUserEmailRecoveryBody input,
  }) async {
    final body = packActivityBody(
      bodyJson: input.toJson(),
      fallbackOrganizationId: input.organizationId ??
          config.organizationId ??
          (throw Exception(
              "Missing organization ID, please pass in a sub-organizationId or instantiate the client with one.")),
      activityType: 'ACTIVITY_TYPE_INIT_USER_EMAIL_RECOVERY',
    );
    return await request<Map<String, dynamic>, TInitUserEmailRecoveryResponse>(
        "/public/v1/submit/init_user_email_recovery",
        body,
        (json) => TInitUserEmailRecoveryResponse.fromJson(
            transformActivityResponse(json, 'InitUserEmailRecovery')));
  }

  /// Produce a `SignedRequest` from `TInitUserEmailRecoveryBody` by using the client's `stamp` function.
  ///
  /// See also: `InitUserEmailRecovery`.

  Future<TSignedRequest> stampInitUserEmailRecovery({
    required TInitUserEmailRecoveryBody input,
  }) async {
    final fullUrl =
        '${config.baseUrl}/public/v1/submit/init_user_email_recovery';
    final body = packActivityBody(
      bodyJson: input.toJson(),
      fallbackOrganizationId: input.organizationId ??
          config.organizationId ??
          (throw Exception(
              "Missing organization ID, please pass in a sub-organizationId or instantiate the client with one.")),
      activityType: 'ACTIVITY_TYPE_INIT_USER_EMAIL_RECOVERY',
    );
    final bodyJson = jsonEncode(body);
    final stamp = await stamper.stamp(bodyJson);

    return TSignedRequest(
      body: bodyJson,
      stamp: stamp,
      url: fullUrl,
    );
  }

  /// Authenticate a user with an OIDC token (Oauth).
  ///
  /// Sign the provided `TOauthBody` with the client's `stamp` function and submit the request (POST /public/v1/submit/oauth).
  ///
  /// See also: `stampOauth`.

  Future<TOauthResponse> oauth({
    required TOauthBody input,
  }) async {
    final body = packActivityBody(
      bodyJson: input.toJson(),
      fallbackOrganizationId: input.organizationId ??
          config.organizationId ??
          (throw Exception(
              "Missing organization ID, please pass in a sub-organizationId or instantiate the client with one.")),
      activityType: 'ACTIVITY_TYPE_OAUTH',
    );
    return await request<Map<String, dynamic>, TOauthResponse>(
        "/public/v1/submit/oauth",
        body,
        (json) =>
            TOauthResponse.fromJson(transformActivityResponse(json, 'Oauth')));
  }

  /// Produce a `SignedRequest` from `TOauthBody` by using the client's `stamp` function.
  ///
  /// See also: `Oauth`.

  Future<TSignedRequest> stampOauth({
    required TOauthBody input,
  }) async {
    final fullUrl = '${config.baseUrl}/public/v1/submit/oauth';
    final body = packActivityBody(
      bodyJson: input.toJson(),
      fallbackOrganizationId: input.organizationId ??
          config.organizationId ??
          (throw Exception(
              "Missing organization ID, please pass in a sub-organizationId or instantiate the client with one.")),
      activityType: 'ACTIVITY_TYPE_OAUTH',
    );
    final bodyJson = jsonEncode(body);
    final stamp = await stamper.stamp(bodyJson);

    return TSignedRequest(
      body: bodyJson,
      stamp: stamp,
      url: fullUrl,
    );
  }

  /// Authenticate a user with an OAuth 2.0 provider and receive an OIDC token to use with the LoginWithOAuth or CreateSubOrganization activities
  ///
  /// Sign the provided `TOauth2AuthenticateBody` with the client's `stamp` function and submit the request (POST /public/v1/submit/oauth2_authenticate).
  ///
  /// See also: `stampOauth2Authenticate`.

  Future<TOauth2AuthenticateResponse> oauth2Authenticate({
    required TOauth2AuthenticateBody input,
  }) async {
    final body = packActivityBody(
      bodyJson: input.toJson(),
      fallbackOrganizationId: input.organizationId ??
          config.organizationId ??
          (throw Exception(
              "Missing organization ID, please pass in a sub-organizationId or instantiate the client with one.")),
      activityType: 'ACTIVITY_TYPE_OAUTH2_AUTHENTICATE',
    );
    return await request<Map<String, dynamic>, TOauth2AuthenticateResponse>(
        "/public/v1/submit/oauth2_authenticate",
        body,
        (json) => TOauth2AuthenticateResponse.fromJson(
            transformActivityResponse(json, 'Oauth2Authenticate')));
  }

  /// Produce a `SignedRequest` from `TOauth2AuthenticateBody` by using the client's `stamp` function.
  ///
  /// See also: `Oauth2Authenticate`.

  Future<TSignedRequest> stampOauth2Authenticate({
    required TOauth2AuthenticateBody input,
  }) async {
    final fullUrl = '${config.baseUrl}/public/v1/submit/oauth2_authenticate';
    final body = packActivityBody(
      bodyJson: input.toJson(),
      fallbackOrganizationId: input.organizationId ??
          config.organizationId ??
          (throw Exception(
              "Missing organization ID, please pass in a sub-organizationId or instantiate the client with one.")),
      activityType: 'ACTIVITY_TYPE_OAUTH2_AUTHENTICATE',
    );
    final bodyJson = jsonEncode(body);
    final stamp = await stamper.stamp(bodyJson);

    return TSignedRequest(
      body: bodyJson,
      stamp: stamp,
      url: fullUrl,
    );
  }

  /// Create an Oauth session for a user.
  ///
  /// Sign the provided `TOauthLoginBody` with the client's `stamp` function and submit the request (POST /public/v1/submit/oauth_login).
  ///
  /// See also: `stampOauthLogin`.

  Future<TOauthLoginResponse> oauthLogin({
    required TOauthLoginBody input,
  }) async {
    final body = packActivityBody(
      bodyJson: input.toJson(),
      fallbackOrganizationId: input.organizationId ??
          config.organizationId ??
          (throw Exception(
              "Missing organization ID, please pass in a sub-organizationId or instantiate the client with one.")),
      activityType: 'ACTIVITY_TYPE_OAUTH_LOGIN',
    );
    return await request<Map<String, dynamic>, TOauthLoginResponse>(
        "/public/v1/submit/oauth_login",
        body,
        (json) => TOauthLoginResponse.fromJson(
            transformActivityResponse(json, 'OauthLogin')));
  }

  /// Produce a `SignedRequest` from `TOauthLoginBody` by using the client's `stamp` function.
  ///
  /// See also: `OauthLogin`.

  Future<TSignedRequest> stampOauthLogin({
    required TOauthLoginBody input,
  }) async {
    final fullUrl = '${config.baseUrl}/public/v1/submit/oauth_login';
    final body = packActivityBody(
      bodyJson: input.toJson(),
      fallbackOrganizationId: input.organizationId ??
          config.organizationId ??
          (throw Exception(
              "Missing organization ID, please pass in a sub-organizationId or instantiate the client with one.")),
      activityType: 'ACTIVITY_TYPE_OAUTH_LOGIN',
    );
    final bodyJson = jsonEncode(body);
    final stamp = await stamper.stamp(bodyJson);

    return TSignedRequest(
      body: bodyJson,
      stamp: stamp,
      url: fullUrl,
    );
  }

  /// Authenticate a user with an OTP code sent via email or SMS.
  ///
  /// Sign the provided `TOtpAuthBody` with the client's `stamp` function and submit the request (POST /public/v1/submit/otp_auth).
  ///
  /// See also: `stampOtpAuth`.

  Future<TOtpAuthResponse> otpAuth({
    required TOtpAuthBody input,
  }) async {
    final body = packActivityBody(
      bodyJson: input.toJson(),
      fallbackOrganizationId: input.organizationId ??
          config.organizationId ??
          (throw Exception(
              "Missing organization ID, please pass in a sub-organizationId or instantiate the client with one.")),
      activityType: 'ACTIVITY_TYPE_OTP_AUTH',
    );
    return await request<Map<String, dynamic>, TOtpAuthResponse>(
        "/public/v1/submit/otp_auth",
        body,
        (json) => TOtpAuthResponse.fromJson(
            transformActivityResponse(json, 'OtpAuth')));
  }

  /// Produce a `SignedRequest` from `TOtpAuthBody` by using the client's `stamp` function.
  ///
  /// See also: `OtpAuth`.

  Future<TSignedRequest> stampOtpAuth({
    required TOtpAuthBody input,
  }) async {
    final fullUrl = '${config.baseUrl}/public/v1/submit/otp_auth';
    final body = packActivityBody(
      bodyJson: input.toJson(),
      fallbackOrganizationId: input.organizationId ??
          config.organizationId ??
          (throw Exception(
              "Missing organization ID, please pass in a sub-organizationId or instantiate the client with one.")),
      activityType: 'ACTIVITY_TYPE_OTP_AUTH',
    );
    final bodyJson = jsonEncode(body);
    final stamp = await stamper.stamp(bodyJson);

    return TSignedRequest(
      body: bodyJson,
      stamp: stamp,
      url: fullUrl,
    );
  }

  /// Create an OTP session for a user.
  ///
  /// Sign the provided `TOtpLoginBody` with the client's `stamp` function and submit the request (POST /public/v1/submit/otp_login).
  ///
  /// See also: `stampOtpLogin`.

  Future<TOtpLoginResponse> otpLogin({
    required TOtpLoginBody input,
  }) async {
    final body = packActivityBody(
      bodyJson: input.toJson(),
      fallbackOrganizationId: input.organizationId ??
          config.organizationId ??
          (throw Exception(
              "Missing organization ID, please pass in a sub-organizationId or instantiate the client with one.")),
      activityType: 'ACTIVITY_TYPE_OTP_LOGIN',
    );
    return await request<Map<String, dynamic>, TOtpLoginResponse>(
        "/public/v1/submit/otp_login",
        body,
        (json) => TOtpLoginResponse.fromJson(
            transformActivityResponse(json, 'OtpLogin')));
  }

  /// Produce a `SignedRequest` from `TOtpLoginBody` by using the client's `stamp` function.
  ///
  /// See also: `OtpLogin`.

  Future<TSignedRequest> stampOtpLogin({
    required TOtpLoginBody input,
  }) async {
    final fullUrl = '${config.baseUrl}/public/v1/submit/otp_login';
    final body = packActivityBody(
      bodyJson: input.toJson(),
      fallbackOrganizationId: input.organizationId ??
          config.organizationId ??
          (throw Exception(
              "Missing organization ID, please pass in a sub-organizationId or instantiate the client with one.")),
      activityType: 'ACTIVITY_TYPE_OTP_LOGIN',
    );
    final bodyJson = jsonEncode(body);
    final stamp = await stamper.stamp(bodyJson);

    return TSignedRequest(
      body: bodyJson,
      stamp: stamp,
      url: fullUrl,
    );
  }

  /// Complete the process of recovering a user by adding an authenticator.
  ///
  /// Sign the provided `TRecoverUserBody` with the client's `stamp` function and submit the request (POST /public/v1/submit/recover_user).
  ///
  /// See also: `stampRecoverUser`.

  Future<TRecoverUserResponse> recoverUser({
    required TRecoverUserBody input,
  }) async {
    final body = packActivityBody(
      bodyJson: input.toJson(),
      fallbackOrganizationId: input.organizationId ??
          config.organizationId ??
          (throw Exception(
              "Missing organization ID, please pass in a sub-organizationId or instantiate the client with one.")),
      activityType: 'ACTIVITY_TYPE_RECOVER_USER',
    );
    return await request<Map<String, dynamic>, TRecoverUserResponse>(
        "/public/v1/submit/recover_user",
        body,
        (json) => TRecoverUserResponse.fromJson(
            transformActivityResponse(json, 'RecoverUser')));
  }

  /// Produce a `SignedRequest` from `TRecoverUserBody` by using the client's `stamp` function.
  ///
  /// See also: `RecoverUser`.

  Future<TSignedRequest> stampRecoverUser({
    required TRecoverUserBody input,
  }) async {
    final fullUrl = '${config.baseUrl}/public/v1/submit/recover_user';
    final body = packActivityBody(
      bodyJson: input.toJson(),
      fallbackOrganizationId: input.organizationId ??
          config.organizationId ??
          (throw Exception(
              "Missing organization ID, please pass in a sub-organizationId or instantiate the client with one.")),
      activityType: 'ACTIVITY_TYPE_RECOVER_USER',
    );
    final bodyJson = jsonEncode(body);
    final stamp = await stamper.stamp(bodyJson);

    return TSignedRequest(
      body: bodyJson,
      stamp: stamp,
      url: fullUrl,
    );
  }

  /// Reject an activity.
  ///
  /// Sign the provided `TRejectActivityBody` with the client's `stamp` function and submit the request (POST /public/v1/submit/reject_activity).
  ///
  /// See also: `stampRejectActivity`.

  Future<TRejectActivityResponse> rejectActivity({
    required TRejectActivityBody input,
  }) async {
    final body = packActivityBody(
      bodyJson: input.toJson(),
      fallbackOrganizationId: input.organizationId ??
          config.organizationId ??
          (throw Exception(
              "Missing organization ID, please pass in a sub-organizationId or instantiate the client with one.")),
      activityType: 'ACTIVITY_TYPE_REJECT_ACTIVITY',
    );
    return await request<Map<String, dynamic>, TRejectActivityResponse>(
        "/public/v1/submit/reject_activity",
        body,
        (json) => TRejectActivityResponse.fromJson(
            transformActivityResponse(json, 'RejectActivity')));
  }

  /// Produce a `SignedRequest` from `TRejectActivityBody` by using the client's `stamp` function.
  ///
  /// See also: `RejectActivity`.

  Future<TSignedRequest> stampRejectActivity({
    required TRejectActivityBody input,
  }) async {
    final fullUrl = '${config.baseUrl}/public/v1/submit/reject_activity';
    final body = packActivityBody(
      bodyJson: input.toJson(),
      fallbackOrganizationId: input.organizationId ??
          config.organizationId ??
          (throw Exception(
              "Missing organization ID, please pass in a sub-organizationId or instantiate the client with one.")),
      activityType: 'ACTIVITY_TYPE_REJECT_ACTIVITY',
    );
    final bodyJson = jsonEncode(body);
    final stamp = await stamper.stamp(bodyJson);

    return TSignedRequest(
      body: bodyJson,
      stamp: stamp,
      url: fullUrl,
    );
  }

  /// Remove an organization feature. This activity must be approved by the current root quorum.
  ///
  /// Sign the provided `TRemoveOrganizationFeatureBody` with the client's `stamp` function and submit the request (POST /public/v1/submit/remove_organization_feature).
  ///
  /// See also: `stampRemoveOrganizationFeature`.

  Future<TRemoveOrganizationFeatureResponse> removeOrganizationFeature({
    required TRemoveOrganizationFeatureBody input,
  }) async {
    final body = packActivityBody(
      bodyJson: input.toJson(),
      fallbackOrganizationId: input.organizationId ??
          config.organizationId ??
          (throw Exception(
              "Missing organization ID, please pass in a sub-organizationId or instantiate the client with one.")),
      activityType: 'ACTIVITY_TYPE_REMOVE_ORGANIZATION_FEATURE',
    );
    return await request<Map<String, dynamic>,
            TRemoveOrganizationFeatureResponse>(
        "/public/v1/submit/remove_organization_feature",
        body,
        (json) => TRemoveOrganizationFeatureResponse.fromJson(
            transformActivityResponse(json, 'RemoveOrganizationFeature')));
  }

  /// Produce a `SignedRequest` from `TRemoveOrganizationFeatureBody` by using the client's `stamp` function.
  ///
  /// See also: `RemoveOrganizationFeature`.

  Future<TSignedRequest> stampRemoveOrganizationFeature({
    required TRemoveOrganizationFeatureBody input,
  }) async {
    final fullUrl =
        '${config.baseUrl}/public/v1/submit/remove_organization_feature';
    final body = packActivityBody(
      bodyJson: input.toJson(),
      fallbackOrganizationId: input.organizationId ??
          config.organizationId ??
          (throw Exception(
              "Missing organization ID, please pass in a sub-organizationId or instantiate the client with one.")),
      activityType: 'ACTIVITY_TYPE_REMOVE_ORGANIZATION_FEATURE',
    );
    final bodyJson = jsonEncode(body);
    final stamp = await stamper.stamp(bodyJson);

    return TSignedRequest(
      body: bodyJson,
      stamp: stamp,
      url: fullUrl,
    );
  }

  /// Set an organization feature. This activity must be approved by the current root quorum.
  ///
  /// Sign the provided `TSetOrganizationFeatureBody` with the client's `stamp` function and submit the request (POST /public/v1/submit/set_organization_feature).
  ///
  /// See also: `stampSetOrganizationFeature`.

  Future<TSetOrganizationFeatureResponse> setOrganizationFeature({
    required TSetOrganizationFeatureBody input,
  }) async {
    final body = packActivityBody(
      bodyJson: input.toJson(),
      fallbackOrganizationId: input.organizationId ??
          config.organizationId ??
          (throw Exception(
              "Missing organization ID, please pass in a sub-organizationId or instantiate the client with one.")),
      activityType: 'ACTIVITY_TYPE_SET_ORGANIZATION_FEATURE',
    );
    return await request<Map<String, dynamic>, TSetOrganizationFeatureResponse>(
        "/public/v1/submit/set_organization_feature",
        body,
        (json) => TSetOrganizationFeatureResponse.fromJson(
            transformActivityResponse(json, 'SetOrganizationFeature')));
  }

  /// Produce a `SignedRequest` from `TSetOrganizationFeatureBody` by using the client's `stamp` function.
  ///
  /// See also: `SetOrganizationFeature`.

  Future<TSignedRequest> stampSetOrganizationFeature({
    required TSetOrganizationFeatureBody input,
  }) async {
    final fullUrl =
        '${config.baseUrl}/public/v1/submit/set_organization_feature';
    final body = packActivityBody(
      bodyJson: input.toJson(),
      fallbackOrganizationId: input.organizationId ??
          config.organizationId ??
          (throw Exception(
              "Missing organization ID, please pass in a sub-organizationId or instantiate the client with one.")),
      activityType: 'ACTIVITY_TYPE_SET_ORGANIZATION_FEATURE',
    );
    final bodyJson = jsonEncode(body);
    final stamp = await stamper.stamp(bodyJson);

    return TSignedRequest(
      body: bodyJson,
      stamp: stamp,
      url: fullUrl,
    );
  }

  /// Sign a raw payload.
  ///
  /// Sign the provided `TSignRawPayloadBody` with the client's `stamp` function and submit the request (POST /public/v1/submit/sign_raw_payload).
  ///
  /// See also: `stampSignRawPayload`.

  Future<TSignRawPayloadResponse> signRawPayload({
    required TSignRawPayloadBody input,
  }) async {
    final body = packActivityBody(
      bodyJson: input.toJson(),
      fallbackOrganizationId: input.organizationId ??
          config.organizationId ??
          (throw Exception(
              "Missing organization ID, please pass in a sub-organizationId or instantiate the client with one.")),
      activityType: 'ACTIVITY_TYPE_SIGN_RAW_PAYLOAD_V2',
    );
    return await request<Map<String, dynamic>, TSignRawPayloadResponse>(
        "/public/v1/submit/sign_raw_payload",
        body,
        (json) => TSignRawPayloadResponse.fromJson(
            transformActivityResponse(json, 'SignRawPayload')));
  }

  /// Produce a `SignedRequest` from `TSignRawPayloadBody` by using the client's `stamp` function.
  ///
  /// See also: `SignRawPayload`.

  Future<TSignedRequest> stampSignRawPayload({
    required TSignRawPayloadBody input,
  }) async {
    final fullUrl = '${config.baseUrl}/public/v1/submit/sign_raw_payload';
    final body = packActivityBody(
      bodyJson: input.toJson(),
      fallbackOrganizationId: input.organizationId ??
          config.organizationId ??
          (throw Exception(
              "Missing organization ID, please pass in a sub-organizationId or instantiate the client with one.")),
      activityType: 'ACTIVITY_TYPE_SIGN_RAW_PAYLOAD_V2',
    );
    final bodyJson = jsonEncode(body);
    final stamp = await stamper.stamp(bodyJson);

    return TSignedRequest(
      body: bodyJson,
      stamp: stamp,
      url: fullUrl,
    );
  }

  /// Sign multiple raw payloads with the same signing parameters.
  ///
  /// Sign the provided `TSignRawPayloadsBody` with the client's `stamp` function and submit the request (POST /public/v1/submit/sign_raw_payloads).
  ///
  /// See also: `stampSignRawPayloads`.

  Future<TSignRawPayloadsResponse> signRawPayloads({
    required TSignRawPayloadsBody input,
  }) async {
    final body = packActivityBody(
      bodyJson: input.toJson(),
      fallbackOrganizationId: input.organizationId ??
          config.organizationId ??
          (throw Exception(
              "Missing organization ID, please pass in a sub-organizationId or instantiate the client with one.")),
      activityType: 'ACTIVITY_TYPE_SIGN_RAW_PAYLOADS',
    );
    return await request<Map<String, dynamic>, TSignRawPayloadsResponse>(
        "/public/v1/submit/sign_raw_payloads",
        body,
        (json) => TSignRawPayloadsResponse.fromJson(
            transformActivityResponse(json, 'SignRawPayloads')));
  }

  /// Produce a `SignedRequest` from `TSignRawPayloadsBody` by using the client's `stamp` function.
  ///
  /// See also: `SignRawPayloads`.

  Future<TSignedRequest> stampSignRawPayloads({
    required TSignRawPayloadsBody input,
  }) async {
    final fullUrl = '${config.baseUrl}/public/v1/submit/sign_raw_payloads';
    final body = packActivityBody(
      bodyJson: input.toJson(),
      fallbackOrganizationId: input.organizationId ??
          config.organizationId ??
          (throw Exception(
              "Missing organization ID, please pass in a sub-organizationId or instantiate the client with one.")),
      activityType: 'ACTIVITY_TYPE_SIGN_RAW_PAYLOADS',
    );
    final bodyJson = jsonEncode(body);
    final stamp = await stamper.stamp(bodyJson);

    return TSignedRequest(
      body: bodyJson,
      stamp: stamp,
      url: fullUrl,
    );
  }

  /// Sign a transaction.
  ///
  /// Sign the provided `TSignTransactionBody` with the client's `stamp` function and submit the request (POST /public/v1/submit/sign_transaction).
  ///
  /// See also: `stampSignTransaction`.

  Future<TSignTransactionResponse> signTransaction({
    required TSignTransactionBody input,
  }) async {
    final body = packActivityBody(
      bodyJson: input.toJson(),
      fallbackOrganizationId: input.organizationId ??
          config.organizationId ??
          (throw Exception(
              "Missing organization ID, please pass in a sub-organizationId or instantiate the client with one.")),
      activityType: 'ACTIVITY_TYPE_SIGN_TRANSACTION_V2',
    );
    return await request<Map<String, dynamic>, TSignTransactionResponse>(
        "/public/v1/submit/sign_transaction",
        body,
        (json) => TSignTransactionResponse.fromJson(
            transformActivityResponse(json, 'SignTransaction')));
  }

  /// Produce a `SignedRequest` from `TSignTransactionBody` by using the client's `stamp` function.
  ///
  /// See also: `SignTransaction`.

  Future<TSignedRequest> stampSignTransaction({
    required TSignTransactionBody input,
  }) async {
    final fullUrl = '${config.baseUrl}/public/v1/submit/sign_transaction';
    final body = packActivityBody(
      bodyJson: input.toJson(),
      fallbackOrganizationId: input.organizationId ??
          config.organizationId ??
          (throw Exception(
              "Missing organization ID, please pass in a sub-organizationId or instantiate the client with one.")),
      activityType: 'ACTIVITY_TYPE_SIGN_TRANSACTION_V2',
    );
    final bodyJson = jsonEncode(body);
    final stamp = await stamper.stamp(bodyJson);

    return TSignedRequest(
      body: bodyJson,
      stamp: stamp,
      url: fullUrl,
    );
  }

  /// Create a session for a user through stamping client side (API key, wallet client, or passkey client).
  ///
  /// Sign the provided `TStampLoginBody` with the client's `stamp` function and submit the request (POST /public/v1/submit/stamp_login).
  ///
  /// See also: `stampStampLogin`.

  Future<TStampLoginResponse> stampLogin({
    required TStampLoginBody input,
  }) async {
    final body = packActivityBody(
      bodyJson: input.toJson(),
      fallbackOrganizationId: input.organizationId ??
          config.organizationId ??
          (throw Exception(
              "Missing organization ID, please pass in a sub-organizationId or instantiate the client with one.")),
      activityType: 'ACTIVITY_TYPE_STAMP_LOGIN',
    );
    return await request<Map<String, dynamic>, TStampLoginResponse>(
        "/public/v1/submit/stamp_login",
        body,
        (json) => TStampLoginResponse.fromJson(
            transformActivityResponse(json, 'StampLogin')));
  }

  /// Produce a `SignedRequest` from `TStampLoginBody` by using the client's `stamp` function.
  ///
  /// See also: `StampLogin`.

  Future<TSignedRequest> stampStampLogin({
    required TStampLoginBody input,
  }) async {
    final fullUrl = '${config.baseUrl}/public/v1/submit/stamp_login';
    final body = packActivityBody(
      bodyJson: input.toJson(),
      fallbackOrganizationId: input.organizationId ??
          config.organizationId ??
          (throw Exception(
              "Missing organization ID, please pass in a sub-organizationId or instantiate the client with one.")),
      activityType: 'ACTIVITY_TYPE_STAMP_LOGIN',
    );
    final bodyJson = jsonEncode(body);
    final stamp = await stamper.stamp(bodyJson);

    return TSignedRequest(
      body: bodyJson,
      stamp: stamp,
      url: fullUrl,
    );
  }

  /// Update an OAuth 2.0 provider credential
  ///
  /// Sign the provided `TUpdateOauth2CredentialBody` with the client's `stamp` function and submit the request (POST /public/v1/submit/update_oauth2_credential).
  ///
  /// See also: `stampUpdateOauth2Credential`.

  Future<TUpdateOauth2CredentialResponse> updateOauth2Credential({
    required TUpdateOauth2CredentialBody input,
  }) async {
    final body = packActivityBody(
      bodyJson: input.toJson(),
      fallbackOrganizationId: input.organizationId ??
          config.organizationId ??
          (throw Exception(
              "Missing organization ID, please pass in a sub-organizationId or instantiate the client with one.")),
      activityType: 'ACTIVITY_TYPE_UPDATE_OAUTH2_CREDENTIAL',
    );
    return await request<Map<String, dynamic>, TUpdateOauth2CredentialResponse>(
        "/public/v1/submit/update_oauth2_credential",
        body,
        (json) => TUpdateOauth2CredentialResponse.fromJson(
            transformActivityResponse(json, 'UpdateOauth2Credential')));
  }

  /// Produce a `SignedRequest` from `TUpdateOauth2CredentialBody` by using the client's `stamp` function.
  ///
  /// See also: `UpdateOauth2Credential`.

  Future<TSignedRequest> stampUpdateOauth2Credential({
    required TUpdateOauth2CredentialBody input,
  }) async {
    final fullUrl =
        '${config.baseUrl}/public/v1/submit/update_oauth2_credential';
    final body = packActivityBody(
      bodyJson: input.toJson(),
      fallbackOrganizationId: input.organizationId ??
          config.organizationId ??
          (throw Exception(
              "Missing organization ID, please pass in a sub-organizationId or instantiate the client with one.")),
      activityType: 'ACTIVITY_TYPE_UPDATE_OAUTH2_CREDENTIAL',
    );
    final bodyJson = jsonEncode(body);
    final stamp = await stamper.stamp(bodyJson);

    return TSignedRequest(
      body: bodyJson,
      stamp: stamp,
      url: fullUrl,
    );
  }

  /// Update an existing policy.
  ///
  /// Sign the provided `TUpdatePolicyBody` with the client's `stamp` function and submit the request (POST /public/v1/submit/update_policy).
  ///
  /// See also: `stampUpdatePolicy`.

  Future<TUpdatePolicyResponse> updatePolicy({
    required TUpdatePolicyBody input,
  }) async {
    final body = packActivityBody(
      bodyJson: input.toJson(),
      fallbackOrganizationId: input.organizationId ??
          config.organizationId ??
          (throw Exception(
              "Missing organization ID, please pass in a sub-organizationId or instantiate the client with one.")),
      activityType: 'ACTIVITY_TYPE_UPDATE_POLICY_V2',
    );
    return await request<Map<String, dynamic>, TUpdatePolicyResponse>(
        "/public/v1/submit/update_policy",
        body,
        (json) => TUpdatePolicyResponse.fromJson(
            transformActivityResponse(json, 'UpdatePolicy')));
  }

  /// Produce a `SignedRequest` from `TUpdatePolicyBody` by using the client's `stamp` function.
  ///
  /// See also: `UpdatePolicy`.

  Future<TSignedRequest> stampUpdatePolicy({
    required TUpdatePolicyBody input,
  }) async {
    final fullUrl = '${config.baseUrl}/public/v1/submit/update_policy';
    final body = packActivityBody(
      bodyJson: input.toJson(),
      fallbackOrganizationId: input.organizationId ??
          config.organizationId ??
          (throw Exception(
              "Missing organization ID, please pass in a sub-organizationId or instantiate the client with one.")),
      activityType: 'ACTIVITY_TYPE_UPDATE_POLICY_V2',
    );
    final bodyJson = jsonEncode(body);
    final stamp = await stamper.stamp(bodyJson);

    return TSignedRequest(
      body: bodyJson,
      stamp: stamp,
      url: fullUrl,
    );
  }

  /// Update human-readable name or associated private keys. Note that this activity is atomic: all of the updates will succeed at once, or all of them will fail.
  ///
  /// Sign the provided `TUpdatePrivateKeyTagBody` with the client's `stamp` function and submit the request (POST /public/v1/submit/update_private_key_tag).
  ///
  /// See also: `stampUpdatePrivateKeyTag`.

  Future<TUpdatePrivateKeyTagResponse> updatePrivateKeyTag({
    required TUpdatePrivateKeyTagBody input,
  }) async {
    final body = packActivityBody(
      bodyJson: input.toJson(),
      fallbackOrganizationId: input.organizationId ??
          config.organizationId ??
          (throw Exception(
              "Missing organization ID, please pass in a sub-organizationId or instantiate the client with one.")),
      activityType: 'ACTIVITY_TYPE_UPDATE_PRIVATE_KEY_TAG',
    );
    return await request<Map<String, dynamic>, TUpdatePrivateKeyTagResponse>(
        "/public/v1/submit/update_private_key_tag",
        body,
        (json) => TUpdatePrivateKeyTagResponse.fromJson(
            transformActivityResponse(json, 'UpdatePrivateKeyTag')));
  }

  /// Produce a `SignedRequest` from `TUpdatePrivateKeyTagBody` by using the client's `stamp` function.
  ///
  /// See also: `UpdatePrivateKeyTag`.

  Future<TSignedRequest> stampUpdatePrivateKeyTag({
    required TUpdatePrivateKeyTagBody input,
  }) async {
    final fullUrl = '${config.baseUrl}/public/v1/submit/update_private_key_tag';
    final body = packActivityBody(
      bodyJson: input.toJson(),
      fallbackOrganizationId: input.organizationId ??
          config.organizationId ??
          (throw Exception(
              "Missing organization ID, please pass in a sub-organizationId or instantiate the client with one.")),
      activityType: 'ACTIVITY_TYPE_UPDATE_PRIVATE_KEY_TAG',
    );
    final bodyJson = jsonEncode(body);
    final stamp = await stamper.stamp(bodyJson);

    return TSignedRequest(
      body: bodyJson,
      stamp: stamp,
      url: fullUrl,
    );
  }

  /// Set the threshold and members of the root quorum. This activity must be approved by the current root quorum.
  ///
  /// Sign the provided `TUpdateRootQuorumBody` with the client's `stamp` function and submit the request (POST /public/v1/submit/update_root_quorum).
  ///
  /// See also: `stampUpdateRootQuorum`.

  Future<TUpdateRootQuorumResponse> updateRootQuorum({
    required TUpdateRootQuorumBody input,
  }) async {
    final body = packActivityBody(
      bodyJson: input.toJson(),
      fallbackOrganizationId: input.organizationId ??
          config.organizationId ??
          (throw Exception(
              "Missing organization ID, please pass in a sub-organizationId or instantiate the client with one.")),
      activityType: 'ACTIVITY_TYPE_UPDATE_ROOT_QUORUM',
    );
    return await request<Map<String, dynamic>, TUpdateRootQuorumResponse>(
        "/public/v1/submit/update_root_quorum",
        body,
        (json) => TUpdateRootQuorumResponse.fromJson(
            transformActivityResponse(json, 'UpdateRootQuorum')));
  }

  /// Produce a `SignedRequest` from `TUpdateRootQuorumBody` by using the client's `stamp` function.
  ///
  /// See also: `UpdateRootQuorum`.

  Future<TSignedRequest> stampUpdateRootQuorum({
    required TUpdateRootQuorumBody input,
  }) async {
    final fullUrl = '${config.baseUrl}/public/v1/submit/update_root_quorum';
    final body = packActivityBody(
      bodyJson: input.toJson(),
      fallbackOrganizationId: input.organizationId ??
          config.organizationId ??
          (throw Exception(
              "Missing organization ID, please pass in a sub-organizationId or instantiate the client with one.")),
      activityType: 'ACTIVITY_TYPE_UPDATE_ROOT_QUORUM',
    );
    final bodyJson = jsonEncode(body);
    final stamp = await stamper.stamp(bodyJson);

    return TSignedRequest(
      body: bodyJson,
      stamp: stamp,
      url: fullUrl,
    );
  }

  /// Update a user in an existing organization.
  ///
  /// Sign the provided `TUpdateUserBody` with the client's `stamp` function and submit the request (POST /public/v1/submit/update_user).
  ///
  /// See also: `stampUpdateUser`.

  Future<TUpdateUserResponse> updateUser({
    required TUpdateUserBody input,
  }) async {
    final body = packActivityBody(
      bodyJson: input.toJson(),
      fallbackOrganizationId: input.organizationId ??
          config.organizationId ??
          (throw Exception(
              "Missing organization ID, please pass in a sub-organizationId or instantiate the client with one.")),
      activityType: 'ACTIVITY_TYPE_UPDATE_USER',
    );
    return await request<Map<String, dynamic>, TUpdateUserResponse>(
        "/public/v1/submit/update_user",
        body,
        (json) => TUpdateUserResponse.fromJson(
            transformActivityResponse(json, 'UpdateUser')));
  }

  /// Produce a `SignedRequest` from `TUpdateUserBody` by using the client's `stamp` function.
  ///
  /// See also: `UpdateUser`.

  Future<TSignedRequest> stampUpdateUser({
    required TUpdateUserBody input,
  }) async {
    final fullUrl = '${config.baseUrl}/public/v1/submit/update_user';
    final body = packActivityBody(
      bodyJson: input.toJson(),
      fallbackOrganizationId: input.organizationId ??
          config.organizationId ??
          (throw Exception(
              "Missing organization ID, please pass in a sub-organizationId or instantiate the client with one.")),
      activityType: 'ACTIVITY_TYPE_UPDATE_USER',
    );
    final bodyJson = jsonEncode(body);
    final stamp = await stamper.stamp(bodyJson);

    return TSignedRequest(
      body: bodyJson,
      stamp: stamp,
      url: fullUrl,
    );
  }

  /// Update a user's email in an existing organization.
  ///
  /// Sign the provided `TUpdateUserEmailBody` with the client's `stamp` function and submit the request (POST /public/v1/submit/update_user_email).
  ///
  /// See also: `stampUpdateUserEmail`.

  Future<TUpdateUserEmailResponse> updateUserEmail({
    required TUpdateUserEmailBody input,
  }) async {
    final body = packActivityBody(
      bodyJson: input.toJson(),
      fallbackOrganizationId: input.organizationId ??
          config.organizationId ??
          (throw Exception(
              "Missing organization ID, please pass in a sub-organizationId or instantiate the client with one.")),
      activityType: 'ACTIVITY_TYPE_UPDATE_USER_EMAIL',
    );
    return await request<Map<String, dynamic>, TUpdateUserEmailResponse>(
        "/public/v1/submit/update_user_email",
        body,
        (json) => TUpdateUserEmailResponse.fromJson(
            transformActivityResponse(json, 'UpdateUserEmail')));
  }

  /// Produce a `SignedRequest` from `TUpdateUserEmailBody` by using the client's `stamp` function.
  ///
  /// See also: `UpdateUserEmail`.

  Future<TSignedRequest> stampUpdateUserEmail({
    required TUpdateUserEmailBody input,
  }) async {
    final fullUrl = '${config.baseUrl}/public/v1/submit/update_user_email';
    final body = packActivityBody(
      bodyJson: input.toJson(),
      fallbackOrganizationId: input.organizationId ??
          config.organizationId ??
          (throw Exception(
              "Missing organization ID, please pass in a sub-organizationId or instantiate the client with one.")),
      activityType: 'ACTIVITY_TYPE_UPDATE_USER_EMAIL',
    );
    final bodyJson = jsonEncode(body);
    final stamp = await stamper.stamp(bodyJson);

    return TSignedRequest(
      body: bodyJson,
      stamp: stamp,
      url: fullUrl,
    );
  }

  /// Update a user's name in an existing organization.
  ///
  /// Sign the provided `TUpdateUserNameBody` with the client's `stamp` function and submit the request (POST /public/v1/submit/update_user_name).
  ///
  /// See also: `stampUpdateUserName`.

  Future<TUpdateUserNameResponse> updateUserName({
    required TUpdateUserNameBody input,
  }) async {
    final body = packActivityBody(
      bodyJson: input.toJson(),
      fallbackOrganizationId: input.organizationId ??
          config.organizationId ??
          (throw Exception(
              "Missing organization ID, please pass in a sub-organizationId or instantiate the client with one.")),
      activityType: 'ACTIVITY_TYPE_UPDATE_USER_NAME',
    );
    return await request<Map<String, dynamic>, TUpdateUserNameResponse>(
        "/public/v1/submit/update_user_name",
        body,
        (json) => TUpdateUserNameResponse.fromJson(
            transformActivityResponse(json, 'UpdateUserName')));
  }

  /// Produce a `SignedRequest` from `TUpdateUserNameBody` by using the client's `stamp` function.
  ///
  /// See also: `UpdateUserName`.

  Future<TSignedRequest> stampUpdateUserName({
    required TUpdateUserNameBody input,
  }) async {
    final fullUrl = '${config.baseUrl}/public/v1/submit/update_user_name';
    final body = packActivityBody(
      bodyJson: input.toJson(),
      fallbackOrganizationId: input.organizationId ??
          config.organizationId ??
          (throw Exception(
              "Missing organization ID, please pass in a sub-organizationId or instantiate the client with one.")),
      activityType: 'ACTIVITY_TYPE_UPDATE_USER_NAME',
    );
    final bodyJson = jsonEncode(body);
    final stamp = await stamper.stamp(bodyJson);

    return TSignedRequest(
      body: bodyJson,
      stamp: stamp,
      url: fullUrl,
    );
  }

  /// Update a user's phone number in an existing organization.
  ///
  /// Sign the provided `TUpdateUserPhoneNumberBody` with the client's `stamp` function and submit the request (POST /public/v1/submit/update_user_phone_number).
  ///
  /// See also: `stampUpdateUserPhoneNumber`.

  Future<TUpdateUserPhoneNumberResponse> updateUserPhoneNumber({
    required TUpdateUserPhoneNumberBody input,
  }) async {
    final body = packActivityBody(
      bodyJson: input.toJson(),
      fallbackOrganizationId: input.organizationId ??
          config.organizationId ??
          (throw Exception(
              "Missing organization ID, please pass in a sub-organizationId or instantiate the client with one.")),
      activityType: 'ACTIVITY_TYPE_UPDATE_USER_PHONE_NUMBER',
    );
    return await request<Map<String, dynamic>, TUpdateUserPhoneNumberResponse>(
        "/public/v1/submit/update_user_phone_number",
        body,
        (json) => TUpdateUserPhoneNumberResponse.fromJson(
            transformActivityResponse(json, 'UpdateUserPhoneNumber')));
  }

  /// Produce a `SignedRequest` from `TUpdateUserPhoneNumberBody` by using the client's `stamp` function.
  ///
  /// See also: `UpdateUserPhoneNumber`.

  Future<TSignedRequest> stampUpdateUserPhoneNumber({
    required TUpdateUserPhoneNumberBody input,
  }) async {
    final fullUrl =
        '${config.baseUrl}/public/v1/submit/update_user_phone_number';
    final body = packActivityBody(
      bodyJson: input.toJson(),
      fallbackOrganizationId: input.organizationId ??
          config.organizationId ??
          (throw Exception(
              "Missing organization ID, please pass in a sub-organizationId or instantiate the client with one.")),
      activityType: 'ACTIVITY_TYPE_UPDATE_USER_PHONE_NUMBER',
    );
    final bodyJson = jsonEncode(body);
    final stamp = await stamper.stamp(bodyJson);

    return TSignedRequest(
      body: bodyJson,
      stamp: stamp,
      url: fullUrl,
    );
  }

  /// Update human-readable name or associated users. Note that this activity is atomic: all of the updates will succeed at once, or all of them will fail.
  ///
  /// Sign the provided `TUpdateUserTagBody` with the client's `stamp` function and submit the request (POST /public/v1/submit/update_user_tag).
  ///
  /// See also: `stampUpdateUserTag`.

  Future<TUpdateUserTagResponse> updateUserTag({
    required TUpdateUserTagBody input,
  }) async {
    final body = packActivityBody(
      bodyJson: input.toJson(),
      fallbackOrganizationId: input.organizationId ??
          config.organizationId ??
          (throw Exception(
              "Missing organization ID, please pass in a sub-organizationId or instantiate the client with one.")),
      activityType: 'ACTIVITY_TYPE_UPDATE_USER_TAG',
    );
    return await request<Map<String, dynamic>, TUpdateUserTagResponse>(
        "/public/v1/submit/update_user_tag",
        body,
        (json) => TUpdateUserTagResponse.fromJson(
            transformActivityResponse(json, 'UpdateUserTag')));
  }

  /// Produce a `SignedRequest` from `TUpdateUserTagBody` by using the client's `stamp` function.
  ///
  /// See also: `UpdateUserTag`.

  Future<TSignedRequest> stampUpdateUserTag({
    required TUpdateUserTagBody input,
  }) async {
    final fullUrl = '${config.baseUrl}/public/v1/submit/update_user_tag';
    final body = packActivityBody(
      bodyJson: input.toJson(),
      fallbackOrganizationId: input.organizationId ??
          config.organizationId ??
          (throw Exception(
              "Missing organization ID, please pass in a sub-organizationId or instantiate the client with one.")),
      activityType: 'ACTIVITY_TYPE_UPDATE_USER_TAG',
    );
    final bodyJson = jsonEncode(body);
    final stamp = await stamper.stamp(bodyJson);

    return TSignedRequest(
      body: bodyJson,
      stamp: stamp,
      url: fullUrl,
    );
  }

  /// Update a wallet for an organization.
  ///
  /// Sign the provided `TUpdateWalletBody` with the client's `stamp` function and submit the request (POST /public/v1/submit/update_wallet).
  ///
  /// See also: `stampUpdateWallet`.

  Future<TUpdateWalletResponse> updateWallet({
    required TUpdateWalletBody input,
  }) async {
    final body = packActivityBody(
      bodyJson: input.toJson(),
      fallbackOrganizationId: input.organizationId ??
          config.organizationId ??
          (throw Exception(
              "Missing organization ID, please pass in a sub-organizationId or instantiate the client with one.")),
      activityType: 'ACTIVITY_TYPE_UPDATE_WALLET',
    );
    return await request<Map<String, dynamic>, TUpdateWalletResponse>(
        "/public/v1/submit/update_wallet",
        body,
        (json) => TUpdateWalletResponse.fromJson(
            transformActivityResponse(json, 'UpdateWallet')));
  }

  /// Produce a `SignedRequest` from `TUpdateWalletBody` by using the client's `stamp` function.
  ///
  /// See also: `UpdateWallet`.

  Future<TSignedRequest> stampUpdateWallet({
    required TUpdateWalletBody input,
  }) async {
    final fullUrl = '${config.baseUrl}/public/v1/submit/update_wallet';
    final body = packActivityBody(
      bodyJson: input.toJson(),
      fallbackOrganizationId: input.organizationId ??
          config.organizationId ??
          (throw Exception(
              "Missing organization ID, please pass in a sub-organizationId or instantiate the client with one.")),
      activityType: 'ACTIVITY_TYPE_UPDATE_WALLET',
    );
    final bodyJson = jsonEncode(body);
    final stamp = await stamper.stamp(bodyJson);

    return TSignedRequest(
      body: bodyJson,
      stamp: stamp,
      url: fullUrl,
    );
  }

  /// Verify a generic OTP.
  ///
  /// Sign the provided `TVerifyOtpBody` with the client's `stamp` function and submit the request (POST /public/v1/submit/verify_otp).
  ///
  /// See also: `stampVerifyOtp`.

  Future<TVerifyOtpResponse> verifyOtp({
    required TVerifyOtpBody input,
  }) async {
    final body = packActivityBody(
      bodyJson: input.toJson(),
      fallbackOrganizationId: input.organizationId ??
          config.organizationId ??
          (throw Exception(
              "Missing organization ID, please pass in a sub-organizationId or instantiate the client with one.")),
      activityType: 'ACTIVITY_TYPE_VERIFY_OTP',
    );
    return await request<Map<String, dynamic>, TVerifyOtpResponse>(
        "/public/v1/submit/verify_otp",
        body,
        (json) => TVerifyOtpResponse.fromJson(
            transformActivityResponse(json, 'VerifyOtp')));
  }

  /// Produce a `SignedRequest` from `TVerifyOtpBody` by using the client's `stamp` function.
  ///
  /// See also: `VerifyOtp`.

  Future<TSignedRequest> stampVerifyOtp({
    required TVerifyOtpBody input,
  }) async {
    final fullUrl = '${config.baseUrl}/public/v1/submit/verify_otp';
    final body = packActivityBody(
      bodyJson: input.toJson(),
      fallbackOrganizationId: input.organizationId ??
          config.organizationId ??
          (throw Exception(
              "Missing organization ID, please pass in a sub-organizationId or instantiate the client with one.")),
      activityType: 'ACTIVITY_TYPE_VERIFY_OTP',
    );
    final bodyJson = jsonEncode(body);
    final stamp = await stamper.stamp(bodyJson);

    return TSignedRequest(
      body: bodyJson,
      stamp: stamp,
      url: fullUrl,
    );
  }

  /// Sign the provided `TNOOPCodegenAnchorBody` with the client's `stamp` function and submit the request (POST /tkhq/api/v1/noop-codegen-anchor).
  ///
  /// See also: `stampNOOPCodegenAnchor`.

  Future<TNOOPCodegenAnchorResponse> nOOPCodegenAnchor({
    required TNOOPCodegenAnchorBody input,
  }) async {
    return await request<TNOOPCodegenAnchorBody, TNOOPCodegenAnchorResponse>(
        "/tkhq/api/v1/noop-codegen-anchor",
        input,
        (json) => TNOOPCodegenAnchorResponse.fromJson(json));
  }

  /// Produce a `SignedRequest` from `TNOOPCodegenAnchorBody` by using the client's `stamp` function.
  ///
  /// See also: `NOOPCodegenAnchor`.

  Future<TSignedRequest> stampNOOPCodegenAnchor({
    required TNOOPCodegenAnchorBody input,
  }) async {
    final fullUrl = '${config.baseUrl}/tkhq/api/v1/noop-codegen-anchor';
    final body = jsonEncode(input);
    final stamp = await stamper.stamp(body);

    return TSignedRequest(
      body: body,
      stamp: stamp,
      url: fullUrl,
    );
  }

  /// Set a rate local rate limit just on the current endpoint, for purposes of testing with Vivosuite.
  ///
  /// Sign the provided `TTestRateLimitsBody` with the client's `stamp` function and submit the request (POST /tkhq/api/v1/test_rate_limits).
  ///
  /// See also: `stampTestRateLimits`.

  Future<TTestRateLimitsResponse> testRateLimits({
    required TTestRateLimitsBody input,
  }) async {
    return await request<TTestRateLimitsBody, TTestRateLimitsResponse>(
        "/tkhq/api/v1/test_rate_limits",
        input,
        (json) => TTestRateLimitsResponse.fromJson(json));
  }

  /// Produce a `SignedRequest` from `TTestRateLimitsBody` by using the client's `stamp` function.
  ///
  /// See also: `TestRateLimits`.

  Future<TSignedRequest> stampTestRateLimits({
    required TTestRateLimitsBody input,
  }) async {
    final fullUrl = '${config.baseUrl}/tkhq/api/v1/test_rate_limits';
    final body = jsonEncode(input);
    final stamp = await stamper.stamp(body);

    return TSignedRequest(
      body: body,
      stamp: stamp,
      url: fullUrl,
    );
  }

  /// Return organization id associated with a given phone number, email, public key, credential ID or OIDC token.
  ///
  /// Sign the provided `ProxyTGetAccountBody` with the client's `stamp` function and submit the request (POST /v1/account).
  ///
  /// See also: `stampGetAccount`.

  Future<ProxyTGetAccountResponse> proxyGetAccount({
    required ProxyTGetAccountBody input,
  }) async {
    return await authProxyRequest<ProxyTGetAccountBody,
            ProxyTGetAccountResponse>("/v1/account", input,
        (json) => ProxyTGetAccountResponse.fromJson(json));
  }

  /// Produce a `SignedRequest` from `ProxyTGetAccountBody` by using the client's `stamp` function.
  ///
  /// See also: `GetAccount`.

  /// Authenticate with an OAuth 2.0 provider and receive an OIDC token issued by Turnkey in response.
  ///
  /// Sign the provided `ProxyTOAuth2AuthenticateBody` with the client's `stamp` function and submit the request (POST /v1/oauth2_authenticate).
  ///
  /// See also: `stampOAuth2Authenticate`.

  Future<ProxyTOAuth2AuthenticateResponse> proxyOAuth2Authenticate({
    required ProxyTOAuth2AuthenticateBody input,
  }) async {
    return await authProxyRequest<ProxyTOAuth2AuthenticateBody,
            ProxyTOAuth2AuthenticateResponse>("/v1/oauth2_authenticate", input,
        (json) => ProxyTOAuth2AuthenticateResponse.fromJson(json));
  }

  /// Produce a `SignedRequest` from `ProxyTOAuth2AuthenticateBody` by using the client's `stamp` function.
  ///
  /// See also: `OAuth2Authenticate`.

  /// Login using an OIDC token and public key.
  ///
  /// Sign the provided `ProxyTOAuthLoginBody` with the client's `stamp` function and submit the request (POST /v1/oauth_login).
  ///
  /// See also: `stampOAuthLogin`.

  Future<ProxyTOAuthLoginResponse> proxyOAuthLogin({
    required ProxyTOAuthLoginBody input,
  }) async {
    return await authProxyRequest<ProxyTOAuthLoginBody,
            ProxyTOAuthLoginResponse>("/v1/oauth_login", input,
        (json) => ProxyTOAuthLoginResponse.fromJson(json));
  }

  /// Produce a `SignedRequest` from `ProxyTOAuthLoginBody` by using the client's `stamp` function.
  ///
  /// See also: `OAuthLogin`.

  /// Initialize an OTP (email or SMS) for a user.
  ///
  /// Sign the provided `ProxyTInitOtpBody` with the client's `stamp` function and submit the request (POST /v1/otp_init).
  ///
  /// See also: `stampInitOtp`.

  Future<ProxyTInitOtpResponse> proxyInitOtp({
    required ProxyTInitOtpBody input,
  }) async {
    return await authProxyRequest<ProxyTInitOtpBody, ProxyTInitOtpResponse>(
        "/v1/otp_init", input, (json) => ProxyTInitOtpResponse.fromJson(json));
  }

  /// Produce a `SignedRequest` from `ProxyTInitOtpBody` by using the client's `stamp` function.
  ///
  /// See also: `InitOtp`.

  /// Login using a verification token and public key.
  ///
  /// Sign the provided `ProxyTOtpLoginBody` with the client's `stamp` function and submit the request (POST /v1/otp_login).
  ///
  /// See also: `stampOtpLogin`.

  Future<ProxyTOtpLoginResponse> proxyOtpLogin({
    required ProxyTOtpLoginBody input,
  }) async {
    return await authProxyRequest<ProxyTOtpLoginBody, ProxyTOtpLoginResponse>(
        "/v1/otp_login",
        input,
        (json) => ProxyTOtpLoginResponse.fromJson(json));
  }

  /// Produce a `SignedRequest` from `ProxyTOtpLoginBody` by using the client's `stamp` function.
  ///
  /// See also: `OtpLogin`.

  /// Verify the OTP code previously sent to the user's contact and return a verification token.
  ///
  /// Sign the provided `ProxyTVerifyOtpBody` with the client's `stamp` function and submit the request (POST /v1/otp_verify).
  ///
  /// See also: `stampVerifyOtp`.

  Future<ProxyTVerifyOtpResponse> proxyVerifyOtp({
    required ProxyTVerifyOtpBody input,
  }) async {
    return await authProxyRequest<ProxyTVerifyOtpBody, ProxyTVerifyOtpResponse>(
        "/v1/otp_verify",
        input,
        (json) => ProxyTVerifyOtpResponse.fromJson(json));
  }

  /// Produce a `SignedRequest` from `ProxyTVerifyOtpBody` by using the client's `stamp` function.
  ///
  /// See also: `VerifyOtp`.

  /// Onboard a new user.
  ///
  /// Sign the provided `ProxyTSignupBody` with the client's `stamp` function and submit the request (POST /v1/signup).
  ///
  /// See also: `stampSignup`.

  Future<ProxyTSignupResponse> proxySignup({
    required ProxyTSignupBody input,
  }) async {
    return await authProxyRequest<ProxyTSignupBody, ProxyTSignupResponse>(
        "/v1/signup", input, (json) => ProxyTSignupResponse.fromJson(json));
  }

  /// Produce a `SignedRequest` from `ProxyTSignupBody` by using the client's `stamp` function.
  ///
  /// See also: `Signup`.

  /// Get wallet kit settings and feature toggles for the calling organization.
  ///
  /// Sign the provided `ProxyTGetWalletKitConfigBody` with the client's `stamp` function and submit the request (POST /v1/wallet_kit_config).
  ///
  /// See also: `stampGetWalletKitConfig`.

  Future<ProxyTGetWalletKitConfigResponse> proxyGetWalletKitConfig({
    required ProxyTGetWalletKitConfigBody input,
  }) async {
    return await authProxyRequest<ProxyTGetWalletKitConfigBody,
            ProxyTGetWalletKitConfigResponse>("/v1/wallet_kit_config", input,
        (json) => ProxyTGetWalletKitConfigResponse.fromJson(json));
  }

  /// Produce a `SignedRequest` from `ProxyTGetWalletKitConfigBody` by using the client's `stamp` function.
  ///
  /// See also: `GetWalletKitConfig`.
}
