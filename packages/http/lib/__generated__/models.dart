// @generated by codegen. DO NOT EDIT BY HAND.
// ignore_for_file: constant_identifier_names, non_constant_identifier_names

// --- Base definitions ---
enum externaldatav1SignatureScheme {
  signature_scheme_ephemeral_key_p256,
}

externaldatav1SignatureScheme externaldatav1SignatureSchemeFromJson(dynamic value) {
  switch (value) {
    case 'SIGNATURE_SCHEME_EPHEMERAL_KEY_P256': return externaldatav1SignatureScheme.signature_scheme_ephemeral_key_p256;
    default: throw ArgumentError('Unknown externaldatav1SignatureScheme: $value');
  }
}

dynamic externaldatav1SignatureSchemeToJson(externaldatav1SignatureScheme value) {
  switch (value) {
    case externaldatav1SignatureScheme.signature_scheme_ephemeral_key_p256: return "SIGNATURE_SCHEME_EPHEMERAL_KEY_P256";
  }
}

enum v1AccessType {
  access_type_web,
  access_type_api,
  access_type_all,
}

v1AccessType v1AccessTypeFromJson(dynamic value) {
  switch (value) {
    case 'ACCESS_TYPE_WEB': return v1AccessType.access_type_web;
    case 'ACCESS_TYPE_API': return v1AccessType.access_type_api;
    case 'ACCESS_TYPE_ALL': return v1AccessType.access_type_all;
    default: throw ArgumentError('Unknown v1AccessType: $value');
  }
}

dynamic v1AccessTypeToJson(v1AccessType value) {
  switch (value) {
    case v1AccessType.access_type_web: return "ACCESS_TYPE_WEB";
    case v1AccessType.access_type_api: return "ACCESS_TYPE_API";
    case v1AccessType.access_type_all: return "ACCESS_TYPE_ALL";
  }
}

enum v1ActivityStatus {
  activity_status_created,
  activity_status_pending,
  activity_status_completed,
  activity_status_failed,
  activity_status_consensus_needed,
  activity_status_rejected,
}

v1ActivityStatus v1ActivityStatusFromJson(dynamic value) {
  switch (value) {
    case 'ACTIVITY_STATUS_CREATED': return v1ActivityStatus.activity_status_created;
    case 'ACTIVITY_STATUS_PENDING': return v1ActivityStatus.activity_status_pending;
    case 'ACTIVITY_STATUS_COMPLETED': return v1ActivityStatus.activity_status_completed;
    case 'ACTIVITY_STATUS_FAILED': return v1ActivityStatus.activity_status_failed;
    case 'ACTIVITY_STATUS_CONSENSUS_NEEDED': return v1ActivityStatus.activity_status_consensus_needed;
    case 'ACTIVITY_STATUS_REJECTED': return v1ActivityStatus.activity_status_rejected;
    default: throw ArgumentError('Unknown v1ActivityStatus: $value');
  }
}

dynamic v1ActivityStatusToJson(v1ActivityStatus value) {
  switch (value) {
    case v1ActivityStatus.activity_status_created: return "ACTIVITY_STATUS_CREATED";
    case v1ActivityStatus.activity_status_pending: return "ACTIVITY_STATUS_PENDING";
    case v1ActivityStatus.activity_status_completed: return "ACTIVITY_STATUS_COMPLETED";
    case v1ActivityStatus.activity_status_failed: return "ACTIVITY_STATUS_FAILED";
    case v1ActivityStatus.activity_status_consensus_needed: return "ACTIVITY_STATUS_CONSENSUS_NEEDED";
    case v1ActivityStatus.activity_status_rejected: return "ACTIVITY_STATUS_REJECTED";
  }
}

enum v1ActivityType {
  activity_type_create_api_keys,
  activity_type_create_users,
  activity_type_create_private_keys,
  activity_type_sign_raw_payload,
  activity_type_create_invitations,
  activity_type_accept_invitation,
  activity_type_create_policy,
  activity_type_disable_private_key,
  activity_type_delete_users,
  activity_type_delete_api_keys,
  activity_type_delete_invitation,
  activity_type_delete_organization,
  activity_type_delete_policy,
  activity_type_create_user_tag,
  activity_type_delete_user_tags,
  activity_type_create_organization,
  activity_type_sign_transaction,
  activity_type_approve_activity,
  activity_type_reject_activity,
  activity_type_delete_authenticators,
  activity_type_create_authenticators,
  activity_type_create_private_key_tag,
  activity_type_delete_private_key_tags,
  activity_type_set_payment_method,
  activity_type_activate_billing_tier,
  activity_type_delete_payment_method,
  activity_type_create_policy_v2,
  activity_type_create_policy_v3,
  activity_type_create_api_only_users,
  activity_type_update_root_quorum,
  activity_type_update_user_tag,
  activity_type_update_private_key_tag,
  activity_type_create_authenticators_v2,
  activity_type_create_organization_v2,
  activity_type_create_users_v2,
  activity_type_accept_invitation_v2,
  activity_type_create_sub_organization,
  activity_type_create_sub_organization_v2,
  activity_type_update_allowed_origins,
  activity_type_create_private_keys_v2,
  activity_type_update_user,
  activity_type_update_policy,
  activity_type_set_payment_method_v2,
  activity_type_create_sub_organization_v3,
  activity_type_create_wallet,
  activity_type_create_wallet_accounts,
  activity_type_init_user_email_recovery,
  activity_type_recover_user,
  activity_type_set_organization_feature,
  activity_type_remove_organization_feature,
  activity_type_sign_raw_payload_v2,
  activity_type_sign_transaction_v2,
  activity_type_export_private_key,
  activity_type_export_wallet,
  activity_type_create_sub_organization_v4,
  activity_type_email_auth,
  activity_type_export_wallet_account,
  activity_type_init_import_wallet,
  activity_type_import_wallet,
  activity_type_init_import_private_key,
  activity_type_import_private_key,
  activity_type_create_policies,
  activity_type_sign_raw_payloads,
  activity_type_create_read_only_session,
  activity_type_create_oauth_providers,
  activity_type_delete_oauth_providers,
  activity_type_create_sub_organization_v5,
  activity_type_oauth,
  activity_type_create_api_keys_v2,
  activity_type_create_read_write_session,
  activity_type_email_auth_v2,
  activity_type_create_sub_organization_v6,
  activity_type_delete_private_keys,
  activity_type_delete_wallets,
  activity_type_create_read_write_session_v2,
  activity_type_delete_sub_organization,
  activity_type_init_otp_auth,
  activity_type_otp_auth,
  activity_type_create_sub_organization_v7,
  activity_type_update_wallet,
  activity_type_update_policy_v2,
  activity_type_create_users_v3,
  activity_type_init_otp_auth_v2,
  activity_type_init_otp,
  activity_type_verify_otp,
  activity_type_otp_login,
  activity_type_stamp_login,
  activity_type_oauth_login,
  activity_type_update_user_name,
  activity_type_update_user_email,
  activity_type_update_user_phone_number,
  activity_type_init_fiat_on_ramp,
  activity_type_create_smart_contract_interface,
  activity_type_delete_smart_contract_interface,
  activity_type_enable_auth_proxy,
  activity_type_disable_auth_proxy,
  activity_type_update_auth_proxy_config,
  activity_type_create_oauth2_credential,
  activity_type_update_oauth2_credential,
  activity_type_delete_oauth2_credential,
  activity_type_oauth2_authenticate,
  activity_type_delete_wallet_accounts,
  activity_type_delete_policies,
  activity_type_eth_send_raw_transaction,
  activity_type_eth_send_transaction,
  activity_type_create_fiat_on_ramp_credential,
  activity_type_update_fiat_on_ramp_credential,
  activity_type_delete_fiat_on_ramp_credential,
  activity_type_email_auth_v3,
  activity_type_init_user_email_recovery_v2,
  activity_type_init_otp_auth_v3,
  activity_type_init_otp_v2,
  activity_type_upsert_gas_usage_config,
  activity_type_create_tvc_app,
  activity_type_create_tvc_deployment,
  activity_type_create_tvc_manifest_approvals,
  activity_type_sol_send_transaction,
}

v1ActivityType v1ActivityTypeFromJson(dynamic value) {
  switch (value) {
    case 'ACTIVITY_TYPE_CREATE_API_KEYS': return v1ActivityType.activity_type_create_api_keys;
    case 'ACTIVITY_TYPE_CREATE_USERS': return v1ActivityType.activity_type_create_users;
    case 'ACTIVITY_TYPE_CREATE_PRIVATE_KEYS': return v1ActivityType.activity_type_create_private_keys;
    case 'ACTIVITY_TYPE_SIGN_RAW_PAYLOAD': return v1ActivityType.activity_type_sign_raw_payload;
    case 'ACTIVITY_TYPE_CREATE_INVITATIONS': return v1ActivityType.activity_type_create_invitations;
    case 'ACTIVITY_TYPE_ACCEPT_INVITATION': return v1ActivityType.activity_type_accept_invitation;
    case 'ACTIVITY_TYPE_CREATE_POLICY': return v1ActivityType.activity_type_create_policy;
    case 'ACTIVITY_TYPE_DISABLE_PRIVATE_KEY': return v1ActivityType.activity_type_disable_private_key;
    case 'ACTIVITY_TYPE_DELETE_USERS': return v1ActivityType.activity_type_delete_users;
    case 'ACTIVITY_TYPE_DELETE_API_KEYS': return v1ActivityType.activity_type_delete_api_keys;
    case 'ACTIVITY_TYPE_DELETE_INVITATION': return v1ActivityType.activity_type_delete_invitation;
    case 'ACTIVITY_TYPE_DELETE_ORGANIZATION': return v1ActivityType.activity_type_delete_organization;
    case 'ACTIVITY_TYPE_DELETE_POLICY': return v1ActivityType.activity_type_delete_policy;
    case 'ACTIVITY_TYPE_CREATE_USER_TAG': return v1ActivityType.activity_type_create_user_tag;
    case 'ACTIVITY_TYPE_DELETE_USER_TAGS': return v1ActivityType.activity_type_delete_user_tags;
    case 'ACTIVITY_TYPE_CREATE_ORGANIZATION': return v1ActivityType.activity_type_create_organization;
    case 'ACTIVITY_TYPE_SIGN_TRANSACTION': return v1ActivityType.activity_type_sign_transaction;
    case 'ACTIVITY_TYPE_APPROVE_ACTIVITY': return v1ActivityType.activity_type_approve_activity;
    case 'ACTIVITY_TYPE_REJECT_ACTIVITY': return v1ActivityType.activity_type_reject_activity;
    case 'ACTIVITY_TYPE_DELETE_AUTHENTICATORS': return v1ActivityType.activity_type_delete_authenticators;
    case 'ACTIVITY_TYPE_CREATE_AUTHENTICATORS': return v1ActivityType.activity_type_create_authenticators;
    case 'ACTIVITY_TYPE_CREATE_PRIVATE_KEY_TAG': return v1ActivityType.activity_type_create_private_key_tag;
    case 'ACTIVITY_TYPE_DELETE_PRIVATE_KEY_TAGS': return v1ActivityType.activity_type_delete_private_key_tags;
    case 'ACTIVITY_TYPE_SET_PAYMENT_METHOD': return v1ActivityType.activity_type_set_payment_method;
    case 'ACTIVITY_TYPE_ACTIVATE_BILLING_TIER': return v1ActivityType.activity_type_activate_billing_tier;
    case 'ACTIVITY_TYPE_DELETE_PAYMENT_METHOD': return v1ActivityType.activity_type_delete_payment_method;
    case 'ACTIVITY_TYPE_CREATE_POLICY_V2': return v1ActivityType.activity_type_create_policy_v2;
    case 'ACTIVITY_TYPE_CREATE_POLICY_V3': return v1ActivityType.activity_type_create_policy_v3;
    case 'ACTIVITY_TYPE_CREATE_API_ONLY_USERS': return v1ActivityType.activity_type_create_api_only_users;
    case 'ACTIVITY_TYPE_UPDATE_ROOT_QUORUM': return v1ActivityType.activity_type_update_root_quorum;
    case 'ACTIVITY_TYPE_UPDATE_USER_TAG': return v1ActivityType.activity_type_update_user_tag;
    case 'ACTIVITY_TYPE_UPDATE_PRIVATE_KEY_TAG': return v1ActivityType.activity_type_update_private_key_tag;
    case 'ACTIVITY_TYPE_CREATE_AUTHENTICATORS_V2': return v1ActivityType.activity_type_create_authenticators_v2;
    case 'ACTIVITY_TYPE_CREATE_ORGANIZATION_V2': return v1ActivityType.activity_type_create_organization_v2;
    case 'ACTIVITY_TYPE_CREATE_USERS_V2': return v1ActivityType.activity_type_create_users_v2;
    case 'ACTIVITY_TYPE_ACCEPT_INVITATION_V2': return v1ActivityType.activity_type_accept_invitation_v2;
    case 'ACTIVITY_TYPE_CREATE_SUB_ORGANIZATION': return v1ActivityType.activity_type_create_sub_organization;
    case 'ACTIVITY_TYPE_CREATE_SUB_ORGANIZATION_V2': return v1ActivityType.activity_type_create_sub_organization_v2;
    case 'ACTIVITY_TYPE_UPDATE_ALLOWED_ORIGINS': return v1ActivityType.activity_type_update_allowed_origins;
    case 'ACTIVITY_TYPE_CREATE_PRIVATE_KEYS_V2': return v1ActivityType.activity_type_create_private_keys_v2;
    case 'ACTIVITY_TYPE_UPDATE_USER': return v1ActivityType.activity_type_update_user;
    case 'ACTIVITY_TYPE_UPDATE_POLICY': return v1ActivityType.activity_type_update_policy;
    case 'ACTIVITY_TYPE_SET_PAYMENT_METHOD_V2': return v1ActivityType.activity_type_set_payment_method_v2;
    case 'ACTIVITY_TYPE_CREATE_SUB_ORGANIZATION_V3': return v1ActivityType.activity_type_create_sub_organization_v3;
    case 'ACTIVITY_TYPE_CREATE_WALLET': return v1ActivityType.activity_type_create_wallet;
    case 'ACTIVITY_TYPE_CREATE_WALLET_ACCOUNTS': return v1ActivityType.activity_type_create_wallet_accounts;
    case 'ACTIVITY_TYPE_INIT_USER_EMAIL_RECOVERY': return v1ActivityType.activity_type_init_user_email_recovery;
    case 'ACTIVITY_TYPE_RECOVER_USER': return v1ActivityType.activity_type_recover_user;
    case 'ACTIVITY_TYPE_SET_ORGANIZATION_FEATURE': return v1ActivityType.activity_type_set_organization_feature;
    case 'ACTIVITY_TYPE_REMOVE_ORGANIZATION_FEATURE': return v1ActivityType.activity_type_remove_organization_feature;
    case 'ACTIVITY_TYPE_SIGN_RAW_PAYLOAD_V2': return v1ActivityType.activity_type_sign_raw_payload_v2;
    case 'ACTIVITY_TYPE_SIGN_TRANSACTION_V2': return v1ActivityType.activity_type_sign_transaction_v2;
    case 'ACTIVITY_TYPE_EXPORT_PRIVATE_KEY': return v1ActivityType.activity_type_export_private_key;
    case 'ACTIVITY_TYPE_EXPORT_WALLET': return v1ActivityType.activity_type_export_wallet;
    case 'ACTIVITY_TYPE_CREATE_SUB_ORGANIZATION_V4': return v1ActivityType.activity_type_create_sub_organization_v4;
    case 'ACTIVITY_TYPE_EMAIL_AUTH': return v1ActivityType.activity_type_email_auth;
    case 'ACTIVITY_TYPE_EXPORT_WALLET_ACCOUNT': return v1ActivityType.activity_type_export_wallet_account;
    case 'ACTIVITY_TYPE_INIT_IMPORT_WALLET': return v1ActivityType.activity_type_init_import_wallet;
    case 'ACTIVITY_TYPE_IMPORT_WALLET': return v1ActivityType.activity_type_import_wallet;
    case 'ACTIVITY_TYPE_INIT_IMPORT_PRIVATE_KEY': return v1ActivityType.activity_type_init_import_private_key;
    case 'ACTIVITY_TYPE_IMPORT_PRIVATE_KEY': return v1ActivityType.activity_type_import_private_key;
    case 'ACTIVITY_TYPE_CREATE_POLICIES': return v1ActivityType.activity_type_create_policies;
    case 'ACTIVITY_TYPE_SIGN_RAW_PAYLOADS': return v1ActivityType.activity_type_sign_raw_payloads;
    case 'ACTIVITY_TYPE_CREATE_READ_ONLY_SESSION': return v1ActivityType.activity_type_create_read_only_session;
    case 'ACTIVITY_TYPE_CREATE_OAUTH_PROVIDERS': return v1ActivityType.activity_type_create_oauth_providers;
    case 'ACTIVITY_TYPE_DELETE_OAUTH_PROVIDERS': return v1ActivityType.activity_type_delete_oauth_providers;
    case 'ACTIVITY_TYPE_CREATE_SUB_ORGANIZATION_V5': return v1ActivityType.activity_type_create_sub_organization_v5;
    case 'ACTIVITY_TYPE_OAUTH': return v1ActivityType.activity_type_oauth;
    case 'ACTIVITY_TYPE_CREATE_API_KEYS_V2': return v1ActivityType.activity_type_create_api_keys_v2;
    case 'ACTIVITY_TYPE_CREATE_READ_WRITE_SESSION': return v1ActivityType.activity_type_create_read_write_session;
    case 'ACTIVITY_TYPE_EMAIL_AUTH_V2': return v1ActivityType.activity_type_email_auth_v2;
    case 'ACTIVITY_TYPE_CREATE_SUB_ORGANIZATION_V6': return v1ActivityType.activity_type_create_sub_organization_v6;
    case 'ACTIVITY_TYPE_DELETE_PRIVATE_KEYS': return v1ActivityType.activity_type_delete_private_keys;
    case 'ACTIVITY_TYPE_DELETE_WALLETS': return v1ActivityType.activity_type_delete_wallets;
    case 'ACTIVITY_TYPE_CREATE_READ_WRITE_SESSION_V2': return v1ActivityType.activity_type_create_read_write_session_v2;
    case 'ACTIVITY_TYPE_DELETE_SUB_ORGANIZATION': return v1ActivityType.activity_type_delete_sub_organization;
    case 'ACTIVITY_TYPE_INIT_OTP_AUTH': return v1ActivityType.activity_type_init_otp_auth;
    case 'ACTIVITY_TYPE_OTP_AUTH': return v1ActivityType.activity_type_otp_auth;
    case 'ACTIVITY_TYPE_CREATE_SUB_ORGANIZATION_V7': return v1ActivityType.activity_type_create_sub_organization_v7;
    case 'ACTIVITY_TYPE_UPDATE_WALLET': return v1ActivityType.activity_type_update_wallet;
    case 'ACTIVITY_TYPE_UPDATE_POLICY_V2': return v1ActivityType.activity_type_update_policy_v2;
    case 'ACTIVITY_TYPE_CREATE_USERS_V3': return v1ActivityType.activity_type_create_users_v3;
    case 'ACTIVITY_TYPE_INIT_OTP_AUTH_V2': return v1ActivityType.activity_type_init_otp_auth_v2;
    case 'ACTIVITY_TYPE_INIT_OTP': return v1ActivityType.activity_type_init_otp;
    case 'ACTIVITY_TYPE_VERIFY_OTP': return v1ActivityType.activity_type_verify_otp;
    case 'ACTIVITY_TYPE_OTP_LOGIN': return v1ActivityType.activity_type_otp_login;
    case 'ACTIVITY_TYPE_STAMP_LOGIN': return v1ActivityType.activity_type_stamp_login;
    case 'ACTIVITY_TYPE_OAUTH_LOGIN': return v1ActivityType.activity_type_oauth_login;
    case 'ACTIVITY_TYPE_UPDATE_USER_NAME': return v1ActivityType.activity_type_update_user_name;
    case 'ACTIVITY_TYPE_UPDATE_USER_EMAIL': return v1ActivityType.activity_type_update_user_email;
    case 'ACTIVITY_TYPE_UPDATE_USER_PHONE_NUMBER': return v1ActivityType.activity_type_update_user_phone_number;
    case 'ACTIVITY_TYPE_INIT_FIAT_ON_RAMP': return v1ActivityType.activity_type_init_fiat_on_ramp;
    case 'ACTIVITY_TYPE_CREATE_SMART_CONTRACT_INTERFACE': return v1ActivityType.activity_type_create_smart_contract_interface;
    case 'ACTIVITY_TYPE_DELETE_SMART_CONTRACT_INTERFACE': return v1ActivityType.activity_type_delete_smart_contract_interface;
    case 'ACTIVITY_TYPE_ENABLE_AUTH_PROXY': return v1ActivityType.activity_type_enable_auth_proxy;
    case 'ACTIVITY_TYPE_DISABLE_AUTH_PROXY': return v1ActivityType.activity_type_disable_auth_proxy;
    case 'ACTIVITY_TYPE_UPDATE_AUTH_PROXY_CONFIG': return v1ActivityType.activity_type_update_auth_proxy_config;
    case 'ACTIVITY_TYPE_CREATE_OAUTH2_CREDENTIAL': return v1ActivityType.activity_type_create_oauth2_credential;
    case 'ACTIVITY_TYPE_UPDATE_OAUTH2_CREDENTIAL': return v1ActivityType.activity_type_update_oauth2_credential;
    case 'ACTIVITY_TYPE_DELETE_OAUTH2_CREDENTIAL': return v1ActivityType.activity_type_delete_oauth2_credential;
    case 'ACTIVITY_TYPE_OAUTH2_AUTHENTICATE': return v1ActivityType.activity_type_oauth2_authenticate;
    case 'ACTIVITY_TYPE_DELETE_WALLET_ACCOUNTS': return v1ActivityType.activity_type_delete_wallet_accounts;
    case 'ACTIVITY_TYPE_DELETE_POLICIES': return v1ActivityType.activity_type_delete_policies;
    case 'ACTIVITY_TYPE_ETH_SEND_RAW_TRANSACTION': return v1ActivityType.activity_type_eth_send_raw_transaction;
    case 'ACTIVITY_TYPE_ETH_SEND_TRANSACTION': return v1ActivityType.activity_type_eth_send_transaction;
    case 'ACTIVITY_TYPE_CREATE_FIAT_ON_RAMP_CREDENTIAL': return v1ActivityType.activity_type_create_fiat_on_ramp_credential;
    case 'ACTIVITY_TYPE_UPDATE_FIAT_ON_RAMP_CREDENTIAL': return v1ActivityType.activity_type_update_fiat_on_ramp_credential;
    case 'ACTIVITY_TYPE_DELETE_FIAT_ON_RAMP_CREDENTIAL': return v1ActivityType.activity_type_delete_fiat_on_ramp_credential;
    case 'ACTIVITY_TYPE_EMAIL_AUTH_V3': return v1ActivityType.activity_type_email_auth_v3;
    case 'ACTIVITY_TYPE_INIT_USER_EMAIL_RECOVERY_V2': return v1ActivityType.activity_type_init_user_email_recovery_v2;
    case 'ACTIVITY_TYPE_INIT_OTP_AUTH_V3': return v1ActivityType.activity_type_init_otp_auth_v3;
    case 'ACTIVITY_TYPE_INIT_OTP_V2': return v1ActivityType.activity_type_init_otp_v2;
    case 'ACTIVITY_TYPE_UPSERT_GAS_USAGE_CONFIG': return v1ActivityType.activity_type_upsert_gas_usage_config;
    case 'ACTIVITY_TYPE_CREATE_TVC_APP': return v1ActivityType.activity_type_create_tvc_app;
    case 'ACTIVITY_TYPE_CREATE_TVC_DEPLOYMENT': return v1ActivityType.activity_type_create_tvc_deployment;
    case 'ACTIVITY_TYPE_CREATE_TVC_MANIFEST_APPROVALS': return v1ActivityType.activity_type_create_tvc_manifest_approvals;
    case 'ACTIVITY_TYPE_SOL_SEND_TRANSACTION': return v1ActivityType.activity_type_sol_send_transaction;
    default: throw ArgumentError('Unknown v1ActivityType: $value');
  }
}

dynamic v1ActivityTypeToJson(v1ActivityType value) {
  switch (value) {
    case v1ActivityType.activity_type_create_api_keys: return "ACTIVITY_TYPE_CREATE_API_KEYS";
    case v1ActivityType.activity_type_create_users: return "ACTIVITY_TYPE_CREATE_USERS";
    case v1ActivityType.activity_type_create_private_keys: return "ACTIVITY_TYPE_CREATE_PRIVATE_KEYS";
    case v1ActivityType.activity_type_sign_raw_payload: return "ACTIVITY_TYPE_SIGN_RAW_PAYLOAD";
    case v1ActivityType.activity_type_create_invitations: return "ACTIVITY_TYPE_CREATE_INVITATIONS";
    case v1ActivityType.activity_type_accept_invitation: return "ACTIVITY_TYPE_ACCEPT_INVITATION";
    case v1ActivityType.activity_type_create_policy: return "ACTIVITY_TYPE_CREATE_POLICY";
    case v1ActivityType.activity_type_disable_private_key: return "ACTIVITY_TYPE_DISABLE_PRIVATE_KEY";
    case v1ActivityType.activity_type_delete_users: return "ACTIVITY_TYPE_DELETE_USERS";
    case v1ActivityType.activity_type_delete_api_keys: return "ACTIVITY_TYPE_DELETE_API_KEYS";
    case v1ActivityType.activity_type_delete_invitation: return "ACTIVITY_TYPE_DELETE_INVITATION";
    case v1ActivityType.activity_type_delete_organization: return "ACTIVITY_TYPE_DELETE_ORGANIZATION";
    case v1ActivityType.activity_type_delete_policy: return "ACTIVITY_TYPE_DELETE_POLICY";
    case v1ActivityType.activity_type_create_user_tag: return "ACTIVITY_TYPE_CREATE_USER_TAG";
    case v1ActivityType.activity_type_delete_user_tags: return "ACTIVITY_TYPE_DELETE_USER_TAGS";
    case v1ActivityType.activity_type_create_organization: return "ACTIVITY_TYPE_CREATE_ORGANIZATION";
    case v1ActivityType.activity_type_sign_transaction: return "ACTIVITY_TYPE_SIGN_TRANSACTION";
    case v1ActivityType.activity_type_approve_activity: return "ACTIVITY_TYPE_APPROVE_ACTIVITY";
    case v1ActivityType.activity_type_reject_activity: return "ACTIVITY_TYPE_REJECT_ACTIVITY";
    case v1ActivityType.activity_type_delete_authenticators: return "ACTIVITY_TYPE_DELETE_AUTHENTICATORS";
    case v1ActivityType.activity_type_create_authenticators: return "ACTIVITY_TYPE_CREATE_AUTHENTICATORS";
    case v1ActivityType.activity_type_create_private_key_tag: return "ACTIVITY_TYPE_CREATE_PRIVATE_KEY_TAG";
    case v1ActivityType.activity_type_delete_private_key_tags: return "ACTIVITY_TYPE_DELETE_PRIVATE_KEY_TAGS";
    case v1ActivityType.activity_type_set_payment_method: return "ACTIVITY_TYPE_SET_PAYMENT_METHOD";
    case v1ActivityType.activity_type_activate_billing_tier: return "ACTIVITY_TYPE_ACTIVATE_BILLING_TIER";
    case v1ActivityType.activity_type_delete_payment_method: return "ACTIVITY_TYPE_DELETE_PAYMENT_METHOD";
    case v1ActivityType.activity_type_create_policy_v2: return "ACTIVITY_TYPE_CREATE_POLICY_V2";
    case v1ActivityType.activity_type_create_policy_v3: return "ACTIVITY_TYPE_CREATE_POLICY_V3";
    case v1ActivityType.activity_type_create_api_only_users: return "ACTIVITY_TYPE_CREATE_API_ONLY_USERS";
    case v1ActivityType.activity_type_update_root_quorum: return "ACTIVITY_TYPE_UPDATE_ROOT_QUORUM";
    case v1ActivityType.activity_type_update_user_tag: return "ACTIVITY_TYPE_UPDATE_USER_TAG";
    case v1ActivityType.activity_type_update_private_key_tag: return "ACTIVITY_TYPE_UPDATE_PRIVATE_KEY_TAG";
    case v1ActivityType.activity_type_create_authenticators_v2: return "ACTIVITY_TYPE_CREATE_AUTHENTICATORS_V2";
    case v1ActivityType.activity_type_create_organization_v2: return "ACTIVITY_TYPE_CREATE_ORGANIZATION_V2";
    case v1ActivityType.activity_type_create_users_v2: return "ACTIVITY_TYPE_CREATE_USERS_V2";
    case v1ActivityType.activity_type_accept_invitation_v2: return "ACTIVITY_TYPE_ACCEPT_INVITATION_V2";
    case v1ActivityType.activity_type_create_sub_organization: return "ACTIVITY_TYPE_CREATE_SUB_ORGANIZATION";
    case v1ActivityType.activity_type_create_sub_organization_v2: return "ACTIVITY_TYPE_CREATE_SUB_ORGANIZATION_V2";
    case v1ActivityType.activity_type_update_allowed_origins: return "ACTIVITY_TYPE_UPDATE_ALLOWED_ORIGINS";
    case v1ActivityType.activity_type_create_private_keys_v2: return "ACTIVITY_TYPE_CREATE_PRIVATE_KEYS_V2";
    case v1ActivityType.activity_type_update_user: return "ACTIVITY_TYPE_UPDATE_USER";
    case v1ActivityType.activity_type_update_policy: return "ACTIVITY_TYPE_UPDATE_POLICY";
    case v1ActivityType.activity_type_set_payment_method_v2: return "ACTIVITY_TYPE_SET_PAYMENT_METHOD_V2";
    case v1ActivityType.activity_type_create_sub_organization_v3: return "ACTIVITY_TYPE_CREATE_SUB_ORGANIZATION_V3";
    case v1ActivityType.activity_type_create_wallet: return "ACTIVITY_TYPE_CREATE_WALLET";
    case v1ActivityType.activity_type_create_wallet_accounts: return "ACTIVITY_TYPE_CREATE_WALLET_ACCOUNTS";
    case v1ActivityType.activity_type_init_user_email_recovery: return "ACTIVITY_TYPE_INIT_USER_EMAIL_RECOVERY";
    case v1ActivityType.activity_type_recover_user: return "ACTIVITY_TYPE_RECOVER_USER";
    case v1ActivityType.activity_type_set_organization_feature: return "ACTIVITY_TYPE_SET_ORGANIZATION_FEATURE";
    case v1ActivityType.activity_type_remove_organization_feature: return "ACTIVITY_TYPE_REMOVE_ORGANIZATION_FEATURE";
    case v1ActivityType.activity_type_sign_raw_payload_v2: return "ACTIVITY_TYPE_SIGN_RAW_PAYLOAD_V2";
    case v1ActivityType.activity_type_sign_transaction_v2: return "ACTIVITY_TYPE_SIGN_TRANSACTION_V2";
    case v1ActivityType.activity_type_export_private_key: return "ACTIVITY_TYPE_EXPORT_PRIVATE_KEY";
    case v1ActivityType.activity_type_export_wallet: return "ACTIVITY_TYPE_EXPORT_WALLET";
    case v1ActivityType.activity_type_create_sub_organization_v4: return "ACTIVITY_TYPE_CREATE_SUB_ORGANIZATION_V4";
    case v1ActivityType.activity_type_email_auth: return "ACTIVITY_TYPE_EMAIL_AUTH";
    case v1ActivityType.activity_type_export_wallet_account: return "ACTIVITY_TYPE_EXPORT_WALLET_ACCOUNT";
    case v1ActivityType.activity_type_init_import_wallet: return "ACTIVITY_TYPE_INIT_IMPORT_WALLET";
    case v1ActivityType.activity_type_import_wallet: return "ACTIVITY_TYPE_IMPORT_WALLET";
    case v1ActivityType.activity_type_init_import_private_key: return "ACTIVITY_TYPE_INIT_IMPORT_PRIVATE_KEY";
    case v1ActivityType.activity_type_import_private_key: return "ACTIVITY_TYPE_IMPORT_PRIVATE_KEY";
    case v1ActivityType.activity_type_create_policies: return "ACTIVITY_TYPE_CREATE_POLICIES";
    case v1ActivityType.activity_type_sign_raw_payloads: return "ACTIVITY_TYPE_SIGN_RAW_PAYLOADS";
    case v1ActivityType.activity_type_create_read_only_session: return "ACTIVITY_TYPE_CREATE_READ_ONLY_SESSION";
    case v1ActivityType.activity_type_create_oauth_providers: return "ACTIVITY_TYPE_CREATE_OAUTH_PROVIDERS";
    case v1ActivityType.activity_type_delete_oauth_providers: return "ACTIVITY_TYPE_DELETE_OAUTH_PROVIDERS";
    case v1ActivityType.activity_type_create_sub_organization_v5: return "ACTIVITY_TYPE_CREATE_SUB_ORGANIZATION_V5";
    case v1ActivityType.activity_type_oauth: return "ACTIVITY_TYPE_OAUTH";
    case v1ActivityType.activity_type_create_api_keys_v2: return "ACTIVITY_TYPE_CREATE_API_KEYS_V2";
    case v1ActivityType.activity_type_create_read_write_session: return "ACTIVITY_TYPE_CREATE_READ_WRITE_SESSION";
    case v1ActivityType.activity_type_email_auth_v2: return "ACTIVITY_TYPE_EMAIL_AUTH_V2";
    case v1ActivityType.activity_type_create_sub_organization_v6: return "ACTIVITY_TYPE_CREATE_SUB_ORGANIZATION_V6";
    case v1ActivityType.activity_type_delete_private_keys: return "ACTIVITY_TYPE_DELETE_PRIVATE_KEYS";
    case v1ActivityType.activity_type_delete_wallets: return "ACTIVITY_TYPE_DELETE_WALLETS";
    case v1ActivityType.activity_type_create_read_write_session_v2: return "ACTIVITY_TYPE_CREATE_READ_WRITE_SESSION_V2";
    case v1ActivityType.activity_type_delete_sub_organization: return "ACTIVITY_TYPE_DELETE_SUB_ORGANIZATION";
    case v1ActivityType.activity_type_init_otp_auth: return "ACTIVITY_TYPE_INIT_OTP_AUTH";
    case v1ActivityType.activity_type_otp_auth: return "ACTIVITY_TYPE_OTP_AUTH";
    case v1ActivityType.activity_type_create_sub_organization_v7: return "ACTIVITY_TYPE_CREATE_SUB_ORGANIZATION_V7";
    case v1ActivityType.activity_type_update_wallet: return "ACTIVITY_TYPE_UPDATE_WALLET";
    case v1ActivityType.activity_type_update_policy_v2: return "ACTIVITY_TYPE_UPDATE_POLICY_V2";
    case v1ActivityType.activity_type_create_users_v3: return "ACTIVITY_TYPE_CREATE_USERS_V3";
    case v1ActivityType.activity_type_init_otp_auth_v2: return "ACTIVITY_TYPE_INIT_OTP_AUTH_V2";
    case v1ActivityType.activity_type_init_otp: return "ACTIVITY_TYPE_INIT_OTP";
    case v1ActivityType.activity_type_verify_otp: return "ACTIVITY_TYPE_VERIFY_OTP";
    case v1ActivityType.activity_type_otp_login: return "ACTIVITY_TYPE_OTP_LOGIN";
    case v1ActivityType.activity_type_stamp_login: return "ACTIVITY_TYPE_STAMP_LOGIN";
    case v1ActivityType.activity_type_oauth_login: return "ACTIVITY_TYPE_OAUTH_LOGIN";
    case v1ActivityType.activity_type_update_user_name: return "ACTIVITY_TYPE_UPDATE_USER_NAME";
    case v1ActivityType.activity_type_update_user_email: return "ACTIVITY_TYPE_UPDATE_USER_EMAIL";
    case v1ActivityType.activity_type_update_user_phone_number: return "ACTIVITY_TYPE_UPDATE_USER_PHONE_NUMBER";
    case v1ActivityType.activity_type_init_fiat_on_ramp: return "ACTIVITY_TYPE_INIT_FIAT_ON_RAMP";
    case v1ActivityType.activity_type_create_smart_contract_interface: return "ACTIVITY_TYPE_CREATE_SMART_CONTRACT_INTERFACE";
    case v1ActivityType.activity_type_delete_smart_contract_interface: return "ACTIVITY_TYPE_DELETE_SMART_CONTRACT_INTERFACE";
    case v1ActivityType.activity_type_enable_auth_proxy: return "ACTIVITY_TYPE_ENABLE_AUTH_PROXY";
    case v1ActivityType.activity_type_disable_auth_proxy: return "ACTIVITY_TYPE_DISABLE_AUTH_PROXY";
    case v1ActivityType.activity_type_update_auth_proxy_config: return "ACTIVITY_TYPE_UPDATE_AUTH_PROXY_CONFIG";
    case v1ActivityType.activity_type_create_oauth2_credential: return "ACTIVITY_TYPE_CREATE_OAUTH2_CREDENTIAL";
    case v1ActivityType.activity_type_update_oauth2_credential: return "ACTIVITY_TYPE_UPDATE_OAUTH2_CREDENTIAL";
    case v1ActivityType.activity_type_delete_oauth2_credential: return "ACTIVITY_TYPE_DELETE_OAUTH2_CREDENTIAL";
    case v1ActivityType.activity_type_oauth2_authenticate: return "ACTIVITY_TYPE_OAUTH2_AUTHENTICATE";
    case v1ActivityType.activity_type_delete_wallet_accounts: return "ACTIVITY_TYPE_DELETE_WALLET_ACCOUNTS";
    case v1ActivityType.activity_type_delete_policies: return "ACTIVITY_TYPE_DELETE_POLICIES";
    case v1ActivityType.activity_type_eth_send_raw_transaction: return "ACTIVITY_TYPE_ETH_SEND_RAW_TRANSACTION";
    case v1ActivityType.activity_type_eth_send_transaction: return "ACTIVITY_TYPE_ETH_SEND_TRANSACTION";
    case v1ActivityType.activity_type_create_fiat_on_ramp_credential: return "ACTIVITY_TYPE_CREATE_FIAT_ON_RAMP_CREDENTIAL";
    case v1ActivityType.activity_type_update_fiat_on_ramp_credential: return "ACTIVITY_TYPE_UPDATE_FIAT_ON_RAMP_CREDENTIAL";
    case v1ActivityType.activity_type_delete_fiat_on_ramp_credential: return "ACTIVITY_TYPE_DELETE_FIAT_ON_RAMP_CREDENTIAL";
    case v1ActivityType.activity_type_email_auth_v3: return "ACTIVITY_TYPE_EMAIL_AUTH_V3";
    case v1ActivityType.activity_type_init_user_email_recovery_v2: return "ACTIVITY_TYPE_INIT_USER_EMAIL_RECOVERY_V2";
    case v1ActivityType.activity_type_init_otp_auth_v3: return "ACTIVITY_TYPE_INIT_OTP_AUTH_V3";
    case v1ActivityType.activity_type_init_otp_v2: return "ACTIVITY_TYPE_INIT_OTP_V2";
    case v1ActivityType.activity_type_upsert_gas_usage_config: return "ACTIVITY_TYPE_UPSERT_GAS_USAGE_CONFIG";
    case v1ActivityType.activity_type_create_tvc_app: return "ACTIVITY_TYPE_CREATE_TVC_APP";
    case v1ActivityType.activity_type_create_tvc_deployment: return "ACTIVITY_TYPE_CREATE_TVC_DEPLOYMENT";
    case v1ActivityType.activity_type_create_tvc_manifest_approvals: return "ACTIVITY_TYPE_CREATE_TVC_MANIFEST_APPROVALS";
    case v1ActivityType.activity_type_sol_send_transaction: return "ACTIVITY_TYPE_SOL_SEND_TRANSACTION";
  }
}

enum v1AddressFormat {
  address_format_uncompressed,
  address_format_compressed,
  address_format_ethereum,
  address_format_solana,
  address_format_cosmos,
  address_format_tron,
  address_format_sui,
  address_format_aptos,
  address_format_bitcoin_mainnet_p2pkh,
  address_format_bitcoin_mainnet_p2sh,
  address_format_bitcoin_mainnet_p2wpkh,
  address_format_bitcoin_mainnet_p2wsh,
  address_format_bitcoin_mainnet_p2tr,
  address_format_bitcoin_testnet_p2pkh,
  address_format_bitcoin_testnet_p2sh,
  address_format_bitcoin_testnet_p2wpkh,
  address_format_bitcoin_testnet_p2wsh,
  address_format_bitcoin_testnet_p2tr,
  address_format_bitcoin_signet_p2pkh,
  address_format_bitcoin_signet_p2sh,
  address_format_bitcoin_signet_p2wpkh,
  address_format_bitcoin_signet_p2wsh,
  address_format_bitcoin_signet_p2tr,
  address_format_bitcoin_regtest_p2pkh,
  address_format_bitcoin_regtest_p2sh,
  address_format_bitcoin_regtest_p2wpkh,
  address_format_bitcoin_regtest_p2wsh,
  address_format_bitcoin_regtest_p2tr,
  address_format_sei,
  address_format_xlm,
  address_format_doge_mainnet,
  address_format_doge_testnet,
  address_format_ton_v3r2,
  address_format_ton_v4r2,
  address_format_ton_v5r1,
  address_format_xrp,
}

v1AddressFormat v1AddressFormatFromJson(dynamic value) {
  switch (value) {
    case 'ADDRESS_FORMAT_UNCOMPRESSED': return v1AddressFormat.address_format_uncompressed;
    case 'ADDRESS_FORMAT_COMPRESSED': return v1AddressFormat.address_format_compressed;
    case 'ADDRESS_FORMAT_ETHEREUM': return v1AddressFormat.address_format_ethereum;
    case 'ADDRESS_FORMAT_SOLANA': return v1AddressFormat.address_format_solana;
    case 'ADDRESS_FORMAT_COSMOS': return v1AddressFormat.address_format_cosmos;
    case 'ADDRESS_FORMAT_TRON': return v1AddressFormat.address_format_tron;
    case 'ADDRESS_FORMAT_SUI': return v1AddressFormat.address_format_sui;
    case 'ADDRESS_FORMAT_APTOS': return v1AddressFormat.address_format_aptos;
    case 'ADDRESS_FORMAT_BITCOIN_MAINNET_P2PKH': return v1AddressFormat.address_format_bitcoin_mainnet_p2pkh;
    case 'ADDRESS_FORMAT_BITCOIN_MAINNET_P2SH': return v1AddressFormat.address_format_bitcoin_mainnet_p2sh;
    case 'ADDRESS_FORMAT_BITCOIN_MAINNET_P2WPKH': return v1AddressFormat.address_format_bitcoin_mainnet_p2wpkh;
    case 'ADDRESS_FORMAT_BITCOIN_MAINNET_P2WSH': return v1AddressFormat.address_format_bitcoin_mainnet_p2wsh;
    case 'ADDRESS_FORMAT_BITCOIN_MAINNET_P2TR': return v1AddressFormat.address_format_bitcoin_mainnet_p2tr;
    case 'ADDRESS_FORMAT_BITCOIN_TESTNET_P2PKH': return v1AddressFormat.address_format_bitcoin_testnet_p2pkh;
    case 'ADDRESS_FORMAT_BITCOIN_TESTNET_P2SH': return v1AddressFormat.address_format_bitcoin_testnet_p2sh;
    case 'ADDRESS_FORMAT_BITCOIN_TESTNET_P2WPKH': return v1AddressFormat.address_format_bitcoin_testnet_p2wpkh;
    case 'ADDRESS_FORMAT_BITCOIN_TESTNET_P2WSH': return v1AddressFormat.address_format_bitcoin_testnet_p2wsh;
    case 'ADDRESS_FORMAT_BITCOIN_TESTNET_P2TR': return v1AddressFormat.address_format_bitcoin_testnet_p2tr;
    case 'ADDRESS_FORMAT_BITCOIN_SIGNET_P2PKH': return v1AddressFormat.address_format_bitcoin_signet_p2pkh;
    case 'ADDRESS_FORMAT_BITCOIN_SIGNET_P2SH': return v1AddressFormat.address_format_bitcoin_signet_p2sh;
    case 'ADDRESS_FORMAT_BITCOIN_SIGNET_P2WPKH': return v1AddressFormat.address_format_bitcoin_signet_p2wpkh;
    case 'ADDRESS_FORMAT_BITCOIN_SIGNET_P2WSH': return v1AddressFormat.address_format_bitcoin_signet_p2wsh;
    case 'ADDRESS_FORMAT_BITCOIN_SIGNET_P2TR': return v1AddressFormat.address_format_bitcoin_signet_p2tr;
    case 'ADDRESS_FORMAT_BITCOIN_REGTEST_P2PKH': return v1AddressFormat.address_format_bitcoin_regtest_p2pkh;
    case 'ADDRESS_FORMAT_BITCOIN_REGTEST_P2SH': return v1AddressFormat.address_format_bitcoin_regtest_p2sh;
    case 'ADDRESS_FORMAT_BITCOIN_REGTEST_P2WPKH': return v1AddressFormat.address_format_bitcoin_regtest_p2wpkh;
    case 'ADDRESS_FORMAT_BITCOIN_REGTEST_P2WSH': return v1AddressFormat.address_format_bitcoin_regtest_p2wsh;
    case 'ADDRESS_FORMAT_BITCOIN_REGTEST_P2TR': return v1AddressFormat.address_format_bitcoin_regtest_p2tr;
    case 'ADDRESS_FORMAT_SEI': return v1AddressFormat.address_format_sei;
    case 'ADDRESS_FORMAT_XLM': return v1AddressFormat.address_format_xlm;
    case 'ADDRESS_FORMAT_DOGE_MAINNET': return v1AddressFormat.address_format_doge_mainnet;
    case 'ADDRESS_FORMAT_DOGE_TESTNET': return v1AddressFormat.address_format_doge_testnet;
    case 'ADDRESS_FORMAT_TON_V3R2': return v1AddressFormat.address_format_ton_v3r2;
    case 'ADDRESS_FORMAT_TON_V4R2': return v1AddressFormat.address_format_ton_v4r2;
    case 'ADDRESS_FORMAT_TON_V5R1': return v1AddressFormat.address_format_ton_v5r1;
    case 'ADDRESS_FORMAT_XRP': return v1AddressFormat.address_format_xrp;
    default: throw ArgumentError('Unknown v1AddressFormat: $value');
  }
}

dynamic v1AddressFormatToJson(v1AddressFormat value) {
  switch (value) {
    case v1AddressFormat.address_format_uncompressed: return "ADDRESS_FORMAT_UNCOMPRESSED";
    case v1AddressFormat.address_format_compressed: return "ADDRESS_FORMAT_COMPRESSED";
    case v1AddressFormat.address_format_ethereum: return "ADDRESS_FORMAT_ETHEREUM";
    case v1AddressFormat.address_format_solana: return "ADDRESS_FORMAT_SOLANA";
    case v1AddressFormat.address_format_cosmos: return "ADDRESS_FORMAT_COSMOS";
    case v1AddressFormat.address_format_tron: return "ADDRESS_FORMAT_TRON";
    case v1AddressFormat.address_format_sui: return "ADDRESS_FORMAT_SUI";
    case v1AddressFormat.address_format_aptos: return "ADDRESS_FORMAT_APTOS";
    case v1AddressFormat.address_format_bitcoin_mainnet_p2pkh: return "ADDRESS_FORMAT_BITCOIN_MAINNET_P2PKH";
    case v1AddressFormat.address_format_bitcoin_mainnet_p2sh: return "ADDRESS_FORMAT_BITCOIN_MAINNET_P2SH";
    case v1AddressFormat.address_format_bitcoin_mainnet_p2wpkh: return "ADDRESS_FORMAT_BITCOIN_MAINNET_P2WPKH";
    case v1AddressFormat.address_format_bitcoin_mainnet_p2wsh: return "ADDRESS_FORMAT_BITCOIN_MAINNET_P2WSH";
    case v1AddressFormat.address_format_bitcoin_mainnet_p2tr: return "ADDRESS_FORMAT_BITCOIN_MAINNET_P2TR";
    case v1AddressFormat.address_format_bitcoin_testnet_p2pkh: return "ADDRESS_FORMAT_BITCOIN_TESTNET_P2PKH";
    case v1AddressFormat.address_format_bitcoin_testnet_p2sh: return "ADDRESS_FORMAT_BITCOIN_TESTNET_P2SH";
    case v1AddressFormat.address_format_bitcoin_testnet_p2wpkh: return "ADDRESS_FORMAT_BITCOIN_TESTNET_P2WPKH";
    case v1AddressFormat.address_format_bitcoin_testnet_p2wsh: return "ADDRESS_FORMAT_BITCOIN_TESTNET_P2WSH";
    case v1AddressFormat.address_format_bitcoin_testnet_p2tr: return "ADDRESS_FORMAT_BITCOIN_TESTNET_P2TR";
    case v1AddressFormat.address_format_bitcoin_signet_p2pkh: return "ADDRESS_FORMAT_BITCOIN_SIGNET_P2PKH";
    case v1AddressFormat.address_format_bitcoin_signet_p2sh: return "ADDRESS_FORMAT_BITCOIN_SIGNET_P2SH";
    case v1AddressFormat.address_format_bitcoin_signet_p2wpkh: return "ADDRESS_FORMAT_BITCOIN_SIGNET_P2WPKH";
    case v1AddressFormat.address_format_bitcoin_signet_p2wsh: return "ADDRESS_FORMAT_BITCOIN_SIGNET_P2WSH";
    case v1AddressFormat.address_format_bitcoin_signet_p2tr: return "ADDRESS_FORMAT_BITCOIN_SIGNET_P2TR";
    case v1AddressFormat.address_format_bitcoin_regtest_p2pkh: return "ADDRESS_FORMAT_BITCOIN_REGTEST_P2PKH";
    case v1AddressFormat.address_format_bitcoin_regtest_p2sh: return "ADDRESS_FORMAT_BITCOIN_REGTEST_P2SH";
    case v1AddressFormat.address_format_bitcoin_regtest_p2wpkh: return "ADDRESS_FORMAT_BITCOIN_REGTEST_P2WPKH";
    case v1AddressFormat.address_format_bitcoin_regtest_p2wsh: return "ADDRESS_FORMAT_BITCOIN_REGTEST_P2WSH";
    case v1AddressFormat.address_format_bitcoin_regtest_p2tr: return "ADDRESS_FORMAT_BITCOIN_REGTEST_P2TR";
    case v1AddressFormat.address_format_sei: return "ADDRESS_FORMAT_SEI";
    case v1AddressFormat.address_format_xlm: return "ADDRESS_FORMAT_XLM";
    case v1AddressFormat.address_format_doge_mainnet: return "ADDRESS_FORMAT_DOGE_MAINNET";
    case v1AddressFormat.address_format_doge_testnet: return "ADDRESS_FORMAT_DOGE_TESTNET";
    case v1AddressFormat.address_format_ton_v3r2: return "ADDRESS_FORMAT_TON_V3R2";
    case v1AddressFormat.address_format_ton_v4r2: return "ADDRESS_FORMAT_TON_V4R2";
    case v1AddressFormat.address_format_ton_v5r1: return "ADDRESS_FORMAT_TON_V5R1";
    case v1AddressFormat.address_format_xrp: return "ADDRESS_FORMAT_XRP";
  }
}

enum v1ApiKeyCurve {
  api_key_curve_p256,
  api_key_curve_secp256k1,
  api_key_curve_ed25519,
}

v1ApiKeyCurve v1ApiKeyCurveFromJson(dynamic value) {
  switch (value) {
    case 'API_KEY_CURVE_P256': return v1ApiKeyCurve.api_key_curve_p256;
    case 'API_KEY_CURVE_SECP256K1': return v1ApiKeyCurve.api_key_curve_secp256k1;
    case 'API_KEY_CURVE_ED25519': return v1ApiKeyCurve.api_key_curve_ed25519;
    default: throw ArgumentError('Unknown v1ApiKeyCurve: $value');
  }
}

dynamic v1ApiKeyCurveToJson(v1ApiKeyCurve value) {
  switch (value) {
    case v1ApiKeyCurve.api_key_curve_p256: return "API_KEY_CURVE_P256";
    case v1ApiKeyCurve.api_key_curve_secp256k1: return "API_KEY_CURVE_SECP256K1";
    case v1ApiKeyCurve.api_key_curve_ed25519: return "API_KEY_CURVE_ED25519";
  }
}

enum v1AuthenticatorTransport {
  authenticator_transport_ble,
  authenticator_transport_internal,
  authenticator_transport_nfc,
  authenticator_transport_usb,
  authenticator_transport_hybrid,
}

v1AuthenticatorTransport v1AuthenticatorTransportFromJson(dynamic value) {
  switch (value) {
    case 'AUTHENTICATOR_TRANSPORT_BLE': return v1AuthenticatorTransport.authenticator_transport_ble;
    case 'AUTHENTICATOR_TRANSPORT_INTERNAL': return v1AuthenticatorTransport.authenticator_transport_internal;
    case 'AUTHENTICATOR_TRANSPORT_NFC': return v1AuthenticatorTransport.authenticator_transport_nfc;
    case 'AUTHENTICATOR_TRANSPORT_USB': return v1AuthenticatorTransport.authenticator_transport_usb;
    case 'AUTHENTICATOR_TRANSPORT_HYBRID': return v1AuthenticatorTransport.authenticator_transport_hybrid;
    default: throw ArgumentError('Unknown v1AuthenticatorTransport: $value');
  }
}

dynamic v1AuthenticatorTransportToJson(v1AuthenticatorTransport value) {
  switch (value) {
    case v1AuthenticatorTransport.authenticator_transport_ble: return "AUTHENTICATOR_TRANSPORT_BLE";
    case v1AuthenticatorTransport.authenticator_transport_internal: return "AUTHENTICATOR_TRANSPORT_INTERNAL";
    case v1AuthenticatorTransport.authenticator_transport_nfc: return "AUTHENTICATOR_TRANSPORT_NFC";
    case v1AuthenticatorTransport.authenticator_transport_usb: return "AUTHENTICATOR_TRANSPORT_USB";
    case v1AuthenticatorTransport.authenticator_transport_hybrid: return "AUTHENTICATOR_TRANSPORT_HYBRID";
  }
}

enum v1ClientSignatureScheme {
  client_signature_scheme_api_p256,
}

v1ClientSignatureScheme v1ClientSignatureSchemeFromJson(dynamic value) {
  switch (value) {
    case 'CLIENT_SIGNATURE_SCHEME_API_P256': return v1ClientSignatureScheme.client_signature_scheme_api_p256;
    default: throw ArgumentError('Unknown v1ClientSignatureScheme: $value');
  }
}

dynamic v1ClientSignatureSchemeToJson(v1ClientSignatureScheme value) {
  switch (value) {
    case v1ClientSignatureScheme.client_signature_scheme_api_p256: return "CLIENT_SIGNATURE_SCHEME_API_P256";
  }
}

enum v1CredentialType {
  credential_type_webauthn_authenticator,
  credential_type_api_key_p256,
  credential_type_recover_user_key_p256,
  credential_type_api_key_secp256k1,
  credential_type_email_auth_key_p256,
  credential_type_api_key_ed25519,
  credential_type_otp_auth_key_p256,
  credential_type_read_write_session_key_p256,
  credential_type_oauth_key_p256,
  credential_type_login,
}

v1CredentialType v1CredentialTypeFromJson(dynamic value) {
  switch (value) {
    case 'CREDENTIAL_TYPE_WEBAUTHN_AUTHENTICATOR': return v1CredentialType.credential_type_webauthn_authenticator;
    case 'CREDENTIAL_TYPE_API_KEY_P256': return v1CredentialType.credential_type_api_key_p256;
    case 'CREDENTIAL_TYPE_RECOVER_USER_KEY_P256': return v1CredentialType.credential_type_recover_user_key_p256;
    case 'CREDENTIAL_TYPE_API_KEY_SECP256K1': return v1CredentialType.credential_type_api_key_secp256k1;
    case 'CREDENTIAL_TYPE_EMAIL_AUTH_KEY_P256': return v1CredentialType.credential_type_email_auth_key_p256;
    case 'CREDENTIAL_TYPE_API_KEY_ED25519': return v1CredentialType.credential_type_api_key_ed25519;
    case 'CREDENTIAL_TYPE_OTP_AUTH_KEY_P256': return v1CredentialType.credential_type_otp_auth_key_p256;
    case 'CREDENTIAL_TYPE_READ_WRITE_SESSION_KEY_P256': return v1CredentialType.credential_type_read_write_session_key_p256;
    case 'CREDENTIAL_TYPE_OAUTH_KEY_P256': return v1CredentialType.credential_type_oauth_key_p256;
    case 'CREDENTIAL_TYPE_LOGIN': return v1CredentialType.credential_type_login;
    default: throw ArgumentError('Unknown v1CredentialType: $value');
  }
}

dynamic v1CredentialTypeToJson(v1CredentialType value) {
  switch (value) {
    case v1CredentialType.credential_type_webauthn_authenticator: return "CREDENTIAL_TYPE_WEBAUTHN_AUTHENTICATOR";
    case v1CredentialType.credential_type_api_key_p256: return "CREDENTIAL_TYPE_API_KEY_P256";
    case v1CredentialType.credential_type_recover_user_key_p256: return "CREDENTIAL_TYPE_RECOVER_USER_KEY_P256";
    case v1CredentialType.credential_type_api_key_secp256k1: return "CREDENTIAL_TYPE_API_KEY_SECP256K1";
    case v1CredentialType.credential_type_email_auth_key_p256: return "CREDENTIAL_TYPE_EMAIL_AUTH_KEY_P256";
    case v1CredentialType.credential_type_api_key_ed25519: return "CREDENTIAL_TYPE_API_KEY_ED25519";
    case v1CredentialType.credential_type_otp_auth_key_p256: return "CREDENTIAL_TYPE_OTP_AUTH_KEY_P256";
    case v1CredentialType.credential_type_read_write_session_key_p256: return "CREDENTIAL_TYPE_READ_WRITE_SESSION_KEY_P256";
    case v1CredentialType.credential_type_oauth_key_p256: return "CREDENTIAL_TYPE_OAUTH_KEY_P256";
    case v1CredentialType.credential_type_login: return "CREDENTIAL_TYPE_LOGIN";
  }
}

enum v1Curve {
  curve_secp256k1,
  curve_ed25519,
  curve_p256,
}

v1Curve v1CurveFromJson(dynamic value) {
  switch (value) {
    case 'CURVE_SECP256K1': return v1Curve.curve_secp256k1;
    case 'CURVE_ED25519': return v1Curve.curve_ed25519;
    case 'CURVE_P256': return v1Curve.curve_p256;
    default: throw ArgumentError('Unknown v1Curve: $value');
  }
}

dynamic v1CurveToJson(v1Curve value) {
  switch (value) {
    case v1Curve.curve_secp256k1: return "CURVE_SECP256K1";
    case v1Curve.curve_ed25519: return "CURVE_ED25519";
    case v1Curve.curve_p256: return "CURVE_P256";
  }
}

enum v1Effect {
  effect_allow,
  effect_deny,
}

v1Effect v1EffectFromJson(dynamic value) {
  switch (value) {
    case 'EFFECT_ALLOW': return v1Effect.effect_allow;
    case 'EFFECT_DENY': return v1Effect.effect_deny;
    default: throw ArgumentError('Unknown v1Effect: $value');
  }
}

dynamic v1EffectToJson(v1Effect value) {
  switch (value) {
    case v1Effect.effect_allow: return "EFFECT_ALLOW";
    case v1Effect.effect_deny: return "EFFECT_DENY";
  }
}

enum v1FeatureName {
  feature_name_root_user_email_recovery,
  feature_name_webauthn_origins,
  feature_name_email_auth,
  feature_name_email_recovery,
  feature_name_webhook,
  feature_name_sms_auth,
  feature_name_otp_email_auth,
  feature_name_auth_proxy,
}

v1FeatureName v1FeatureNameFromJson(dynamic value) {
  switch (value) {
    case 'FEATURE_NAME_ROOT_USER_EMAIL_RECOVERY': return v1FeatureName.feature_name_root_user_email_recovery;
    case 'FEATURE_NAME_WEBAUTHN_ORIGINS': return v1FeatureName.feature_name_webauthn_origins;
    case 'FEATURE_NAME_EMAIL_AUTH': return v1FeatureName.feature_name_email_auth;
    case 'FEATURE_NAME_EMAIL_RECOVERY': return v1FeatureName.feature_name_email_recovery;
    case 'FEATURE_NAME_WEBHOOK': return v1FeatureName.feature_name_webhook;
    case 'FEATURE_NAME_SMS_AUTH': return v1FeatureName.feature_name_sms_auth;
    case 'FEATURE_NAME_OTP_EMAIL_AUTH': return v1FeatureName.feature_name_otp_email_auth;
    case 'FEATURE_NAME_AUTH_PROXY': return v1FeatureName.feature_name_auth_proxy;
    default: throw ArgumentError('Unknown v1FeatureName: $value');
  }
}

dynamic v1FeatureNameToJson(v1FeatureName value) {
  switch (value) {
    case v1FeatureName.feature_name_root_user_email_recovery: return "FEATURE_NAME_ROOT_USER_EMAIL_RECOVERY";
    case v1FeatureName.feature_name_webauthn_origins: return "FEATURE_NAME_WEBAUTHN_ORIGINS";
    case v1FeatureName.feature_name_email_auth: return "FEATURE_NAME_EMAIL_AUTH";
    case v1FeatureName.feature_name_email_recovery: return "FEATURE_NAME_EMAIL_RECOVERY";
    case v1FeatureName.feature_name_webhook: return "FEATURE_NAME_WEBHOOK";
    case v1FeatureName.feature_name_sms_auth: return "FEATURE_NAME_SMS_AUTH";
    case v1FeatureName.feature_name_otp_email_auth: return "FEATURE_NAME_OTP_EMAIL_AUTH";
    case v1FeatureName.feature_name_auth_proxy: return "FEATURE_NAME_AUTH_PROXY";
  }
}

enum v1FiatOnRampBlockchainNetwork {
  fiat_on_ramp_blockchain_network_bitcoin,
  fiat_on_ramp_blockchain_network_ethereum,
  fiat_on_ramp_blockchain_network_solana,
  fiat_on_ramp_blockchain_network_base,
}

v1FiatOnRampBlockchainNetwork v1FiatOnRampBlockchainNetworkFromJson(dynamic value) {
  switch (value) {
    case 'FIAT_ON_RAMP_BLOCKCHAIN_NETWORK_BITCOIN': return v1FiatOnRampBlockchainNetwork.fiat_on_ramp_blockchain_network_bitcoin;
    case 'FIAT_ON_RAMP_BLOCKCHAIN_NETWORK_ETHEREUM': return v1FiatOnRampBlockchainNetwork.fiat_on_ramp_blockchain_network_ethereum;
    case 'FIAT_ON_RAMP_BLOCKCHAIN_NETWORK_SOLANA': return v1FiatOnRampBlockchainNetwork.fiat_on_ramp_blockchain_network_solana;
    case 'FIAT_ON_RAMP_BLOCKCHAIN_NETWORK_BASE': return v1FiatOnRampBlockchainNetwork.fiat_on_ramp_blockchain_network_base;
    default: throw ArgumentError('Unknown v1FiatOnRampBlockchainNetwork: $value');
  }
}

dynamic v1FiatOnRampBlockchainNetworkToJson(v1FiatOnRampBlockchainNetwork value) {
  switch (value) {
    case v1FiatOnRampBlockchainNetwork.fiat_on_ramp_blockchain_network_bitcoin: return "FIAT_ON_RAMP_BLOCKCHAIN_NETWORK_BITCOIN";
    case v1FiatOnRampBlockchainNetwork.fiat_on_ramp_blockchain_network_ethereum: return "FIAT_ON_RAMP_BLOCKCHAIN_NETWORK_ETHEREUM";
    case v1FiatOnRampBlockchainNetwork.fiat_on_ramp_blockchain_network_solana: return "FIAT_ON_RAMP_BLOCKCHAIN_NETWORK_SOLANA";
    case v1FiatOnRampBlockchainNetwork.fiat_on_ramp_blockchain_network_base: return "FIAT_ON_RAMP_BLOCKCHAIN_NETWORK_BASE";
  }
}

enum v1FiatOnRampCryptoCurrency {
  fiat_on_ramp_crypto_currency_btc,
  fiat_on_ramp_crypto_currency_eth,
  fiat_on_ramp_crypto_currency_sol,
  fiat_on_ramp_crypto_currency_usdc,
}

v1FiatOnRampCryptoCurrency v1FiatOnRampCryptoCurrencyFromJson(dynamic value) {
  switch (value) {
    case 'FIAT_ON_RAMP_CRYPTO_CURRENCY_BTC': return v1FiatOnRampCryptoCurrency.fiat_on_ramp_crypto_currency_btc;
    case 'FIAT_ON_RAMP_CRYPTO_CURRENCY_ETH': return v1FiatOnRampCryptoCurrency.fiat_on_ramp_crypto_currency_eth;
    case 'FIAT_ON_RAMP_CRYPTO_CURRENCY_SOL': return v1FiatOnRampCryptoCurrency.fiat_on_ramp_crypto_currency_sol;
    case 'FIAT_ON_RAMP_CRYPTO_CURRENCY_USDC': return v1FiatOnRampCryptoCurrency.fiat_on_ramp_crypto_currency_usdc;
    default: throw ArgumentError('Unknown v1FiatOnRampCryptoCurrency: $value');
  }
}

dynamic v1FiatOnRampCryptoCurrencyToJson(v1FiatOnRampCryptoCurrency value) {
  switch (value) {
    case v1FiatOnRampCryptoCurrency.fiat_on_ramp_crypto_currency_btc: return "FIAT_ON_RAMP_CRYPTO_CURRENCY_BTC";
    case v1FiatOnRampCryptoCurrency.fiat_on_ramp_crypto_currency_eth: return "FIAT_ON_RAMP_CRYPTO_CURRENCY_ETH";
    case v1FiatOnRampCryptoCurrency.fiat_on_ramp_crypto_currency_sol: return "FIAT_ON_RAMP_CRYPTO_CURRENCY_SOL";
    case v1FiatOnRampCryptoCurrency.fiat_on_ramp_crypto_currency_usdc: return "FIAT_ON_RAMP_CRYPTO_CURRENCY_USDC";
  }
}

enum v1FiatOnRampCurrency {
  fiat_on_ramp_currency_aud,
  fiat_on_ramp_currency_bgn,
  fiat_on_ramp_currency_brl,
  fiat_on_ramp_currency_cad,
  fiat_on_ramp_currency_chf,
  fiat_on_ramp_currency_cop,
  fiat_on_ramp_currency_czk,
  fiat_on_ramp_currency_dkk,
  fiat_on_ramp_currency_dop,
  fiat_on_ramp_currency_egp,
  fiat_on_ramp_currency_eur,
  fiat_on_ramp_currency_gbp,
  fiat_on_ramp_currency_hkd,
  fiat_on_ramp_currency_idr,
  fiat_on_ramp_currency_ils,
  fiat_on_ramp_currency_jod,
  fiat_on_ramp_currency_kes,
  fiat_on_ramp_currency_kwd,
  fiat_on_ramp_currency_lkr,
  fiat_on_ramp_currency_mxn,
  fiat_on_ramp_currency_ngn,
  fiat_on_ramp_currency_nok,
  fiat_on_ramp_currency_nzd,
  fiat_on_ramp_currency_omr,
  fiat_on_ramp_currency_pen,
  fiat_on_ramp_currency_pln,
  fiat_on_ramp_currency_ron,
  fiat_on_ramp_currency_sek,
  fiat_on_ramp_currency_thb,
  fiat_on_ramp_currency_try,
  fiat_on_ramp_currency_twd,
  fiat_on_ramp_currency_usd,
  fiat_on_ramp_currency_vnd,
  fiat_on_ramp_currency_zar,
}

v1FiatOnRampCurrency v1FiatOnRampCurrencyFromJson(dynamic value) {
  switch (value) {
    case 'FIAT_ON_RAMP_CURRENCY_AUD': return v1FiatOnRampCurrency.fiat_on_ramp_currency_aud;
    case 'FIAT_ON_RAMP_CURRENCY_BGN': return v1FiatOnRampCurrency.fiat_on_ramp_currency_bgn;
    case 'FIAT_ON_RAMP_CURRENCY_BRL': return v1FiatOnRampCurrency.fiat_on_ramp_currency_brl;
    case 'FIAT_ON_RAMP_CURRENCY_CAD': return v1FiatOnRampCurrency.fiat_on_ramp_currency_cad;
    case 'FIAT_ON_RAMP_CURRENCY_CHF': return v1FiatOnRampCurrency.fiat_on_ramp_currency_chf;
    case 'FIAT_ON_RAMP_CURRENCY_COP': return v1FiatOnRampCurrency.fiat_on_ramp_currency_cop;
    case 'FIAT_ON_RAMP_CURRENCY_CZK': return v1FiatOnRampCurrency.fiat_on_ramp_currency_czk;
    case 'FIAT_ON_RAMP_CURRENCY_DKK': return v1FiatOnRampCurrency.fiat_on_ramp_currency_dkk;
    case 'FIAT_ON_RAMP_CURRENCY_DOP': return v1FiatOnRampCurrency.fiat_on_ramp_currency_dop;
    case 'FIAT_ON_RAMP_CURRENCY_EGP': return v1FiatOnRampCurrency.fiat_on_ramp_currency_egp;
    case 'FIAT_ON_RAMP_CURRENCY_EUR': return v1FiatOnRampCurrency.fiat_on_ramp_currency_eur;
    case 'FIAT_ON_RAMP_CURRENCY_GBP': return v1FiatOnRampCurrency.fiat_on_ramp_currency_gbp;
    case 'FIAT_ON_RAMP_CURRENCY_HKD': return v1FiatOnRampCurrency.fiat_on_ramp_currency_hkd;
    case 'FIAT_ON_RAMP_CURRENCY_IDR': return v1FiatOnRampCurrency.fiat_on_ramp_currency_idr;
    case 'FIAT_ON_RAMP_CURRENCY_ILS': return v1FiatOnRampCurrency.fiat_on_ramp_currency_ils;
    case 'FIAT_ON_RAMP_CURRENCY_JOD': return v1FiatOnRampCurrency.fiat_on_ramp_currency_jod;
    case 'FIAT_ON_RAMP_CURRENCY_KES': return v1FiatOnRampCurrency.fiat_on_ramp_currency_kes;
    case 'FIAT_ON_RAMP_CURRENCY_KWD': return v1FiatOnRampCurrency.fiat_on_ramp_currency_kwd;
    case 'FIAT_ON_RAMP_CURRENCY_LKR': return v1FiatOnRampCurrency.fiat_on_ramp_currency_lkr;
    case 'FIAT_ON_RAMP_CURRENCY_MXN': return v1FiatOnRampCurrency.fiat_on_ramp_currency_mxn;
    case 'FIAT_ON_RAMP_CURRENCY_NGN': return v1FiatOnRampCurrency.fiat_on_ramp_currency_ngn;
    case 'FIAT_ON_RAMP_CURRENCY_NOK': return v1FiatOnRampCurrency.fiat_on_ramp_currency_nok;
    case 'FIAT_ON_RAMP_CURRENCY_NZD': return v1FiatOnRampCurrency.fiat_on_ramp_currency_nzd;
    case 'FIAT_ON_RAMP_CURRENCY_OMR': return v1FiatOnRampCurrency.fiat_on_ramp_currency_omr;
    case 'FIAT_ON_RAMP_CURRENCY_PEN': return v1FiatOnRampCurrency.fiat_on_ramp_currency_pen;
    case 'FIAT_ON_RAMP_CURRENCY_PLN': return v1FiatOnRampCurrency.fiat_on_ramp_currency_pln;
    case 'FIAT_ON_RAMP_CURRENCY_RON': return v1FiatOnRampCurrency.fiat_on_ramp_currency_ron;
    case 'FIAT_ON_RAMP_CURRENCY_SEK': return v1FiatOnRampCurrency.fiat_on_ramp_currency_sek;
    case 'FIAT_ON_RAMP_CURRENCY_THB': return v1FiatOnRampCurrency.fiat_on_ramp_currency_thb;
    case 'FIAT_ON_RAMP_CURRENCY_TRY': return v1FiatOnRampCurrency.fiat_on_ramp_currency_try;
    case 'FIAT_ON_RAMP_CURRENCY_TWD': return v1FiatOnRampCurrency.fiat_on_ramp_currency_twd;
    case 'FIAT_ON_RAMP_CURRENCY_USD': return v1FiatOnRampCurrency.fiat_on_ramp_currency_usd;
    case 'FIAT_ON_RAMP_CURRENCY_VND': return v1FiatOnRampCurrency.fiat_on_ramp_currency_vnd;
    case 'FIAT_ON_RAMP_CURRENCY_ZAR': return v1FiatOnRampCurrency.fiat_on_ramp_currency_zar;
    default: throw ArgumentError('Unknown v1FiatOnRampCurrency: $value');
  }
}

dynamic v1FiatOnRampCurrencyToJson(v1FiatOnRampCurrency value) {
  switch (value) {
    case v1FiatOnRampCurrency.fiat_on_ramp_currency_aud: return "FIAT_ON_RAMP_CURRENCY_AUD";
    case v1FiatOnRampCurrency.fiat_on_ramp_currency_bgn: return "FIAT_ON_RAMP_CURRENCY_BGN";
    case v1FiatOnRampCurrency.fiat_on_ramp_currency_brl: return "FIAT_ON_RAMP_CURRENCY_BRL";
    case v1FiatOnRampCurrency.fiat_on_ramp_currency_cad: return "FIAT_ON_RAMP_CURRENCY_CAD";
    case v1FiatOnRampCurrency.fiat_on_ramp_currency_chf: return "FIAT_ON_RAMP_CURRENCY_CHF";
    case v1FiatOnRampCurrency.fiat_on_ramp_currency_cop: return "FIAT_ON_RAMP_CURRENCY_COP";
    case v1FiatOnRampCurrency.fiat_on_ramp_currency_czk: return "FIAT_ON_RAMP_CURRENCY_CZK";
    case v1FiatOnRampCurrency.fiat_on_ramp_currency_dkk: return "FIAT_ON_RAMP_CURRENCY_DKK";
    case v1FiatOnRampCurrency.fiat_on_ramp_currency_dop: return "FIAT_ON_RAMP_CURRENCY_DOP";
    case v1FiatOnRampCurrency.fiat_on_ramp_currency_egp: return "FIAT_ON_RAMP_CURRENCY_EGP";
    case v1FiatOnRampCurrency.fiat_on_ramp_currency_eur: return "FIAT_ON_RAMP_CURRENCY_EUR";
    case v1FiatOnRampCurrency.fiat_on_ramp_currency_gbp: return "FIAT_ON_RAMP_CURRENCY_GBP";
    case v1FiatOnRampCurrency.fiat_on_ramp_currency_hkd: return "FIAT_ON_RAMP_CURRENCY_HKD";
    case v1FiatOnRampCurrency.fiat_on_ramp_currency_idr: return "FIAT_ON_RAMP_CURRENCY_IDR";
    case v1FiatOnRampCurrency.fiat_on_ramp_currency_ils: return "FIAT_ON_RAMP_CURRENCY_ILS";
    case v1FiatOnRampCurrency.fiat_on_ramp_currency_jod: return "FIAT_ON_RAMP_CURRENCY_JOD";
    case v1FiatOnRampCurrency.fiat_on_ramp_currency_kes: return "FIAT_ON_RAMP_CURRENCY_KES";
    case v1FiatOnRampCurrency.fiat_on_ramp_currency_kwd: return "FIAT_ON_RAMP_CURRENCY_KWD";
    case v1FiatOnRampCurrency.fiat_on_ramp_currency_lkr: return "FIAT_ON_RAMP_CURRENCY_LKR";
    case v1FiatOnRampCurrency.fiat_on_ramp_currency_mxn: return "FIAT_ON_RAMP_CURRENCY_MXN";
    case v1FiatOnRampCurrency.fiat_on_ramp_currency_ngn: return "FIAT_ON_RAMP_CURRENCY_NGN";
    case v1FiatOnRampCurrency.fiat_on_ramp_currency_nok: return "FIAT_ON_RAMP_CURRENCY_NOK";
    case v1FiatOnRampCurrency.fiat_on_ramp_currency_nzd: return "FIAT_ON_RAMP_CURRENCY_NZD";
    case v1FiatOnRampCurrency.fiat_on_ramp_currency_omr: return "FIAT_ON_RAMP_CURRENCY_OMR";
    case v1FiatOnRampCurrency.fiat_on_ramp_currency_pen: return "FIAT_ON_RAMP_CURRENCY_PEN";
    case v1FiatOnRampCurrency.fiat_on_ramp_currency_pln: return "FIAT_ON_RAMP_CURRENCY_PLN";
    case v1FiatOnRampCurrency.fiat_on_ramp_currency_ron: return "FIAT_ON_RAMP_CURRENCY_RON";
    case v1FiatOnRampCurrency.fiat_on_ramp_currency_sek: return "FIAT_ON_RAMP_CURRENCY_SEK";
    case v1FiatOnRampCurrency.fiat_on_ramp_currency_thb: return "FIAT_ON_RAMP_CURRENCY_THB";
    case v1FiatOnRampCurrency.fiat_on_ramp_currency_try: return "FIAT_ON_RAMP_CURRENCY_TRY";
    case v1FiatOnRampCurrency.fiat_on_ramp_currency_twd: return "FIAT_ON_RAMP_CURRENCY_TWD";
    case v1FiatOnRampCurrency.fiat_on_ramp_currency_usd: return "FIAT_ON_RAMP_CURRENCY_USD";
    case v1FiatOnRampCurrency.fiat_on_ramp_currency_vnd: return "FIAT_ON_RAMP_CURRENCY_VND";
    case v1FiatOnRampCurrency.fiat_on_ramp_currency_zar: return "FIAT_ON_RAMP_CURRENCY_ZAR";
  }
}

enum v1FiatOnRampPaymentMethod {
  fiat_on_ramp_payment_method_credit_debit_card,
  fiat_on_ramp_payment_method_apple_pay,
  fiat_on_ramp_payment_method_gbp_bank_transfer,
  fiat_on_ramp_payment_method_gbp_open_banking_payment,
  fiat_on_ramp_payment_method_google_pay,
  fiat_on_ramp_payment_method_sepa_bank_transfer,
  fiat_on_ramp_payment_method_pix_instant_payment,
  fiat_on_ramp_payment_method_paypal,
  fiat_on_ramp_payment_method_venmo,
  fiat_on_ramp_payment_method_moonpay_balance,
  fiat_on_ramp_payment_method_crypto_account,
  fiat_on_ramp_payment_method_fiat_wallet,
  fiat_on_ramp_payment_method_ach_bank_account,
}

v1FiatOnRampPaymentMethod v1FiatOnRampPaymentMethodFromJson(dynamic value) {
  switch (value) {
    case 'FIAT_ON_RAMP_PAYMENT_METHOD_CREDIT_DEBIT_CARD': return v1FiatOnRampPaymentMethod.fiat_on_ramp_payment_method_credit_debit_card;
    case 'FIAT_ON_RAMP_PAYMENT_METHOD_APPLE_PAY': return v1FiatOnRampPaymentMethod.fiat_on_ramp_payment_method_apple_pay;
    case 'FIAT_ON_RAMP_PAYMENT_METHOD_GBP_BANK_TRANSFER': return v1FiatOnRampPaymentMethod.fiat_on_ramp_payment_method_gbp_bank_transfer;
    case 'FIAT_ON_RAMP_PAYMENT_METHOD_GBP_OPEN_BANKING_PAYMENT': return v1FiatOnRampPaymentMethod.fiat_on_ramp_payment_method_gbp_open_banking_payment;
    case 'FIAT_ON_RAMP_PAYMENT_METHOD_GOOGLE_PAY': return v1FiatOnRampPaymentMethod.fiat_on_ramp_payment_method_google_pay;
    case 'FIAT_ON_RAMP_PAYMENT_METHOD_SEPA_BANK_TRANSFER': return v1FiatOnRampPaymentMethod.fiat_on_ramp_payment_method_sepa_bank_transfer;
    case 'FIAT_ON_RAMP_PAYMENT_METHOD_PIX_INSTANT_PAYMENT': return v1FiatOnRampPaymentMethod.fiat_on_ramp_payment_method_pix_instant_payment;
    case 'FIAT_ON_RAMP_PAYMENT_METHOD_PAYPAL': return v1FiatOnRampPaymentMethod.fiat_on_ramp_payment_method_paypal;
    case 'FIAT_ON_RAMP_PAYMENT_METHOD_VENMO': return v1FiatOnRampPaymentMethod.fiat_on_ramp_payment_method_venmo;
    case 'FIAT_ON_RAMP_PAYMENT_METHOD_MOONPAY_BALANCE': return v1FiatOnRampPaymentMethod.fiat_on_ramp_payment_method_moonpay_balance;
    case 'FIAT_ON_RAMP_PAYMENT_METHOD_CRYPTO_ACCOUNT': return v1FiatOnRampPaymentMethod.fiat_on_ramp_payment_method_crypto_account;
    case 'FIAT_ON_RAMP_PAYMENT_METHOD_FIAT_WALLET': return v1FiatOnRampPaymentMethod.fiat_on_ramp_payment_method_fiat_wallet;
    case 'FIAT_ON_RAMP_PAYMENT_METHOD_ACH_BANK_ACCOUNT': return v1FiatOnRampPaymentMethod.fiat_on_ramp_payment_method_ach_bank_account;
    default: throw ArgumentError('Unknown v1FiatOnRampPaymentMethod: $value');
  }
}

dynamic v1FiatOnRampPaymentMethodToJson(v1FiatOnRampPaymentMethod value) {
  switch (value) {
    case v1FiatOnRampPaymentMethod.fiat_on_ramp_payment_method_credit_debit_card: return "FIAT_ON_RAMP_PAYMENT_METHOD_CREDIT_DEBIT_CARD";
    case v1FiatOnRampPaymentMethod.fiat_on_ramp_payment_method_apple_pay: return "FIAT_ON_RAMP_PAYMENT_METHOD_APPLE_PAY";
    case v1FiatOnRampPaymentMethod.fiat_on_ramp_payment_method_gbp_bank_transfer: return "FIAT_ON_RAMP_PAYMENT_METHOD_GBP_BANK_TRANSFER";
    case v1FiatOnRampPaymentMethod.fiat_on_ramp_payment_method_gbp_open_banking_payment: return "FIAT_ON_RAMP_PAYMENT_METHOD_GBP_OPEN_BANKING_PAYMENT";
    case v1FiatOnRampPaymentMethod.fiat_on_ramp_payment_method_google_pay: return "FIAT_ON_RAMP_PAYMENT_METHOD_GOOGLE_PAY";
    case v1FiatOnRampPaymentMethod.fiat_on_ramp_payment_method_sepa_bank_transfer: return "FIAT_ON_RAMP_PAYMENT_METHOD_SEPA_BANK_TRANSFER";
    case v1FiatOnRampPaymentMethod.fiat_on_ramp_payment_method_pix_instant_payment: return "FIAT_ON_RAMP_PAYMENT_METHOD_PIX_INSTANT_PAYMENT";
    case v1FiatOnRampPaymentMethod.fiat_on_ramp_payment_method_paypal: return "FIAT_ON_RAMP_PAYMENT_METHOD_PAYPAL";
    case v1FiatOnRampPaymentMethod.fiat_on_ramp_payment_method_venmo: return "FIAT_ON_RAMP_PAYMENT_METHOD_VENMO";
    case v1FiatOnRampPaymentMethod.fiat_on_ramp_payment_method_moonpay_balance: return "FIAT_ON_RAMP_PAYMENT_METHOD_MOONPAY_BALANCE";
    case v1FiatOnRampPaymentMethod.fiat_on_ramp_payment_method_crypto_account: return "FIAT_ON_RAMP_PAYMENT_METHOD_CRYPTO_ACCOUNT";
    case v1FiatOnRampPaymentMethod.fiat_on_ramp_payment_method_fiat_wallet: return "FIAT_ON_RAMP_PAYMENT_METHOD_FIAT_WALLET";
    case v1FiatOnRampPaymentMethod.fiat_on_ramp_payment_method_ach_bank_account: return "FIAT_ON_RAMP_PAYMENT_METHOD_ACH_BANK_ACCOUNT";
  }
}

enum v1FiatOnRampProvider {
  fiat_on_ramp_provider_coinbase,
  fiat_on_ramp_provider_moonpay,
}

v1FiatOnRampProvider v1FiatOnRampProviderFromJson(dynamic value) {
  switch (value) {
    case 'FIAT_ON_RAMP_PROVIDER_COINBASE': return v1FiatOnRampProvider.fiat_on_ramp_provider_coinbase;
    case 'FIAT_ON_RAMP_PROVIDER_MOONPAY': return v1FiatOnRampProvider.fiat_on_ramp_provider_moonpay;
    default: throw ArgumentError('Unknown v1FiatOnRampProvider: $value');
  }
}

dynamic v1FiatOnRampProviderToJson(v1FiatOnRampProvider value) {
  switch (value) {
    case v1FiatOnRampProvider.fiat_on_ramp_provider_coinbase: return "FIAT_ON_RAMP_PROVIDER_COINBASE";
    case v1FiatOnRampProvider.fiat_on_ramp_provider_moonpay: return "FIAT_ON_RAMP_PROVIDER_MOONPAY";
  }
}

enum v1HashFunction {
  hash_function_no_op,
  hash_function_sha256,
  hash_function_keccak256,
  hash_function_not_applicable,
}

v1HashFunction v1HashFunctionFromJson(dynamic value) {
  switch (value) {
    case 'HASH_FUNCTION_NO_OP': return v1HashFunction.hash_function_no_op;
    case 'HASH_FUNCTION_SHA256': return v1HashFunction.hash_function_sha256;
    case 'HASH_FUNCTION_KECCAK256': return v1HashFunction.hash_function_keccak256;
    case 'HASH_FUNCTION_NOT_APPLICABLE': return v1HashFunction.hash_function_not_applicable;
    default: throw ArgumentError('Unknown v1HashFunction: $value');
  }
}

dynamic v1HashFunctionToJson(v1HashFunction value) {
  switch (value) {
    case v1HashFunction.hash_function_no_op: return "HASH_FUNCTION_NO_OP";
    case v1HashFunction.hash_function_sha256: return "HASH_FUNCTION_SHA256";
    case v1HashFunction.hash_function_keccak256: return "HASH_FUNCTION_KECCAK256";
    case v1HashFunction.hash_function_not_applicable: return "HASH_FUNCTION_NOT_APPLICABLE";
  }
}

enum v1InvitationStatus {
  invitation_status_created,
  invitation_status_accepted,
  invitation_status_revoked,
}

v1InvitationStatus v1InvitationStatusFromJson(dynamic value) {
  switch (value) {
    case 'INVITATION_STATUS_CREATED': return v1InvitationStatus.invitation_status_created;
    case 'INVITATION_STATUS_ACCEPTED': return v1InvitationStatus.invitation_status_accepted;
    case 'INVITATION_STATUS_REVOKED': return v1InvitationStatus.invitation_status_revoked;
    default: throw ArgumentError('Unknown v1InvitationStatus: $value');
  }
}

dynamic v1InvitationStatusToJson(v1InvitationStatus value) {
  switch (value) {
    case v1InvitationStatus.invitation_status_created: return "INVITATION_STATUS_CREATED";
    case v1InvitationStatus.invitation_status_accepted: return "INVITATION_STATUS_ACCEPTED";
    case v1InvitationStatus.invitation_status_revoked: return "INVITATION_STATUS_REVOKED";
  }
}

enum v1MnemonicLanguage {
  mnemonic_language_english,
  mnemonic_language_simplified_chinese,
  mnemonic_language_traditional_chinese,
  mnemonic_language_czech,
  mnemonic_language_french,
  mnemonic_language_italian,
  mnemonic_language_japanese,
  mnemonic_language_korean,
  mnemonic_language_spanish,
}

v1MnemonicLanguage v1MnemonicLanguageFromJson(dynamic value) {
  switch (value) {
    case 'MNEMONIC_LANGUAGE_ENGLISH': return v1MnemonicLanguage.mnemonic_language_english;
    case 'MNEMONIC_LANGUAGE_SIMPLIFIED_CHINESE': return v1MnemonicLanguage.mnemonic_language_simplified_chinese;
    case 'MNEMONIC_LANGUAGE_TRADITIONAL_CHINESE': return v1MnemonicLanguage.mnemonic_language_traditional_chinese;
    case 'MNEMONIC_LANGUAGE_CZECH': return v1MnemonicLanguage.mnemonic_language_czech;
    case 'MNEMONIC_LANGUAGE_FRENCH': return v1MnemonicLanguage.mnemonic_language_french;
    case 'MNEMONIC_LANGUAGE_ITALIAN': return v1MnemonicLanguage.mnemonic_language_italian;
    case 'MNEMONIC_LANGUAGE_JAPANESE': return v1MnemonicLanguage.mnemonic_language_japanese;
    case 'MNEMONIC_LANGUAGE_KOREAN': return v1MnemonicLanguage.mnemonic_language_korean;
    case 'MNEMONIC_LANGUAGE_SPANISH': return v1MnemonicLanguage.mnemonic_language_spanish;
    default: throw ArgumentError('Unknown v1MnemonicLanguage: $value');
  }
}

dynamic v1MnemonicLanguageToJson(v1MnemonicLanguage value) {
  switch (value) {
    case v1MnemonicLanguage.mnemonic_language_english: return "MNEMONIC_LANGUAGE_ENGLISH";
    case v1MnemonicLanguage.mnemonic_language_simplified_chinese: return "MNEMONIC_LANGUAGE_SIMPLIFIED_CHINESE";
    case v1MnemonicLanguage.mnemonic_language_traditional_chinese: return "MNEMONIC_LANGUAGE_TRADITIONAL_CHINESE";
    case v1MnemonicLanguage.mnemonic_language_czech: return "MNEMONIC_LANGUAGE_CZECH";
    case v1MnemonicLanguage.mnemonic_language_french: return "MNEMONIC_LANGUAGE_FRENCH";
    case v1MnemonicLanguage.mnemonic_language_italian: return "MNEMONIC_LANGUAGE_ITALIAN";
    case v1MnemonicLanguage.mnemonic_language_japanese: return "MNEMONIC_LANGUAGE_JAPANESE";
    case v1MnemonicLanguage.mnemonic_language_korean: return "MNEMONIC_LANGUAGE_KOREAN";
    case v1MnemonicLanguage.mnemonic_language_spanish: return "MNEMONIC_LANGUAGE_SPANISH";
  }
}

enum v1Oauth2Provider {
  oauth2_provider_x,
  oauth2_provider_discord,
}

v1Oauth2Provider v1Oauth2ProviderFromJson(dynamic value) {
  switch (value) {
    case 'OAUTH2_PROVIDER_X': return v1Oauth2Provider.oauth2_provider_x;
    case 'OAUTH2_PROVIDER_DISCORD': return v1Oauth2Provider.oauth2_provider_discord;
    default: throw ArgumentError('Unknown v1Oauth2Provider: $value');
  }
}

dynamic v1Oauth2ProviderToJson(v1Oauth2Provider value) {
  switch (value) {
    case v1Oauth2Provider.oauth2_provider_x: return "OAUTH2_PROVIDER_X";
    case v1Oauth2Provider.oauth2_provider_discord: return "OAUTH2_PROVIDER_DISCORD";
  }
}

enum v1Operator {
  operator_equal,
  operator_more_than,
  operator_more_than_or_equal,
  operator_less_than,
  operator_less_than_or_equal,
  operator_contains,
  operator_not_equal,
  operator_in,
  operator_not_in,
  operator_contains_one,
  operator_contains_all,
}

v1Operator v1OperatorFromJson(dynamic value) {
  switch (value) {
    case 'OPERATOR_EQUAL': return v1Operator.operator_equal;
    case 'OPERATOR_MORE_THAN': return v1Operator.operator_more_than;
    case 'OPERATOR_MORE_THAN_OR_EQUAL': return v1Operator.operator_more_than_or_equal;
    case 'OPERATOR_LESS_THAN': return v1Operator.operator_less_than;
    case 'OPERATOR_LESS_THAN_OR_EQUAL': return v1Operator.operator_less_than_or_equal;
    case 'OPERATOR_CONTAINS': return v1Operator.operator_contains;
    case 'OPERATOR_NOT_EQUAL': return v1Operator.operator_not_equal;
    case 'OPERATOR_IN': return v1Operator.operator_in;
    case 'OPERATOR_NOT_IN': return v1Operator.operator_not_in;
    case 'OPERATOR_CONTAINS_ONE': return v1Operator.operator_contains_one;
    case 'OPERATOR_CONTAINS_ALL': return v1Operator.operator_contains_all;
    default: throw ArgumentError('Unknown v1Operator: $value');
  }
}

dynamic v1OperatorToJson(v1Operator value) {
  switch (value) {
    case v1Operator.operator_equal: return "OPERATOR_EQUAL";
    case v1Operator.operator_more_than: return "OPERATOR_MORE_THAN";
    case v1Operator.operator_more_than_or_equal: return "OPERATOR_MORE_THAN_OR_EQUAL";
    case v1Operator.operator_less_than: return "OPERATOR_LESS_THAN";
    case v1Operator.operator_less_than_or_equal: return "OPERATOR_LESS_THAN_OR_EQUAL";
    case v1Operator.operator_contains: return "OPERATOR_CONTAINS";
    case v1Operator.operator_not_equal: return "OPERATOR_NOT_EQUAL";
    case v1Operator.operator_in: return "OPERATOR_IN";
    case v1Operator.operator_not_in: return "OPERATOR_NOT_IN";
    case v1Operator.operator_contains_one: return "OPERATOR_CONTAINS_ONE";
    case v1Operator.operator_contains_all: return "OPERATOR_CONTAINS_ALL";
  }
}

enum v1Outcome {
  outcome_allow,
  outcome_deny_explicit,
  outcome_deny_implicit,
  outcome_requires_consensus,
  outcome_rejected,
  outcome_error,
}

v1Outcome v1OutcomeFromJson(dynamic value) {
  switch (value) {
    case 'OUTCOME_ALLOW': return v1Outcome.outcome_allow;
    case 'OUTCOME_DENY_EXPLICIT': return v1Outcome.outcome_deny_explicit;
    case 'OUTCOME_DENY_IMPLICIT': return v1Outcome.outcome_deny_implicit;
    case 'OUTCOME_REQUIRES_CONSENSUS': return v1Outcome.outcome_requires_consensus;
    case 'OUTCOME_REJECTED': return v1Outcome.outcome_rejected;
    case 'OUTCOME_ERROR': return v1Outcome.outcome_error;
    default: throw ArgumentError('Unknown v1Outcome: $value');
  }
}

dynamic v1OutcomeToJson(v1Outcome value) {
  switch (value) {
    case v1Outcome.outcome_allow: return "OUTCOME_ALLOW";
    case v1Outcome.outcome_deny_explicit: return "OUTCOME_DENY_EXPLICIT";
    case v1Outcome.outcome_deny_implicit: return "OUTCOME_DENY_IMPLICIT";
    case v1Outcome.outcome_requires_consensus: return "OUTCOME_REQUIRES_CONSENSUS";
    case v1Outcome.outcome_rejected: return "OUTCOME_REJECTED";
    case v1Outcome.outcome_error: return "OUTCOME_ERROR";
  }
}

enum v1PathFormat {
  path_format_bip32,
}

v1PathFormat v1PathFormatFromJson(dynamic value) {
  switch (value) {
    case 'PATH_FORMAT_BIP32': return v1PathFormat.path_format_bip32;
    default: throw ArgumentError('Unknown v1PathFormat: $value');
  }
}

dynamic v1PathFormatToJson(v1PathFormat value) {
  switch (value) {
    case v1PathFormat.path_format_bip32: return "PATH_FORMAT_BIP32";
  }
}

enum v1PayloadEncoding {
  payload_encoding_hexadecimal,
  payload_encoding_text_utf8,
  payload_encoding_eip712,
  payload_encoding_eip7702_authorization,
}

v1PayloadEncoding v1PayloadEncodingFromJson(dynamic value) {
  switch (value) {
    case 'PAYLOAD_ENCODING_HEXADECIMAL': return v1PayloadEncoding.payload_encoding_hexadecimal;
    case 'PAYLOAD_ENCODING_TEXT_UTF8': return v1PayloadEncoding.payload_encoding_text_utf8;
    case 'PAYLOAD_ENCODING_EIP712': return v1PayloadEncoding.payload_encoding_eip712;
    case 'PAYLOAD_ENCODING_EIP7702_AUTHORIZATION': return v1PayloadEncoding.payload_encoding_eip7702_authorization;
    default: throw ArgumentError('Unknown v1PayloadEncoding: $value');
  }
}

dynamic v1PayloadEncodingToJson(v1PayloadEncoding value) {
  switch (value) {
    case v1PayloadEncoding.payload_encoding_hexadecimal: return "PAYLOAD_ENCODING_HEXADECIMAL";
    case v1PayloadEncoding.payload_encoding_text_utf8: return "PAYLOAD_ENCODING_TEXT_UTF8";
    case v1PayloadEncoding.payload_encoding_eip712: return "PAYLOAD_ENCODING_EIP712";
    case v1PayloadEncoding.payload_encoding_eip7702_authorization: return "PAYLOAD_ENCODING_EIP7702_AUTHORIZATION";
  }
}

enum v1SmartContractInterfaceType {
  smart_contract_interface_type_ethereum,
  smart_contract_interface_type_solana,
}

v1SmartContractInterfaceType v1SmartContractInterfaceTypeFromJson(dynamic value) {
  switch (value) {
    case 'SMART_CONTRACT_INTERFACE_TYPE_ETHEREUM': return v1SmartContractInterfaceType.smart_contract_interface_type_ethereum;
    case 'SMART_CONTRACT_INTERFACE_TYPE_SOLANA': return v1SmartContractInterfaceType.smart_contract_interface_type_solana;
    default: throw ArgumentError('Unknown v1SmartContractInterfaceType: $value');
  }
}

dynamic v1SmartContractInterfaceTypeToJson(v1SmartContractInterfaceType value) {
  switch (value) {
    case v1SmartContractInterfaceType.smart_contract_interface_type_ethereum: return "SMART_CONTRACT_INTERFACE_TYPE_ETHEREUM";
    case v1SmartContractInterfaceType.smart_contract_interface_type_solana: return "SMART_CONTRACT_INTERFACE_TYPE_SOLANA";
  }
}

enum v1TagType {
  tag_type_user,
  tag_type_private_key,
}

v1TagType v1TagTypeFromJson(dynamic value) {
  switch (value) {
    case 'TAG_TYPE_USER': return v1TagType.tag_type_user;
    case 'TAG_TYPE_PRIVATE_KEY': return v1TagType.tag_type_private_key;
    default: throw ArgumentError('Unknown v1TagType: $value');
  }
}

dynamic v1TagTypeToJson(v1TagType value) {
  switch (value) {
    case v1TagType.tag_type_user: return "TAG_TYPE_USER";
    case v1TagType.tag_type_private_key: return "TAG_TYPE_PRIVATE_KEY";
  }
}

enum v1TransactionType {
  transaction_type_ethereum,
  transaction_type_solana,
  transaction_type_tron,
  transaction_type_bitcoin,
  transaction_type_tempo,
}

v1TransactionType v1TransactionTypeFromJson(dynamic value) {
  switch (value) {
    case 'TRANSACTION_TYPE_ETHEREUM': return v1TransactionType.transaction_type_ethereum;
    case 'TRANSACTION_TYPE_SOLANA': return v1TransactionType.transaction_type_solana;
    case 'TRANSACTION_TYPE_TRON': return v1TransactionType.transaction_type_tron;
    case 'TRANSACTION_TYPE_BITCOIN': return v1TransactionType.transaction_type_bitcoin;
    case 'TRANSACTION_TYPE_TEMPO': return v1TransactionType.transaction_type_tempo;
    default: throw ArgumentError('Unknown v1TransactionType: $value');
  }
}

dynamic v1TransactionTypeToJson(v1TransactionType value) {
  switch (value) {
    case v1TransactionType.transaction_type_ethereum: return "TRANSACTION_TYPE_ETHEREUM";
    case v1TransactionType.transaction_type_solana: return "TRANSACTION_TYPE_SOLANA";
    case v1TransactionType.transaction_type_tron: return "TRANSACTION_TYPE_TRON";
    case v1TransactionType.transaction_type_bitcoin: return "TRANSACTION_TYPE_BITCOIN";
    case v1TransactionType.transaction_type_tempo: return "TRANSACTION_TYPE_TEMPO";
  }
}

enum v1TvcDeploymentStage {
  tvc_deployment_stage_approve,
  tvc_deployment_stage_provision,
  tvc_deployment_stage_live,
  tvc_deployment_stage_delete,
}

v1TvcDeploymentStage v1TvcDeploymentStageFromJson(dynamic value) {
  switch (value) {
    case 'TVC_DEPLOYMENT_STAGE_APPROVE': return v1TvcDeploymentStage.tvc_deployment_stage_approve;
    case 'TVC_DEPLOYMENT_STAGE_PROVISION': return v1TvcDeploymentStage.tvc_deployment_stage_provision;
    case 'TVC_DEPLOYMENT_STAGE_LIVE': return v1TvcDeploymentStage.tvc_deployment_stage_live;
    case 'TVC_DEPLOYMENT_STAGE_DELETE': return v1TvcDeploymentStage.tvc_deployment_stage_delete;
    default: throw ArgumentError('Unknown v1TvcDeploymentStage: $value');
  }
}

dynamic v1TvcDeploymentStageToJson(v1TvcDeploymentStage value) {
  switch (value) {
    case v1TvcDeploymentStage.tvc_deployment_stage_approve: return "TVC_DEPLOYMENT_STAGE_APPROVE";
    case v1TvcDeploymentStage.tvc_deployment_stage_provision: return "TVC_DEPLOYMENT_STAGE_PROVISION";
    case v1TvcDeploymentStage.tvc_deployment_stage_live: return "TVC_DEPLOYMENT_STAGE_LIVE";
    case v1TvcDeploymentStage.tvc_deployment_stage_delete: return "TVC_DEPLOYMENT_STAGE_DELETE";
  }
}

enum v1UsageType {
  usage_type_signup,
  usage_type_login,
}

v1UsageType v1UsageTypeFromJson(dynamic value) {
  switch (value) {
    case 'USAGE_TYPE_SIGNUP': return v1UsageType.usage_type_signup;
    case 'USAGE_TYPE_LOGIN': return v1UsageType.usage_type_login;
    default: throw ArgumentError('Unknown v1UsageType: $value');
  }
}

dynamic v1UsageTypeToJson(v1UsageType value) {
  switch (value) {
    case v1UsageType.usage_type_signup: return "USAGE_TYPE_SIGNUP";
    case v1UsageType.usage_type_login: return "USAGE_TYPE_LOGIN";
  }
}

class apiApiKeyParams {
  /// Human-readable name for an API Key.
  final String apiKeyName;
  /// The public component of a cryptographic key pair used to sign messages and transactions.
  final String publicKey;
  /// Optional window (in seconds) indicating how long the API Key should last.
  final String? expirationSeconds;

  const apiApiKeyParams({
    required  this.apiKeyName,
    required  this.publicKey,
     this.expirationSeconds,
  });

  factory apiApiKeyParams.fromJson(Map<String, dynamic> json) {
    final _apiKeyName = json['apiKeyName'] as String;
    final _publicKey = json['publicKey'] as String;
    final _expirationSeconds = json['expirationSeconds'] as String?;
    return apiApiKeyParams(
      apiKeyName: _apiKeyName,
      publicKey: _publicKey,
      expirationSeconds: _expirationSeconds,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['apiKeyName'] = apiKeyName;
    _json['publicKey'] = publicKey;
    if (expirationSeconds != null) {
      _json['expirationSeconds'] = expirationSeconds;
    }
    return _json;
  }
}

class billingActivateBillingTierIntent {
  /// The product that the customer wants to subscribe to.
  final String productId;

  const billingActivateBillingTierIntent({
    required  this.productId,
  });

  factory billingActivateBillingTierIntent.fromJson(Map<String, dynamic> json) {
    final _productId = json['productId'] as String;
    return billingActivateBillingTierIntent(
      productId: _productId,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['productId'] = productId;
    return _json;
  }
}

class billingActivateBillingTierResult {
  /// The id of the product being subscribed to.
  final String productId;

  const billingActivateBillingTierResult({
    required  this.productId,
  });

  factory billingActivateBillingTierResult.fromJson(Map<String, dynamic> json) {
    final _productId = json['productId'] as String;
    return billingActivateBillingTierResult(
      productId: _productId,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['productId'] = productId;
    return _json;
  }
}

class billingDeletePaymentMethodIntent {
  /// The payment method that the customer wants to remove.
  final String paymentMethodId;

  const billingDeletePaymentMethodIntent({
    required  this.paymentMethodId,
  });

  factory billingDeletePaymentMethodIntent.fromJson(Map<String, dynamic> json) {
    final _paymentMethodId = json['paymentMethodId'] as String;
    return billingDeletePaymentMethodIntent(
      paymentMethodId: _paymentMethodId,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['paymentMethodId'] = paymentMethodId;
    return _json;
  }
}

class billingDeletePaymentMethodResult {
  /// The payment method that was removed.
  final String paymentMethodId;

  const billingDeletePaymentMethodResult({
    required  this.paymentMethodId,
  });

  factory billingDeletePaymentMethodResult.fromJson(Map<String, dynamic> json) {
    final _paymentMethodId = json['paymentMethodId'] as String;
    return billingDeletePaymentMethodResult(
      paymentMethodId: _paymentMethodId,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['paymentMethodId'] = paymentMethodId;
    return _json;
  }
}

class billingSetPaymentMethodIntent {
  /// The account number of the customer's credit card.
  final String number;
  /// The verification digits of the customer's credit card.
  final String cvv;
  /// The month that the credit card expires.
  final String expiryMonth;
  /// The year that the credit card expires.
  final String expiryYear;
  /// The email that will receive invoices for the credit card.
  final String cardHolderEmail;
  /// The name associated with the credit card.
  final String cardHolderName;

  const billingSetPaymentMethodIntent({
    required  this.number,
    required  this.cvv,
    required  this.expiryMonth,
    required  this.expiryYear,
    required  this.cardHolderEmail,
    required  this.cardHolderName,
  });

  factory billingSetPaymentMethodIntent.fromJson(Map<String, dynamic> json) {
    final _number = json['number'] as String;
    final _cvv = json['cvv'] as String;
    final _expiryMonth = json['expiryMonth'] as String;
    final _expiryYear = json['expiryYear'] as String;
    final _cardHolderEmail = json['cardHolderEmail'] as String;
    final _cardHolderName = json['cardHolderName'] as String;
    return billingSetPaymentMethodIntent(
      number: _number,
      cvv: _cvv,
      expiryMonth: _expiryMonth,
      expiryYear: _expiryYear,
      cardHolderEmail: _cardHolderEmail,
      cardHolderName: _cardHolderName,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['number'] = number;
    _json['cvv'] = cvv;
    _json['expiryMonth'] = expiryMonth;
    _json['expiryYear'] = expiryYear;
    _json['cardHolderEmail'] = cardHolderEmail;
    _json['cardHolderName'] = cardHolderName;
    return _json;
  }
}

class billingSetPaymentMethodIntentV2 {
  /// The id of the payment method that was created clientside.
  final String paymentMethodId;
  /// The email that will receive invoices for the credit card.
  final String cardHolderEmail;
  /// The name associated with the credit card.
  final String cardHolderName;

  const billingSetPaymentMethodIntentV2({
    required  this.paymentMethodId,
    required  this.cardHolderEmail,
    required  this.cardHolderName,
  });

  factory billingSetPaymentMethodIntentV2.fromJson(Map<String, dynamic> json) {
    final _paymentMethodId = json['paymentMethodId'] as String;
    final _cardHolderEmail = json['cardHolderEmail'] as String;
    final _cardHolderName = json['cardHolderName'] as String;
    return billingSetPaymentMethodIntentV2(
      paymentMethodId: _paymentMethodId,
      cardHolderEmail: _cardHolderEmail,
      cardHolderName: _cardHolderName,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['paymentMethodId'] = paymentMethodId;
    _json['cardHolderEmail'] = cardHolderEmail;
    _json['cardHolderName'] = cardHolderName;
    return _json;
  }
}

class billingSetPaymentMethodResult {
  /// The last four digits of the credit card added.
  final String lastFour;
  /// The name associated with the payment method.
  final String cardHolderName;
  /// The email address associated with the payment method.
  final String cardHolderEmail;

  const billingSetPaymentMethodResult({
    required  this.lastFour,
    required  this.cardHolderName,
    required  this.cardHolderEmail,
  });

  factory billingSetPaymentMethodResult.fromJson(Map<String, dynamic> json) {
    final _lastFour = json['lastFour'] as String;
    final _cardHolderName = json['cardHolderName'] as String;
    final _cardHolderEmail = json['cardHolderEmail'] as String;
    return billingSetPaymentMethodResult(
      lastFour: _lastFour,
      cardHolderName: _cardHolderName,
      cardHolderEmail: _cardHolderEmail,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['lastFour'] = lastFour;
    _json['cardHolderName'] = cardHolderName;
    _json['cardHolderEmail'] = cardHolderEmail;
    return _json;
  }
}

class datav1Tag {
  /// Unique identifier for a given Tag.
  final String tagId;
  /// Human-readable name for a Tag.
  final String tagName;
  final v1TagType tagType;
  final externaldatav1Timestamp createdAt;
  final externaldatav1Timestamp updatedAt;

  const datav1Tag({
    required  this.tagId,
    required  this.tagName,
    required  this.tagType,
    required  this.createdAt,
    required  this.updatedAt,
  });

  factory datav1Tag.fromJson(Map<String, dynamic> json) {
    final _tagId = json['tagId'] as String;
    final _tagName = json['tagName'] as String;
    final _tagType = v1TagTypeFromJson(json['tagType']);
    final _createdAt = externaldatav1Timestamp.fromJson(json['createdAt'] as Map<String, dynamic>);
    final _updatedAt = externaldatav1Timestamp.fromJson(json['updatedAt'] as Map<String, dynamic>);
    return datav1Tag(
      tagId: _tagId,
      tagName: _tagName,
      tagType: _tagType,
      createdAt: _createdAt,
      updatedAt: _updatedAt,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['tagId'] = tagId;
    _json['tagName'] = tagName;
    _json['tagType'] = v1TagTypeToJson(tagType);
    _json['createdAt'] = createdAt.toJson();
    _json['updatedAt'] = updatedAt.toJson();
    return _json;
  }
}

class externalactivityv1PolicyEvaluation {
  /// Unique identifier for a given policy evaluation.
  final String id;
  /// Unique identifier for a given Activity.
  final String activityId;
  /// Unique identifier for the Organization the Activity belongs to.
  final String organizationId;
  /// Unique identifier for the Vote associated with this policy evaluation.
  final String voteId;
  /// Detailed evaluation result for each Policy that was run.
  final List<immutablecommonv1PolicyEvaluation> policyEvaluations;
  final externaldatav1Timestamp createdAt;

  const externalactivityv1PolicyEvaluation({
    required  this.id,
    required  this.activityId,
    required  this.organizationId,
    required  this.voteId,
    required  this.policyEvaluations,
    required  this.createdAt,
  });

  factory externalactivityv1PolicyEvaluation.fromJson(Map<String, dynamic> json) {
    final _id = json['id'] as String;
    final _activityId = json['activityId'] as String;
    final _organizationId = json['organizationId'] as String;
    final _voteId = json['voteId'] as String;
    final _policyEvaluations = (json['policyEvaluations'] as List).map((e) => immutablecommonv1PolicyEvaluation.fromJson(e as Map<String, dynamic>)).toList();
    final _createdAt = externaldatav1Timestamp.fromJson(json['createdAt'] as Map<String, dynamic>);
    return externalactivityv1PolicyEvaluation(
      id: _id,
      activityId: _activityId,
      organizationId: _organizationId,
      voteId: _voteId,
      policyEvaluations: _policyEvaluations,
      createdAt: _createdAt,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['id'] = id;
    _json['activityId'] = activityId;
    _json['organizationId'] = organizationId;
    _json['voteId'] = voteId;
    _json['policyEvaluations'] = policyEvaluations.map((e) => e.toJson()).toList();
    _json['createdAt'] = createdAt.toJson();
    return _json;
  }
}

class externaldatav1Address {
  final v1AddressFormat? format;
  final String? address;

  const externaldatav1Address({
     this.format,
     this.address,
  });

  factory externaldatav1Address.fromJson(Map<String, dynamic> json) {
    final _format = json['format'] == null ? null : v1AddressFormatFromJson(json['format']);
    final _address = json['address'] as String?;
    return externaldatav1Address(
      format: _format,
      address: _address,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    if (format != null) {
      _json['format'] = v1AddressFormatToJson(format!);
    }
    if (address != null) {
      _json['address'] = address;
    }
    return _json;
  }
}

class externaldatav1Credential {
  /// The public component of a cryptographic key pair used to sign messages and transactions.
  final String publicKey;
  final v1CredentialType type;

  const externaldatav1Credential({
    required  this.publicKey,
    required  this.type,
  });

  factory externaldatav1Credential.fromJson(Map<String, dynamic> json) {
    final _publicKey = json['publicKey'] as String;
    final _type = v1CredentialTypeFromJson(json['type']);
    return externaldatav1Credential(
      publicKey: _publicKey,
      type: _type,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['publicKey'] = publicKey;
    _json['type'] = v1CredentialTypeToJson(type);
    return _json;
  }
}

class externaldatav1Quorum {
  /// Count of unique approvals required to meet quorum.
  final num threshold;
  /// Unique identifiers of quorum set members.
  final List<String> userIds;

  const externaldatav1Quorum({
    required  this.threshold,
    required  this.userIds,
  });

  factory externaldatav1Quorum.fromJson(Map<String, dynamic> json) {
    final _threshold = json['threshold'] as num;
    final _userIds = (json['userIds'] as List).map((e) => e as String).toList();
    return externaldatav1Quorum(
      threshold: _threshold,
      userIds: _userIds,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['threshold'] = threshold;
    _json['userIds'] = userIds;
    return _json;
  }
}

class externaldatav1SmartContractInterface {
  /// The Organization the Smart Contract Interface belongs to.
  final String organizationId;
  /// Unique identifier for a given Smart Contract Interface (ABI or IDL).
  final String smartContractInterfaceId;
  /// The address corresponding to the Smart Contract or Program.
  final String smartContractAddress;
  /// The JSON corresponding to the Smart Contract Interface (ABI or IDL).
  final String smartContractInterface;
  /// The type corresponding to the Smart Contract Interface (either ETHEREUM or SOLANA).
  final String type;
  /// The label corresponding to the Smart Contract Interface (either ETHEREUM or SOLANA).
  final String label;
  /// The notes corresponding to the Smart Contract Interface (either ETHEREUM or SOLANA).
  final String notes;
  final externaldatav1Timestamp createdAt;
  final externaldatav1Timestamp updatedAt;

  const externaldatav1SmartContractInterface({
    required  this.organizationId,
    required  this.smartContractInterfaceId,
    required  this.smartContractAddress,
    required  this.smartContractInterface,
    required  this.type,
    required  this.label,
    required  this.notes,
    required  this.createdAt,
    required  this.updatedAt,
  });

  factory externaldatav1SmartContractInterface.fromJson(Map<String, dynamic> json) {
    final _organizationId = json['organizationId'] as String;
    final _smartContractInterfaceId = json['smartContractInterfaceId'] as String;
    final _smartContractAddress = json['smartContractAddress'] as String;
    final _smartContractInterface = json['smartContractInterface'] as String;
    final _type = json['type'] as String;
    final _label = json['label'] as String;
    final _notes = json['notes'] as String;
    final _createdAt = externaldatav1Timestamp.fromJson(json['createdAt'] as Map<String, dynamic>);
    final _updatedAt = externaldatav1Timestamp.fromJson(json['updatedAt'] as Map<String, dynamic>);
    return externaldatav1SmartContractInterface(
      organizationId: _organizationId,
      smartContractInterfaceId: _smartContractInterfaceId,
      smartContractAddress: _smartContractAddress,
      smartContractInterface: _smartContractInterface,
      type: _type,
      label: _label,
      notes: _notes,
      createdAt: _createdAt,
      updatedAt: _updatedAt,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['organizationId'] = organizationId;
    _json['smartContractInterfaceId'] = smartContractInterfaceId;
    _json['smartContractAddress'] = smartContractAddress;
    _json['smartContractInterface'] = smartContractInterface;
    _json['type'] = type;
    _json['label'] = label;
    _json['notes'] = notes;
    _json['createdAt'] = createdAt.toJson();
    _json['updatedAt'] = updatedAt.toJson();
    return _json;
  }
}

class externaldatav1Timestamp {
  final String seconds;
  final String nanos;

  const externaldatav1Timestamp({
    required  this.seconds,
    required  this.nanos,
  });

  factory externaldatav1Timestamp.fromJson(Map<String, dynamic> json) {
    final _seconds = json['seconds'] as String;
    final _nanos = json['nanos'] as String;
    return externaldatav1Timestamp(
      seconds: _seconds,
      nanos: _nanos,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['seconds'] = seconds;
    _json['nanos'] = nanos;
    return _json;
  }
}

class immutableactivityv1Address {
  final v1AddressFormat? format;
  final String? address;

  const immutableactivityv1Address({
     this.format,
     this.address,
  });

  factory immutableactivityv1Address.fromJson(Map<String, dynamic> json) {
    final _format = json['format'] == null ? null : v1AddressFormatFromJson(json['format']);
    final _address = json['address'] as String?;
    return immutableactivityv1Address(
      format: _format,
      address: _address,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    if (format != null) {
      _json['format'] = v1AddressFormatToJson(format!);
    }
    if (address != null) {
      _json['address'] = address;
    }
    return _json;
  }
}

class immutablecommonv1PolicyEvaluation {
  final String? policyId;
  final v1Outcome? outcome;

  const immutablecommonv1PolicyEvaluation({
     this.policyId,
     this.outcome,
  });

  factory immutablecommonv1PolicyEvaluation.fromJson(Map<String, dynamic> json) {
    final _policyId = json['policyId'] as String?;
    final _outcome = json['outcome'] == null ? null : v1OutcomeFromJson(json['outcome']);
    return immutablecommonv1PolicyEvaluation(
      policyId: _policyId,
      outcome: _outcome,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    if (policyId != null) {
      _json['policyId'] = policyId;
    }
    if (outcome != null) {
      _json['outcome'] = v1OutcomeToJson(outcome!);
    }
    return _json;
  }
}

class protobufAny {
  final String? type;
  /// Unrecognized properties captured here.
  final Map<String, dynamic>? additionalProperties;

  const protobufAny({
     this.type,
    this.additionalProperties,
  });

  factory protobufAny.fromJson(Map<String, dynamic> json) {
    final extras = <String, dynamic>{};
    final _type = json['@type'] as String?;
    for (final entry in json.entries) {
      if (!{ '@type' }.contains(entry.key)) {
        extras[entry.key] = entry.value;
      }
    }
    return protobufAny(
      type: _type,
      additionalProperties: extras.isEmpty ? null : extras,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    if (type != null) {
      _json['@type'] = type;
    }
    if (additionalProperties != null) {
      _json.addAll(additionalProperties!);
    }
    return _json;
  }
}

class rpcStatus {
  final num? code;
  final String? message;
  final List<protobufAny>? details;

  const rpcStatus({
     this.code,
     this.message,
     this.details,
  });

  factory rpcStatus.fromJson(Map<String, dynamic> json) {
    final _code = json['code'] as num?;
    final _message = json['message'] as String?;
    final _details = (json['details'] as List?)?.map((e) => protobufAny.fromJson(e as Map<String, dynamic>)).toList();
    return rpcStatus(
      code: _code,
      message: _message,
      details: _details,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    if (code != null) {
      _json['code'] = code;
    }
    if (message != null) {
      _json['message'] = message;
    }
    if (details != null) {
      _json['details'] = details?.map((e) => e.toJson()).toList();
    }
    return _json;
  }
}

class v1AcceptInvitationIntent {
  /// Unique identifier for a given Invitation object.
  final String invitationId;
  /// Unique identifier for a given User.
  final String userId;
  /// WebAuthN hardware devices that can be used to log in to the Turnkey web app.
  final v1AuthenticatorParams authenticator;

  const v1AcceptInvitationIntent({
    required  this.invitationId,
    required  this.userId,
    required  this.authenticator,
  });

  factory v1AcceptInvitationIntent.fromJson(Map<String, dynamic> json) {
    final _invitationId = json['invitationId'] as String;
    final _userId = json['userId'] as String;
    final _authenticator = v1AuthenticatorParams.fromJson(json['authenticator'] as Map<String, dynamic>);
    return v1AcceptInvitationIntent(
      invitationId: _invitationId,
      userId: _userId,
      authenticator: _authenticator,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['invitationId'] = invitationId;
    _json['userId'] = userId;
    _json['authenticator'] = authenticator.toJson();
    return _json;
  }
}

class v1AcceptInvitationIntentV2 {
  /// Unique identifier for a given Invitation object.
  final String invitationId;
  /// Unique identifier for a given User.
  final String userId;
  /// WebAuthN hardware devices that can be used to log in to the Turnkey web app.
  final v1AuthenticatorParamsV2 authenticator;

  const v1AcceptInvitationIntentV2({
    required  this.invitationId,
    required  this.userId,
    required  this.authenticator,
  });

  factory v1AcceptInvitationIntentV2.fromJson(Map<String, dynamic> json) {
    final _invitationId = json['invitationId'] as String;
    final _userId = json['userId'] as String;
    final _authenticator = v1AuthenticatorParamsV2.fromJson(json['authenticator'] as Map<String, dynamic>);
    return v1AcceptInvitationIntentV2(
      invitationId: _invitationId,
      userId: _userId,
      authenticator: _authenticator,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['invitationId'] = invitationId;
    _json['userId'] = userId;
    _json['authenticator'] = authenticator.toJson();
    return _json;
  }
}

class v1AcceptInvitationResult {
  /// Unique identifier for a given Invitation.
  final String invitationId;
  /// Unique identifier for a given User.
  final String userId;

  const v1AcceptInvitationResult({
    required  this.invitationId,
    required  this.userId,
  });

  factory v1AcceptInvitationResult.fromJson(Map<String, dynamic> json) {
    final _invitationId = json['invitationId'] as String;
    final _userId = json['userId'] as String;
    return v1AcceptInvitationResult(
      invitationId: _invitationId,
      userId: _userId,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['invitationId'] = invitationId;
    _json['userId'] = userId;
    return _json;
  }
}

class v1Activity {
  /// Unique identifier for a given Activity object.
  final String id;
  /// Unique identifier for a given Organization.
  final String organizationId;
  /// The current processing status of a specified Activity.
  final v1ActivityStatus status;
  /// Type of Activity, such as Add User, or Sign Transaction.
  final v1ActivityType type;
  /// Intent object crafted by Turnkey based on the user request, used to assess the permissibility of an action.
  final v1Intent intent;
  /// Result of the intended action.
  final v1Result result;
  /// A list of objects representing a particular User's approval or rejection of a Consensus request, including all relevant metadata.
  final List<v1Vote> votes;
  /// A list of App Proofs generated by enclaves during activity execution, providing verifiable attestations of performed operations.
  final List<v1AppProof>? appProofs;
  /// An artifact verifying a User's action.
  final String fingerprint;
  final bool canApprove;
  final bool canReject;
  final externaldatav1Timestamp createdAt;
  final externaldatav1Timestamp updatedAt;
  /// Failure reason of the intended action.
  final rpcStatus? failure;

  const v1Activity({
    required  this.id,
    required  this.organizationId,
    required  this.status,
    required  this.type,
    required  this.intent,
    required  this.result,
    required  this.votes,
     this.appProofs,
    required  this.fingerprint,
    required  this.canApprove,
    required  this.canReject,
    required  this.createdAt,
    required  this.updatedAt,
     this.failure,
  });

  factory v1Activity.fromJson(Map<String, dynamic> json) {
    final _id = json['id'] as String;
    final _organizationId = json['organizationId'] as String;
    final _status = v1ActivityStatusFromJson(json['status']);
    final _type = v1ActivityTypeFromJson(json['type']);
    final _intent = v1Intent.fromJson(json['intent'] as Map<String, dynamic>);
    final _result = v1Result.fromJson(json['result'] as Map<String, dynamic>);
    final _votes = (json['votes'] as List).map((e) => v1Vote.fromJson(e as Map<String, dynamic>)).toList();
    final _appProofs = (json['appProofs'] as List?)?.map((e) => v1AppProof.fromJson(e as Map<String, dynamic>)).toList();
    final _fingerprint = json['fingerprint'] as String;
    final _canApprove = json['canApprove'] as bool;
    final _canReject = json['canReject'] as bool;
    final _createdAt = externaldatav1Timestamp.fromJson(json['createdAt'] as Map<String, dynamic>);
    final _updatedAt = externaldatav1Timestamp.fromJson(json['updatedAt'] as Map<String, dynamic>);
    final _failure = json['failure'] == null ? null : rpcStatus.fromJson(json['failure'] as Map<String, dynamic>);
    return v1Activity(
      id: _id,
      organizationId: _organizationId,
      status: _status,
      type: _type,
      intent: _intent,
      result: _result,
      votes: _votes,
      appProofs: _appProofs,
      fingerprint: _fingerprint,
      canApprove: _canApprove,
      canReject: _canReject,
      createdAt: _createdAt,
      updatedAt: _updatedAt,
      failure: _failure,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['id'] = id;
    _json['organizationId'] = organizationId;
    _json['status'] = v1ActivityStatusToJson(status);
    _json['type'] = v1ActivityTypeToJson(type);
    _json['intent'] = intent.toJson();
    _json['result'] = result.toJson();
    _json['votes'] = votes.map((e) => e.toJson()).toList();
    if (appProofs != null) {
      _json['appProofs'] = appProofs?.map((e) => e.toJson()).toList();
    }
    _json['fingerprint'] = fingerprint;
    _json['canApprove'] = canApprove;
    _json['canReject'] = canReject;
    _json['createdAt'] = createdAt.toJson();
    _json['updatedAt'] = updatedAt.toJson();
    if (failure != null) {
      _json['failure'] = failure?.toJson();
    }
    return _json;
  }
}

class v1ActivityResponse {
  /// An action that can be taken within the Turnkey infrastructure.
  final v1Activity activity;

  const v1ActivityResponse({
    required  this.activity,
  });

  factory v1ActivityResponse.fromJson(Map<String, dynamic> json) {
    final _activity = v1Activity.fromJson(json['activity'] as Map<String, dynamic>);
    return v1ActivityResponse(
      activity: _activity,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['activity'] = activity.toJson();
    return _json;
  }
}

class v1ApiKey {
  /// A User credential that can be used to authenticate to Turnkey.
  final externaldatav1Credential credential;
  /// Unique identifier for a given API Key.
  final String apiKeyId;
  /// Human-readable name for an API Key.
  final String apiKeyName;
  final externaldatav1Timestamp createdAt;
  final externaldatav1Timestamp updatedAt;
  /// Optional window (in seconds) indicating how long the API Key should last.
  final String? expirationSeconds;

  const v1ApiKey({
    required  this.credential,
    required  this.apiKeyId,
    required  this.apiKeyName,
    required  this.createdAt,
    required  this.updatedAt,
     this.expirationSeconds,
  });

  factory v1ApiKey.fromJson(Map<String, dynamic> json) {
    final _credential = externaldatav1Credential.fromJson(json['credential'] as Map<String, dynamic>);
    final _apiKeyId = json['apiKeyId'] as String;
    final _apiKeyName = json['apiKeyName'] as String;
    final _createdAt = externaldatav1Timestamp.fromJson(json['createdAt'] as Map<String, dynamic>);
    final _updatedAt = externaldatav1Timestamp.fromJson(json['updatedAt'] as Map<String, dynamic>);
    final _expirationSeconds = json['expirationSeconds'] as String?;
    return v1ApiKey(
      credential: _credential,
      apiKeyId: _apiKeyId,
      apiKeyName: _apiKeyName,
      createdAt: _createdAt,
      updatedAt: _updatedAt,
      expirationSeconds: _expirationSeconds,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['credential'] = credential.toJson();
    _json['apiKeyId'] = apiKeyId;
    _json['apiKeyName'] = apiKeyName;
    _json['createdAt'] = createdAt.toJson();
    _json['updatedAt'] = updatedAt.toJson();
    if (expirationSeconds != null) {
      _json['expirationSeconds'] = expirationSeconds;
    }
    return _json;
  }
}

class v1ApiKeyParamsV2 {
  /// Human-readable name for an API Key.
  final String apiKeyName;
  /// The public component of a cryptographic key pair used to sign messages and transactions.
  final String publicKey;
  /// The curve type to be used for processing API key signatures.
  final v1ApiKeyCurve curveType;
  /// Optional window (in seconds) indicating how long the API Key should last.
  final String? expirationSeconds;

  const v1ApiKeyParamsV2({
    required  this.apiKeyName,
    required  this.publicKey,
    required  this.curveType,
     this.expirationSeconds,
  });

  factory v1ApiKeyParamsV2.fromJson(Map<String, dynamic> json) {
    final _apiKeyName = json['apiKeyName'] as String;
    final _publicKey = json['publicKey'] as String;
    final _curveType = v1ApiKeyCurveFromJson(json['curveType']);
    final _expirationSeconds = json['expirationSeconds'] as String?;
    return v1ApiKeyParamsV2(
      apiKeyName: _apiKeyName,
      publicKey: _publicKey,
      curveType: _curveType,
      expirationSeconds: _expirationSeconds,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['apiKeyName'] = apiKeyName;
    _json['publicKey'] = publicKey;
    _json['curveType'] = v1ApiKeyCurveToJson(curveType);
    if (expirationSeconds != null) {
      _json['expirationSeconds'] = expirationSeconds;
    }
    return _json;
  }
}

class v1ApiOnlyUserParams {
  /// The name of the new API-only User.
  final String userName;
  /// The email address for this API-only User (optional).
  final String? userEmail;
  /// A list of tags assigned to the new API-only User. This field, if not needed, should be an empty array in your request body.
  final List<String> userTags;
  /// A list of API Key parameters. This field, if not needed, should be an empty array in your request body.
  final List<apiApiKeyParams> apiKeys;

  const v1ApiOnlyUserParams({
    required  this.userName,
     this.userEmail,
    required  this.userTags,
    required  this.apiKeys,
  });

  factory v1ApiOnlyUserParams.fromJson(Map<String, dynamic> json) {
    final _userName = json['userName'] as String;
    final _userEmail = json['userEmail'] as String?;
    final _userTags = (json['userTags'] as List).map((e) => e as String).toList();
    final _apiKeys = (json['apiKeys'] as List).map((e) => apiApiKeyParams.fromJson(e as Map<String, dynamic>)).toList();
    return v1ApiOnlyUserParams(
      userName: _userName,
      userEmail: _userEmail,
      userTags: _userTags,
      apiKeys: _apiKeys,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['userName'] = userName;
    if (userEmail != null) {
      _json['userEmail'] = userEmail;
    }
    _json['userTags'] = userTags;
    _json['apiKeys'] = apiKeys.map((e) => e.toJson()).toList();
    return _json;
  }
}

class v1AppProof {
  /// Scheme of signing key.
  final externaldatav1SignatureScheme scheme;
  /// Ephemeral public key.
  final String publicKey;
  /// JSON serialized AppProofPayload.
  final String proofPayload;
  /// Signature over hashed proof_payload.
  final String signature;

  const v1AppProof({
    required  this.scheme,
    required  this.publicKey,
    required  this.proofPayload,
    required  this.signature,
  });

  factory v1AppProof.fromJson(Map<String, dynamic> json) {
    final _scheme = externaldatav1SignatureSchemeFromJson(json['scheme']);
    final _publicKey = json['publicKey'] as String;
    final _proofPayload = json['proofPayload'] as String;
    final _signature = json['signature'] as String;
    return v1AppProof(
      scheme: _scheme,
      publicKey: _publicKey,
      proofPayload: _proofPayload,
      signature: _signature,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['scheme'] = externaldatav1SignatureSchemeToJson(scheme);
    _json['publicKey'] = publicKey;
    _json['proofPayload'] = proofPayload;
    _json['signature'] = signature;
    return _json;
  }
}

class v1ApproveActivityIntent {
  /// An artifact verifying a User's action.
  final String fingerprint;

  const v1ApproveActivityIntent({
    required  this.fingerprint,
  });

  factory v1ApproveActivityIntent.fromJson(Map<String, dynamic> json) {
    final _fingerprint = json['fingerprint'] as String;
    return v1ApproveActivityIntent(
      fingerprint: _fingerprint,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['fingerprint'] = fingerprint;
    return _json;
  }
}

class v1ApproveActivityRequest {
  final String type;
  /// Timestamp (in milliseconds) of the request, used to verify liveness of user requests.
  final String timestampMs;
  /// Unique identifier for a given Organization.
  final String organizationId;
  final v1ApproveActivityIntent parameters;
  final bool? generateAppProofs;

  const v1ApproveActivityRequest({
    required  this.type,
    required  this.timestampMs,
    required  this.organizationId,
    required  this.parameters,
     this.generateAppProofs,
  });

  factory v1ApproveActivityRequest.fromJson(Map<String, dynamic> json) {
    final _type = json['type'] as String;
    final _timestampMs = json['timestampMs'] as String;
    final _organizationId = json['organizationId'] as String;
    final _parameters = v1ApproveActivityIntent.fromJson(json['parameters'] as Map<String, dynamic>);
    final _generateAppProofs = json['generateAppProofs'] as bool?;
    return v1ApproveActivityRequest(
      type: _type,
      timestampMs: _timestampMs,
      organizationId: _organizationId,
      parameters: _parameters,
      generateAppProofs: _generateAppProofs,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['type'] = type;
    _json['timestampMs'] = timestampMs;
    _json['organizationId'] = organizationId;
    _json['parameters'] = parameters.toJson();
    if (generateAppProofs != null) {
      _json['generateAppProofs'] = generateAppProofs;
    }
    return _json;
  }
}

class v1AssetBalance {
  final String? caip19;
  final String? symbol;
  final String? balance;
  final num? decimals;

  const v1AssetBalance({
     this.caip19,
     this.symbol,
     this.balance,
     this.decimals,
  });

  factory v1AssetBalance.fromJson(Map<String, dynamic> json) {
    final _caip19 = json['caip19'] as String?;
    final _symbol = json['symbol'] as String?;
    final _balance = json['balance'] as String?;
    final _decimals = json['decimals'] as num?;
    return v1AssetBalance(
      caip19: _caip19,
      symbol: _symbol,
      balance: _balance,
      decimals: _decimals,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    if (caip19 != null) {
      _json['caip19'] = caip19;
    }
    if (symbol != null) {
      _json['symbol'] = symbol;
    }
    if (balance != null) {
      _json['balance'] = balance;
    }
    if (decimals != null) {
      _json['decimals'] = decimals;
    }
    return _json;
  }
}

class v1Attestation {
  /// The cbor encoded then base64 url encoded id of the credential.
  final String credentialId;
  /// A base64 url encoded payload containing metadata about the signing context and the challenge.
  final String clientDataJson;
  /// A base64 url encoded payload containing authenticator data and any attestation the webauthn provider chooses.
  final String attestationObject;
  /// The type of authenticator transports.
  final List<v1AuthenticatorTransport> transports;

  const v1Attestation({
    required  this.credentialId,
    required  this.clientDataJson,
    required  this.attestationObject,
    required  this.transports,
  });

  factory v1Attestation.fromJson(Map<String, dynamic> json) {
    final _credentialId = json['credentialId'] as String;
    final _clientDataJson = json['clientDataJson'] as String;
    final _attestationObject = json['attestationObject'] as String;
    final _transports = (json['transports'] as List).map((e) => v1AuthenticatorTransportFromJson(e)).toList();
    return v1Attestation(
      credentialId: _credentialId,
      clientDataJson: _clientDataJson,
      attestationObject: _attestationObject,
      transports: _transports,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['credentialId'] = credentialId;
    _json['clientDataJson'] = clientDataJson;
    _json['attestationObject'] = attestationObject;
    _json['transports'] = transports.map((e) => v1AuthenticatorTransportToJson(e)).toList();
    return _json;
  }
}

class v1Authenticator {
  /// Types of transports that may be used by an Authenticator (e.g., USB, NFC, BLE).
  final List<v1AuthenticatorTransport> transports;
  final String attestationType;
  /// Identifier indicating the type of the Security Key.
  final String aaguid;
  /// Unique identifier for a WebAuthn credential.
  final String credentialId;
  /// The type of Authenticator device.
  final String model;
  /// A User credential that can be used to authenticate to Turnkey.
  final externaldatav1Credential credential;
  /// Unique identifier for a given Authenticator.
  final String authenticatorId;
  /// Human-readable name for an Authenticator.
  final String authenticatorName;
  final externaldatav1Timestamp createdAt;
  final externaldatav1Timestamp updatedAt;

  const v1Authenticator({
    required  this.transports,
    required  this.attestationType,
    required  this.aaguid,
    required  this.credentialId,
    required  this.model,
    required  this.credential,
    required  this.authenticatorId,
    required  this.authenticatorName,
    required  this.createdAt,
    required  this.updatedAt,
  });

  factory v1Authenticator.fromJson(Map<String, dynamic> json) {
    final _transports = (json['transports'] as List).map((e) => v1AuthenticatorTransportFromJson(e)).toList();
    final _attestationType = json['attestationType'] as String;
    final _aaguid = json['aaguid'] as String;
    final _credentialId = json['credentialId'] as String;
    final _model = json['model'] as String;
    final _credential = externaldatav1Credential.fromJson(json['credential'] as Map<String, dynamic>);
    final _authenticatorId = json['authenticatorId'] as String;
    final _authenticatorName = json['authenticatorName'] as String;
    final _createdAt = externaldatav1Timestamp.fromJson(json['createdAt'] as Map<String, dynamic>);
    final _updatedAt = externaldatav1Timestamp.fromJson(json['updatedAt'] as Map<String, dynamic>);
    return v1Authenticator(
      transports: _transports,
      attestationType: _attestationType,
      aaguid: _aaguid,
      credentialId: _credentialId,
      model: _model,
      credential: _credential,
      authenticatorId: _authenticatorId,
      authenticatorName: _authenticatorName,
      createdAt: _createdAt,
      updatedAt: _updatedAt,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['transports'] = transports.map((e) => v1AuthenticatorTransportToJson(e)).toList();
    _json['attestationType'] = attestationType;
    _json['aaguid'] = aaguid;
    _json['credentialId'] = credentialId;
    _json['model'] = model;
    _json['credential'] = credential.toJson();
    _json['authenticatorId'] = authenticatorId;
    _json['authenticatorName'] = authenticatorName;
    _json['createdAt'] = createdAt.toJson();
    _json['updatedAt'] = updatedAt.toJson();
    return _json;
  }
}

class v1AuthenticatorAttestationResponse {
  final String clientDataJson;
  final String attestationObject;
  final List<v1AuthenticatorTransport>? transports;
  final String? authenticatorAttachment;

  const v1AuthenticatorAttestationResponse({
    required  this.clientDataJson,
    required  this.attestationObject,
     this.transports,
     this.authenticatorAttachment,
  });

  factory v1AuthenticatorAttestationResponse.fromJson(Map<String, dynamic> json) {
    final _clientDataJson = json['clientDataJson'] as String;
    final _attestationObject = json['attestationObject'] as String;
    final _transports = (json['transports'] as List?)?.map((e) => v1AuthenticatorTransportFromJson(e)).toList();
    final _authenticatorAttachment = json['authenticatorAttachment'] as String?;
    return v1AuthenticatorAttestationResponse(
      clientDataJson: _clientDataJson,
      attestationObject: _attestationObject,
      transports: _transports,
      authenticatorAttachment: _authenticatorAttachment,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['clientDataJson'] = clientDataJson;
    _json['attestationObject'] = attestationObject;
    if (transports != null) {
      _json['transports'] = transports?.map((e) => v1AuthenticatorTransportToJson(e)).toList();
    }
    if (authenticatorAttachment != null) {
      _json['authenticatorAttachment'] = authenticatorAttachment;
    }
    return _json;
  }
}

class v1AuthenticatorParams {
  /// Human-readable name for an Authenticator.
  final String authenticatorName;
  /// Unique identifier for a given User.
  final String userId;
  final v1PublicKeyCredentialWithAttestation attestation;
  /// Challenge presented for authentication purposes.
  final String challenge;

  const v1AuthenticatorParams({
    required  this.authenticatorName,
    required  this.userId,
    required  this.attestation,
    required  this.challenge,
  });

  factory v1AuthenticatorParams.fromJson(Map<String, dynamic> json) {
    final _authenticatorName = json['authenticatorName'] as String;
    final _userId = json['userId'] as String;
    final _attestation = v1PublicKeyCredentialWithAttestation.fromJson(json['attestation'] as Map<String, dynamic>);
    final _challenge = json['challenge'] as String;
    return v1AuthenticatorParams(
      authenticatorName: _authenticatorName,
      userId: _userId,
      attestation: _attestation,
      challenge: _challenge,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['authenticatorName'] = authenticatorName;
    _json['userId'] = userId;
    _json['attestation'] = attestation.toJson();
    _json['challenge'] = challenge;
    return _json;
  }
}

class v1AuthenticatorParamsV2 {
  /// Human-readable name for an Authenticator.
  final String authenticatorName;
  /// Challenge presented for authentication purposes.
  final String challenge;
  /// The attestation that proves custody of the authenticator and provides metadata about it.
  final v1Attestation attestation;

  const v1AuthenticatorParamsV2({
    required  this.authenticatorName,
    required  this.challenge,
    required  this.attestation,
  });

  factory v1AuthenticatorParamsV2.fromJson(Map<String, dynamic> json) {
    final _authenticatorName = json['authenticatorName'] as String;
    final _challenge = json['challenge'] as String;
    final _attestation = v1Attestation.fromJson(json['attestation'] as Map<String, dynamic>);
    return v1AuthenticatorParamsV2(
      authenticatorName: _authenticatorName,
      challenge: _challenge,
      attestation: _attestation,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['authenticatorName'] = authenticatorName;
    _json['challenge'] = challenge;
    _json['attestation'] = attestation.toJson();
    return _json;
  }
}

class v1BootProof {
  /// The hex encoded Ephemeral Public Key.
  final String ephemeralPublicKeyHex;
  /// The DER encoded COSE Sign1 struct Attestation doc.
  final String awsAttestationDocB64;
  /// The borsch serialized base64 encoded Manifest.
  final String qosManifestB64;
  /// The borsch serialized base64 encoded Manifest Envelope.
  final String qosManifestEnvelopeB64;
  /// The label under which the enclave app was deployed.
  final String deploymentLabel;
  /// Name of the enclave app
  final String enclaveApp;
  /// Owner of the app i.e. 'tkhq'
  final String owner;
  final externaldatav1Timestamp createdAt;

  const v1BootProof({
    required  this.ephemeralPublicKeyHex,
    required  this.awsAttestationDocB64,
    required  this.qosManifestB64,
    required  this.qosManifestEnvelopeB64,
    required  this.deploymentLabel,
    required  this.enclaveApp,
    required  this.owner,
    required  this.createdAt,
  });

  factory v1BootProof.fromJson(Map<String, dynamic> json) {
    final _ephemeralPublicKeyHex = json['ephemeralPublicKeyHex'] as String;
    final _awsAttestationDocB64 = json['awsAttestationDocB64'] as String;
    final _qosManifestB64 = json['qosManifestB64'] as String;
    final _qosManifestEnvelopeB64 = json['qosManifestEnvelopeB64'] as String;
    final _deploymentLabel = json['deploymentLabel'] as String;
    final _enclaveApp = json['enclaveApp'] as String;
    final _owner = json['owner'] as String;
    final _createdAt = externaldatav1Timestamp.fromJson(json['createdAt'] as Map<String, dynamic>);
    return v1BootProof(
      ephemeralPublicKeyHex: _ephemeralPublicKeyHex,
      awsAttestationDocB64: _awsAttestationDocB64,
      qosManifestB64: _qosManifestB64,
      qosManifestEnvelopeB64: _qosManifestEnvelopeB64,
      deploymentLabel: _deploymentLabel,
      enclaveApp: _enclaveApp,
      owner: _owner,
      createdAt: _createdAt,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['ephemeralPublicKeyHex'] = ephemeralPublicKeyHex;
    _json['awsAttestationDocB64'] = awsAttestationDocB64;
    _json['qosManifestB64'] = qosManifestB64;
    _json['qosManifestEnvelopeB64'] = qosManifestEnvelopeB64;
    _json['deploymentLabel'] = deploymentLabel;
    _json['enclaveApp'] = enclaveApp;
    _json['owner'] = owner;
    _json['createdAt'] = createdAt.toJson();
    return _json;
  }
}

class v1BootProofResponse {
  final v1BootProof bootProof;

  const v1BootProofResponse({
    required  this.bootProof,
  });

  factory v1BootProofResponse.fromJson(Map<String, dynamic> json) {
    final _bootProof = v1BootProof.fromJson(json['bootProof'] as Map<String, dynamic>);
    return v1BootProofResponse(
      bootProof: _bootProof,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['bootProof'] = bootProof.toJson();
    return _json;
  }
}

class v1ClientSignature {
  /// The public component of a cryptographic key pair used to create the signature.
  final String publicKey;
  /// The signature scheme used to generate the client signature.
  final v1ClientSignatureScheme scheme;
  /// The message that was signed.
  final String message;
  /// The cryptographic signature over the message.
  final String signature;

  const v1ClientSignature({
    required  this.publicKey,
    required  this.scheme,
    required  this.message,
    required  this.signature,
  });

  factory v1ClientSignature.fromJson(Map<String, dynamic> json) {
    final _publicKey = json['publicKey'] as String;
    final _scheme = v1ClientSignatureSchemeFromJson(json['scheme']);
    final _message = json['message'] as String;
    final _signature = json['signature'] as String;
    return v1ClientSignature(
      publicKey: _publicKey,
      scheme: _scheme,
      message: _message,
      signature: _signature,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['publicKey'] = publicKey;
    _json['scheme'] = v1ClientSignatureSchemeToJson(scheme);
    _json['message'] = message;
    _json['signature'] = signature;
    return _json;
  }
}

class v1Config {
  final List<v1Feature>? features;
  final externaldatav1Quorum? quorum;

  const v1Config({
     this.features,
     this.quorum,
  });

  factory v1Config.fromJson(Map<String, dynamic> json) {
    final _features = (json['features'] as List?)?.map((e) => v1Feature.fromJson(e as Map<String, dynamic>)).toList();
    final _quorum = json['quorum'] == null ? null : externaldatav1Quorum.fromJson(json['quorum'] as Map<String, dynamic>);
    return v1Config(
      features: _features,
      quorum: _quorum,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    if (features != null) {
      _json['features'] = features?.map((e) => e.toJson()).toList();
    }
    if (quorum != null) {
      _json['quorum'] = quorum?.toJson();
    }
    return _json;
  }
}

class v1CreateApiKeysIntent {
  /// A list of API Keys.
  final List<apiApiKeyParams> apiKeys;
  /// Unique identifier for a given User.
  final String userId;

  const v1CreateApiKeysIntent({
    required  this.apiKeys,
    required  this.userId,
  });

  factory v1CreateApiKeysIntent.fromJson(Map<String, dynamic> json) {
    final _apiKeys = (json['apiKeys'] as List).map((e) => apiApiKeyParams.fromJson(e as Map<String, dynamic>)).toList();
    final _userId = json['userId'] as String;
    return v1CreateApiKeysIntent(
      apiKeys: _apiKeys,
      userId: _userId,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['apiKeys'] = apiKeys.map((e) => e.toJson()).toList();
    _json['userId'] = userId;
    return _json;
  }
}

class v1CreateApiKeysIntentV2 {
  /// A list of API Keys.
  final List<v1ApiKeyParamsV2> apiKeys;
  /// Unique identifier for a given User.
  final String userId;

  const v1CreateApiKeysIntentV2({
    required  this.apiKeys,
    required  this.userId,
  });

  factory v1CreateApiKeysIntentV2.fromJson(Map<String, dynamic> json) {
    final _apiKeys = (json['apiKeys'] as List).map((e) => v1ApiKeyParamsV2.fromJson(e as Map<String, dynamic>)).toList();
    final _userId = json['userId'] as String;
    return v1CreateApiKeysIntentV2(
      apiKeys: _apiKeys,
      userId: _userId,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['apiKeys'] = apiKeys.map((e) => e.toJson()).toList();
    _json['userId'] = userId;
    return _json;
  }
}

class v1CreateApiKeysRequest {
  final String type;
  /// Timestamp (in milliseconds) of the request, used to verify liveness of user requests.
  final String timestampMs;
  /// Unique identifier for a given Organization.
  final String organizationId;
  final v1CreateApiKeysIntentV2 parameters;
  final bool? generateAppProofs;

  const v1CreateApiKeysRequest({
    required  this.type,
    required  this.timestampMs,
    required  this.organizationId,
    required  this.parameters,
     this.generateAppProofs,
  });

  factory v1CreateApiKeysRequest.fromJson(Map<String, dynamic> json) {
    final _type = json['type'] as String;
    final _timestampMs = json['timestampMs'] as String;
    final _organizationId = json['organizationId'] as String;
    final _parameters = v1CreateApiKeysIntentV2.fromJson(json['parameters'] as Map<String, dynamic>);
    final _generateAppProofs = json['generateAppProofs'] as bool?;
    return v1CreateApiKeysRequest(
      type: _type,
      timestampMs: _timestampMs,
      organizationId: _organizationId,
      parameters: _parameters,
      generateAppProofs: _generateAppProofs,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['type'] = type;
    _json['timestampMs'] = timestampMs;
    _json['organizationId'] = organizationId;
    _json['parameters'] = parameters.toJson();
    if (generateAppProofs != null) {
      _json['generateAppProofs'] = generateAppProofs;
    }
    return _json;
  }
}

class v1CreateApiKeysResult {
  /// A list of API Key IDs.
  final List<String> apiKeyIds;

  const v1CreateApiKeysResult({
    required  this.apiKeyIds,
  });

  factory v1CreateApiKeysResult.fromJson(Map<String, dynamic> json) {
    final _apiKeyIds = (json['apiKeyIds'] as List).map((e) => e as String).toList();
    return v1CreateApiKeysResult(
      apiKeyIds: _apiKeyIds,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['apiKeyIds'] = apiKeyIds;
    return _json;
  }
}

class v1CreateApiOnlyUsersIntent {
  /// A list of API-only Users to create.
  final List<v1ApiOnlyUserParams> apiOnlyUsers;

  const v1CreateApiOnlyUsersIntent({
    required  this.apiOnlyUsers,
  });

  factory v1CreateApiOnlyUsersIntent.fromJson(Map<String, dynamic> json) {
    final _apiOnlyUsers = (json['apiOnlyUsers'] as List).map((e) => v1ApiOnlyUserParams.fromJson(e as Map<String, dynamic>)).toList();
    return v1CreateApiOnlyUsersIntent(
      apiOnlyUsers: _apiOnlyUsers,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['apiOnlyUsers'] = apiOnlyUsers.map((e) => e.toJson()).toList();
    return _json;
  }
}

class v1CreateApiOnlyUsersRequest {
  final String type;
  /// Timestamp (in milliseconds) of the request, used to verify liveness of user requests.
  final String timestampMs;
  /// Unique identifier for a given Organization.
  final String organizationId;
  final v1CreateApiOnlyUsersIntent parameters;
  final bool? generateAppProofs;

  const v1CreateApiOnlyUsersRequest({
    required  this.type,
    required  this.timestampMs,
    required  this.organizationId,
    required  this.parameters,
     this.generateAppProofs,
  });

  factory v1CreateApiOnlyUsersRequest.fromJson(Map<String, dynamic> json) {
    final _type = json['type'] as String;
    final _timestampMs = json['timestampMs'] as String;
    final _organizationId = json['organizationId'] as String;
    final _parameters = v1CreateApiOnlyUsersIntent.fromJson(json['parameters'] as Map<String, dynamic>);
    final _generateAppProofs = json['generateAppProofs'] as bool?;
    return v1CreateApiOnlyUsersRequest(
      type: _type,
      timestampMs: _timestampMs,
      organizationId: _organizationId,
      parameters: _parameters,
      generateAppProofs: _generateAppProofs,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['type'] = type;
    _json['timestampMs'] = timestampMs;
    _json['organizationId'] = organizationId;
    _json['parameters'] = parameters.toJson();
    if (generateAppProofs != null) {
      _json['generateAppProofs'] = generateAppProofs;
    }
    return _json;
  }
}

class v1CreateApiOnlyUsersResult {
  /// A list of API-only User IDs.
  final List<String> userIds;

  const v1CreateApiOnlyUsersResult({
    required  this.userIds,
  });

  factory v1CreateApiOnlyUsersResult.fromJson(Map<String, dynamic> json) {
    final _userIds = (json['userIds'] as List).map((e) => e as String).toList();
    return v1CreateApiOnlyUsersResult(
      userIds: _userIds,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['userIds'] = userIds;
    return _json;
  }
}

class v1CreateAuthenticatorsIntent {
  /// A list of Authenticators.
  final List<v1AuthenticatorParams> authenticators;
  /// Unique identifier for a given User.
  final String userId;

  const v1CreateAuthenticatorsIntent({
    required  this.authenticators,
    required  this.userId,
  });

  factory v1CreateAuthenticatorsIntent.fromJson(Map<String, dynamic> json) {
    final _authenticators = (json['authenticators'] as List).map((e) => v1AuthenticatorParams.fromJson(e as Map<String, dynamic>)).toList();
    final _userId = json['userId'] as String;
    return v1CreateAuthenticatorsIntent(
      authenticators: _authenticators,
      userId: _userId,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['authenticators'] = authenticators.map((e) => e.toJson()).toList();
    _json['userId'] = userId;
    return _json;
  }
}

class v1CreateAuthenticatorsIntentV2 {
  /// A list of Authenticators.
  final List<v1AuthenticatorParamsV2> authenticators;
  /// Unique identifier for a given User.
  final String userId;

  const v1CreateAuthenticatorsIntentV2({
    required  this.authenticators,
    required  this.userId,
  });

  factory v1CreateAuthenticatorsIntentV2.fromJson(Map<String, dynamic> json) {
    final _authenticators = (json['authenticators'] as List).map((e) => v1AuthenticatorParamsV2.fromJson(e as Map<String, dynamic>)).toList();
    final _userId = json['userId'] as String;
    return v1CreateAuthenticatorsIntentV2(
      authenticators: _authenticators,
      userId: _userId,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['authenticators'] = authenticators.map((e) => e.toJson()).toList();
    _json['userId'] = userId;
    return _json;
  }
}

class v1CreateAuthenticatorsRequest {
  final String type;
  /// Timestamp (in milliseconds) of the request, used to verify liveness of user requests.
  final String timestampMs;
  /// Unique identifier for a given Organization.
  final String organizationId;
  final v1CreateAuthenticatorsIntentV2 parameters;
  final bool? generateAppProofs;

  const v1CreateAuthenticatorsRequest({
    required  this.type,
    required  this.timestampMs,
    required  this.organizationId,
    required  this.parameters,
     this.generateAppProofs,
  });

  factory v1CreateAuthenticatorsRequest.fromJson(Map<String, dynamic> json) {
    final _type = json['type'] as String;
    final _timestampMs = json['timestampMs'] as String;
    final _organizationId = json['organizationId'] as String;
    final _parameters = v1CreateAuthenticatorsIntentV2.fromJson(json['parameters'] as Map<String, dynamic>);
    final _generateAppProofs = json['generateAppProofs'] as bool?;
    return v1CreateAuthenticatorsRequest(
      type: _type,
      timestampMs: _timestampMs,
      organizationId: _organizationId,
      parameters: _parameters,
      generateAppProofs: _generateAppProofs,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['type'] = type;
    _json['timestampMs'] = timestampMs;
    _json['organizationId'] = organizationId;
    _json['parameters'] = parameters.toJson();
    if (generateAppProofs != null) {
      _json['generateAppProofs'] = generateAppProofs;
    }
    return _json;
  }
}

class v1CreateAuthenticatorsResult {
  /// A list of Authenticator IDs.
  final List<String> authenticatorIds;

  const v1CreateAuthenticatorsResult({
    required  this.authenticatorIds,
  });

  factory v1CreateAuthenticatorsResult.fromJson(Map<String, dynamic> json) {
    final _authenticatorIds = (json['authenticatorIds'] as List).map((e) => e as String).toList();
    return v1CreateAuthenticatorsResult(
      authenticatorIds: _authenticatorIds,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['authenticatorIds'] = authenticatorIds;
    return _json;
  }
}

class v1CreateFiatOnRampCredentialIntent {
  /// The fiat on-ramp provider
  final v1FiatOnRampProvider onrampProvider;
  /// Project ID for the on-ramp provider. Some providers, like Coinbase, require this additional identifier
  final String? projectId;
  /// Publishable API key for the on-ramp provider
  final String publishableApiKey;
  /// Secret API key for the on-ramp provider encrypted to our on-ramp encryption public key
  final String encryptedSecretApiKey;
  /// Private API key for the on-ramp provider encrypted to our on-ramp encryption public key. Some providers, like Coinbase, require this additional key.
  final String? encryptedPrivateApiKey;
  /// If the on-ramp credential is a sandbox credential
  final bool? sandboxMode;

  const v1CreateFiatOnRampCredentialIntent({
    required  this.onrampProvider,
     this.projectId,
    required  this.publishableApiKey,
    required  this.encryptedSecretApiKey,
     this.encryptedPrivateApiKey,
     this.sandboxMode,
  });

  factory v1CreateFiatOnRampCredentialIntent.fromJson(Map<String, dynamic> json) {
    final _onrampProvider = v1FiatOnRampProviderFromJson(json['onrampProvider']);
    final _projectId = json['projectId'] as String?;
    final _publishableApiKey = json['publishableApiKey'] as String;
    final _encryptedSecretApiKey = json['encryptedSecretApiKey'] as String;
    final _encryptedPrivateApiKey = json['encryptedPrivateApiKey'] as String?;
    final _sandboxMode = json['sandboxMode'] as bool?;
    return v1CreateFiatOnRampCredentialIntent(
      onrampProvider: _onrampProvider,
      projectId: _projectId,
      publishableApiKey: _publishableApiKey,
      encryptedSecretApiKey: _encryptedSecretApiKey,
      encryptedPrivateApiKey: _encryptedPrivateApiKey,
      sandboxMode: _sandboxMode,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['onrampProvider'] = v1FiatOnRampProviderToJson(onrampProvider);
    if (projectId != null) {
      _json['projectId'] = projectId;
    }
    _json['publishableApiKey'] = publishableApiKey;
    _json['encryptedSecretApiKey'] = encryptedSecretApiKey;
    if (encryptedPrivateApiKey != null) {
      _json['encryptedPrivateApiKey'] = encryptedPrivateApiKey;
    }
    if (sandboxMode != null) {
      _json['sandboxMode'] = sandboxMode;
    }
    return _json;
  }
}

class v1CreateFiatOnRampCredentialRequest {
  final String type;
  /// Timestamp (in milliseconds) of the request, used to verify liveness of user requests.
  final String timestampMs;
  /// Unique identifier for a given Organization.
  final String organizationId;
  final v1CreateFiatOnRampCredentialIntent parameters;
  final bool? generateAppProofs;

  const v1CreateFiatOnRampCredentialRequest({
    required  this.type,
    required  this.timestampMs,
    required  this.organizationId,
    required  this.parameters,
     this.generateAppProofs,
  });

  factory v1CreateFiatOnRampCredentialRequest.fromJson(Map<String, dynamic> json) {
    final _type = json['type'] as String;
    final _timestampMs = json['timestampMs'] as String;
    final _organizationId = json['organizationId'] as String;
    final _parameters = v1CreateFiatOnRampCredentialIntent.fromJson(json['parameters'] as Map<String, dynamic>);
    final _generateAppProofs = json['generateAppProofs'] as bool?;
    return v1CreateFiatOnRampCredentialRequest(
      type: _type,
      timestampMs: _timestampMs,
      organizationId: _organizationId,
      parameters: _parameters,
      generateAppProofs: _generateAppProofs,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['type'] = type;
    _json['timestampMs'] = timestampMs;
    _json['organizationId'] = organizationId;
    _json['parameters'] = parameters.toJson();
    if (generateAppProofs != null) {
      _json['generateAppProofs'] = generateAppProofs;
    }
    return _json;
  }
}

class v1CreateFiatOnRampCredentialResult {
  /// Unique identifier of the Fiat On-Ramp credential that was created
  final String fiatOnRampCredentialId;

  const v1CreateFiatOnRampCredentialResult({
    required  this.fiatOnRampCredentialId,
  });

  factory v1CreateFiatOnRampCredentialResult.fromJson(Map<String, dynamic> json) {
    final _fiatOnRampCredentialId = json['fiatOnRampCredentialId'] as String;
    return v1CreateFiatOnRampCredentialResult(
      fiatOnRampCredentialId: _fiatOnRampCredentialId,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['fiatOnRampCredentialId'] = fiatOnRampCredentialId;
    return _json;
  }
}

class v1CreateInvitationsIntent {
  /// A list of Invitations.
  final List<v1InvitationParams> invitations;

  const v1CreateInvitationsIntent({
    required  this.invitations,
  });

  factory v1CreateInvitationsIntent.fromJson(Map<String, dynamic> json) {
    final _invitations = (json['invitations'] as List).map((e) => v1InvitationParams.fromJson(e as Map<String, dynamic>)).toList();
    return v1CreateInvitationsIntent(
      invitations: _invitations,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['invitations'] = invitations.map((e) => e.toJson()).toList();
    return _json;
  }
}

class v1CreateInvitationsRequest {
  final String type;
  /// Timestamp (in milliseconds) of the request, used to verify liveness of user requests.
  final String timestampMs;
  /// Unique identifier for a given Organization.
  final String organizationId;
  final v1CreateInvitationsIntent parameters;
  final bool? generateAppProofs;

  const v1CreateInvitationsRequest({
    required  this.type,
    required  this.timestampMs,
    required  this.organizationId,
    required  this.parameters,
     this.generateAppProofs,
  });

  factory v1CreateInvitationsRequest.fromJson(Map<String, dynamic> json) {
    final _type = json['type'] as String;
    final _timestampMs = json['timestampMs'] as String;
    final _organizationId = json['organizationId'] as String;
    final _parameters = v1CreateInvitationsIntent.fromJson(json['parameters'] as Map<String, dynamic>);
    final _generateAppProofs = json['generateAppProofs'] as bool?;
    return v1CreateInvitationsRequest(
      type: _type,
      timestampMs: _timestampMs,
      organizationId: _organizationId,
      parameters: _parameters,
      generateAppProofs: _generateAppProofs,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['type'] = type;
    _json['timestampMs'] = timestampMs;
    _json['organizationId'] = organizationId;
    _json['parameters'] = parameters.toJson();
    if (generateAppProofs != null) {
      _json['generateAppProofs'] = generateAppProofs;
    }
    return _json;
  }
}

class v1CreateInvitationsResult {
  /// A list of Invitation IDs
  final List<String> invitationIds;

  const v1CreateInvitationsResult({
    required  this.invitationIds,
  });

  factory v1CreateInvitationsResult.fromJson(Map<String, dynamic> json) {
    final _invitationIds = (json['invitationIds'] as List).map((e) => e as String).toList();
    return v1CreateInvitationsResult(
      invitationIds: _invitationIds,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['invitationIds'] = invitationIds;
    return _json;
  }
}

class v1CreateOauth2CredentialIntent {
  /// The OAuth 2.0 provider
  final v1Oauth2Provider provider;
  /// The Client ID issued by the OAuth 2.0 provider
  final String clientId;
  /// The client secret issued by the OAuth 2.0 provider encrypted to the TLS Fetcher quorum key
  final String encryptedClientSecret;

  const v1CreateOauth2CredentialIntent({
    required  this.provider,
    required  this.clientId,
    required  this.encryptedClientSecret,
  });

  factory v1CreateOauth2CredentialIntent.fromJson(Map<String, dynamic> json) {
    final _provider = v1Oauth2ProviderFromJson(json['provider']);
    final _clientId = json['clientId'] as String;
    final _encryptedClientSecret = json['encryptedClientSecret'] as String;
    return v1CreateOauth2CredentialIntent(
      provider: _provider,
      clientId: _clientId,
      encryptedClientSecret: _encryptedClientSecret,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['provider'] = v1Oauth2ProviderToJson(provider);
    _json['clientId'] = clientId;
    _json['encryptedClientSecret'] = encryptedClientSecret;
    return _json;
  }
}

class v1CreateOauth2CredentialRequest {
  final String type;
  /// Timestamp (in milliseconds) of the request, used to verify liveness of user requests.
  final String timestampMs;
  /// Unique identifier for a given Organization.
  final String organizationId;
  final v1CreateOauth2CredentialIntent parameters;
  final bool? generateAppProofs;

  const v1CreateOauth2CredentialRequest({
    required  this.type,
    required  this.timestampMs,
    required  this.organizationId,
    required  this.parameters,
     this.generateAppProofs,
  });

  factory v1CreateOauth2CredentialRequest.fromJson(Map<String, dynamic> json) {
    final _type = json['type'] as String;
    final _timestampMs = json['timestampMs'] as String;
    final _organizationId = json['organizationId'] as String;
    final _parameters = v1CreateOauth2CredentialIntent.fromJson(json['parameters'] as Map<String, dynamic>);
    final _generateAppProofs = json['generateAppProofs'] as bool?;
    return v1CreateOauth2CredentialRequest(
      type: _type,
      timestampMs: _timestampMs,
      organizationId: _organizationId,
      parameters: _parameters,
      generateAppProofs: _generateAppProofs,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['type'] = type;
    _json['timestampMs'] = timestampMs;
    _json['organizationId'] = organizationId;
    _json['parameters'] = parameters.toJson();
    if (generateAppProofs != null) {
      _json['generateAppProofs'] = generateAppProofs;
    }
    return _json;
  }
}

class v1CreateOauth2CredentialResult {
  /// Unique identifier of the OAuth 2.0 credential that was created
  final String oauth2CredentialId;

  const v1CreateOauth2CredentialResult({
    required  this.oauth2CredentialId,
  });

  factory v1CreateOauth2CredentialResult.fromJson(Map<String, dynamic> json) {
    final _oauth2CredentialId = json['oauth2CredentialId'] as String;
    return v1CreateOauth2CredentialResult(
      oauth2CredentialId: _oauth2CredentialId,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['oauth2CredentialId'] = oauth2CredentialId;
    return _json;
  }
}

class v1CreateOauthProvidersIntent {
  /// The ID of the User to add an Oauth provider to
  final String userId;
  /// A list of Oauth providers.
  final List<v1OauthProviderParams> oauthProviders;

  const v1CreateOauthProvidersIntent({
    required  this.userId,
    required  this.oauthProviders,
  });

  factory v1CreateOauthProvidersIntent.fromJson(Map<String, dynamic> json) {
    final _userId = json['userId'] as String;
    final _oauthProviders = (json['oauthProviders'] as List).map((e) => v1OauthProviderParams.fromJson(e as Map<String, dynamic>)).toList();
    return v1CreateOauthProvidersIntent(
      userId: _userId,
      oauthProviders: _oauthProviders,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['userId'] = userId;
    _json['oauthProviders'] = oauthProviders.map((e) => e.toJson()).toList();
    return _json;
  }
}

class v1CreateOauthProvidersRequest {
  final String type;
  /// Timestamp (in milliseconds) of the request, used to verify liveness of user requests.
  final String timestampMs;
  /// Unique identifier for a given Organization.
  final String organizationId;
  final v1CreateOauthProvidersIntent parameters;
  final bool? generateAppProofs;

  const v1CreateOauthProvidersRequest({
    required  this.type,
    required  this.timestampMs,
    required  this.organizationId,
    required  this.parameters,
     this.generateAppProofs,
  });

  factory v1CreateOauthProvidersRequest.fromJson(Map<String, dynamic> json) {
    final _type = json['type'] as String;
    final _timestampMs = json['timestampMs'] as String;
    final _organizationId = json['organizationId'] as String;
    final _parameters = v1CreateOauthProvidersIntent.fromJson(json['parameters'] as Map<String, dynamic>);
    final _generateAppProofs = json['generateAppProofs'] as bool?;
    return v1CreateOauthProvidersRequest(
      type: _type,
      timestampMs: _timestampMs,
      organizationId: _organizationId,
      parameters: _parameters,
      generateAppProofs: _generateAppProofs,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['type'] = type;
    _json['timestampMs'] = timestampMs;
    _json['organizationId'] = organizationId;
    _json['parameters'] = parameters.toJson();
    if (generateAppProofs != null) {
      _json['generateAppProofs'] = generateAppProofs;
    }
    return _json;
  }
}

class v1CreateOauthProvidersResult {
  /// A list of unique identifiers for Oauth Providers
  final List<String> providerIds;

  const v1CreateOauthProvidersResult({
    required  this.providerIds,
  });

  factory v1CreateOauthProvidersResult.fromJson(Map<String, dynamic> json) {
    final _providerIds = (json['providerIds'] as List).map((e) => e as String).toList();
    return v1CreateOauthProvidersResult(
      providerIds: _providerIds,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['providerIds'] = providerIds;
    return _json;
  }
}

class v1CreateOrganizationIntent {
  /// Human-readable name for an Organization.
  final String organizationName;
  /// The root user's email address.
  final String rootEmail;
  /// The root user's Authenticator.
  final v1AuthenticatorParams rootAuthenticator;
  /// Unique identifier for the root user object.
  final String? rootUserId;

  const v1CreateOrganizationIntent({
    required  this.organizationName,
    required  this.rootEmail,
    required  this.rootAuthenticator,
     this.rootUserId,
  });

  factory v1CreateOrganizationIntent.fromJson(Map<String, dynamic> json) {
    final _organizationName = json['organizationName'] as String;
    final _rootEmail = json['rootEmail'] as String;
    final _rootAuthenticator = v1AuthenticatorParams.fromJson(json['rootAuthenticator'] as Map<String, dynamic>);
    final _rootUserId = json['rootUserId'] as String?;
    return v1CreateOrganizationIntent(
      organizationName: _organizationName,
      rootEmail: _rootEmail,
      rootAuthenticator: _rootAuthenticator,
      rootUserId: _rootUserId,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['organizationName'] = organizationName;
    _json['rootEmail'] = rootEmail;
    _json['rootAuthenticator'] = rootAuthenticator.toJson();
    if (rootUserId != null) {
      _json['rootUserId'] = rootUserId;
    }
    return _json;
  }
}

class v1CreateOrganizationIntentV2 {
  /// Human-readable name for an Organization.
  final String organizationName;
  /// The root user's email address.
  final String rootEmail;
  /// The root user's Authenticator.
  final v1AuthenticatorParamsV2 rootAuthenticator;
  /// Unique identifier for the root user object.
  final String? rootUserId;

  const v1CreateOrganizationIntentV2({
    required  this.organizationName,
    required  this.rootEmail,
    required  this.rootAuthenticator,
     this.rootUserId,
  });

  factory v1CreateOrganizationIntentV2.fromJson(Map<String, dynamic> json) {
    final _organizationName = json['organizationName'] as String;
    final _rootEmail = json['rootEmail'] as String;
    final _rootAuthenticator = v1AuthenticatorParamsV2.fromJson(json['rootAuthenticator'] as Map<String, dynamic>);
    final _rootUserId = json['rootUserId'] as String?;
    return v1CreateOrganizationIntentV2(
      organizationName: _organizationName,
      rootEmail: _rootEmail,
      rootAuthenticator: _rootAuthenticator,
      rootUserId: _rootUserId,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['organizationName'] = organizationName;
    _json['rootEmail'] = rootEmail;
    _json['rootAuthenticator'] = rootAuthenticator.toJson();
    if (rootUserId != null) {
      _json['rootUserId'] = rootUserId;
    }
    return _json;
  }
}

class v1CreateOrganizationResult {
  /// Unique identifier for a given Organization.
  final String organizationId;

  const v1CreateOrganizationResult({
    required  this.organizationId,
  });

  factory v1CreateOrganizationResult.fromJson(Map<String, dynamic> json) {
    final _organizationId = json['organizationId'] as String;
    return v1CreateOrganizationResult(
      organizationId: _organizationId,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['organizationId'] = organizationId;
    return _json;
  }
}

class v1CreatePoliciesIntent {
  /// An array of policy intents to be created.
  final List<v1CreatePolicyIntentV3> policies;

  const v1CreatePoliciesIntent({
    required  this.policies,
  });

  factory v1CreatePoliciesIntent.fromJson(Map<String, dynamic> json) {
    final _policies = (json['policies'] as List).map((e) => v1CreatePolicyIntentV3.fromJson(e as Map<String, dynamic>)).toList();
    return v1CreatePoliciesIntent(
      policies: _policies,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['policies'] = policies.map((e) => e.toJson()).toList();
    return _json;
  }
}

class v1CreatePoliciesRequest {
  final String type;
  /// Timestamp (in milliseconds) of the request, used to verify liveness of user requests.
  final String timestampMs;
  /// Unique identifier for a given Organization.
  final String organizationId;
  final v1CreatePoliciesIntent parameters;
  final bool? generateAppProofs;

  const v1CreatePoliciesRequest({
    required  this.type,
    required  this.timestampMs,
    required  this.organizationId,
    required  this.parameters,
     this.generateAppProofs,
  });

  factory v1CreatePoliciesRequest.fromJson(Map<String, dynamic> json) {
    final _type = json['type'] as String;
    final _timestampMs = json['timestampMs'] as String;
    final _organizationId = json['organizationId'] as String;
    final _parameters = v1CreatePoliciesIntent.fromJson(json['parameters'] as Map<String, dynamic>);
    final _generateAppProofs = json['generateAppProofs'] as bool?;
    return v1CreatePoliciesRequest(
      type: _type,
      timestampMs: _timestampMs,
      organizationId: _organizationId,
      parameters: _parameters,
      generateAppProofs: _generateAppProofs,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['type'] = type;
    _json['timestampMs'] = timestampMs;
    _json['organizationId'] = organizationId;
    _json['parameters'] = parameters.toJson();
    if (generateAppProofs != null) {
      _json['generateAppProofs'] = generateAppProofs;
    }
    return _json;
  }
}

class v1CreatePoliciesResult {
  /// A list of unique identifiers for the created policies.
  final List<String> policyIds;

  const v1CreatePoliciesResult({
    required  this.policyIds,
  });

  factory v1CreatePoliciesResult.fromJson(Map<String, dynamic> json) {
    final _policyIds = (json['policyIds'] as List).map((e) => e as String).toList();
    return v1CreatePoliciesResult(
      policyIds: _policyIds,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['policyIds'] = policyIds;
    return _json;
  }
}

class v1CreatePolicyIntent {
  /// Human-readable name for a Policy.
  final String policyName;
  /// A list of simple functions each including a subject, target and boolean. See Policy Engine Language section for additional details.
  final List<v1Selector> selectors;
  /// The instruction to DENY or ALLOW a particular activity following policy selector(s).
  final v1Effect effect;
  final String? notes;

  const v1CreatePolicyIntent({
    required  this.policyName,
    required  this.selectors,
    required  this.effect,
     this.notes,
  });

  factory v1CreatePolicyIntent.fromJson(Map<String, dynamic> json) {
    final _policyName = json['policyName'] as String;
    final _selectors = (json['selectors'] as List).map((e) => v1Selector.fromJson(e as Map<String, dynamic>)).toList();
    final _effect = v1EffectFromJson(json['effect']);
    final _notes = json['notes'] as String?;
    return v1CreatePolicyIntent(
      policyName: _policyName,
      selectors: _selectors,
      effect: _effect,
      notes: _notes,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['policyName'] = policyName;
    _json['selectors'] = selectors.map((e) => e.toJson()).toList();
    _json['effect'] = v1EffectToJson(effect);
    if (notes != null) {
      _json['notes'] = notes;
    }
    return _json;
  }
}

class v1CreatePolicyIntentV2 {
  /// Human-readable name for a Policy.
  final String policyName;
  /// A list of simple functions each including a subject, target and boolean. See Policy Engine Language section for additional details.
  final List<v1SelectorV2> selectors;
  /// Whether to ALLOW or DENY requests that match the condition and consensus requirements.
  final v1Effect effect;
  final String? notes;

  const v1CreatePolicyIntentV2({
    required  this.policyName,
    required  this.selectors,
    required  this.effect,
     this.notes,
  });

  factory v1CreatePolicyIntentV2.fromJson(Map<String, dynamic> json) {
    final _policyName = json['policyName'] as String;
    final _selectors = (json['selectors'] as List).map((e) => v1SelectorV2.fromJson(e as Map<String, dynamic>)).toList();
    final _effect = v1EffectFromJson(json['effect']);
    final _notes = json['notes'] as String?;
    return v1CreatePolicyIntentV2(
      policyName: _policyName,
      selectors: _selectors,
      effect: _effect,
      notes: _notes,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['policyName'] = policyName;
    _json['selectors'] = selectors.map((e) => e.toJson()).toList();
    _json['effect'] = v1EffectToJson(effect);
    if (notes != null) {
      _json['notes'] = notes;
    }
    return _json;
  }
}

class v1CreatePolicyIntentV3 {
  /// Human-readable name for a Policy.
  final String policyName;
  /// The instruction to DENY or ALLOW an activity.
  final v1Effect effect;
  /// The condition expression that triggers the Effect
  final String? condition;
  /// The consensus expression that triggers the Effect
  final String? consensus;
  /// Notes for a Policy.
  final String notes;

  const v1CreatePolicyIntentV3({
    required  this.policyName,
    required  this.effect,
     this.condition,
     this.consensus,
    required  this.notes,
  });

  factory v1CreatePolicyIntentV3.fromJson(Map<String, dynamic> json) {
    final _policyName = json['policyName'] as String;
    final _effect = v1EffectFromJson(json['effect']);
    final _condition = json['condition'] as String?;
    final _consensus = json['consensus'] as String?;
    final _notes = json['notes'] as String;
    return v1CreatePolicyIntentV3(
      policyName: _policyName,
      effect: _effect,
      condition: _condition,
      consensus: _consensus,
      notes: _notes,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['policyName'] = policyName;
    _json['effect'] = v1EffectToJson(effect);
    if (condition != null) {
      _json['condition'] = condition;
    }
    if (consensus != null) {
      _json['consensus'] = consensus;
    }
    _json['notes'] = notes;
    return _json;
  }
}

class v1CreatePolicyRequest {
  final String type;
  /// Timestamp (in milliseconds) of the request, used to verify liveness of user requests.
  final String timestampMs;
  /// Unique identifier for a given Organization.
  final String organizationId;
  final v1CreatePolicyIntentV3 parameters;
  final bool? generateAppProofs;

  const v1CreatePolicyRequest({
    required  this.type,
    required  this.timestampMs,
    required  this.organizationId,
    required  this.parameters,
     this.generateAppProofs,
  });

  factory v1CreatePolicyRequest.fromJson(Map<String, dynamic> json) {
    final _type = json['type'] as String;
    final _timestampMs = json['timestampMs'] as String;
    final _organizationId = json['organizationId'] as String;
    final _parameters = v1CreatePolicyIntentV3.fromJson(json['parameters'] as Map<String, dynamic>);
    final _generateAppProofs = json['generateAppProofs'] as bool?;
    return v1CreatePolicyRequest(
      type: _type,
      timestampMs: _timestampMs,
      organizationId: _organizationId,
      parameters: _parameters,
      generateAppProofs: _generateAppProofs,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['type'] = type;
    _json['timestampMs'] = timestampMs;
    _json['organizationId'] = organizationId;
    _json['parameters'] = parameters.toJson();
    if (generateAppProofs != null) {
      _json['generateAppProofs'] = generateAppProofs;
    }
    return _json;
  }
}

class v1CreatePolicyResult {
  /// Unique identifier for a given Policy.
  final String policyId;

  const v1CreatePolicyResult({
    required  this.policyId,
  });

  factory v1CreatePolicyResult.fromJson(Map<String, dynamic> json) {
    final _policyId = json['policyId'] as String;
    return v1CreatePolicyResult(
      policyId: _policyId,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['policyId'] = policyId;
    return _json;
  }
}

class v1CreatePrivateKeyTagIntent {
  /// Human-readable name for a Private Key Tag.
  final String privateKeyTagName;
  /// A list of Private Key IDs.
  final List<String> privateKeyIds;

  const v1CreatePrivateKeyTagIntent({
    required  this.privateKeyTagName,
    required  this.privateKeyIds,
  });

  factory v1CreatePrivateKeyTagIntent.fromJson(Map<String, dynamic> json) {
    final _privateKeyTagName = json['privateKeyTagName'] as String;
    final _privateKeyIds = (json['privateKeyIds'] as List).map((e) => e as String).toList();
    return v1CreatePrivateKeyTagIntent(
      privateKeyTagName: _privateKeyTagName,
      privateKeyIds: _privateKeyIds,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['privateKeyTagName'] = privateKeyTagName;
    _json['privateKeyIds'] = privateKeyIds;
    return _json;
  }
}

class v1CreatePrivateKeyTagRequest {
  final String type;
  /// Timestamp (in milliseconds) of the request, used to verify liveness of user requests.
  final String timestampMs;
  /// Unique identifier for a given Organization.
  final String organizationId;
  final v1CreatePrivateKeyTagIntent parameters;
  final bool? generateAppProofs;

  const v1CreatePrivateKeyTagRequest({
    required  this.type,
    required  this.timestampMs,
    required  this.organizationId,
    required  this.parameters,
     this.generateAppProofs,
  });

  factory v1CreatePrivateKeyTagRequest.fromJson(Map<String, dynamic> json) {
    final _type = json['type'] as String;
    final _timestampMs = json['timestampMs'] as String;
    final _organizationId = json['organizationId'] as String;
    final _parameters = v1CreatePrivateKeyTagIntent.fromJson(json['parameters'] as Map<String, dynamic>);
    final _generateAppProofs = json['generateAppProofs'] as bool?;
    return v1CreatePrivateKeyTagRequest(
      type: _type,
      timestampMs: _timestampMs,
      organizationId: _organizationId,
      parameters: _parameters,
      generateAppProofs: _generateAppProofs,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['type'] = type;
    _json['timestampMs'] = timestampMs;
    _json['organizationId'] = organizationId;
    _json['parameters'] = parameters.toJson();
    if (generateAppProofs != null) {
      _json['generateAppProofs'] = generateAppProofs;
    }
    return _json;
  }
}

class v1CreatePrivateKeyTagResult {
  /// Unique identifier for a given Private Key Tag.
  final String privateKeyTagId;
  /// A list of Private Key IDs.
  final List<String> privateKeyIds;

  const v1CreatePrivateKeyTagResult({
    required  this.privateKeyTagId,
    required  this.privateKeyIds,
  });

  factory v1CreatePrivateKeyTagResult.fromJson(Map<String, dynamic> json) {
    final _privateKeyTagId = json['privateKeyTagId'] as String;
    final _privateKeyIds = (json['privateKeyIds'] as List).map((e) => e as String).toList();
    return v1CreatePrivateKeyTagResult(
      privateKeyTagId: _privateKeyTagId,
      privateKeyIds: _privateKeyIds,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['privateKeyTagId'] = privateKeyTagId;
    _json['privateKeyIds'] = privateKeyIds;
    return _json;
  }
}

class v1CreatePrivateKeysIntent {
  /// A list of Private Keys.
  final List<v1PrivateKeyParams> privateKeys;

  const v1CreatePrivateKeysIntent({
    required  this.privateKeys,
  });

  factory v1CreatePrivateKeysIntent.fromJson(Map<String, dynamic> json) {
    final _privateKeys = (json['privateKeys'] as List).map((e) => v1PrivateKeyParams.fromJson(e as Map<String, dynamic>)).toList();
    return v1CreatePrivateKeysIntent(
      privateKeys: _privateKeys,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['privateKeys'] = privateKeys.map((e) => e.toJson()).toList();
    return _json;
  }
}

class v1CreatePrivateKeysIntentV2 {
  /// A list of Private Keys.
  final List<v1PrivateKeyParams> privateKeys;

  const v1CreatePrivateKeysIntentV2({
    required  this.privateKeys,
  });

  factory v1CreatePrivateKeysIntentV2.fromJson(Map<String, dynamic> json) {
    final _privateKeys = (json['privateKeys'] as List).map((e) => v1PrivateKeyParams.fromJson(e as Map<String, dynamic>)).toList();
    return v1CreatePrivateKeysIntentV2(
      privateKeys: _privateKeys,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['privateKeys'] = privateKeys.map((e) => e.toJson()).toList();
    return _json;
  }
}

class v1CreatePrivateKeysRequest {
  final String type;
  /// Timestamp (in milliseconds) of the request, used to verify liveness of user requests.
  final String timestampMs;
  /// Unique identifier for a given Organization.
  final String organizationId;
  final v1CreatePrivateKeysIntentV2 parameters;
  final bool? generateAppProofs;

  const v1CreatePrivateKeysRequest({
    required  this.type,
    required  this.timestampMs,
    required  this.organizationId,
    required  this.parameters,
     this.generateAppProofs,
  });

  factory v1CreatePrivateKeysRequest.fromJson(Map<String, dynamic> json) {
    final _type = json['type'] as String;
    final _timestampMs = json['timestampMs'] as String;
    final _organizationId = json['organizationId'] as String;
    final _parameters = v1CreatePrivateKeysIntentV2.fromJson(json['parameters'] as Map<String, dynamic>);
    final _generateAppProofs = json['generateAppProofs'] as bool?;
    return v1CreatePrivateKeysRequest(
      type: _type,
      timestampMs: _timestampMs,
      organizationId: _organizationId,
      parameters: _parameters,
      generateAppProofs: _generateAppProofs,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['type'] = type;
    _json['timestampMs'] = timestampMs;
    _json['organizationId'] = organizationId;
    _json['parameters'] = parameters.toJson();
    if (generateAppProofs != null) {
      _json['generateAppProofs'] = generateAppProofs;
    }
    return _json;
  }
}

class v1CreatePrivateKeysResult {
  /// A list of Private Key IDs.
  final List<String> privateKeyIds;

  const v1CreatePrivateKeysResult({
    required  this.privateKeyIds,
  });

  factory v1CreatePrivateKeysResult.fromJson(Map<String, dynamic> json) {
    final _privateKeyIds = (json['privateKeyIds'] as List).map((e) => e as String).toList();
    return v1CreatePrivateKeysResult(
      privateKeyIds: _privateKeyIds,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['privateKeyIds'] = privateKeyIds;
    return _json;
  }
}

class v1CreatePrivateKeysResultV2 {
  /// A list of Private Key IDs and addresses.
  final List<v1PrivateKeyResult> privateKeys;

  const v1CreatePrivateKeysResultV2({
    required  this.privateKeys,
  });

  factory v1CreatePrivateKeysResultV2.fromJson(Map<String, dynamic> json) {
    final _privateKeys = (json['privateKeys'] as List).map((e) => v1PrivateKeyResult.fromJson(e as Map<String, dynamic>)).toList();
    return v1CreatePrivateKeysResultV2(
      privateKeys: _privateKeys,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['privateKeys'] = privateKeys.map((e) => e.toJson()).toList();
    return _json;
  }
}

class v1CreateReadOnlySessionIntent {
  const v1CreateReadOnlySessionIntent();
  factory v1CreateReadOnlySessionIntent.fromJson(Map<String, dynamic> json) => const v1CreateReadOnlySessionIntent();
  Map<String, dynamic> toJson() => {};
}

class v1CreateReadOnlySessionRequest {
  final String type;
  /// Timestamp (in milliseconds) of the request, used to verify liveness of user requests.
  final String timestampMs;
  /// Unique identifier for a given Organization.
  final String organizationId;
  final v1CreateReadOnlySessionIntent parameters;
  final bool? generateAppProofs;

  const v1CreateReadOnlySessionRequest({
    required  this.type,
    required  this.timestampMs,
    required  this.organizationId,
    required  this.parameters,
     this.generateAppProofs,
  });

  factory v1CreateReadOnlySessionRequest.fromJson(Map<String, dynamic> json) {
    final _type = json['type'] as String;
    final _timestampMs = json['timestampMs'] as String;
    final _organizationId = json['organizationId'] as String;
    final _parameters = v1CreateReadOnlySessionIntent.fromJson(json['parameters'] as Map<String, dynamic>);
    final _generateAppProofs = json['generateAppProofs'] as bool?;
    return v1CreateReadOnlySessionRequest(
      type: _type,
      timestampMs: _timestampMs,
      organizationId: _organizationId,
      parameters: _parameters,
      generateAppProofs: _generateAppProofs,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['type'] = type;
    _json['timestampMs'] = timestampMs;
    _json['organizationId'] = organizationId;
    _json['parameters'] = parameters.toJson();
    if (generateAppProofs != null) {
      _json['generateAppProofs'] = generateAppProofs;
    }
    return _json;
  }
}

class v1CreateReadOnlySessionResult {
  /// Unique identifier for a given Organization. If the request is being made by a user and their Sub-Organization ID is unknown, this can be the Parent Organization ID. However, using the Sub-Organization ID is preferred due to performance reasons.
  final String organizationId;
  /// Human-readable name for an Organization.
  final String organizationName;
  /// Unique identifier for a given User.
  final String userId;
  /// Human-readable name for a User.
  final String username;
  /// String representing a read only session
  final String session;
  /// UTC timestamp in seconds representing the expiry time for the read only session.
  final String sessionExpiry;

  const v1CreateReadOnlySessionResult({
    required  this.organizationId,
    required  this.organizationName,
    required  this.userId,
    required  this.username,
    required  this.session,
    required  this.sessionExpiry,
  });

  factory v1CreateReadOnlySessionResult.fromJson(Map<String, dynamic> json) {
    final _organizationId = json['organizationId'] as String;
    final _organizationName = json['organizationName'] as String;
    final _userId = json['userId'] as String;
    final _username = json['username'] as String;
    final _session = json['session'] as String;
    final _sessionExpiry = json['sessionExpiry'] as String;
    return v1CreateReadOnlySessionResult(
      organizationId: _organizationId,
      organizationName: _organizationName,
      userId: _userId,
      username: _username,
      session: _session,
      sessionExpiry: _sessionExpiry,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['organizationId'] = organizationId;
    _json['organizationName'] = organizationName;
    _json['userId'] = userId;
    _json['username'] = username;
    _json['session'] = session;
    _json['sessionExpiry'] = sessionExpiry;
    return _json;
  }
}

class v1CreateReadWriteSessionIntent {
  /// Client-side public key generated by the user, to which the read write session bundle (credentials) will be encrypted.
  final String targetPublicKey;
  /// Email of the user to create a read write session for
  final String email;
  /// Optional human-readable name for an API Key. If none provided, default to Read Write Session - <Timestamp>
  final String? apiKeyName;
  /// Expiration window (in seconds) indicating how long the API key is valid for. If not provided, a default of 15 minutes will be used.
  final String? expirationSeconds;

  const v1CreateReadWriteSessionIntent({
    required  this.targetPublicKey,
    required  this.email,
     this.apiKeyName,
     this.expirationSeconds,
  });

  factory v1CreateReadWriteSessionIntent.fromJson(Map<String, dynamic> json) {
    final _targetPublicKey = json['targetPublicKey'] as String;
    final _email = json['email'] as String;
    final _apiKeyName = json['apiKeyName'] as String?;
    final _expirationSeconds = json['expirationSeconds'] as String?;
    return v1CreateReadWriteSessionIntent(
      targetPublicKey: _targetPublicKey,
      email: _email,
      apiKeyName: _apiKeyName,
      expirationSeconds: _expirationSeconds,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['targetPublicKey'] = targetPublicKey;
    _json['email'] = email;
    if (apiKeyName != null) {
      _json['apiKeyName'] = apiKeyName;
    }
    if (expirationSeconds != null) {
      _json['expirationSeconds'] = expirationSeconds;
    }
    return _json;
  }
}

class v1CreateReadWriteSessionIntentV2 {
  /// Client-side public key generated by the user, to which the read write session bundle (credentials) will be encrypted.
  final String targetPublicKey;
  /// Unique identifier for a given User.
  final String? userId;
  /// Optional human-readable name for an API Key. If none provided, default to Read Write Session - <Timestamp>
  final String? apiKeyName;
  /// Expiration window (in seconds) indicating how long the API key is valid for. If not provided, a default of 15 minutes will be used.
  final String? expirationSeconds;
  /// Invalidate all other previously generated ReadWriteSession API keys
  final bool? invalidateExisting;

  const v1CreateReadWriteSessionIntentV2({
    required  this.targetPublicKey,
     this.userId,
     this.apiKeyName,
     this.expirationSeconds,
     this.invalidateExisting,
  });

  factory v1CreateReadWriteSessionIntentV2.fromJson(Map<String, dynamic> json) {
    final _targetPublicKey = json['targetPublicKey'] as String;
    final _userId = json['userId'] as String?;
    final _apiKeyName = json['apiKeyName'] as String?;
    final _expirationSeconds = json['expirationSeconds'] as String?;
    final _invalidateExisting = json['invalidateExisting'] as bool?;
    return v1CreateReadWriteSessionIntentV2(
      targetPublicKey: _targetPublicKey,
      userId: _userId,
      apiKeyName: _apiKeyName,
      expirationSeconds: _expirationSeconds,
      invalidateExisting: _invalidateExisting,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['targetPublicKey'] = targetPublicKey;
    if (userId != null) {
      _json['userId'] = userId;
    }
    if (apiKeyName != null) {
      _json['apiKeyName'] = apiKeyName;
    }
    if (expirationSeconds != null) {
      _json['expirationSeconds'] = expirationSeconds;
    }
    if (invalidateExisting != null) {
      _json['invalidateExisting'] = invalidateExisting;
    }
    return _json;
  }
}

class v1CreateReadWriteSessionRequest {
  final String type;
  /// Timestamp (in milliseconds) of the request, used to verify liveness of user requests.
  final String timestampMs;
  /// Unique identifier for a given Organization.
  final String organizationId;
  final v1CreateReadWriteSessionIntentV2 parameters;
  final bool? generateAppProofs;

  const v1CreateReadWriteSessionRequest({
    required  this.type,
    required  this.timestampMs,
    required  this.organizationId,
    required  this.parameters,
     this.generateAppProofs,
  });

  factory v1CreateReadWriteSessionRequest.fromJson(Map<String, dynamic> json) {
    final _type = json['type'] as String;
    final _timestampMs = json['timestampMs'] as String;
    final _organizationId = json['organizationId'] as String;
    final _parameters = v1CreateReadWriteSessionIntentV2.fromJson(json['parameters'] as Map<String, dynamic>);
    final _generateAppProofs = json['generateAppProofs'] as bool?;
    return v1CreateReadWriteSessionRequest(
      type: _type,
      timestampMs: _timestampMs,
      organizationId: _organizationId,
      parameters: _parameters,
      generateAppProofs: _generateAppProofs,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['type'] = type;
    _json['timestampMs'] = timestampMs;
    _json['organizationId'] = organizationId;
    _json['parameters'] = parameters.toJson();
    if (generateAppProofs != null) {
      _json['generateAppProofs'] = generateAppProofs;
    }
    return _json;
  }
}

class v1CreateReadWriteSessionResult {
  /// Unique identifier for a given Organization. If the request is being made by a user and their Sub-Organization ID is unknown, this can be the Parent Organization ID. However, using the Sub-Organization ID is preferred due to performance reasons.
  final String organizationId;
  /// Human-readable name for an Organization.
  final String organizationName;
  /// Unique identifier for a given User.
  final String userId;
  /// Human-readable name for a User.
  final String username;
  /// Unique identifier for the created API key.
  final String apiKeyId;
  /// HPKE encrypted credential bundle
  final String credentialBundle;

  const v1CreateReadWriteSessionResult({
    required  this.organizationId,
    required  this.organizationName,
    required  this.userId,
    required  this.username,
    required  this.apiKeyId,
    required  this.credentialBundle,
  });

  factory v1CreateReadWriteSessionResult.fromJson(Map<String, dynamic> json) {
    final _organizationId = json['organizationId'] as String;
    final _organizationName = json['organizationName'] as String;
    final _userId = json['userId'] as String;
    final _username = json['username'] as String;
    final _apiKeyId = json['apiKeyId'] as String;
    final _credentialBundle = json['credentialBundle'] as String;
    return v1CreateReadWriteSessionResult(
      organizationId: _organizationId,
      organizationName: _organizationName,
      userId: _userId,
      username: _username,
      apiKeyId: _apiKeyId,
      credentialBundle: _credentialBundle,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['organizationId'] = organizationId;
    _json['organizationName'] = organizationName;
    _json['userId'] = userId;
    _json['username'] = username;
    _json['apiKeyId'] = apiKeyId;
    _json['credentialBundle'] = credentialBundle;
    return _json;
  }
}

class v1CreateReadWriteSessionResultV2 {
  /// Unique identifier for a given Organization. If the request is being made by a user and their Sub-Organization ID is unknown, this can be the Parent Organization ID. However, using the Sub-Organization ID is preferred due to performance reasons.
  final String organizationId;
  /// Human-readable name for an Organization.
  final String organizationName;
  /// Unique identifier for a given User.
  final String userId;
  /// Human-readable name for a User.
  final String username;
  /// Unique identifier for the created API key.
  final String apiKeyId;
  /// HPKE encrypted credential bundle
  final String credentialBundle;

  const v1CreateReadWriteSessionResultV2({
    required  this.organizationId,
    required  this.organizationName,
    required  this.userId,
    required  this.username,
    required  this.apiKeyId,
    required  this.credentialBundle,
  });

  factory v1CreateReadWriteSessionResultV2.fromJson(Map<String, dynamic> json) {
    final _organizationId = json['organizationId'] as String;
    final _organizationName = json['organizationName'] as String;
    final _userId = json['userId'] as String;
    final _username = json['username'] as String;
    final _apiKeyId = json['apiKeyId'] as String;
    final _credentialBundle = json['credentialBundle'] as String;
    return v1CreateReadWriteSessionResultV2(
      organizationId: _organizationId,
      organizationName: _organizationName,
      userId: _userId,
      username: _username,
      apiKeyId: _apiKeyId,
      credentialBundle: _credentialBundle,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['organizationId'] = organizationId;
    _json['organizationName'] = organizationName;
    _json['userId'] = userId;
    _json['username'] = username;
    _json['apiKeyId'] = apiKeyId;
    _json['credentialBundle'] = credentialBundle;
    return _json;
  }
}

class v1CreateSmartContractInterfaceIntent {
  /// Corresponding contract address or program ID
  final String smartContractAddress;
  /// ABI/IDL as a JSON string. Limited to 400kb
  final String smartContractInterface;
  final v1SmartContractInterfaceType type;
  /// Human-readable name for a Smart Contract Interface.
  final String label;
  /// Notes for a Smart Contract Interface.
  final String? notes;

  const v1CreateSmartContractInterfaceIntent({
    required  this.smartContractAddress,
    required  this.smartContractInterface,
    required  this.type,
    required  this.label,
     this.notes,
  });

  factory v1CreateSmartContractInterfaceIntent.fromJson(Map<String, dynamic> json) {
    final _smartContractAddress = json['smartContractAddress'] as String;
    final _smartContractInterface = json['smartContractInterface'] as String;
    final _type = v1SmartContractInterfaceTypeFromJson(json['type']);
    final _label = json['label'] as String;
    final _notes = json['notes'] as String?;
    return v1CreateSmartContractInterfaceIntent(
      smartContractAddress: _smartContractAddress,
      smartContractInterface: _smartContractInterface,
      type: _type,
      label: _label,
      notes: _notes,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['smartContractAddress'] = smartContractAddress;
    _json['smartContractInterface'] = smartContractInterface;
    _json['type'] = v1SmartContractInterfaceTypeToJson(type);
    _json['label'] = label;
    if (notes != null) {
      _json['notes'] = notes;
    }
    return _json;
  }
}

class v1CreateSmartContractInterfaceRequest {
  final String type;
  /// Timestamp (in milliseconds) of the request, used to verify liveness of user requests.
  final String timestampMs;
  /// Unique identifier for a given Organization.
  final String organizationId;
  final v1CreateSmartContractInterfaceIntent parameters;
  final bool? generateAppProofs;

  const v1CreateSmartContractInterfaceRequest({
    required  this.type,
    required  this.timestampMs,
    required  this.organizationId,
    required  this.parameters,
     this.generateAppProofs,
  });

  factory v1CreateSmartContractInterfaceRequest.fromJson(Map<String, dynamic> json) {
    final _type = json['type'] as String;
    final _timestampMs = json['timestampMs'] as String;
    final _organizationId = json['organizationId'] as String;
    final _parameters = v1CreateSmartContractInterfaceIntent.fromJson(json['parameters'] as Map<String, dynamic>);
    final _generateAppProofs = json['generateAppProofs'] as bool?;
    return v1CreateSmartContractInterfaceRequest(
      type: _type,
      timestampMs: _timestampMs,
      organizationId: _organizationId,
      parameters: _parameters,
      generateAppProofs: _generateAppProofs,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['type'] = type;
    _json['timestampMs'] = timestampMs;
    _json['organizationId'] = organizationId;
    _json['parameters'] = parameters.toJson();
    if (generateAppProofs != null) {
      _json['generateAppProofs'] = generateAppProofs;
    }
    return _json;
  }
}

class v1CreateSmartContractInterfaceResult {
  /// The ID of the created Smart Contract Interface.
  final String smartContractInterfaceId;

  const v1CreateSmartContractInterfaceResult({
    required  this.smartContractInterfaceId,
  });

  factory v1CreateSmartContractInterfaceResult.fromJson(Map<String, dynamic> json) {
    final _smartContractInterfaceId = json['smartContractInterfaceId'] as String;
    return v1CreateSmartContractInterfaceResult(
      smartContractInterfaceId: _smartContractInterfaceId,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['smartContractInterfaceId'] = smartContractInterfaceId;
    return _json;
  }
}

class v1CreateSubOrganizationIntent {
  /// Name for this sub-organization
  final String name;
  /// Root User authenticator for this new sub-organization
  final v1AuthenticatorParamsV2 rootAuthenticator;

  const v1CreateSubOrganizationIntent({
    required  this.name,
    required  this.rootAuthenticator,
  });

  factory v1CreateSubOrganizationIntent.fromJson(Map<String, dynamic> json) {
    final _name = json['name'] as String;
    final _rootAuthenticator = v1AuthenticatorParamsV2.fromJson(json['rootAuthenticator'] as Map<String, dynamic>);
    return v1CreateSubOrganizationIntent(
      name: _name,
      rootAuthenticator: _rootAuthenticator,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['name'] = name;
    _json['rootAuthenticator'] = rootAuthenticator.toJson();
    return _json;
  }
}

class v1CreateSubOrganizationIntentV2 {
  /// Name for this sub-organization
  final String subOrganizationName;
  /// Root users to create within this sub-organization
  final List<v1RootUserParams> rootUsers;
  /// The threshold of unique approvals to reach root quorum. This value must be less than or equal to the number of root users
  final num rootQuorumThreshold;

  const v1CreateSubOrganizationIntentV2({
    required  this.subOrganizationName,
    required  this.rootUsers,
    required  this.rootQuorumThreshold,
  });

  factory v1CreateSubOrganizationIntentV2.fromJson(Map<String, dynamic> json) {
    final _subOrganizationName = json['subOrganizationName'] as String;
    final _rootUsers = (json['rootUsers'] as List).map((e) => v1RootUserParams.fromJson(e as Map<String, dynamic>)).toList();
    final _rootQuorumThreshold = json['rootQuorumThreshold'] as num;
    return v1CreateSubOrganizationIntentV2(
      subOrganizationName: _subOrganizationName,
      rootUsers: _rootUsers,
      rootQuorumThreshold: _rootQuorumThreshold,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['subOrganizationName'] = subOrganizationName;
    _json['rootUsers'] = rootUsers.map((e) => e.toJson()).toList();
    _json['rootQuorumThreshold'] = rootQuorumThreshold;
    return _json;
  }
}

class v1CreateSubOrganizationIntentV3 {
  /// Name for this sub-organization
  final String subOrganizationName;
  /// Root users to create within this sub-organization
  final List<v1RootUserParams> rootUsers;
  /// The threshold of unique approvals to reach root quorum. This value must be less than or equal to the number of root users
  final num rootQuorumThreshold;
  /// A list of Private Keys.
  final List<v1PrivateKeyParams> privateKeys;

  const v1CreateSubOrganizationIntentV3({
    required  this.subOrganizationName,
    required  this.rootUsers,
    required  this.rootQuorumThreshold,
    required  this.privateKeys,
  });

  factory v1CreateSubOrganizationIntentV3.fromJson(Map<String, dynamic> json) {
    final _subOrganizationName = json['subOrganizationName'] as String;
    final _rootUsers = (json['rootUsers'] as List).map((e) => v1RootUserParams.fromJson(e as Map<String, dynamic>)).toList();
    final _rootQuorumThreshold = json['rootQuorumThreshold'] as num;
    final _privateKeys = (json['privateKeys'] as List).map((e) => v1PrivateKeyParams.fromJson(e as Map<String, dynamic>)).toList();
    return v1CreateSubOrganizationIntentV3(
      subOrganizationName: _subOrganizationName,
      rootUsers: _rootUsers,
      rootQuorumThreshold: _rootQuorumThreshold,
      privateKeys: _privateKeys,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['subOrganizationName'] = subOrganizationName;
    _json['rootUsers'] = rootUsers.map((e) => e.toJson()).toList();
    _json['rootQuorumThreshold'] = rootQuorumThreshold;
    _json['privateKeys'] = privateKeys.map((e) => e.toJson()).toList();
    return _json;
  }
}

class v1CreateSubOrganizationIntentV4 {
  /// Name for this sub-organization
  final String subOrganizationName;
  /// Root users to create within this sub-organization
  final List<v1RootUserParams> rootUsers;
  /// The threshold of unique approvals to reach root quorum. This value must be less than or equal to the number of root users
  final num rootQuorumThreshold;
  /// The wallet to create for the sub-organization
  final v1WalletParams? wallet;
  /// Disable email recovery for the sub-organization
  final bool? disableEmailRecovery;
  /// Disable email auth for the sub-organization
  final bool? disableEmailAuth;

  const v1CreateSubOrganizationIntentV4({
    required  this.subOrganizationName,
    required  this.rootUsers,
    required  this.rootQuorumThreshold,
     this.wallet,
     this.disableEmailRecovery,
     this.disableEmailAuth,
  });

  factory v1CreateSubOrganizationIntentV4.fromJson(Map<String, dynamic> json) {
    final _subOrganizationName = json['subOrganizationName'] as String;
    final _rootUsers = (json['rootUsers'] as List).map((e) => v1RootUserParams.fromJson(e as Map<String, dynamic>)).toList();
    final _rootQuorumThreshold = json['rootQuorumThreshold'] as num;
    final _wallet = json['wallet'] == null ? null : v1WalletParams.fromJson(json['wallet'] as Map<String, dynamic>);
    final _disableEmailRecovery = json['disableEmailRecovery'] as bool?;
    final _disableEmailAuth = json['disableEmailAuth'] as bool?;
    return v1CreateSubOrganizationIntentV4(
      subOrganizationName: _subOrganizationName,
      rootUsers: _rootUsers,
      rootQuorumThreshold: _rootQuorumThreshold,
      wallet: _wallet,
      disableEmailRecovery: _disableEmailRecovery,
      disableEmailAuth: _disableEmailAuth,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['subOrganizationName'] = subOrganizationName;
    _json['rootUsers'] = rootUsers.map((e) => e.toJson()).toList();
    _json['rootQuorumThreshold'] = rootQuorumThreshold;
    if (wallet != null) {
      _json['wallet'] = wallet?.toJson();
    }
    if (disableEmailRecovery != null) {
      _json['disableEmailRecovery'] = disableEmailRecovery;
    }
    if (disableEmailAuth != null) {
      _json['disableEmailAuth'] = disableEmailAuth;
    }
    return _json;
  }
}

class v1CreateSubOrganizationIntentV5 {
  /// Name for this sub-organization
  final String subOrganizationName;
  /// Root users to create within this sub-organization
  final List<v1RootUserParamsV2> rootUsers;
  /// The threshold of unique approvals to reach root quorum. This value must be less than or equal to the number of root users
  final num rootQuorumThreshold;
  /// The wallet to create for the sub-organization
  final v1WalletParams? wallet;
  /// Disable email recovery for the sub-organization
  final bool? disableEmailRecovery;
  /// Disable email auth for the sub-organization
  final bool? disableEmailAuth;

  const v1CreateSubOrganizationIntentV5({
    required  this.subOrganizationName,
    required  this.rootUsers,
    required  this.rootQuorumThreshold,
     this.wallet,
     this.disableEmailRecovery,
     this.disableEmailAuth,
  });

  factory v1CreateSubOrganizationIntentV5.fromJson(Map<String, dynamic> json) {
    final _subOrganizationName = json['subOrganizationName'] as String;
    final _rootUsers = (json['rootUsers'] as List).map((e) => v1RootUserParamsV2.fromJson(e as Map<String, dynamic>)).toList();
    final _rootQuorumThreshold = json['rootQuorumThreshold'] as num;
    final _wallet = json['wallet'] == null ? null : v1WalletParams.fromJson(json['wallet'] as Map<String, dynamic>);
    final _disableEmailRecovery = json['disableEmailRecovery'] as bool?;
    final _disableEmailAuth = json['disableEmailAuth'] as bool?;
    return v1CreateSubOrganizationIntentV5(
      subOrganizationName: _subOrganizationName,
      rootUsers: _rootUsers,
      rootQuorumThreshold: _rootQuorumThreshold,
      wallet: _wallet,
      disableEmailRecovery: _disableEmailRecovery,
      disableEmailAuth: _disableEmailAuth,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['subOrganizationName'] = subOrganizationName;
    _json['rootUsers'] = rootUsers.map((e) => e.toJson()).toList();
    _json['rootQuorumThreshold'] = rootQuorumThreshold;
    if (wallet != null) {
      _json['wallet'] = wallet?.toJson();
    }
    if (disableEmailRecovery != null) {
      _json['disableEmailRecovery'] = disableEmailRecovery;
    }
    if (disableEmailAuth != null) {
      _json['disableEmailAuth'] = disableEmailAuth;
    }
    return _json;
  }
}

class v1CreateSubOrganizationIntentV6 {
  /// Name for this sub-organization
  final String subOrganizationName;
  /// Root users to create within this sub-organization
  final List<v1RootUserParamsV3> rootUsers;
  /// The threshold of unique approvals to reach root quorum. This value must be less than or equal to the number of root users
  final num rootQuorumThreshold;
  /// The wallet to create for the sub-organization
  final v1WalletParams? wallet;
  /// Disable email recovery for the sub-organization
  final bool? disableEmailRecovery;
  /// Disable email auth for the sub-organization
  final bool? disableEmailAuth;

  const v1CreateSubOrganizationIntentV6({
    required  this.subOrganizationName,
    required  this.rootUsers,
    required  this.rootQuorumThreshold,
     this.wallet,
     this.disableEmailRecovery,
     this.disableEmailAuth,
  });

  factory v1CreateSubOrganizationIntentV6.fromJson(Map<String, dynamic> json) {
    final _subOrganizationName = json['subOrganizationName'] as String;
    final _rootUsers = (json['rootUsers'] as List).map((e) => v1RootUserParamsV3.fromJson(e as Map<String, dynamic>)).toList();
    final _rootQuorumThreshold = json['rootQuorumThreshold'] as num;
    final _wallet = json['wallet'] == null ? null : v1WalletParams.fromJson(json['wallet'] as Map<String, dynamic>);
    final _disableEmailRecovery = json['disableEmailRecovery'] as bool?;
    final _disableEmailAuth = json['disableEmailAuth'] as bool?;
    return v1CreateSubOrganizationIntentV6(
      subOrganizationName: _subOrganizationName,
      rootUsers: _rootUsers,
      rootQuorumThreshold: _rootQuorumThreshold,
      wallet: _wallet,
      disableEmailRecovery: _disableEmailRecovery,
      disableEmailAuth: _disableEmailAuth,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['subOrganizationName'] = subOrganizationName;
    _json['rootUsers'] = rootUsers.map((e) => e.toJson()).toList();
    _json['rootQuorumThreshold'] = rootQuorumThreshold;
    if (wallet != null) {
      _json['wallet'] = wallet?.toJson();
    }
    if (disableEmailRecovery != null) {
      _json['disableEmailRecovery'] = disableEmailRecovery;
    }
    if (disableEmailAuth != null) {
      _json['disableEmailAuth'] = disableEmailAuth;
    }
    return _json;
  }
}

class v1CreateSubOrganizationIntentV7 {
  /// Name for this sub-organization
  final String subOrganizationName;
  /// Root users to create within this sub-organization
  final List<v1RootUserParamsV4> rootUsers;
  /// The threshold of unique approvals to reach root quorum. This value must be less than or equal to the number of root users
  final num rootQuorumThreshold;
  /// The wallet to create for the sub-organization
  final v1WalletParams? wallet;
  /// Disable email recovery for the sub-organization
  final bool? disableEmailRecovery;
  /// Disable email auth for the sub-organization
  final bool? disableEmailAuth;
  /// Disable OTP SMS auth for the sub-organization
  final bool? disableSmsAuth;
  /// Disable OTP email auth for the sub-organization
  final bool? disableOtpEmailAuth;
  /// Signed JWT containing a unique id, expiry, verification type, contact
  final String? verificationToken;
  /// Optional signature proving authorization for this sub-organization creation. The signature is over the verification token ID and the root user parameters for the root user associated with the verification token. Only required if a public key was provided during the verification step.
  final v1ClientSignature? clientSignature;

  const v1CreateSubOrganizationIntentV7({
    required  this.subOrganizationName,
    required  this.rootUsers,
    required  this.rootQuorumThreshold,
     this.wallet,
     this.disableEmailRecovery,
     this.disableEmailAuth,
     this.disableSmsAuth,
     this.disableOtpEmailAuth,
     this.verificationToken,
     this.clientSignature,
  });

  factory v1CreateSubOrganizationIntentV7.fromJson(Map<String, dynamic> json) {
    final _subOrganizationName = json['subOrganizationName'] as String;
    final _rootUsers = (json['rootUsers'] as List).map((e) => v1RootUserParamsV4.fromJson(e as Map<String, dynamic>)).toList();
    final _rootQuorumThreshold = json['rootQuorumThreshold'] as num;
    final _wallet = json['wallet'] == null ? null : v1WalletParams.fromJson(json['wallet'] as Map<String, dynamic>);
    final _disableEmailRecovery = json['disableEmailRecovery'] as bool?;
    final _disableEmailAuth = json['disableEmailAuth'] as bool?;
    final _disableSmsAuth = json['disableSmsAuth'] as bool?;
    final _disableOtpEmailAuth = json['disableOtpEmailAuth'] as bool?;
    final _verificationToken = json['verificationToken'] as String?;
    final _clientSignature = json['clientSignature'] == null ? null : v1ClientSignature.fromJson(json['clientSignature'] as Map<String, dynamic>);
    return v1CreateSubOrganizationIntentV7(
      subOrganizationName: _subOrganizationName,
      rootUsers: _rootUsers,
      rootQuorumThreshold: _rootQuorumThreshold,
      wallet: _wallet,
      disableEmailRecovery: _disableEmailRecovery,
      disableEmailAuth: _disableEmailAuth,
      disableSmsAuth: _disableSmsAuth,
      disableOtpEmailAuth: _disableOtpEmailAuth,
      verificationToken: _verificationToken,
      clientSignature: _clientSignature,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['subOrganizationName'] = subOrganizationName;
    _json['rootUsers'] = rootUsers.map((e) => e.toJson()).toList();
    _json['rootQuorumThreshold'] = rootQuorumThreshold;
    if (wallet != null) {
      _json['wallet'] = wallet?.toJson();
    }
    if (disableEmailRecovery != null) {
      _json['disableEmailRecovery'] = disableEmailRecovery;
    }
    if (disableEmailAuth != null) {
      _json['disableEmailAuth'] = disableEmailAuth;
    }
    if (disableSmsAuth != null) {
      _json['disableSmsAuth'] = disableSmsAuth;
    }
    if (disableOtpEmailAuth != null) {
      _json['disableOtpEmailAuth'] = disableOtpEmailAuth;
    }
    if (verificationToken != null) {
      _json['verificationToken'] = verificationToken;
    }
    if (clientSignature != null) {
      _json['clientSignature'] = clientSignature?.toJson();
    }
    return _json;
  }
}

class v1CreateSubOrganizationRequest {
  final String type;
  /// Timestamp (in milliseconds) of the request, used to verify liveness of user requests.
  final String timestampMs;
  /// Unique identifier for a given Organization.
  final String organizationId;
  final v1CreateSubOrganizationIntentV7 parameters;
  final bool? generateAppProofs;

  const v1CreateSubOrganizationRequest({
    required  this.type,
    required  this.timestampMs,
    required  this.organizationId,
    required  this.parameters,
     this.generateAppProofs,
  });

  factory v1CreateSubOrganizationRequest.fromJson(Map<String, dynamic> json) {
    final _type = json['type'] as String;
    final _timestampMs = json['timestampMs'] as String;
    final _organizationId = json['organizationId'] as String;
    final _parameters = v1CreateSubOrganizationIntentV7.fromJson(json['parameters'] as Map<String, dynamic>);
    final _generateAppProofs = json['generateAppProofs'] as bool?;
    return v1CreateSubOrganizationRequest(
      type: _type,
      timestampMs: _timestampMs,
      organizationId: _organizationId,
      parameters: _parameters,
      generateAppProofs: _generateAppProofs,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['type'] = type;
    _json['timestampMs'] = timestampMs;
    _json['organizationId'] = organizationId;
    _json['parameters'] = parameters.toJson();
    if (generateAppProofs != null) {
      _json['generateAppProofs'] = generateAppProofs;
    }
    return _json;
  }
}

class v1CreateSubOrganizationResult {
  final String subOrganizationId;
  final List<String>? rootUserIds;

  const v1CreateSubOrganizationResult({
    required  this.subOrganizationId,
     this.rootUserIds,
  });

  factory v1CreateSubOrganizationResult.fromJson(Map<String, dynamic> json) {
    final _subOrganizationId = json['subOrganizationId'] as String;
    final _rootUserIds = (json['rootUserIds'] as List?)?.map((e) => e as String).toList();
    return v1CreateSubOrganizationResult(
      subOrganizationId: _subOrganizationId,
      rootUserIds: _rootUserIds,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['subOrganizationId'] = subOrganizationId;
    if (rootUserIds != null) {
      _json['rootUserIds'] = rootUserIds;
    }
    return _json;
  }
}

class v1CreateSubOrganizationResultV3 {
  final String subOrganizationId;
  /// A list of Private Key IDs and addresses.
  final List<v1PrivateKeyResult> privateKeys;
  final List<String>? rootUserIds;

  const v1CreateSubOrganizationResultV3({
    required  this.subOrganizationId,
    required  this.privateKeys,
     this.rootUserIds,
  });

  factory v1CreateSubOrganizationResultV3.fromJson(Map<String, dynamic> json) {
    final _subOrganizationId = json['subOrganizationId'] as String;
    final _privateKeys = (json['privateKeys'] as List).map((e) => v1PrivateKeyResult.fromJson(e as Map<String, dynamic>)).toList();
    final _rootUserIds = (json['rootUserIds'] as List?)?.map((e) => e as String).toList();
    return v1CreateSubOrganizationResultV3(
      subOrganizationId: _subOrganizationId,
      privateKeys: _privateKeys,
      rootUserIds: _rootUserIds,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['subOrganizationId'] = subOrganizationId;
    _json['privateKeys'] = privateKeys.map((e) => e.toJson()).toList();
    if (rootUserIds != null) {
      _json['rootUserIds'] = rootUserIds;
    }
    return _json;
  }
}

class v1CreateSubOrganizationResultV4 {
  final String subOrganizationId;
  final v1WalletResult? wallet;
  final List<String>? rootUserIds;

  const v1CreateSubOrganizationResultV4({
    required  this.subOrganizationId,
     this.wallet,
     this.rootUserIds,
  });

  factory v1CreateSubOrganizationResultV4.fromJson(Map<String, dynamic> json) {
    final _subOrganizationId = json['subOrganizationId'] as String;
    final _wallet = json['wallet'] == null ? null : v1WalletResult.fromJson(json['wallet'] as Map<String, dynamic>);
    final _rootUserIds = (json['rootUserIds'] as List?)?.map((e) => e as String).toList();
    return v1CreateSubOrganizationResultV4(
      subOrganizationId: _subOrganizationId,
      wallet: _wallet,
      rootUserIds: _rootUserIds,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['subOrganizationId'] = subOrganizationId;
    if (wallet != null) {
      _json['wallet'] = wallet?.toJson();
    }
    if (rootUserIds != null) {
      _json['rootUserIds'] = rootUserIds;
    }
    return _json;
  }
}

class v1CreateSubOrganizationResultV5 {
  final String subOrganizationId;
  final v1WalletResult? wallet;
  final List<String>? rootUserIds;

  const v1CreateSubOrganizationResultV5({
    required  this.subOrganizationId,
     this.wallet,
     this.rootUserIds,
  });

  factory v1CreateSubOrganizationResultV5.fromJson(Map<String, dynamic> json) {
    final _subOrganizationId = json['subOrganizationId'] as String;
    final _wallet = json['wallet'] == null ? null : v1WalletResult.fromJson(json['wallet'] as Map<String, dynamic>);
    final _rootUserIds = (json['rootUserIds'] as List?)?.map((e) => e as String).toList();
    return v1CreateSubOrganizationResultV5(
      subOrganizationId: _subOrganizationId,
      wallet: _wallet,
      rootUserIds: _rootUserIds,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['subOrganizationId'] = subOrganizationId;
    if (wallet != null) {
      _json['wallet'] = wallet?.toJson();
    }
    if (rootUserIds != null) {
      _json['rootUserIds'] = rootUserIds;
    }
    return _json;
  }
}

class v1CreateSubOrganizationResultV6 {
  final String subOrganizationId;
  final v1WalletResult? wallet;
  final List<String>? rootUserIds;

  const v1CreateSubOrganizationResultV6({
    required  this.subOrganizationId,
     this.wallet,
     this.rootUserIds,
  });

  factory v1CreateSubOrganizationResultV6.fromJson(Map<String, dynamic> json) {
    final _subOrganizationId = json['subOrganizationId'] as String;
    final _wallet = json['wallet'] == null ? null : v1WalletResult.fromJson(json['wallet'] as Map<String, dynamic>);
    final _rootUserIds = (json['rootUserIds'] as List?)?.map((e) => e as String).toList();
    return v1CreateSubOrganizationResultV6(
      subOrganizationId: _subOrganizationId,
      wallet: _wallet,
      rootUserIds: _rootUserIds,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['subOrganizationId'] = subOrganizationId;
    if (wallet != null) {
      _json['wallet'] = wallet?.toJson();
    }
    if (rootUserIds != null) {
      _json['rootUserIds'] = rootUserIds;
    }
    return _json;
  }
}

class v1CreateSubOrganizationResultV7 {
  final String subOrganizationId;
  final v1WalletResult? wallet;
  final List<String>? rootUserIds;

  const v1CreateSubOrganizationResultV7({
    required  this.subOrganizationId,
     this.wallet,
     this.rootUserIds,
  });

  factory v1CreateSubOrganizationResultV7.fromJson(Map<String, dynamic> json) {
    final _subOrganizationId = json['subOrganizationId'] as String;
    final _wallet = json['wallet'] == null ? null : v1WalletResult.fromJson(json['wallet'] as Map<String, dynamic>);
    final _rootUserIds = (json['rootUserIds'] as List?)?.map((e) => e as String).toList();
    return v1CreateSubOrganizationResultV7(
      subOrganizationId: _subOrganizationId,
      wallet: _wallet,
      rootUserIds: _rootUserIds,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['subOrganizationId'] = subOrganizationId;
    if (wallet != null) {
      _json['wallet'] = wallet?.toJson();
    }
    if (rootUserIds != null) {
      _json['rootUserIds'] = rootUserIds;
    }
    return _json;
  }
}

class v1CreateTvcAppIntent {
  /// The name of the new TVC application
  final String name;
  /// Quorum public key to use for this application
  final String quorumPublicKey;
  /// Unique identifier for an existing TVC operator set to use as the Manifest Set for this TVC application. If left empty, a new Manifest Set configuration is required
  final String? manifestSetId;
  /// Configuration to create a new TVC operator set, used as the Manifest Set for this TVC application. If left empty, a Manifest Set ID is required
  final v1TvcOperatorSetParams? manifestSetParams;
  /// Unique identifier for an existing TVC operator set to use as the Share Set for this TVC application. If left empty, a new Share Set configuration is required
  final String? shareSetId;
  /// Configuration to create a new TVC operator set, used as the Share Set for this TVC application. If left empty, a Share Set ID is required
  final v1TvcOperatorSetParams? shareSetParams;
  /// Enables external connectivity for this TVC app. Default if not provided: false.
  final bool? externalConnectivity;

  const v1CreateTvcAppIntent({
    required  this.name,
    required  this.quorumPublicKey,
     this.manifestSetId,
     this.manifestSetParams,
     this.shareSetId,
     this.shareSetParams,
     this.externalConnectivity,
  });

  factory v1CreateTvcAppIntent.fromJson(Map<String, dynamic> json) {
    final _name = json['name'] as String;
    final _quorumPublicKey = json['quorumPublicKey'] as String;
    final _manifestSetId = json['manifestSetId'] as String?;
    final _manifestSetParams = json['manifestSetParams'] == null ? null : v1TvcOperatorSetParams.fromJson(json['manifestSetParams'] as Map<String, dynamic>);
    final _shareSetId = json['shareSetId'] as String?;
    final _shareSetParams = json['shareSetParams'] == null ? null : v1TvcOperatorSetParams.fromJson(json['shareSetParams'] as Map<String, dynamic>);
    final _externalConnectivity = json['externalConnectivity'] as bool?;
    return v1CreateTvcAppIntent(
      name: _name,
      quorumPublicKey: _quorumPublicKey,
      manifestSetId: _manifestSetId,
      manifestSetParams: _manifestSetParams,
      shareSetId: _shareSetId,
      shareSetParams: _shareSetParams,
      externalConnectivity: _externalConnectivity,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['name'] = name;
    _json['quorumPublicKey'] = quorumPublicKey;
    if (manifestSetId != null) {
      _json['manifestSetId'] = manifestSetId;
    }
    if (manifestSetParams != null) {
      _json['manifestSetParams'] = manifestSetParams?.toJson();
    }
    if (shareSetId != null) {
      _json['shareSetId'] = shareSetId;
    }
    if (shareSetParams != null) {
      _json['shareSetParams'] = shareSetParams?.toJson();
    }
    if (externalConnectivity != null) {
      _json['externalConnectivity'] = externalConnectivity;
    }
    return _json;
  }
}

class v1CreateTvcAppRequest {
  final String type;
  /// Timestamp (in milliseconds) of the request, used to verify liveness of user requests.
  final String timestampMs;
  /// Unique identifier for a given Organization.
  final String organizationId;
  final v1CreateTvcAppIntent parameters;

  const v1CreateTvcAppRequest({
    required  this.type,
    required  this.timestampMs,
    required  this.organizationId,
    required  this.parameters,
  });

  factory v1CreateTvcAppRequest.fromJson(Map<String, dynamic> json) {
    final _type = json['type'] as String;
    final _timestampMs = json['timestampMs'] as String;
    final _organizationId = json['organizationId'] as String;
    final _parameters = v1CreateTvcAppIntent.fromJson(json['parameters'] as Map<String, dynamic>);
    return v1CreateTvcAppRequest(
      type: _type,
      timestampMs: _timestampMs,
      organizationId: _organizationId,
      parameters: _parameters,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['type'] = type;
    _json['timestampMs'] = timestampMs;
    _json['organizationId'] = organizationId;
    _json['parameters'] = parameters.toJson();
    return _json;
  }
}

class v1CreateTvcAppResult {
  /// The unique identifier for the TVC application
  final String appId;
  /// The unique identifier for the TVC manifest set
  final String manifestSetId;
  /// The unique identifier(s) of the manifest set operators
  final List<String> manifestSetOperatorIds;
  /// The required number of approvals for the manifest set
  final num manifestSetThreshold;

  const v1CreateTvcAppResult({
    required  this.appId,
    required  this.manifestSetId,
    required  this.manifestSetOperatorIds,
    required  this.manifestSetThreshold,
  });

  factory v1CreateTvcAppResult.fromJson(Map<String, dynamic> json) {
    final _appId = json['appId'] as String;
    final _manifestSetId = json['manifestSetId'] as String;
    final _manifestSetOperatorIds = (json['manifestSetOperatorIds'] as List).map((e) => e as String).toList();
    final _manifestSetThreshold = json['manifestSetThreshold'] as num;
    return v1CreateTvcAppResult(
      appId: _appId,
      manifestSetId: _manifestSetId,
      manifestSetOperatorIds: _manifestSetOperatorIds,
      manifestSetThreshold: _manifestSetThreshold,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['appId'] = appId;
    _json['manifestSetId'] = manifestSetId;
    _json['manifestSetOperatorIds'] = manifestSetOperatorIds;
    _json['manifestSetThreshold'] = manifestSetThreshold;
    return _json;
  }
}

class v1CreateTvcDeploymentIntent {
  /// The unique identifier of the to-be-deployed TVC application
  final String appId;
  /// The QuorumOS version to use to deploy this application
  final String qosVersion;
  /// URL of the container containing the pivot binary
  final String pivotContainerImageUrl;
  /// Location of the binary in the pivot container
  final String pivotPath;
  /// Arguments to pass to the pivot binary at startup. Encoded as a list of strings, for example ["--foo", "bar"]
  final List<String> pivotArgs;
  /// Digest of the pivot binary in the pivot container. This value will be inserted in the QOS manifest to ensure application integrity.
  final String expectedPivotDigest;
  /// URL of the container containing the host binary
  final String hostContainerImageUrl;
  /// Location of the binary inside the host container
  final String hostPath;
  /// Arguments to pass to the host binary at startup. Encoded as a list of strings, for example ["--foo", "bar"]
  final List<String> hostArgs;
  /// Optional nonce to ensure uniqueness of the deployment manifest. If not provided, it defaults to the current Unix timestamp in seconds.
  final num? nonce;

  const v1CreateTvcDeploymentIntent({
    required  this.appId,
    required  this.qosVersion,
    required  this.pivotContainerImageUrl,
    required  this.pivotPath,
    required  this.pivotArgs,
    required  this.expectedPivotDigest,
    required  this.hostContainerImageUrl,
    required  this.hostPath,
    required  this.hostArgs,
     this.nonce,
  });

  factory v1CreateTvcDeploymentIntent.fromJson(Map<String, dynamic> json) {
    final _appId = json['appId'] as String;
    final _qosVersion = json['qosVersion'] as String;
    final _pivotContainerImageUrl = json['pivotContainerImageUrl'] as String;
    final _pivotPath = json['pivotPath'] as String;
    final _pivotArgs = (json['pivotArgs'] as List).map((e) => e as String).toList();
    final _expectedPivotDigest = json['expectedPivotDigest'] as String;
    final _hostContainerImageUrl = json['hostContainerImageUrl'] as String;
    final _hostPath = json['hostPath'] as String;
    final _hostArgs = (json['hostArgs'] as List).map((e) => e as String).toList();
    final _nonce = json['nonce'] as num?;
    return v1CreateTvcDeploymentIntent(
      appId: _appId,
      qosVersion: _qosVersion,
      pivotContainerImageUrl: _pivotContainerImageUrl,
      pivotPath: _pivotPath,
      pivotArgs: _pivotArgs,
      expectedPivotDigest: _expectedPivotDigest,
      hostContainerImageUrl: _hostContainerImageUrl,
      hostPath: _hostPath,
      hostArgs: _hostArgs,
      nonce: _nonce,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['appId'] = appId;
    _json['qosVersion'] = qosVersion;
    _json['pivotContainerImageUrl'] = pivotContainerImageUrl;
    _json['pivotPath'] = pivotPath;
    _json['pivotArgs'] = pivotArgs;
    _json['expectedPivotDigest'] = expectedPivotDigest;
    _json['hostContainerImageUrl'] = hostContainerImageUrl;
    _json['hostPath'] = hostPath;
    _json['hostArgs'] = hostArgs;
    if (nonce != null) {
      _json['nonce'] = nonce;
    }
    return _json;
  }
}

class v1CreateTvcDeploymentRequest {
  final String type;
  /// Timestamp (in milliseconds) of the request, used to verify liveness of user requests.
  final String timestampMs;
  /// Unique identifier for a given Organization.
  final String organizationId;
  final v1CreateTvcDeploymentIntent parameters;

  const v1CreateTvcDeploymentRequest({
    required  this.type,
    required  this.timestampMs,
    required  this.organizationId,
    required  this.parameters,
  });

  factory v1CreateTvcDeploymentRequest.fromJson(Map<String, dynamic> json) {
    final _type = json['type'] as String;
    final _timestampMs = json['timestampMs'] as String;
    final _organizationId = json['organizationId'] as String;
    final _parameters = v1CreateTvcDeploymentIntent.fromJson(json['parameters'] as Map<String, dynamic>);
    return v1CreateTvcDeploymentRequest(
      type: _type,
      timestampMs: _timestampMs,
      organizationId: _organizationId,
      parameters: _parameters,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['type'] = type;
    _json['timestampMs'] = timestampMs;
    _json['organizationId'] = organizationId;
    _json['parameters'] = parameters.toJson();
    return _json;
  }
}

class v1CreateTvcDeploymentResult {
  /// The unique identifier for the TVC deployment
  final String deploymentId;
  /// The unique identifier for the TVC manifest
  final String manifestId;

  const v1CreateTvcDeploymentResult({
    required  this.deploymentId,
    required  this.manifestId,
  });

  factory v1CreateTvcDeploymentResult.fromJson(Map<String, dynamic> json) {
    final _deploymentId = json['deploymentId'] as String;
    final _manifestId = json['manifestId'] as String;
    return v1CreateTvcDeploymentResult(
      deploymentId: _deploymentId,
      manifestId: _manifestId,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['deploymentId'] = deploymentId;
    _json['manifestId'] = manifestId;
    return _json;
  }
}

class v1CreateTvcManifestApprovalsIntent {
  /// Unique identifier of the TVC deployment to approve
  final String manifestId;
  /// List of manifest approvals
  final List<v1TvcManifestApproval> approvals;

  const v1CreateTvcManifestApprovalsIntent({
    required  this.manifestId,
    required  this.approvals,
  });

  factory v1CreateTvcManifestApprovalsIntent.fromJson(Map<String, dynamic> json) {
    final _manifestId = json['manifestId'] as String;
    final _approvals = (json['approvals'] as List).map((e) => v1TvcManifestApproval.fromJson(e as Map<String, dynamic>)).toList();
    return v1CreateTvcManifestApprovalsIntent(
      manifestId: _manifestId,
      approvals: _approvals,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['manifestId'] = manifestId;
    _json['approvals'] = approvals.map((e) => e.toJson()).toList();
    return _json;
  }
}

class v1CreateTvcManifestApprovalsRequest {
  final String type;
  /// Timestamp (in milliseconds) of the request, used to verify liveness of user requests.
  final String timestampMs;
  /// Unique identifier for a given Organization.
  final String organizationId;
  final v1CreateTvcManifestApprovalsIntent parameters;

  const v1CreateTvcManifestApprovalsRequest({
    required  this.type,
    required  this.timestampMs,
    required  this.organizationId,
    required  this.parameters,
  });

  factory v1CreateTvcManifestApprovalsRequest.fromJson(Map<String, dynamic> json) {
    final _type = json['type'] as String;
    final _timestampMs = json['timestampMs'] as String;
    final _organizationId = json['organizationId'] as String;
    final _parameters = v1CreateTvcManifestApprovalsIntent.fromJson(json['parameters'] as Map<String, dynamic>);
    return v1CreateTvcManifestApprovalsRequest(
      type: _type,
      timestampMs: _timestampMs,
      organizationId: _organizationId,
      parameters: _parameters,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['type'] = type;
    _json['timestampMs'] = timestampMs;
    _json['organizationId'] = organizationId;
    _json['parameters'] = parameters.toJson();
    return _json;
  }
}

class v1CreateTvcManifestApprovalsResult {
  /// The unique identifier(s) for the manifest approvals
  final List<String> approvalIds;

  const v1CreateTvcManifestApprovalsResult({
    required  this.approvalIds,
  });

  factory v1CreateTvcManifestApprovalsResult.fromJson(Map<String, dynamic> json) {
    final _approvalIds = (json['approvalIds'] as List).map((e) => e as String).toList();
    return v1CreateTvcManifestApprovalsResult(
      approvalIds: _approvalIds,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['approvalIds'] = approvalIds;
    return _json;
  }
}

class v1CreateUserTagIntent {
  /// Human-readable name for a User Tag.
  final String userTagName;
  /// A list of User IDs.
  final List<String> userIds;

  const v1CreateUserTagIntent({
    required  this.userTagName,
    required  this.userIds,
  });

  factory v1CreateUserTagIntent.fromJson(Map<String, dynamic> json) {
    final _userTagName = json['userTagName'] as String;
    final _userIds = (json['userIds'] as List).map((e) => e as String).toList();
    return v1CreateUserTagIntent(
      userTagName: _userTagName,
      userIds: _userIds,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['userTagName'] = userTagName;
    _json['userIds'] = userIds;
    return _json;
  }
}

class v1CreateUserTagRequest {
  final String type;
  /// Timestamp (in milliseconds) of the request, used to verify liveness of user requests.
  final String timestampMs;
  /// Unique identifier for a given Organization.
  final String organizationId;
  final v1CreateUserTagIntent parameters;
  final bool? generateAppProofs;

  const v1CreateUserTagRequest({
    required  this.type,
    required  this.timestampMs,
    required  this.organizationId,
    required  this.parameters,
     this.generateAppProofs,
  });

  factory v1CreateUserTagRequest.fromJson(Map<String, dynamic> json) {
    final _type = json['type'] as String;
    final _timestampMs = json['timestampMs'] as String;
    final _organizationId = json['organizationId'] as String;
    final _parameters = v1CreateUserTagIntent.fromJson(json['parameters'] as Map<String, dynamic>);
    final _generateAppProofs = json['generateAppProofs'] as bool?;
    return v1CreateUserTagRequest(
      type: _type,
      timestampMs: _timestampMs,
      organizationId: _organizationId,
      parameters: _parameters,
      generateAppProofs: _generateAppProofs,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['type'] = type;
    _json['timestampMs'] = timestampMs;
    _json['organizationId'] = organizationId;
    _json['parameters'] = parameters.toJson();
    if (generateAppProofs != null) {
      _json['generateAppProofs'] = generateAppProofs;
    }
    return _json;
  }
}

class v1CreateUserTagResult {
  /// Unique identifier for a given User Tag.
  final String userTagId;
  /// A list of User IDs.
  final List<String> userIds;

  const v1CreateUserTagResult({
    required  this.userTagId,
    required  this.userIds,
  });

  factory v1CreateUserTagResult.fromJson(Map<String, dynamic> json) {
    final _userTagId = json['userTagId'] as String;
    final _userIds = (json['userIds'] as List).map((e) => e as String).toList();
    return v1CreateUserTagResult(
      userTagId: _userTagId,
      userIds: _userIds,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['userTagId'] = userTagId;
    _json['userIds'] = userIds;
    return _json;
  }
}

class v1CreateUsersIntent {
  /// A list of Users.
  final List<v1UserParams> users;

  const v1CreateUsersIntent({
    required  this.users,
  });

  factory v1CreateUsersIntent.fromJson(Map<String, dynamic> json) {
    final _users = (json['users'] as List).map((e) => v1UserParams.fromJson(e as Map<String, dynamic>)).toList();
    return v1CreateUsersIntent(
      users: _users,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['users'] = users.map((e) => e.toJson()).toList();
    return _json;
  }
}

class v1CreateUsersIntentV2 {
  /// A list of Users.
  final List<v1UserParamsV2> users;

  const v1CreateUsersIntentV2({
    required  this.users,
  });

  factory v1CreateUsersIntentV2.fromJson(Map<String, dynamic> json) {
    final _users = (json['users'] as List).map((e) => v1UserParamsV2.fromJson(e as Map<String, dynamic>)).toList();
    return v1CreateUsersIntentV2(
      users: _users,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['users'] = users.map((e) => e.toJson()).toList();
    return _json;
  }
}

class v1CreateUsersIntentV3 {
  /// A list of Users.
  final List<v1UserParamsV3> users;

  const v1CreateUsersIntentV3({
    required  this.users,
  });

  factory v1CreateUsersIntentV3.fromJson(Map<String, dynamic> json) {
    final _users = (json['users'] as List).map((e) => v1UserParamsV3.fromJson(e as Map<String, dynamic>)).toList();
    return v1CreateUsersIntentV3(
      users: _users,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['users'] = users.map((e) => e.toJson()).toList();
    return _json;
  }
}

class v1CreateUsersRequest {
  final String type;
  /// Timestamp (in milliseconds) of the request, used to verify liveness of user requests.
  final String timestampMs;
  /// Unique identifier for a given Organization.
  final String organizationId;
  final v1CreateUsersIntentV3 parameters;
  final bool? generateAppProofs;

  const v1CreateUsersRequest({
    required  this.type,
    required  this.timestampMs,
    required  this.organizationId,
    required  this.parameters,
     this.generateAppProofs,
  });

  factory v1CreateUsersRequest.fromJson(Map<String, dynamic> json) {
    final _type = json['type'] as String;
    final _timestampMs = json['timestampMs'] as String;
    final _organizationId = json['organizationId'] as String;
    final _parameters = v1CreateUsersIntentV3.fromJson(json['parameters'] as Map<String, dynamic>);
    final _generateAppProofs = json['generateAppProofs'] as bool?;
    return v1CreateUsersRequest(
      type: _type,
      timestampMs: _timestampMs,
      organizationId: _organizationId,
      parameters: _parameters,
      generateAppProofs: _generateAppProofs,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['type'] = type;
    _json['timestampMs'] = timestampMs;
    _json['organizationId'] = organizationId;
    _json['parameters'] = parameters.toJson();
    if (generateAppProofs != null) {
      _json['generateAppProofs'] = generateAppProofs;
    }
    return _json;
  }
}

class v1CreateUsersResult {
  /// A list of User IDs.
  final List<String> userIds;

  const v1CreateUsersResult({
    required  this.userIds,
  });

  factory v1CreateUsersResult.fromJson(Map<String, dynamic> json) {
    final _userIds = (json['userIds'] as List).map((e) => e as String).toList();
    return v1CreateUsersResult(
      userIds: _userIds,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['userIds'] = userIds;
    return _json;
  }
}

class v1CreateWalletAccountsIntent {
  /// Unique identifier for a given Wallet.
  final String walletId;
  /// A list of wallet Accounts.
  final List<v1WalletAccountParams> accounts;
  /// Indicates if the wallet accounts should be persisted. This is helpful if you'd like to see the addresses of different derivation paths without actually creating the accounts. Defaults to true.
  final bool? persist;

  const v1CreateWalletAccountsIntent({
    required  this.walletId,
    required  this.accounts,
     this.persist,
  });

  factory v1CreateWalletAccountsIntent.fromJson(Map<String, dynamic> json) {
    final _walletId = json['walletId'] as String;
    final _accounts = (json['accounts'] as List).map((e) => v1WalletAccountParams.fromJson(e as Map<String, dynamic>)).toList();
    final _persist = json['persist'] as bool?;
    return v1CreateWalletAccountsIntent(
      walletId: _walletId,
      accounts: _accounts,
      persist: _persist,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['walletId'] = walletId;
    _json['accounts'] = accounts.map((e) => e.toJson()).toList();
    if (persist != null) {
      _json['persist'] = persist;
    }
    return _json;
  }
}

class v1CreateWalletAccountsRequest {
  final String type;
  /// Timestamp (in milliseconds) of the request, used to verify liveness of user requests.
  final String timestampMs;
  /// Unique identifier for a given Organization.
  final String organizationId;
  final v1CreateWalletAccountsIntent parameters;
  final bool? generateAppProofs;

  const v1CreateWalletAccountsRequest({
    required  this.type,
    required  this.timestampMs,
    required  this.organizationId,
    required  this.parameters,
     this.generateAppProofs,
  });

  factory v1CreateWalletAccountsRequest.fromJson(Map<String, dynamic> json) {
    final _type = json['type'] as String;
    final _timestampMs = json['timestampMs'] as String;
    final _organizationId = json['organizationId'] as String;
    final _parameters = v1CreateWalletAccountsIntent.fromJson(json['parameters'] as Map<String, dynamic>);
    final _generateAppProofs = json['generateAppProofs'] as bool?;
    return v1CreateWalletAccountsRequest(
      type: _type,
      timestampMs: _timestampMs,
      organizationId: _organizationId,
      parameters: _parameters,
      generateAppProofs: _generateAppProofs,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['type'] = type;
    _json['timestampMs'] = timestampMs;
    _json['organizationId'] = organizationId;
    _json['parameters'] = parameters.toJson();
    if (generateAppProofs != null) {
      _json['generateAppProofs'] = generateAppProofs;
    }
    return _json;
  }
}

class v1CreateWalletAccountsResult {
  /// A list of derived addresses.
  final List<String> addresses;

  const v1CreateWalletAccountsResult({
    required  this.addresses,
  });

  factory v1CreateWalletAccountsResult.fromJson(Map<String, dynamic> json) {
    final _addresses = (json['addresses'] as List).map((e) => e as String).toList();
    return v1CreateWalletAccountsResult(
      addresses: _addresses,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['addresses'] = addresses;
    return _json;
  }
}

class v1CreateWalletIntent {
  /// Human-readable name for a Wallet.
  final String walletName;
  /// A list of wallet Accounts. This field, if not needed, should be an empty array in your request body.
  final List<v1WalletAccountParams> accounts;
  /// Length of mnemonic to generate the Wallet seed. Defaults to 12. Accepted values: 12, 15, 18, 21, 24.
  final num? mnemonicLength;

  const v1CreateWalletIntent({
    required  this.walletName,
    required  this.accounts,
     this.mnemonicLength,
  });

  factory v1CreateWalletIntent.fromJson(Map<String, dynamic> json) {
    final _walletName = json['walletName'] as String;
    final _accounts = (json['accounts'] as List).map((e) => v1WalletAccountParams.fromJson(e as Map<String, dynamic>)).toList();
    final _mnemonicLength = json['mnemonicLength'] as num?;
    return v1CreateWalletIntent(
      walletName: _walletName,
      accounts: _accounts,
      mnemonicLength: _mnemonicLength,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['walletName'] = walletName;
    _json['accounts'] = accounts.map((e) => e.toJson()).toList();
    if (mnemonicLength != null) {
      _json['mnemonicLength'] = mnemonicLength;
    }
    return _json;
  }
}

class v1CreateWalletRequest {
  final String type;
  /// Timestamp (in milliseconds) of the request, used to verify liveness of user requests.
  final String timestampMs;
  /// Unique identifier for a given Organization.
  final String organizationId;
  final v1CreateWalletIntent parameters;
  final bool? generateAppProofs;

  const v1CreateWalletRequest({
    required  this.type,
    required  this.timestampMs,
    required  this.organizationId,
    required  this.parameters,
     this.generateAppProofs,
  });

  factory v1CreateWalletRequest.fromJson(Map<String, dynamic> json) {
    final _type = json['type'] as String;
    final _timestampMs = json['timestampMs'] as String;
    final _organizationId = json['organizationId'] as String;
    final _parameters = v1CreateWalletIntent.fromJson(json['parameters'] as Map<String, dynamic>);
    final _generateAppProofs = json['generateAppProofs'] as bool?;
    return v1CreateWalletRequest(
      type: _type,
      timestampMs: _timestampMs,
      organizationId: _organizationId,
      parameters: _parameters,
      generateAppProofs: _generateAppProofs,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['type'] = type;
    _json['timestampMs'] = timestampMs;
    _json['organizationId'] = organizationId;
    _json['parameters'] = parameters.toJson();
    if (generateAppProofs != null) {
      _json['generateAppProofs'] = generateAppProofs;
    }
    return _json;
  }
}

class v1CreateWalletResult {
  /// Unique identifier for a Wallet.
  final String walletId;
  /// A list of account addresses.
  final List<String> addresses;

  const v1CreateWalletResult({
    required  this.walletId,
    required  this.addresses,
  });

  factory v1CreateWalletResult.fromJson(Map<String, dynamic> json) {
    final _walletId = json['walletId'] as String;
    final _addresses = (json['addresses'] as List).map((e) => e as String).toList();
    return v1CreateWalletResult(
      walletId: _walletId,
      addresses: _addresses,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['walletId'] = walletId;
    _json['addresses'] = addresses;
    return _json;
  }
}

class v1CredPropsAuthenticationExtensionsClientOutputs {
  final bool rk;

  const v1CredPropsAuthenticationExtensionsClientOutputs({
    required  this.rk,
  });

  factory v1CredPropsAuthenticationExtensionsClientOutputs.fromJson(Map<String, dynamic> json) {
    final _rk = json['rk'] as bool;
    return v1CredPropsAuthenticationExtensionsClientOutputs(
      rk: _rk,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['rk'] = rk;
    return _json;
  }
}

class v1CustomRevertError {
  /// The name of the custom error.
  final String? errorName;
  /// The decoded parameters as a JSON object.
  final String? paramsJson;

  const v1CustomRevertError({
     this.errorName,
     this.paramsJson,
  });

  factory v1CustomRevertError.fromJson(Map<String, dynamic> json) {
    final _errorName = json['errorName'] as String?;
    final _paramsJson = json['paramsJson'] as String?;
    return v1CustomRevertError(
      errorName: _errorName,
      paramsJson: _paramsJson,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    if (errorName != null) {
      _json['errorName'] = errorName;
    }
    if (paramsJson != null) {
      _json['paramsJson'] = paramsJson;
    }
    return _json;
  }
}

class v1DeleteApiKeysIntent {
  /// Unique identifier for a given User.
  final String userId;
  /// A list of API Key IDs.
  final List<String> apiKeyIds;

  const v1DeleteApiKeysIntent({
    required  this.userId,
    required  this.apiKeyIds,
  });

  factory v1DeleteApiKeysIntent.fromJson(Map<String, dynamic> json) {
    final _userId = json['userId'] as String;
    final _apiKeyIds = (json['apiKeyIds'] as List).map((e) => e as String).toList();
    return v1DeleteApiKeysIntent(
      userId: _userId,
      apiKeyIds: _apiKeyIds,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['userId'] = userId;
    _json['apiKeyIds'] = apiKeyIds;
    return _json;
  }
}

class v1DeleteApiKeysRequest {
  final String type;
  /// Timestamp (in milliseconds) of the request, used to verify liveness of user requests.
  final String timestampMs;
  /// Unique identifier for a given Organization.
  final String organizationId;
  final v1DeleteApiKeysIntent parameters;
  final bool? generateAppProofs;

  const v1DeleteApiKeysRequest({
    required  this.type,
    required  this.timestampMs,
    required  this.organizationId,
    required  this.parameters,
     this.generateAppProofs,
  });

  factory v1DeleteApiKeysRequest.fromJson(Map<String, dynamic> json) {
    final _type = json['type'] as String;
    final _timestampMs = json['timestampMs'] as String;
    final _organizationId = json['organizationId'] as String;
    final _parameters = v1DeleteApiKeysIntent.fromJson(json['parameters'] as Map<String, dynamic>);
    final _generateAppProofs = json['generateAppProofs'] as bool?;
    return v1DeleteApiKeysRequest(
      type: _type,
      timestampMs: _timestampMs,
      organizationId: _organizationId,
      parameters: _parameters,
      generateAppProofs: _generateAppProofs,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['type'] = type;
    _json['timestampMs'] = timestampMs;
    _json['organizationId'] = organizationId;
    _json['parameters'] = parameters.toJson();
    if (generateAppProofs != null) {
      _json['generateAppProofs'] = generateAppProofs;
    }
    return _json;
  }
}

class v1DeleteApiKeysResult {
  /// A list of API Key IDs.
  final List<String> apiKeyIds;

  const v1DeleteApiKeysResult({
    required  this.apiKeyIds,
  });

  factory v1DeleteApiKeysResult.fromJson(Map<String, dynamic> json) {
    final _apiKeyIds = (json['apiKeyIds'] as List).map((e) => e as String).toList();
    return v1DeleteApiKeysResult(
      apiKeyIds: _apiKeyIds,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['apiKeyIds'] = apiKeyIds;
    return _json;
  }
}

class v1DeleteAuthenticatorsIntent {
  /// Unique identifier for a given User.
  final String userId;
  /// A list of Authenticator IDs.
  final List<String> authenticatorIds;

  const v1DeleteAuthenticatorsIntent({
    required  this.userId,
    required  this.authenticatorIds,
  });

  factory v1DeleteAuthenticatorsIntent.fromJson(Map<String, dynamic> json) {
    final _userId = json['userId'] as String;
    final _authenticatorIds = (json['authenticatorIds'] as List).map((e) => e as String).toList();
    return v1DeleteAuthenticatorsIntent(
      userId: _userId,
      authenticatorIds: _authenticatorIds,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['userId'] = userId;
    _json['authenticatorIds'] = authenticatorIds;
    return _json;
  }
}

class v1DeleteAuthenticatorsRequest {
  final String type;
  /// Timestamp (in milliseconds) of the request, used to verify liveness of user requests.
  final String timestampMs;
  /// Unique identifier for a given Organization.
  final String organizationId;
  final v1DeleteAuthenticatorsIntent parameters;
  final bool? generateAppProofs;

  const v1DeleteAuthenticatorsRequest({
    required  this.type,
    required  this.timestampMs,
    required  this.organizationId,
    required  this.parameters,
     this.generateAppProofs,
  });

  factory v1DeleteAuthenticatorsRequest.fromJson(Map<String, dynamic> json) {
    final _type = json['type'] as String;
    final _timestampMs = json['timestampMs'] as String;
    final _organizationId = json['organizationId'] as String;
    final _parameters = v1DeleteAuthenticatorsIntent.fromJson(json['parameters'] as Map<String, dynamic>);
    final _generateAppProofs = json['generateAppProofs'] as bool?;
    return v1DeleteAuthenticatorsRequest(
      type: _type,
      timestampMs: _timestampMs,
      organizationId: _organizationId,
      parameters: _parameters,
      generateAppProofs: _generateAppProofs,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['type'] = type;
    _json['timestampMs'] = timestampMs;
    _json['organizationId'] = organizationId;
    _json['parameters'] = parameters.toJson();
    if (generateAppProofs != null) {
      _json['generateAppProofs'] = generateAppProofs;
    }
    return _json;
  }
}

class v1DeleteAuthenticatorsResult {
  /// Unique identifier for a given Authenticator.
  final List<String> authenticatorIds;

  const v1DeleteAuthenticatorsResult({
    required  this.authenticatorIds,
  });

  factory v1DeleteAuthenticatorsResult.fromJson(Map<String, dynamic> json) {
    final _authenticatorIds = (json['authenticatorIds'] as List).map((e) => e as String).toList();
    return v1DeleteAuthenticatorsResult(
      authenticatorIds: _authenticatorIds,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['authenticatorIds'] = authenticatorIds;
    return _json;
  }
}

class v1DeleteFiatOnRampCredentialIntent {
  /// The ID of the fiat on-ramp credential to delete
  final String fiatOnrampCredentialId;

  const v1DeleteFiatOnRampCredentialIntent({
    required  this.fiatOnrampCredentialId,
  });

  factory v1DeleteFiatOnRampCredentialIntent.fromJson(Map<String, dynamic> json) {
    final _fiatOnrampCredentialId = json['fiatOnrampCredentialId'] as String;
    return v1DeleteFiatOnRampCredentialIntent(
      fiatOnrampCredentialId: _fiatOnrampCredentialId,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['fiatOnrampCredentialId'] = fiatOnrampCredentialId;
    return _json;
  }
}

class v1DeleteFiatOnRampCredentialRequest {
  final String type;
  /// Timestamp (in milliseconds) of the request, used to verify liveness of user requests.
  final String timestampMs;
  /// Unique identifier for a given Organization.
  final String organizationId;
  final v1DeleteFiatOnRampCredentialIntent parameters;
  final bool? generateAppProofs;

  const v1DeleteFiatOnRampCredentialRequest({
    required  this.type,
    required  this.timestampMs,
    required  this.organizationId,
    required  this.parameters,
     this.generateAppProofs,
  });

  factory v1DeleteFiatOnRampCredentialRequest.fromJson(Map<String, dynamic> json) {
    final _type = json['type'] as String;
    final _timestampMs = json['timestampMs'] as String;
    final _organizationId = json['organizationId'] as String;
    final _parameters = v1DeleteFiatOnRampCredentialIntent.fromJson(json['parameters'] as Map<String, dynamic>);
    final _generateAppProofs = json['generateAppProofs'] as bool?;
    return v1DeleteFiatOnRampCredentialRequest(
      type: _type,
      timestampMs: _timestampMs,
      organizationId: _organizationId,
      parameters: _parameters,
      generateAppProofs: _generateAppProofs,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['type'] = type;
    _json['timestampMs'] = timestampMs;
    _json['organizationId'] = organizationId;
    _json['parameters'] = parameters.toJson();
    if (generateAppProofs != null) {
      _json['generateAppProofs'] = generateAppProofs;
    }
    return _json;
  }
}

class v1DeleteFiatOnRampCredentialResult {
  /// Unique identifier of the Fiat On-Ramp credential that was deleted
  final String fiatOnRampCredentialId;

  const v1DeleteFiatOnRampCredentialResult({
    required  this.fiatOnRampCredentialId,
  });

  factory v1DeleteFiatOnRampCredentialResult.fromJson(Map<String, dynamic> json) {
    final _fiatOnRampCredentialId = json['fiatOnRampCredentialId'] as String;
    return v1DeleteFiatOnRampCredentialResult(
      fiatOnRampCredentialId: _fiatOnRampCredentialId,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['fiatOnRampCredentialId'] = fiatOnRampCredentialId;
    return _json;
  }
}

class v1DeleteInvitationIntent {
  /// Unique identifier for a given Invitation object.
  final String invitationId;

  const v1DeleteInvitationIntent({
    required  this.invitationId,
  });

  factory v1DeleteInvitationIntent.fromJson(Map<String, dynamic> json) {
    final _invitationId = json['invitationId'] as String;
    return v1DeleteInvitationIntent(
      invitationId: _invitationId,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['invitationId'] = invitationId;
    return _json;
  }
}

class v1DeleteInvitationRequest {
  final String type;
  /// Timestamp (in milliseconds) of the request, used to verify liveness of user requests.
  final String timestampMs;
  /// Unique identifier for a given Organization.
  final String organizationId;
  final v1DeleteInvitationIntent parameters;
  final bool? generateAppProofs;

  const v1DeleteInvitationRequest({
    required  this.type,
    required  this.timestampMs,
    required  this.organizationId,
    required  this.parameters,
     this.generateAppProofs,
  });

  factory v1DeleteInvitationRequest.fromJson(Map<String, dynamic> json) {
    final _type = json['type'] as String;
    final _timestampMs = json['timestampMs'] as String;
    final _organizationId = json['organizationId'] as String;
    final _parameters = v1DeleteInvitationIntent.fromJson(json['parameters'] as Map<String, dynamic>);
    final _generateAppProofs = json['generateAppProofs'] as bool?;
    return v1DeleteInvitationRequest(
      type: _type,
      timestampMs: _timestampMs,
      organizationId: _organizationId,
      parameters: _parameters,
      generateAppProofs: _generateAppProofs,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['type'] = type;
    _json['timestampMs'] = timestampMs;
    _json['organizationId'] = organizationId;
    _json['parameters'] = parameters.toJson();
    if (generateAppProofs != null) {
      _json['generateAppProofs'] = generateAppProofs;
    }
    return _json;
  }
}

class v1DeleteInvitationResult {
  /// Unique identifier for a given Invitation.
  final String invitationId;

  const v1DeleteInvitationResult({
    required  this.invitationId,
  });

  factory v1DeleteInvitationResult.fromJson(Map<String, dynamic> json) {
    final _invitationId = json['invitationId'] as String;
    return v1DeleteInvitationResult(
      invitationId: _invitationId,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['invitationId'] = invitationId;
    return _json;
  }
}

class v1DeleteOauth2CredentialIntent {
  /// The ID of the OAuth 2.0 credential to delete
  final String oauth2CredentialId;

  const v1DeleteOauth2CredentialIntent({
    required  this.oauth2CredentialId,
  });

  factory v1DeleteOauth2CredentialIntent.fromJson(Map<String, dynamic> json) {
    final _oauth2CredentialId = json['oauth2CredentialId'] as String;
    return v1DeleteOauth2CredentialIntent(
      oauth2CredentialId: _oauth2CredentialId,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['oauth2CredentialId'] = oauth2CredentialId;
    return _json;
  }
}

class v1DeleteOauth2CredentialRequest {
  final String type;
  /// Timestamp (in milliseconds) of the request, used to verify liveness of user requests.
  final String timestampMs;
  /// Unique identifier for a given Organization.
  final String organizationId;
  final v1DeleteOauth2CredentialIntent parameters;
  final bool? generateAppProofs;

  const v1DeleteOauth2CredentialRequest({
    required  this.type,
    required  this.timestampMs,
    required  this.organizationId,
    required  this.parameters,
     this.generateAppProofs,
  });

  factory v1DeleteOauth2CredentialRequest.fromJson(Map<String, dynamic> json) {
    final _type = json['type'] as String;
    final _timestampMs = json['timestampMs'] as String;
    final _organizationId = json['organizationId'] as String;
    final _parameters = v1DeleteOauth2CredentialIntent.fromJson(json['parameters'] as Map<String, dynamic>);
    final _generateAppProofs = json['generateAppProofs'] as bool?;
    return v1DeleteOauth2CredentialRequest(
      type: _type,
      timestampMs: _timestampMs,
      organizationId: _organizationId,
      parameters: _parameters,
      generateAppProofs: _generateAppProofs,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['type'] = type;
    _json['timestampMs'] = timestampMs;
    _json['organizationId'] = organizationId;
    _json['parameters'] = parameters.toJson();
    if (generateAppProofs != null) {
      _json['generateAppProofs'] = generateAppProofs;
    }
    return _json;
  }
}

class v1DeleteOauth2CredentialResult {
  /// Unique identifier of the OAuth 2.0 credential that was deleted
  final String oauth2CredentialId;

  const v1DeleteOauth2CredentialResult({
    required  this.oauth2CredentialId,
  });

  factory v1DeleteOauth2CredentialResult.fromJson(Map<String, dynamic> json) {
    final _oauth2CredentialId = json['oauth2CredentialId'] as String;
    return v1DeleteOauth2CredentialResult(
      oauth2CredentialId: _oauth2CredentialId,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['oauth2CredentialId'] = oauth2CredentialId;
    return _json;
  }
}

class v1DeleteOauthProvidersIntent {
  /// The ID of the User to remove an Oauth provider from
  final String userId;
  /// Unique identifier for a given Provider.
  final List<String> providerIds;

  const v1DeleteOauthProvidersIntent({
    required  this.userId,
    required  this.providerIds,
  });

  factory v1DeleteOauthProvidersIntent.fromJson(Map<String, dynamic> json) {
    final _userId = json['userId'] as String;
    final _providerIds = (json['providerIds'] as List).map((e) => e as String).toList();
    return v1DeleteOauthProvidersIntent(
      userId: _userId,
      providerIds: _providerIds,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['userId'] = userId;
    _json['providerIds'] = providerIds;
    return _json;
  }
}

class v1DeleteOauthProvidersRequest {
  final String type;
  /// Timestamp (in milliseconds) of the request, used to verify liveness of user requests.
  final String timestampMs;
  /// Unique identifier for a given Organization.
  final String organizationId;
  final v1DeleteOauthProvidersIntent parameters;
  final bool? generateAppProofs;

  const v1DeleteOauthProvidersRequest({
    required  this.type,
    required  this.timestampMs,
    required  this.organizationId,
    required  this.parameters,
     this.generateAppProofs,
  });

  factory v1DeleteOauthProvidersRequest.fromJson(Map<String, dynamic> json) {
    final _type = json['type'] as String;
    final _timestampMs = json['timestampMs'] as String;
    final _organizationId = json['organizationId'] as String;
    final _parameters = v1DeleteOauthProvidersIntent.fromJson(json['parameters'] as Map<String, dynamic>);
    final _generateAppProofs = json['generateAppProofs'] as bool?;
    return v1DeleteOauthProvidersRequest(
      type: _type,
      timestampMs: _timestampMs,
      organizationId: _organizationId,
      parameters: _parameters,
      generateAppProofs: _generateAppProofs,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['type'] = type;
    _json['timestampMs'] = timestampMs;
    _json['organizationId'] = organizationId;
    _json['parameters'] = parameters.toJson();
    if (generateAppProofs != null) {
      _json['generateAppProofs'] = generateAppProofs;
    }
    return _json;
  }
}

class v1DeleteOauthProvidersResult {
  /// A list of unique identifiers for Oauth Providers
  final List<String> providerIds;

  const v1DeleteOauthProvidersResult({
    required  this.providerIds,
  });

  factory v1DeleteOauthProvidersResult.fromJson(Map<String, dynamic> json) {
    final _providerIds = (json['providerIds'] as List).map((e) => e as String).toList();
    return v1DeleteOauthProvidersResult(
      providerIds: _providerIds,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['providerIds'] = providerIds;
    return _json;
  }
}

class v1DeleteOrganizationIntent {
  /// Unique identifier for a given Organization.
  final String organizationId;

  const v1DeleteOrganizationIntent({
    required  this.organizationId,
  });

  factory v1DeleteOrganizationIntent.fromJson(Map<String, dynamic> json) {
    final _organizationId = json['organizationId'] as String;
    return v1DeleteOrganizationIntent(
      organizationId: _organizationId,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['organizationId'] = organizationId;
    return _json;
  }
}

class v1DeleteOrganizationResult {
  /// Unique identifier for a given Organization.
  final String organizationId;

  const v1DeleteOrganizationResult({
    required  this.organizationId,
  });

  factory v1DeleteOrganizationResult.fromJson(Map<String, dynamic> json) {
    final _organizationId = json['organizationId'] as String;
    return v1DeleteOrganizationResult(
      organizationId: _organizationId,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['organizationId'] = organizationId;
    return _json;
  }
}

class v1DeletePoliciesIntent {
  /// List of unique identifiers for policies within an organization
  final List<String> policyIds;

  const v1DeletePoliciesIntent({
    required  this.policyIds,
  });

  factory v1DeletePoliciesIntent.fromJson(Map<String, dynamic> json) {
    final _policyIds = (json['policyIds'] as List).map((e) => e as String).toList();
    return v1DeletePoliciesIntent(
      policyIds: _policyIds,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['policyIds'] = policyIds;
    return _json;
  }
}

class v1DeletePoliciesRequest {
  final String type;
  /// Timestamp (in milliseconds) of the request, used to verify liveness of user requests.
  final String timestampMs;
  /// Unique identifier for a given Organization.
  final String organizationId;
  final v1DeletePoliciesIntent parameters;
  final bool? generateAppProofs;

  const v1DeletePoliciesRequest({
    required  this.type,
    required  this.timestampMs,
    required  this.organizationId,
    required  this.parameters,
     this.generateAppProofs,
  });

  factory v1DeletePoliciesRequest.fromJson(Map<String, dynamic> json) {
    final _type = json['type'] as String;
    final _timestampMs = json['timestampMs'] as String;
    final _organizationId = json['organizationId'] as String;
    final _parameters = v1DeletePoliciesIntent.fromJson(json['parameters'] as Map<String, dynamic>);
    final _generateAppProofs = json['generateAppProofs'] as bool?;
    return v1DeletePoliciesRequest(
      type: _type,
      timestampMs: _timestampMs,
      organizationId: _organizationId,
      parameters: _parameters,
      generateAppProofs: _generateAppProofs,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['type'] = type;
    _json['timestampMs'] = timestampMs;
    _json['organizationId'] = organizationId;
    _json['parameters'] = parameters.toJson();
    if (generateAppProofs != null) {
      _json['generateAppProofs'] = generateAppProofs;
    }
    return _json;
  }
}

class v1DeletePoliciesResult {
  /// A list of unique identifiers for the deleted policies.
  final List<String> policyIds;

  const v1DeletePoliciesResult({
    required  this.policyIds,
  });

  factory v1DeletePoliciesResult.fromJson(Map<String, dynamic> json) {
    final _policyIds = (json['policyIds'] as List).map((e) => e as String).toList();
    return v1DeletePoliciesResult(
      policyIds: _policyIds,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['policyIds'] = policyIds;
    return _json;
  }
}

class v1DeletePolicyIntent {
  /// Unique identifier for a given Policy.
  final String policyId;

  const v1DeletePolicyIntent({
    required  this.policyId,
  });

  factory v1DeletePolicyIntent.fromJson(Map<String, dynamic> json) {
    final _policyId = json['policyId'] as String;
    return v1DeletePolicyIntent(
      policyId: _policyId,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['policyId'] = policyId;
    return _json;
  }
}

class v1DeletePolicyRequest {
  final String type;
  /// Timestamp (in milliseconds) of the request, used to verify liveness of user requests.
  final String timestampMs;
  /// Unique identifier for a given Organization.
  final String organizationId;
  final v1DeletePolicyIntent parameters;
  final bool? generateAppProofs;

  const v1DeletePolicyRequest({
    required  this.type,
    required  this.timestampMs,
    required  this.organizationId,
    required  this.parameters,
     this.generateAppProofs,
  });

  factory v1DeletePolicyRequest.fromJson(Map<String, dynamic> json) {
    final _type = json['type'] as String;
    final _timestampMs = json['timestampMs'] as String;
    final _organizationId = json['organizationId'] as String;
    final _parameters = v1DeletePolicyIntent.fromJson(json['parameters'] as Map<String, dynamic>);
    final _generateAppProofs = json['generateAppProofs'] as bool?;
    return v1DeletePolicyRequest(
      type: _type,
      timestampMs: _timestampMs,
      organizationId: _organizationId,
      parameters: _parameters,
      generateAppProofs: _generateAppProofs,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['type'] = type;
    _json['timestampMs'] = timestampMs;
    _json['organizationId'] = organizationId;
    _json['parameters'] = parameters.toJson();
    if (generateAppProofs != null) {
      _json['generateAppProofs'] = generateAppProofs;
    }
    return _json;
  }
}

class v1DeletePolicyResult {
  /// Unique identifier for a given Policy.
  final String policyId;

  const v1DeletePolicyResult({
    required  this.policyId,
  });

  factory v1DeletePolicyResult.fromJson(Map<String, dynamic> json) {
    final _policyId = json['policyId'] as String;
    return v1DeletePolicyResult(
      policyId: _policyId,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['policyId'] = policyId;
    return _json;
  }
}

class v1DeletePrivateKeyTagsIntent {
  /// A list of Private Key Tag IDs.
  final List<String> privateKeyTagIds;

  const v1DeletePrivateKeyTagsIntent({
    required  this.privateKeyTagIds,
  });

  factory v1DeletePrivateKeyTagsIntent.fromJson(Map<String, dynamic> json) {
    final _privateKeyTagIds = (json['privateKeyTagIds'] as List).map((e) => e as String).toList();
    return v1DeletePrivateKeyTagsIntent(
      privateKeyTagIds: _privateKeyTagIds,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['privateKeyTagIds'] = privateKeyTagIds;
    return _json;
  }
}

class v1DeletePrivateKeyTagsRequest {
  final String type;
  /// Timestamp (in milliseconds) of the request, used to verify liveness of user requests.
  final String timestampMs;
  /// Unique identifier for a given Organization.
  final String organizationId;
  final v1DeletePrivateKeyTagsIntent parameters;
  final bool? generateAppProofs;

  const v1DeletePrivateKeyTagsRequest({
    required  this.type,
    required  this.timestampMs,
    required  this.organizationId,
    required  this.parameters,
     this.generateAppProofs,
  });

  factory v1DeletePrivateKeyTagsRequest.fromJson(Map<String, dynamic> json) {
    final _type = json['type'] as String;
    final _timestampMs = json['timestampMs'] as String;
    final _organizationId = json['organizationId'] as String;
    final _parameters = v1DeletePrivateKeyTagsIntent.fromJson(json['parameters'] as Map<String, dynamic>);
    final _generateAppProofs = json['generateAppProofs'] as bool?;
    return v1DeletePrivateKeyTagsRequest(
      type: _type,
      timestampMs: _timestampMs,
      organizationId: _organizationId,
      parameters: _parameters,
      generateAppProofs: _generateAppProofs,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['type'] = type;
    _json['timestampMs'] = timestampMs;
    _json['organizationId'] = organizationId;
    _json['parameters'] = parameters.toJson();
    if (generateAppProofs != null) {
      _json['generateAppProofs'] = generateAppProofs;
    }
    return _json;
  }
}

class v1DeletePrivateKeyTagsResult {
  /// A list of Private Key Tag IDs.
  final List<String> privateKeyTagIds;
  /// A list of Private Key IDs.
  final List<String> privateKeyIds;

  const v1DeletePrivateKeyTagsResult({
    required  this.privateKeyTagIds,
    required  this.privateKeyIds,
  });

  factory v1DeletePrivateKeyTagsResult.fromJson(Map<String, dynamic> json) {
    final _privateKeyTagIds = (json['privateKeyTagIds'] as List).map((e) => e as String).toList();
    final _privateKeyIds = (json['privateKeyIds'] as List).map((e) => e as String).toList();
    return v1DeletePrivateKeyTagsResult(
      privateKeyTagIds: _privateKeyTagIds,
      privateKeyIds: _privateKeyIds,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['privateKeyTagIds'] = privateKeyTagIds;
    _json['privateKeyIds'] = privateKeyIds;
    return _json;
  }
}

class v1DeletePrivateKeysIntent {
  /// List of unique identifiers for private keys within an organization
  final List<String> privateKeyIds;
  /// Optional parameter for deleting the private keys, even if any have not been previously exported. If they have been exported, this field is ignored.
  final bool? deleteWithoutExport;

  const v1DeletePrivateKeysIntent({
    required  this.privateKeyIds,
     this.deleteWithoutExport,
  });

  factory v1DeletePrivateKeysIntent.fromJson(Map<String, dynamic> json) {
    final _privateKeyIds = (json['privateKeyIds'] as List).map((e) => e as String).toList();
    final _deleteWithoutExport = json['deleteWithoutExport'] as bool?;
    return v1DeletePrivateKeysIntent(
      privateKeyIds: _privateKeyIds,
      deleteWithoutExport: _deleteWithoutExport,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['privateKeyIds'] = privateKeyIds;
    if (deleteWithoutExport != null) {
      _json['deleteWithoutExport'] = deleteWithoutExport;
    }
    return _json;
  }
}

class v1DeletePrivateKeysRequest {
  final String type;
  /// Timestamp (in milliseconds) of the request, used to verify liveness of user requests.
  final String timestampMs;
  /// Unique identifier for a given Organization.
  final String organizationId;
  final v1DeletePrivateKeysIntent parameters;
  final bool? generateAppProofs;

  const v1DeletePrivateKeysRequest({
    required  this.type,
    required  this.timestampMs,
    required  this.organizationId,
    required  this.parameters,
     this.generateAppProofs,
  });

  factory v1DeletePrivateKeysRequest.fromJson(Map<String, dynamic> json) {
    final _type = json['type'] as String;
    final _timestampMs = json['timestampMs'] as String;
    final _organizationId = json['organizationId'] as String;
    final _parameters = v1DeletePrivateKeysIntent.fromJson(json['parameters'] as Map<String, dynamic>);
    final _generateAppProofs = json['generateAppProofs'] as bool?;
    return v1DeletePrivateKeysRequest(
      type: _type,
      timestampMs: _timestampMs,
      organizationId: _organizationId,
      parameters: _parameters,
      generateAppProofs: _generateAppProofs,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['type'] = type;
    _json['timestampMs'] = timestampMs;
    _json['organizationId'] = organizationId;
    _json['parameters'] = parameters.toJson();
    if (generateAppProofs != null) {
      _json['generateAppProofs'] = generateAppProofs;
    }
    return _json;
  }
}

class v1DeletePrivateKeysResult {
  /// A list of private key unique identifiers that were removed
  final List<String> privateKeyIds;

  const v1DeletePrivateKeysResult({
    required  this.privateKeyIds,
  });

  factory v1DeletePrivateKeysResult.fromJson(Map<String, dynamic> json) {
    final _privateKeyIds = (json['privateKeyIds'] as List).map((e) => e as String).toList();
    return v1DeletePrivateKeysResult(
      privateKeyIds: _privateKeyIds,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['privateKeyIds'] = privateKeyIds;
    return _json;
  }
}

class v1DeleteSmartContractInterfaceIntent {
  /// The ID of a Smart Contract Interface intended for deletion.
  final String smartContractInterfaceId;

  const v1DeleteSmartContractInterfaceIntent({
    required  this.smartContractInterfaceId,
  });

  factory v1DeleteSmartContractInterfaceIntent.fromJson(Map<String, dynamic> json) {
    final _smartContractInterfaceId = json['smartContractInterfaceId'] as String;
    return v1DeleteSmartContractInterfaceIntent(
      smartContractInterfaceId: _smartContractInterfaceId,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['smartContractInterfaceId'] = smartContractInterfaceId;
    return _json;
  }
}

class v1DeleteSmartContractInterfaceRequest {
  final String type;
  /// Timestamp (in milliseconds) of the request, used to verify liveness of user requests.
  final String timestampMs;
  /// Unique identifier for a given Organization.
  final String organizationId;
  final v1DeleteSmartContractInterfaceIntent parameters;
  final bool? generateAppProofs;

  const v1DeleteSmartContractInterfaceRequest({
    required  this.type,
    required  this.timestampMs,
    required  this.organizationId,
    required  this.parameters,
     this.generateAppProofs,
  });

  factory v1DeleteSmartContractInterfaceRequest.fromJson(Map<String, dynamic> json) {
    final _type = json['type'] as String;
    final _timestampMs = json['timestampMs'] as String;
    final _organizationId = json['organizationId'] as String;
    final _parameters = v1DeleteSmartContractInterfaceIntent.fromJson(json['parameters'] as Map<String, dynamic>);
    final _generateAppProofs = json['generateAppProofs'] as bool?;
    return v1DeleteSmartContractInterfaceRequest(
      type: _type,
      timestampMs: _timestampMs,
      organizationId: _organizationId,
      parameters: _parameters,
      generateAppProofs: _generateAppProofs,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['type'] = type;
    _json['timestampMs'] = timestampMs;
    _json['organizationId'] = organizationId;
    _json['parameters'] = parameters.toJson();
    if (generateAppProofs != null) {
      _json['generateAppProofs'] = generateAppProofs;
    }
    return _json;
  }
}

class v1DeleteSmartContractInterfaceResult {
  /// The ID of the deleted Smart Contract Interface.
  final String smartContractInterfaceId;

  const v1DeleteSmartContractInterfaceResult({
    required  this.smartContractInterfaceId,
  });

  factory v1DeleteSmartContractInterfaceResult.fromJson(Map<String, dynamic> json) {
    final _smartContractInterfaceId = json['smartContractInterfaceId'] as String;
    return v1DeleteSmartContractInterfaceResult(
      smartContractInterfaceId: _smartContractInterfaceId,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['smartContractInterfaceId'] = smartContractInterfaceId;
    return _json;
  }
}

class v1DeleteSubOrganizationIntent {
  /// Sub-organization deletion, by default, requires associated wallets and private keys to be exported for security reasons. Set this boolean to true to force sub-organization deletion even if some wallets or private keys within it have not been exported yet. Default: false.
  final bool? deleteWithoutExport;

  const v1DeleteSubOrganizationIntent({
     this.deleteWithoutExport,
  });

  factory v1DeleteSubOrganizationIntent.fromJson(Map<String, dynamic> json) {
    final _deleteWithoutExport = json['deleteWithoutExport'] as bool?;
    return v1DeleteSubOrganizationIntent(
      deleteWithoutExport: _deleteWithoutExport,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    if (deleteWithoutExport != null) {
      _json['deleteWithoutExport'] = deleteWithoutExport;
    }
    return _json;
  }
}

class v1DeleteSubOrganizationRequest {
  final String type;
  /// Timestamp (in milliseconds) of the request, used to verify liveness of user requests.
  final String timestampMs;
  /// Unique identifier for a given Organization.
  final String organizationId;
  final v1DeleteSubOrganizationIntent parameters;
  final bool? generateAppProofs;

  const v1DeleteSubOrganizationRequest({
    required  this.type,
    required  this.timestampMs,
    required  this.organizationId,
    required  this.parameters,
     this.generateAppProofs,
  });

  factory v1DeleteSubOrganizationRequest.fromJson(Map<String, dynamic> json) {
    final _type = json['type'] as String;
    final _timestampMs = json['timestampMs'] as String;
    final _organizationId = json['organizationId'] as String;
    final _parameters = v1DeleteSubOrganizationIntent.fromJson(json['parameters'] as Map<String, dynamic>);
    final _generateAppProofs = json['generateAppProofs'] as bool?;
    return v1DeleteSubOrganizationRequest(
      type: _type,
      timestampMs: _timestampMs,
      organizationId: _organizationId,
      parameters: _parameters,
      generateAppProofs: _generateAppProofs,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['type'] = type;
    _json['timestampMs'] = timestampMs;
    _json['organizationId'] = organizationId;
    _json['parameters'] = parameters.toJson();
    if (generateAppProofs != null) {
      _json['generateAppProofs'] = generateAppProofs;
    }
    return _json;
  }
}

class v1DeleteSubOrganizationResult {
  /// Unique identifier of the sub organization that was removed
  final String subOrganizationUuid;

  const v1DeleteSubOrganizationResult({
    required  this.subOrganizationUuid,
  });

  factory v1DeleteSubOrganizationResult.fromJson(Map<String, dynamic> json) {
    final _subOrganizationUuid = json['subOrganizationUuid'] as String;
    return v1DeleteSubOrganizationResult(
      subOrganizationUuid: _subOrganizationUuid,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['subOrganizationUuid'] = subOrganizationUuid;
    return _json;
  }
}

class v1DeleteUserTagsIntent {
  /// A list of User Tag IDs.
  final List<String> userTagIds;

  const v1DeleteUserTagsIntent({
    required  this.userTagIds,
  });

  factory v1DeleteUserTagsIntent.fromJson(Map<String, dynamic> json) {
    final _userTagIds = (json['userTagIds'] as List).map((e) => e as String).toList();
    return v1DeleteUserTagsIntent(
      userTagIds: _userTagIds,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['userTagIds'] = userTagIds;
    return _json;
  }
}

class v1DeleteUserTagsRequest {
  final String type;
  /// Timestamp (in milliseconds) of the request, used to verify liveness of user requests.
  final String timestampMs;
  /// Unique identifier for a given Organization.
  final String organizationId;
  final v1DeleteUserTagsIntent parameters;
  final bool? generateAppProofs;

  const v1DeleteUserTagsRequest({
    required  this.type,
    required  this.timestampMs,
    required  this.organizationId,
    required  this.parameters,
     this.generateAppProofs,
  });

  factory v1DeleteUserTagsRequest.fromJson(Map<String, dynamic> json) {
    final _type = json['type'] as String;
    final _timestampMs = json['timestampMs'] as String;
    final _organizationId = json['organizationId'] as String;
    final _parameters = v1DeleteUserTagsIntent.fromJson(json['parameters'] as Map<String, dynamic>);
    final _generateAppProofs = json['generateAppProofs'] as bool?;
    return v1DeleteUserTagsRequest(
      type: _type,
      timestampMs: _timestampMs,
      organizationId: _organizationId,
      parameters: _parameters,
      generateAppProofs: _generateAppProofs,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['type'] = type;
    _json['timestampMs'] = timestampMs;
    _json['organizationId'] = organizationId;
    _json['parameters'] = parameters.toJson();
    if (generateAppProofs != null) {
      _json['generateAppProofs'] = generateAppProofs;
    }
    return _json;
  }
}

class v1DeleteUserTagsResult {
  /// A list of User Tag IDs.
  final List<String> userTagIds;
  /// A list of User IDs.
  final List<String> userIds;

  const v1DeleteUserTagsResult({
    required  this.userTagIds,
    required  this.userIds,
  });

  factory v1DeleteUserTagsResult.fromJson(Map<String, dynamic> json) {
    final _userTagIds = (json['userTagIds'] as List).map((e) => e as String).toList();
    final _userIds = (json['userIds'] as List).map((e) => e as String).toList();
    return v1DeleteUserTagsResult(
      userTagIds: _userTagIds,
      userIds: _userIds,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['userTagIds'] = userTagIds;
    _json['userIds'] = userIds;
    return _json;
  }
}

class v1DeleteUsersIntent {
  /// A list of User IDs.
  final List<String> userIds;

  const v1DeleteUsersIntent({
    required  this.userIds,
  });

  factory v1DeleteUsersIntent.fromJson(Map<String, dynamic> json) {
    final _userIds = (json['userIds'] as List).map((e) => e as String).toList();
    return v1DeleteUsersIntent(
      userIds: _userIds,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['userIds'] = userIds;
    return _json;
  }
}

class v1DeleteUsersRequest {
  final String type;
  /// Timestamp (in milliseconds) of the request, used to verify liveness of user requests.
  final String timestampMs;
  /// Unique identifier for a given Organization.
  final String organizationId;
  final v1DeleteUsersIntent parameters;
  final bool? generateAppProofs;

  const v1DeleteUsersRequest({
    required  this.type,
    required  this.timestampMs,
    required  this.organizationId,
    required  this.parameters,
     this.generateAppProofs,
  });

  factory v1DeleteUsersRequest.fromJson(Map<String, dynamic> json) {
    final _type = json['type'] as String;
    final _timestampMs = json['timestampMs'] as String;
    final _organizationId = json['organizationId'] as String;
    final _parameters = v1DeleteUsersIntent.fromJson(json['parameters'] as Map<String, dynamic>);
    final _generateAppProofs = json['generateAppProofs'] as bool?;
    return v1DeleteUsersRequest(
      type: _type,
      timestampMs: _timestampMs,
      organizationId: _organizationId,
      parameters: _parameters,
      generateAppProofs: _generateAppProofs,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['type'] = type;
    _json['timestampMs'] = timestampMs;
    _json['organizationId'] = organizationId;
    _json['parameters'] = parameters.toJson();
    if (generateAppProofs != null) {
      _json['generateAppProofs'] = generateAppProofs;
    }
    return _json;
  }
}

class v1DeleteUsersResult {
  /// A list of User IDs.
  final List<String> userIds;

  const v1DeleteUsersResult({
    required  this.userIds,
  });

  factory v1DeleteUsersResult.fromJson(Map<String, dynamic> json) {
    final _userIds = (json['userIds'] as List).map((e) => e as String).toList();
    return v1DeleteUsersResult(
      userIds: _userIds,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['userIds'] = userIds;
    return _json;
  }
}

class v1DeleteWalletAccountsIntent {
  /// List of unique identifiers for wallet accounts within an organization
  final List<String> walletAccountIds;
  /// Optional parameter for deleting the wallet accounts, even if any have not been previously exported. If they have been exported, this field is ignored.
  final bool? deleteWithoutExport;

  const v1DeleteWalletAccountsIntent({
    required  this.walletAccountIds,
     this.deleteWithoutExport,
  });

  factory v1DeleteWalletAccountsIntent.fromJson(Map<String, dynamic> json) {
    final _walletAccountIds = (json['walletAccountIds'] as List).map((e) => e as String).toList();
    final _deleteWithoutExport = json['deleteWithoutExport'] as bool?;
    return v1DeleteWalletAccountsIntent(
      walletAccountIds: _walletAccountIds,
      deleteWithoutExport: _deleteWithoutExport,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['walletAccountIds'] = walletAccountIds;
    if (deleteWithoutExport != null) {
      _json['deleteWithoutExport'] = deleteWithoutExport;
    }
    return _json;
  }
}

class v1DeleteWalletAccountsRequest {
  final String type;
  /// Timestamp (in milliseconds) of the request, used to verify liveness of user requests.
  final String timestampMs;
  /// Unique identifier for a given Organization.
  final String organizationId;
  final v1DeleteWalletAccountsIntent parameters;
  final bool? generateAppProofs;

  const v1DeleteWalletAccountsRequest({
    required  this.type,
    required  this.timestampMs,
    required  this.organizationId,
    required  this.parameters,
     this.generateAppProofs,
  });

  factory v1DeleteWalletAccountsRequest.fromJson(Map<String, dynamic> json) {
    final _type = json['type'] as String;
    final _timestampMs = json['timestampMs'] as String;
    final _organizationId = json['organizationId'] as String;
    final _parameters = v1DeleteWalletAccountsIntent.fromJson(json['parameters'] as Map<String, dynamic>);
    final _generateAppProofs = json['generateAppProofs'] as bool?;
    return v1DeleteWalletAccountsRequest(
      type: _type,
      timestampMs: _timestampMs,
      organizationId: _organizationId,
      parameters: _parameters,
      generateAppProofs: _generateAppProofs,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['type'] = type;
    _json['timestampMs'] = timestampMs;
    _json['organizationId'] = organizationId;
    _json['parameters'] = parameters.toJson();
    if (generateAppProofs != null) {
      _json['generateAppProofs'] = generateAppProofs;
    }
    return _json;
  }
}

class v1DeleteWalletAccountsResult {
  /// A list of wallet account unique identifiers that were removed
  final List<String> walletAccountIds;

  const v1DeleteWalletAccountsResult({
    required  this.walletAccountIds,
  });

  factory v1DeleteWalletAccountsResult.fromJson(Map<String, dynamic> json) {
    final _walletAccountIds = (json['walletAccountIds'] as List).map((e) => e as String).toList();
    return v1DeleteWalletAccountsResult(
      walletAccountIds: _walletAccountIds,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['walletAccountIds'] = walletAccountIds;
    return _json;
  }
}

class v1DeleteWalletsIntent {
  /// List of unique identifiers for wallets within an organization
  final List<String> walletIds;
  /// Optional parameter for deleting the wallets, even if any have not been previously exported. If they have been exported, this field is ignored.
  final bool? deleteWithoutExport;

  const v1DeleteWalletsIntent({
    required  this.walletIds,
     this.deleteWithoutExport,
  });

  factory v1DeleteWalletsIntent.fromJson(Map<String, dynamic> json) {
    final _walletIds = (json['walletIds'] as List).map((e) => e as String).toList();
    final _deleteWithoutExport = json['deleteWithoutExport'] as bool?;
    return v1DeleteWalletsIntent(
      walletIds: _walletIds,
      deleteWithoutExport: _deleteWithoutExport,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['walletIds'] = walletIds;
    if (deleteWithoutExport != null) {
      _json['deleteWithoutExport'] = deleteWithoutExport;
    }
    return _json;
  }
}

class v1DeleteWalletsRequest {
  final String type;
  /// Timestamp (in milliseconds) of the request, used to verify liveness of user requests.
  final String timestampMs;
  /// Unique identifier for a given Organization.
  final String organizationId;
  final v1DeleteWalletsIntent parameters;
  final bool? generateAppProofs;

  const v1DeleteWalletsRequest({
    required  this.type,
    required  this.timestampMs,
    required  this.organizationId,
    required  this.parameters,
     this.generateAppProofs,
  });

  factory v1DeleteWalletsRequest.fromJson(Map<String, dynamic> json) {
    final _type = json['type'] as String;
    final _timestampMs = json['timestampMs'] as String;
    final _organizationId = json['organizationId'] as String;
    final _parameters = v1DeleteWalletsIntent.fromJson(json['parameters'] as Map<String, dynamic>);
    final _generateAppProofs = json['generateAppProofs'] as bool?;
    return v1DeleteWalletsRequest(
      type: _type,
      timestampMs: _timestampMs,
      organizationId: _organizationId,
      parameters: _parameters,
      generateAppProofs: _generateAppProofs,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['type'] = type;
    _json['timestampMs'] = timestampMs;
    _json['organizationId'] = organizationId;
    _json['parameters'] = parameters.toJson();
    if (generateAppProofs != null) {
      _json['generateAppProofs'] = generateAppProofs;
    }
    return _json;
  }
}

class v1DeleteWalletsResult {
  /// A list of wallet unique identifiers that were removed
  final List<String> walletIds;

  const v1DeleteWalletsResult({
    required  this.walletIds,
  });

  factory v1DeleteWalletsResult.fromJson(Map<String, dynamic> json) {
    final _walletIds = (json['walletIds'] as List).map((e) => e as String).toList();
    return v1DeleteWalletsResult(
      walletIds: _walletIds,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['walletIds'] = walletIds;
    return _json;
  }
}

class v1DisableAuthProxyIntent {
  const v1DisableAuthProxyIntent();
  factory v1DisableAuthProxyIntent.fromJson(Map<String, dynamic> json) => const v1DisableAuthProxyIntent();
  Map<String, dynamic> toJson() => {};
}

class v1DisableAuthProxyResult {
  const v1DisableAuthProxyResult();
  factory v1DisableAuthProxyResult.fromJson(Map<String, dynamic> json) => const v1DisableAuthProxyResult();
  Map<String, dynamic> toJson() => {};
}

class v1DisablePrivateKeyIntent {
  /// Unique identifier for a given Private Key.
  final String privateKeyId;

  const v1DisablePrivateKeyIntent({
    required  this.privateKeyId,
  });

  factory v1DisablePrivateKeyIntent.fromJson(Map<String, dynamic> json) {
    final _privateKeyId = json['privateKeyId'] as String;
    return v1DisablePrivateKeyIntent(
      privateKeyId: _privateKeyId,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['privateKeyId'] = privateKeyId;
    return _json;
  }
}

class v1DisablePrivateKeyResult {
  /// Unique identifier for a given Private Key.
  final String privateKeyId;

  const v1DisablePrivateKeyResult({
    required  this.privateKeyId,
  });

  factory v1DisablePrivateKeyResult.fromJson(Map<String, dynamic> json) {
    final _privateKeyId = json['privateKeyId'] as String;
    return v1DisablePrivateKeyResult(
      privateKeyId: _privateKeyId,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['privateKeyId'] = privateKeyId;
    return _json;
  }
}

class v1EmailAuthCustomizationParams {
  /// The name of the application. This field is required and will be used in email notifications if an email template is not provided.
  final String appName;
  /// A URL pointing to a logo in PNG format. Note this logo will be resized to fit into 340px x 124px.
  final String? logoUrl;
  /// A template for the URL to be used in a magic link button, e.g. `https://dapp.xyz/%s`. The auth bundle will be interpolated into the `%s`.
  final String? magicLinkTemplate;
  /// JSON object containing key/value pairs to be used with custom templates.
  final String? templateVariables;
  /// Unique identifier for a given Email Template. If not specified, the default is the most recent Email Template.
  final String? templateId;

  const v1EmailAuthCustomizationParams({
    required  this.appName,
     this.logoUrl,
     this.magicLinkTemplate,
     this.templateVariables,
     this.templateId,
  });

  factory v1EmailAuthCustomizationParams.fromJson(Map<String, dynamic> json) {
    final _appName = json['appName'] as String;
    final _logoUrl = json['logoUrl'] as String?;
    final _magicLinkTemplate = json['magicLinkTemplate'] as String?;
    final _templateVariables = json['templateVariables'] as String?;
    final _templateId = json['templateId'] as String?;
    return v1EmailAuthCustomizationParams(
      appName: _appName,
      logoUrl: _logoUrl,
      magicLinkTemplate: _magicLinkTemplate,
      templateVariables: _templateVariables,
      templateId: _templateId,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['appName'] = appName;
    if (logoUrl != null) {
      _json['logoUrl'] = logoUrl;
    }
    if (magicLinkTemplate != null) {
      _json['magicLinkTemplate'] = magicLinkTemplate;
    }
    if (templateVariables != null) {
      _json['templateVariables'] = templateVariables;
    }
    if (templateId != null) {
      _json['templateId'] = templateId;
    }
    return _json;
  }
}

class v1EmailAuthIntent {
  /// Email of the authenticating user.
  final String email;
  /// Client-side public key generated by the user, to which the email auth bundle (credentials) will be encrypted.
  final String targetPublicKey;
  /// Optional human-readable name for an API Key. If none provided, default to Email Auth - <Timestamp>
  final String? apiKeyName;
  /// Expiration window (in seconds) indicating how long the API key is valid for. If not provided, a default of 15 minutes will be used.
  final String? expirationSeconds;
  /// Optional parameters for customizing emails. If not provided, the default email will be used.
  final v1EmailCustomizationParams? emailCustomization;
  /// Invalidate all other previously generated Email Auth API keys
  final bool? invalidateExisting;
  /// Optional custom email address from which to send the email
  final String? sendFromEmailAddress;
  /// Optional custom sender name for use with sendFromEmailAddress; if left empty, will default to 'Notifications'
  final String? sendFromEmailSenderName;
  /// Optional custom email address to use as reply-to
  final String? replyToEmailAddress;

  const v1EmailAuthIntent({
    required  this.email,
    required  this.targetPublicKey,
     this.apiKeyName,
     this.expirationSeconds,
     this.emailCustomization,
     this.invalidateExisting,
     this.sendFromEmailAddress,
     this.sendFromEmailSenderName,
     this.replyToEmailAddress,
  });

  factory v1EmailAuthIntent.fromJson(Map<String, dynamic> json) {
    final _email = json['email'] as String;
    final _targetPublicKey = json['targetPublicKey'] as String;
    final _apiKeyName = json['apiKeyName'] as String?;
    final _expirationSeconds = json['expirationSeconds'] as String?;
    final _emailCustomization = json['emailCustomization'] == null ? null : v1EmailCustomizationParams.fromJson(json['emailCustomization'] as Map<String, dynamic>);
    final _invalidateExisting = json['invalidateExisting'] as bool?;
    final _sendFromEmailAddress = json['sendFromEmailAddress'] as String?;
    final _sendFromEmailSenderName = json['sendFromEmailSenderName'] as String?;
    final _replyToEmailAddress = json['replyToEmailAddress'] as String?;
    return v1EmailAuthIntent(
      email: _email,
      targetPublicKey: _targetPublicKey,
      apiKeyName: _apiKeyName,
      expirationSeconds: _expirationSeconds,
      emailCustomization: _emailCustomization,
      invalidateExisting: _invalidateExisting,
      sendFromEmailAddress: _sendFromEmailAddress,
      sendFromEmailSenderName: _sendFromEmailSenderName,
      replyToEmailAddress: _replyToEmailAddress,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['email'] = email;
    _json['targetPublicKey'] = targetPublicKey;
    if (apiKeyName != null) {
      _json['apiKeyName'] = apiKeyName;
    }
    if (expirationSeconds != null) {
      _json['expirationSeconds'] = expirationSeconds;
    }
    if (emailCustomization != null) {
      _json['emailCustomization'] = emailCustomization?.toJson();
    }
    if (invalidateExisting != null) {
      _json['invalidateExisting'] = invalidateExisting;
    }
    if (sendFromEmailAddress != null) {
      _json['sendFromEmailAddress'] = sendFromEmailAddress;
    }
    if (sendFromEmailSenderName != null) {
      _json['sendFromEmailSenderName'] = sendFromEmailSenderName;
    }
    if (replyToEmailAddress != null) {
      _json['replyToEmailAddress'] = replyToEmailAddress;
    }
    return _json;
  }
}

class v1EmailAuthIntentV2 {
  /// Email of the authenticating user.
  final String email;
  /// Client-side public key generated by the user, to which the email auth bundle (credentials) will be encrypted.
  final String targetPublicKey;
  /// Optional human-readable name for an API Key. If none provided, default to Email Auth - <Timestamp>
  final String? apiKeyName;
  /// Expiration window (in seconds) indicating how long the API key is valid for. If not provided, a default of 15 minutes will be used.
  final String? expirationSeconds;
  /// Optional parameters for customizing emails. If not provided, the default email will be used.
  final v1EmailCustomizationParams? emailCustomization;
  /// Invalidate all other previously generated Email Auth API keys
  final bool? invalidateExisting;
  /// Optional custom email address from which to send the email
  final String? sendFromEmailAddress;
  /// Optional custom sender name for use with sendFromEmailAddress; if left empty, will default to 'Notifications'
  final String? sendFromEmailSenderName;
  /// Optional custom email address to use as reply-to
  final String? replyToEmailAddress;

  const v1EmailAuthIntentV2({
    required  this.email,
    required  this.targetPublicKey,
     this.apiKeyName,
     this.expirationSeconds,
     this.emailCustomization,
     this.invalidateExisting,
     this.sendFromEmailAddress,
     this.sendFromEmailSenderName,
     this.replyToEmailAddress,
  });

  factory v1EmailAuthIntentV2.fromJson(Map<String, dynamic> json) {
    final _email = json['email'] as String;
    final _targetPublicKey = json['targetPublicKey'] as String;
    final _apiKeyName = json['apiKeyName'] as String?;
    final _expirationSeconds = json['expirationSeconds'] as String?;
    final _emailCustomization = json['emailCustomization'] == null ? null : v1EmailCustomizationParams.fromJson(json['emailCustomization'] as Map<String, dynamic>);
    final _invalidateExisting = json['invalidateExisting'] as bool?;
    final _sendFromEmailAddress = json['sendFromEmailAddress'] as String?;
    final _sendFromEmailSenderName = json['sendFromEmailSenderName'] as String?;
    final _replyToEmailAddress = json['replyToEmailAddress'] as String?;
    return v1EmailAuthIntentV2(
      email: _email,
      targetPublicKey: _targetPublicKey,
      apiKeyName: _apiKeyName,
      expirationSeconds: _expirationSeconds,
      emailCustomization: _emailCustomization,
      invalidateExisting: _invalidateExisting,
      sendFromEmailAddress: _sendFromEmailAddress,
      sendFromEmailSenderName: _sendFromEmailSenderName,
      replyToEmailAddress: _replyToEmailAddress,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['email'] = email;
    _json['targetPublicKey'] = targetPublicKey;
    if (apiKeyName != null) {
      _json['apiKeyName'] = apiKeyName;
    }
    if (expirationSeconds != null) {
      _json['expirationSeconds'] = expirationSeconds;
    }
    if (emailCustomization != null) {
      _json['emailCustomization'] = emailCustomization?.toJson();
    }
    if (invalidateExisting != null) {
      _json['invalidateExisting'] = invalidateExisting;
    }
    if (sendFromEmailAddress != null) {
      _json['sendFromEmailAddress'] = sendFromEmailAddress;
    }
    if (sendFromEmailSenderName != null) {
      _json['sendFromEmailSenderName'] = sendFromEmailSenderName;
    }
    if (replyToEmailAddress != null) {
      _json['replyToEmailAddress'] = replyToEmailAddress;
    }
    return _json;
  }
}

class v1EmailAuthIntentV3 {
  /// Email of the authenticating user.
  final String email;
  /// Client-side public key generated by the user, to which the email auth bundle (credentials) will be encrypted.
  final String targetPublicKey;
  /// Optional human-readable name for an API Key. If none provided, default to Email Auth - <Timestamp>
  final String? apiKeyName;
  /// Expiration window (in seconds) indicating how long the API key is valid for. If not provided, a default of 15 minutes will be used.
  final String? expirationSeconds;
  /// Parameters for customizing emails. If not provided, the default email will be used. Note that app_name is required.
  final v1EmailAuthCustomizationParams emailCustomization;
  /// Invalidate all other previously generated Email Auth API keys
  final bool? invalidateExisting;
  /// Optional custom email address from which to send the email
  final String? sendFromEmailAddress;
  /// Optional custom sender name for use with sendFromEmailAddress; if left empty, will default to 'Notifications'
  final String? sendFromEmailSenderName;
  /// Optional custom email address to use as reply-to
  final String? replyToEmailAddress;

  const v1EmailAuthIntentV3({
    required  this.email,
    required  this.targetPublicKey,
     this.apiKeyName,
     this.expirationSeconds,
    required  this.emailCustomization,
     this.invalidateExisting,
     this.sendFromEmailAddress,
     this.sendFromEmailSenderName,
     this.replyToEmailAddress,
  });

  factory v1EmailAuthIntentV3.fromJson(Map<String, dynamic> json) {
    final _email = json['email'] as String;
    final _targetPublicKey = json['targetPublicKey'] as String;
    final _apiKeyName = json['apiKeyName'] as String?;
    final _expirationSeconds = json['expirationSeconds'] as String?;
    final _emailCustomization = v1EmailAuthCustomizationParams.fromJson(json['emailCustomization'] as Map<String, dynamic>);
    final _invalidateExisting = json['invalidateExisting'] as bool?;
    final _sendFromEmailAddress = json['sendFromEmailAddress'] as String?;
    final _sendFromEmailSenderName = json['sendFromEmailSenderName'] as String?;
    final _replyToEmailAddress = json['replyToEmailAddress'] as String?;
    return v1EmailAuthIntentV3(
      email: _email,
      targetPublicKey: _targetPublicKey,
      apiKeyName: _apiKeyName,
      expirationSeconds: _expirationSeconds,
      emailCustomization: _emailCustomization,
      invalidateExisting: _invalidateExisting,
      sendFromEmailAddress: _sendFromEmailAddress,
      sendFromEmailSenderName: _sendFromEmailSenderName,
      replyToEmailAddress: _replyToEmailAddress,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['email'] = email;
    _json['targetPublicKey'] = targetPublicKey;
    if (apiKeyName != null) {
      _json['apiKeyName'] = apiKeyName;
    }
    if (expirationSeconds != null) {
      _json['expirationSeconds'] = expirationSeconds;
    }
    _json['emailCustomization'] = emailCustomization.toJson();
    if (invalidateExisting != null) {
      _json['invalidateExisting'] = invalidateExisting;
    }
    if (sendFromEmailAddress != null) {
      _json['sendFromEmailAddress'] = sendFromEmailAddress;
    }
    if (sendFromEmailSenderName != null) {
      _json['sendFromEmailSenderName'] = sendFromEmailSenderName;
    }
    if (replyToEmailAddress != null) {
      _json['replyToEmailAddress'] = replyToEmailAddress;
    }
    return _json;
  }
}

class v1EmailAuthRequest {
  final String type;
  /// Timestamp (in milliseconds) of the request, used to verify liveness of user requests.
  final String timestampMs;
  /// Unique identifier for a given Organization.
  final String organizationId;
  final v1EmailAuthIntentV3 parameters;
  final bool? generateAppProofs;

  const v1EmailAuthRequest({
    required  this.type,
    required  this.timestampMs,
    required  this.organizationId,
    required  this.parameters,
     this.generateAppProofs,
  });

  factory v1EmailAuthRequest.fromJson(Map<String, dynamic> json) {
    final _type = json['type'] as String;
    final _timestampMs = json['timestampMs'] as String;
    final _organizationId = json['organizationId'] as String;
    final _parameters = v1EmailAuthIntentV3.fromJson(json['parameters'] as Map<String, dynamic>);
    final _generateAppProofs = json['generateAppProofs'] as bool?;
    return v1EmailAuthRequest(
      type: _type,
      timestampMs: _timestampMs,
      organizationId: _organizationId,
      parameters: _parameters,
      generateAppProofs: _generateAppProofs,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['type'] = type;
    _json['timestampMs'] = timestampMs;
    _json['organizationId'] = organizationId;
    _json['parameters'] = parameters.toJson();
    if (generateAppProofs != null) {
      _json['generateAppProofs'] = generateAppProofs;
    }
    return _json;
  }
}

class v1EmailAuthResult {
  /// Unique identifier for the authenticating User.
  final String userId;
  /// Unique identifier for the created API key.
  final String apiKeyId;

  const v1EmailAuthResult({
    required  this.userId,
    required  this.apiKeyId,
  });

  factory v1EmailAuthResult.fromJson(Map<String, dynamic> json) {
    final _userId = json['userId'] as String;
    final _apiKeyId = json['apiKeyId'] as String;
    return v1EmailAuthResult(
      userId: _userId,
      apiKeyId: _apiKeyId,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['userId'] = userId;
    _json['apiKeyId'] = apiKeyId;
    return _json;
  }
}

class v1EmailCustomizationParams {
  /// The name of the application.
  final String? appName;
  /// A URL pointing to a logo in PNG format. Note this logo will be resized to fit into 340px x 124px.
  final String? logoUrl;
  /// A template for the URL to be used in a magic link button, e.g. `https://dapp.xyz/%s`. The auth bundle will be interpolated into the `%s`.
  final String? magicLinkTemplate;
  /// JSON object containing key/value pairs to be used with custom templates.
  final String? templateVariables;
  /// Unique identifier for a given Email Template. If not specified, the default is the most recent Email Template.
  final String? templateId;

  const v1EmailCustomizationParams({
     this.appName,
     this.logoUrl,
     this.magicLinkTemplate,
     this.templateVariables,
     this.templateId,
  });

  factory v1EmailCustomizationParams.fromJson(Map<String, dynamic> json) {
    final _appName = json['appName'] as String?;
    final _logoUrl = json['logoUrl'] as String?;
    final _magicLinkTemplate = json['magicLinkTemplate'] as String?;
    final _templateVariables = json['templateVariables'] as String?;
    final _templateId = json['templateId'] as String?;
    return v1EmailCustomizationParams(
      appName: _appName,
      logoUrl: _logoUrl,
      magicLinkTemplate: _magicLinkTemplate,
      templateVariables: _templateVariables,
      templateId: _templateId,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    if (appName != null) {
      _json['appName'] = appName;
    }
    if (logoUrl != null) {
      _json['logoUrl'] = logoUrl;
    }
    if (magicLinkTemplate != null) {
      _json['magicLinkTemplate'] = magicLinkTemplate;
    }
    if (templateVariables != null) {
      _json['templateVariables'] = templateVariables;
    }
    if (templateId != null) {
      _json['templateId'] = templateId;
    }
    return _json;
  }
}

class v1EmailCustomizationParamsV2 {
  /// A URL pointing to a logo in PNG format. Note this logo will be resized to fit into 340px x 124px.
  final String? logoUrl;
  /// A template for the URL to be used in a magic link button, e.g. `https://dapp.xyz/%s`. The auth bundle will be interpolated into the `%s`.
  final String? magicLinkTemplate;
  /// JSON object containing key/value pairs to be used with custom templates.
  final String? templateVariables;
  /// Unique identifier for a given Email Template. If not specified, the default is the most recent Email Template.
  final String? templateId;

  const v1EmailCustomizationParamsV2({
     this.logoUrl,
     this.magicLinkTemplate,
     this.templateVariables,
     this.templateId,
  });

  factory v1EmailCustomizationParamsV2.fromJson(Map<String, dynamic> json) {
    final _logoUrl = json['logoUrl'] as String?;
    final _magicLinkTemplate = json['magicLinkTemplate'] as String?;
    final _templateVariables = json['templateVariables'] as String?;
    final _templateId = json['templateId'] as String?;
    return v1EmailCustomizationParamsV2(
      logoUrl: _logoUrl,
      magicLinkTemplate: _magicLinkTemplate,
      templateVariables: _templateVariables,
      templateId: _templateId,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    if (logoUrl != null) {
      _json['logoUrl'] = logoUrl;
    }
    if (magicLinkTemplate != null) {
      _json['magicLinkTemplate'] = magicLinkTemplate;
    }
    if (templateVariables != null) {
      _json['templateVariables'] = templateVariables;
    }
    if (templateId != null) {
      _json['templateId'] = templateId;
    }
    return _json;
  }
}

class v1EnableAuthProxyIntent {
  const v1EnableAuthProxyIntent();
  factory v1EnableAuthProxyIntent.fromJson(Map<String, dynamic> json) => const v1EnableAuthProxyIntent();
  Map<String, dynamic> toJson() => {};
}

class v1EnableAuthProxyResult {
  /// A User ID with permission to initiate authentication.
  final String userId;

  const v1EnableAuthProxyResult({
    required  this.userId,
  });

  factory v1EnableAuthProxyResult.fromJson(Map<String, dynamic> json) {
    final _userId = json['userId'] as String;
    return v1EnableAuthProxyResult(
      userId: _userId,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['userId'] = userId;
    return _json;
  }
}

class v1EthSendRawTransactionIntent {
  /// The raw, signed transaction to be sent.
  final String signedTransaction;
  /// CAIP-2 chain ID (e.g., 'eip155:1' for Ethereum mainnet).
  final String caip2;

  const v1EthSendRawTransactionIntent({
    required  this.signedTransaction,
    required  this.caip2,
  });

  factory v1EthSendRawTransactionIntent.fromJson(Map<String, dynamic> json) {
    final _signedTransaction = json['signedTransaction'] as String;
    final _caip2 = json['caip2'] as String;
    return v1EthSendRawTransactionIntent(
      signedTransaction: _signedTransaction,
      caip2: _caip2,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['signedTransaction'] = signedTransaction;
    _json['caip2'] = caip2;
    return _json;
  }
}

class v1EthSendRawTransactionRequest {
  final String type;
  /// Timestamp (in milliseconds) of the request, used to verify liveness of user requests.
  final String timestampMs;
  /// Unique identifier for a given Organization.
  final String organizationId;
  final v1EthSendRawTransactionIntent parameters;
  final bool? generateAppProofs;

  const v1EthSendRawTransactionRequest({
    required  this.type,
    required  this.timestampMs,
    required  this.organizationId,
    required  this.parameters,
     this.generateAppProofs,
  });

  factory v1EthSendRawTransactionRequest.fromJson(Map<String, dynamic> json) {
    final _type = json['type'] as String;
    final _timestampMs = json['timestampMs'] as String;
    final _organizationId = json['organizationId'] as String;
    final _parameters = v1EthSendRawTransactionIntent.fromJson(json['parameters'] as Map<String, dynamic>);
    final _generateAppProofs = json['generateAppProofs'] as bool?;
    return v1EthSendRawTransactionRequest(
      type: _type,
      timestampMs: _timestampMs,
      organizationId: _organizationId,
      parameters: _parameters,
      generateAppProofs: _generateAppProofs,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['type'] = type;
    _json['timestampMs'] = timestampMs;
    _json['organizationId'] = organizationId;
    _json['parameters'] = parameters.toJson();
    if (generateAppProofs != null) {
      _json['generateAppProofs'] = generateAppProofs;
    }
    return _json;
  }
}

class v1EthSendRawTransactionResult {
  /// The transaction hash of the sent transaction
  final String transactionHash;

  const v1EthSendRawTransactionResult({
    required  this.transactionHash,
  });

  factory v1EthSendRawTransactionResult.fromJson(Map<String, dynamic> json) {
    final _transactionHash = json['transactionHash'] as String;
    return v1EthSendRawTransactionResult(
      transactionHash: _transactionHash,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['transactionHash'] = transactionHash;
    return _json;
  }
}

class v1EthSendTransactionIntent {
  /// A wallet or private key address to sign with. This does not support private key IDs.
  final String from;
  /// Whether to sponsor this transaction via Gas Station.
  final bool? sponsor;
  /// CAIP-2 chain ID (e.g., 'eip155:1' for Ethereum mainnet).
  final String caip2;
  /// Recipient address as a hex string with 0x prefix.
  final String to;
  /// Amount of native asset to send in wei.
  final String? value;
  /// Hex-encoded call data for contract interactions.
  final String? data;
  /// Transaction nonce, for EIP-1559 and Turnkey Gas Station authorizations.
  final String? nonce;
  /// Maximum amount of gas to use for this transaction, for EIP-1559 transactions.
  final String? gasLimit;
  /// Maximum total fee per gas unit (base fee + priority fee) in wei. Required for non-sponsored (EIP-1559) transactions. Not used for sponsored transactions.
  final String? maxFeePerGas;
  /// Maximum priority fee (tip) per gas unit in wei. Required for non-sponsored (EIP-1559) transactions. Not used for sponsored transactions.
  final String? maxPriorityFeePerGas;
  /// The gas station delegate contract nonce. Only used when sponsor=true. Include this if you want maximal security posture.
  final String? gasStationNonce;

  const v1EthSendTransactionIntent({
    required  this.from,
     this.sponsor,
    required  this.caip2,
    required  this.to,
     this.value,
     this.data,
     this.nonce,
     this.gasLimit,
     this.maxFeePerGas,
     this.maxPriorityFeePerGas,
     this.gasStationNonce,
  });

  factory v1EthSendTransactionIntent.fromJson(Map<String, dynamic> json) {
    final _from = json['from'] as String;
    final _sponsor = json['sponsor'] as bool?;
    final _caip2 = json['caip2'] as String;
    final _to = json['to'] as String;
    final _value = json['value'] as String?;
    final _data = json['data'] as String?;
    final _nonce = json['nonce'] as String?;
    final _gasLimit = json['gasLimit'] as String?;
    final _maxFeePerGas = json['maxFeePerGas'] as String?;
    final _maxPriorityFeePerGas = json['maxPriorityFeePerGas'] as String?;
    final _gasStationNonce = json['gasStationNonce'] as String?;
    return v1EthSendTransactionIntent(
      from: _from,
      sponsor: _sponsor,
      caip2: _caip2,
      to: _to,
      value: _value,
      data: _data,
      nonce: _nonce,
      gasLimit: _gasLimit,
      maxFeePerGas: _maxFeePerGas,
      maxPriorityFeePerGas: _maxPriorityFeePerGas,
      gasStationNonce: _gasStationNonce,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['from'] = from;
    if (sponsor != null) {
      _json['sponsor'] = sponsor;
    }
    _json['caip2'] = caip2;
    _json['to'] = to;
    if (value != null) {
      _json['value'] = value;
    }
    if (data != null) {
      _json['data'] = data;
    }
    if (nonce != null) {
      _json['nonce'] = nonce;
    }
    if (gasLimit != null) {
      _json['gasLimit'] = gasLimit;
    }
    if (maxFeePerGas != null) {
      _json['maxFeePerGas'] = maxFeePerGas;
    }
    if (maxPriorityFeePerGas != null) {
      _json['maxPriorityFeePerGas'] = maxPriorityFeePerGas;
    }
    if (gasStationNonce != null) {
      _json['gasStationNonce'] = gasStationNonce;
    }
    return _json;
  }
}

class v1EthSendTransactionRequest {
  final String type;
  /// Timestamp (in milliseconds) of the request, used to verify liveness of user requests.
  final String timestampMs;
  /// Unique identifier for a given Organization.
  final String organizationId;
  final v1EthSendTransactionIntent parameters;
  final bool? generateAppProofs;

  const v1EthSendTransactionRequest({
    required  this.type,
    required  this.timestampMs,
    required  this.organizationId,
    required  this.parameters,
     this.generateAppProofs,
  });

  factory v1EthSendTransactionRequest.fromJson(Map<String, dynamic> json) {
    final _type = json['type'] as String;
    final _timestampMs = json['timestampMs'] as String;
    final _organizationId = json['organizationId'] as String;
    final _parameters = v1EthSendTransactionIntent.fromJson(json['parameters'] as Map<String, dynamic>);
    final _generateAppProofs = json['generateAppProofs'] as bool?;
    return v1EthSendTransactionRequest(
      type: _type,
      timestampMs: _timestampMs,
      organizationId: _organizationId,
      parameters: _parameters,
      generateAppProofs: _generateAppProofs,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['type'] = type;
    _json['timestampMs'] = timestampMs;
    _json['organizationId'] = organizationId;
    _json['parameters'] = parameters.toJson();
    if (generateAppProofs != null) {
      _json['generateAppProofs'] = generateAppProofs;
    }
    return _json;
  }
}

class v1EthSendTransactionResult {
  /// The send_transaction_status ID associated with the transaction submission
  final String sendTransactionStatusId;

  const v1EthSendTransactionResult({
    required  this.sendTransactionStatusId,
  });

  factory v1EthSendTransactionResult.fromJson(Map<String, dynamic> json) {
    final _sendTransactionStatusId = json['sendTransactionStatusId'] as String;
    return v1EthSendTransactionResult(
      sendTransactionStatusId: _sendTransactionStatusId,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['sendTransactionStatusId'] = sendTransactionStatusId;
    return _json;
  }
}

class v1EthSendTransactionStatus {
  /// The Ethereum transaction hash, if available.
  final String? txHash;

  const v1EthSendTransactionStatus({
     this.txHash,
  });

  factory v1EthSendTransactionStatus.fromJson(Map<String, dynamic> json) {
    final _txHash = json['txHash'] as String?;
    return v1EthSendTransactionStatus(
      txHash: _txHash,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    if (txHash != null) {
      _json['txHash'] = txHash;
    }
    return _json;
  }
}

class v1ExportPrivateKeyIntent {
  /// Unique identifier for a given Private Key.
  final String privateKeyId;
  /// Client-side public key generated by the user, to which the export bundle will be encrypted.
  final String targetPublicKey;

  const v1ExportPrivateKeyIntent({
    required  this.privateKeyId,
    required  this.targetPublicKey,
  });

  factory v1ExportPrivateKeyIntent.fromJson(Map<String, dynamic> json) {
    final _privateKeyId = json['privateKeyId'] as String;
    final _targetPublicKey = json['targetPublicKey'] as String;
    return v1ExportPrivateKeyIntent(
      privateKeyId: _privateKeyId,
      targetPublicKey: _targetPublicKey,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['privateKeyId'] = privateKeyId;
    _json['targetPublicKey'] = targetPublicKey;
    return _json;
  }
}

class v1ExportPrivateKeyRequest {
  final String type;
  /// Timestamp (in milliseconds) of the request, used to verify liveness of user requests.
  final String timestampMs;
  /// Unique identifier for a given Organization.
  final String organizationId;
  final v1ExportPrivateKeyIntent parameters;
  final bool? generateAppProofs;

  const v1ExportPrivateKeyRequest({
    required  this.type,
    required  this.timestampMs,
    required  this.organizationId,
    required  this.parameters,
     this.generateAppProofs,
  });

  factory v1ExportPrivateKeyRequest.fromJson(Map<String, dynamic> json) {
    final _type = json['type'] as String;
    final _timestampMs = json['timestampMs'] as String;
    final _organizationId = json['organizationId'] as String;
    final _parameters = v1ExportPrivateKeyIntent.fromJson(json['parameters'] as Map<String, dynamic>);
    final _generateAppProofs = json['generateAppProofs'] as bool?;
    return v1ExportPrivateKeyRequest(
      type: _type,
      timestampMs: _timestampMs,
      organizationId: _organizationId,
      parameters: _parameters,
      generateAppProofs: _generateAppProofs,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['type'] = type;
    _json['timestampMs'] = timestampMs;
    _json['organizationId'] = organizationId;
    _json['parameters'] = parameters.toJson();
    if (generateAppProofs != null) {
      _json['generateAppProofs'] = generateAppProofs;
    }
    return _json;
  }
}

class v1ExportPrivateKeyResult {
  /// Unique identifier for a given Private Key.
  final String privateKeyId;
  /// Export bundle containing a private key encrypted to the client's target public key.
  final String exportBundle;

  const v1ExportPrivateKeyResult({
    required  this.privateKeyId,
    required  this.exportBundle,
  });

  factory v1ExportPrivateKeyResult.fromJson(Map<String, dynamic> json) {
    final _privateKeyId = json['privateKeyId'] as String;
    final _exportBundle = json['exportBundle'] as String;
    return v1ExportPrivateKeyResult(
      privateKeyId: _privateKeyId,
      exportBundle: _exportBundle,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['privateKeyId'] = privateKeyId;
    _json['exportBundle'] = exportBundle;
    return _json;
  }
}

class v1ExportWalletAccountIntent {
  /// Address to identify Wallet Account.
  final String address;
  /// Client-side public key generated by the user, to which the export bundle will be encrypted.
  final String targetPublicKey;

  const v1ExportWalletAccountIntent({
    required  this.address,
    required  this.targetPublicKey,
  });

  factory v1ExportWalletAccountIntent.fromJson(Map<String, dynamic> json) {
    final _address = json['address'] as String;
    final _targetPublicKey = json['targetPublicKey'] as String;
    return v1ExportWalletAccountIntent(
      address: _address,
      targetPublicKey: _targetPublicKey,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['address'] = address;
    _json['targetPublicKey'] = targetPublicKey;
    return _json;
  }
}

class v1ExportWalletAccountRequest {
  final String type;
  /// Timestamp (in milliseconds) of the request, used to verify liveness of user requests.
  final String timestampMs;
  /// Unique identifier for a given Organization.
  final String organizationId;
  final v1ExportWalletAccountIntent parameters;
  final bool? generateAppProofs;

  const v1ExportWalletAccountRequest({
    required  this.type,
    required  this.timestampMs,
    required  this.organizationId,
    required  this.parameters,
     this.generateAppProofs,
  });

  factory v1ExportWalletAccountRequest.fromJson(Map<String, dynamic> json) {
    final _type = json['type'] as String;
    final _timestampMs = json['timestampMs'] as String;
    final _organizationId = json['organizationId'] as String;
    final _parameters = v1ExportWalletAccountIntent.fromJson(json['parameters'] as Map<String, dynamic>);
    final _generateAppProofs = json['generateAppProofs'] as bool?;
    return v1ExportWalletAccountRequest(
      type: _type,
      timestampMs: _timestampMs,
      organizationId: _organizationId,
      parameters: _parameters,
      generateAppProofs: _generateAppProofs,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['type'] = type;
    _json['timestampMs'] = timestampMs;
    _json['organizationId'] = organizationId;
    _json['parameters'] = parameters.toJson();
    if (generateAppProofs != null) {
      _json['generateAppProofs'] = generateAppProofs;
    }
    return _json;
  }
}

class v1ExportWalletAccountResult {
  /// Address to identify Wallet Account.
  final String address;
  /// Export bundle containing a private key encrypted by the client's target public key.
  final String exportBundle;

  const v1ExportWalletAccountResult({
    required  this.address,
    required  this.exportBundle,
  });

  factory v1ExportWalletAccountResult.fromJson(Map<String, dynamic> json) {
    final _address = json['address'] as String;
    final _exportBundle = json['exportBundle'] as String;
    return v1ExportWalletAccountResult(
      address: _address,
      exportBundle: _exportBundle,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['address'] = address;
    _json['exportBundle'] = exportBundle;
    return _json;
  }
}

class v1ExportWalletIntent {
  /// Unique identifier for a given Wallet.
  final String walletId;
  /// Client-side public key generated by the user, to which the export bundle will be encrypted.
  final String targetPublicKey;
  /// The language of the mnemonic to export. Defaults to English.
  final v1MnemonicLanguage? language;

  const v1ExportWalletIntent({
    required  this.walletId,
    required  this.targetPublicKey,
     this.language,
  });

  factory v1ExportWalletIntent.fromJson(Map<String, dynamic> json) {
    final _walletId = json['walletId'] as String;
    final _targetPublicKey = json['targetPublicKey'] as String;
    final _language = json['language'] == null ? null : v1MnemonicLanguageFromJson(json['language']);
    return v1ExportWalletIntent(
      walletId: _walletId,
      targetPublicKey: _targetPublicKey,
      language: _language,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['walletId'] = walletId;
    _json['targetPublicKey'] = targetPublicKey;
    if (language != null) {
      _json['language'] = v1MnemonicLanguageToJson(language!);
    }
    return _json;
  }
}

class v1ExportWalletRequest {
  final String type;
  /// Timestamp (in milliseconds) of the request, used to verify liveness of user requests.
  final String timestampMs;
  /// Unique identifier for a given Organization.
  final String organizationId;
  final v1ExportWalletIntent parameters;
  final bool? generateAppProofs;

  const v1ExportWalletRequest({
    required  this.type,
    required  this.timestampMs,
    required  this.organizationId,
    required  this.parameters,
     this.generateAppProofs,
  });

  factory v1ExportWalletRequest.fromJson(Map<String, dynamic> json) {
    final _type = json['type'] as String;
    final _timestampMs = json['timestampMs'] as String;
    final _organizationId = json['organizationId'] as String;
    final _parameters = v1ExportWalletIntent.fromJson(json['parameters'] as Map<String, dynamic>);
    final _generateAppProofs = json['generateAppProofs'] as bool?;
    return v1ExportWalletRequest(
      type: _type,
      timestampMs: _timestampMs,
      organizationId: _organizationId,
      parameters: _parameters,
      generateAppProofs: _generateAppProofs,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['type'] = type;
    _json['timestampMs'] = timestampMs;
    _json['organizationId'] = organizationId;
    _json['parameters'] = parameters.toJson();
    if (generateAppProofs != null) {
      _json['generateAppProofs'] = generateAppProofs;
    }
    return _json;
  }
}

class v1ExportWalletResult {
  /// Unique identifier for a given Wallet.
  final String walletId;
  /// Export bundle containing a wallet mnemonic + optional newline passphrase encrypted by the client's target public key.
  final String exportBundle;

  const v1ExportWalletResult({
    required  this.walletId,
    required  this.exportBundle,
  });

  factory v1ExportWalletResult.fromJson(Map<String, dynamic> json) {
    final _walletId = json['walletId'] as String;
    final _exportBundle = json['exportBundle'] as String;
    return v1ExportWalletResult(
      walletId: _walletId,
      exportBundle: _exportBundle,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['walletId'] = walletId;
    _json['exportBundle'] = exportBundle;
    return _json;
  }
}

class v1Feature {
  final v1FeatureName? name;
  final String? value;

  const v1Feature({
     this.name,
     this.value,
  });

  factory v1Feature.fromJson(Map<String, dynamic> json) {
    final _name = json['name'] == null ? null : v1FeatureNameFromJson(json['name']);
    final _value = json['value'] as String?;
    return v1Feature(
      name: _name,
      value: _value,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    if (name != null) {
      _json['name'] = v1FeatureNameToJson(name!);
    }
    if (value != null) {
      _json['value'] = value;
    }
    return _json;
  }
}

class v1FiatOnRampCredential {
  /// Unique identifier for a given Fiat On-Ramp Credential.
  final String fiatOnrampCredentialId;
  /// Unique identifier for an Organization.
  final String organizationId;
  /// The fiat on-ramp provider.
  final v1FiatOnRampProvider onrampProvider;
  /// Project ID for the on-ramp provider. Some providers, like Coinbase, require this additional identifier.
  final String? projectId;
  /// Publishable API key for the on-ramp provider.
  final String publishableApiKey;
  /// Secret API key for the on-ramp provider encrypted to our on-ramp encryption public key.
  final String encryptedSecretApiKey;
  /// Private API key for the on-ramp provider encrypted to our on-ramp encryption public key. Some providers, like Coinbase, require this additional key.
  final String? encryptedPrivateApiKey;
  /// If the on-ramp credential is a sandbox credential.
  final bool? sandboxMode;
  final externaldatav1Timestamp createdAt;
  final externaldatav1Timestamp updatedAt;

  const v1FiatOnRampCredential({
    required  this.fiatOnrampCredentialId,
    required  this.organizationId,
    required  this.onrampProvider,
     this.projectId,
    required  this.publishableApiKey,
    required  this.encryptedSecretApiKey,
     this.encryptedPrivateApiKey,
     this.sandboxMode,
    required  this.createdAt,
    required  this.updatedAt,
  });

  factory v1FiatOnRampCredential.fromJson(Map<String, dynamic> json) {
    final _fiatOnrampCredentialId = json['fiatOnrampCredentialId'] as String;
    final _organizationId = json['organizationId'] as String;
    final _onrampProvider = v1FiatOnRampProviderFromJson(json['onrampProvider']);
    final _projectId = json['projectId'] as String?;
    final _publishableApiKey = json['publishableApiKey'] as String;
    final _encryptedSecretApiKey = json['encryptedSecretApiKey'] as String;
    final _encryptedPrivateApiKey = json['encryptedPrivateApiKey'] as String?;
    final _sandboxMode = json['sandboxMode'] as bool?;
    final _createdAt = externaldatav1Timestamp.fromJson(json['createdAt'] as Map<String, dynamic>);
    final _updatedAt = externaldatav1Timestamp.fromJson(json['updatedAt'] as Map<String, dynamic>);
    return v1FiatOnRampCredential(
      fiatOnrampCredentialId: _fiatOnrampCredentialId,
      organizationId: _organizationId,
      onrampProvider: _onrampProvider,
      projectId: _projectId,
      publishableApiKey: _publishableApiKey,
      encryptedSecretApiKey: _encryptedSecretApiKey,
      encryptedPrivateApiKey: _encryptedPrivateApiKey,
      sandboxMode: _sandboxMode,
      createdAt: _createdAt,
      updatedAt: _updatedAt,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['fiatOnrampCredentialId'] = fiatOnrampCredentialId;
    _json['organizationId'] = organizationId;
    _json['onrampProvider'] = v1FiatOnRampProviderToJson(onrampProvider);
    if (projectId != null) {
      _json['projectId'] = projectId;
    }
    _json['publishableApiKey'] = publishableApiKey;
    _json['encryptedSecretApiKey'] = encryptedSecretApiKey;
    if (encryptedPrivateApiKey != null) {
      _json['encryptedPrivateApiKey'] = encryptedPrivateApiKey;
    }
    if (sandboxMode != null) {
      _json['sandboxMode'] = sandboxMode;
    }
    _json['createdAt'] = createdAt.toJson();
    _json['updatedAt'] = updatedAt.toJson();
    return _json;
  }
}

class v1GetActivitiesRequest {
  /// Unique identifier for a given organization.
  final String organizationId;
  /// Array of activity statuses filtering which activities will be listed in the response.
  final List<v1ActivityStatus>? filterByStatus;
  /// Parameters used for cursor-based pagination.
  final v1Pagination? paginationOptions;
  /// Array of activity types filtering which activities will be listed in the response.
  final List<v1ActivityType>? filterByType;

  const v1GetActivitiesRequest({
    required  this.organizationId,
     this.filterByStatus,
     this.paginationOptions,
     this.filterByType,
  });

  factory v1GetActivitiesRequest.fromJson(Map<String, dynamic> json) {
    final _organizationId = json['organizationId'] as String;
    final _filterByStatus = (json['filterByStatus'] as List?)?.map((e) => v1ActivityStatusFromJson(e)).toList();
    final _paginationOptions = json['paginationOptions'] == null ? null : v1Pagination.fromJson(json['paginationOptions'] as Map<String, dynamic>);
    final _filterByType = (json['filterByType'] as List?)?.map((e) => v1ActivityTypeFromJson(e)).toList();
    return v1GetActivitiesRequest(
      organizationId: _organizationId,
      filterByStatus: _filterByStatus,
      paginationOptions: _paginationOptions,
      filterByType: _filterByType,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['organizationId'] = organizationId;
    if (filterByStatus != null) {
      _json['filterByStatus'] = filterByStatus?.map((e) => v1ActivityStatusToJson(e)).toList();
    }
    if (paginationOptions != null) {
      _json['paginationOptions'] = paginationOptions?.toJson();
    }
    if (filterByType != null) {
      _json['filterByType'] = filterByType?.map((e) => v1ActivityTypeToJson(e)).toList();
    }
    return _json;
  }
}

class v1GetActivitiesResponse {
  /// A list of activities.
  final List<v1Activity> activities;

  const v1GetActivitiesResponse({
    required  this.activities,
  });

  factory v1GetActivitiesResponse.fromJson(Map<String, dynamic> json) {
    final _activities = (json['activities'] as List).map((e) => v1Activity.fromJson(e as Map<String, dynamic>)).toList();
    return v1GetActivitiesResponse(
      activities: _activities,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['activities'] = activities.map((e) => e.toJson()).toList();
    return _json;
  }
}

class v1GetActivityRequest {
  /// Unique identifier for a given organization.
  final String organizationId;
  /// Unique identifier for a given activity object.
  final String activityId;

  const v1GetActivityRequest({
    required  this.organizationId,
    required  this.activityId,
  });

  factory v1GetActivityRequest.fromJson(Map<String, dynamic> json) {
    final _organizationId = json['organizationId'] as String;
    final _activityId = json['activityId'] as String;
    return v1GetActivityRequest(
      organizationId: _organizationId,
      activityId: _activityId,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['organizationId'] = organizationId;
    _json['activityId'] = activityId;
    return _json;
  }
}

class v1GetApiKeyRequest {
  /// Unique identifier for a given organization.
  final String organizationId;
  /// Unique identifier for a given API key.
  final String apiKeyId;

  const v1GetApiKeyRequest({
    required  this.organizationId,
    required  this.apiKeyId,
  });

  factory v1GetApiKeyRequest.fromJson(Map<String, dynamic> json) {
    final _organizationId = json['organizationId'] as String;
    final _apiKeyId = json['apiKeyId'] as String;
    return v1GetApiKeyRequest(
      organizationId: _organizationId,
      apiKeyId: _apiKeyId,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['organizationId'] = organizationId;
    _json['apiKeyId'] = apiKeyId;
    return _json;
  }
}

class v1GetApiKeyResponse {
  /// An API key.
  final v1ApiKey apiKey;

  const v1GetApiKeyResponse({
    required  this.apiKey,
  });

  factory v1GetApiKeyResponse.fromJson(Map<String, dynamic> json) {
    final _apiKey = v1ApiKey.fromJson(json['apiKey'] as Map<String, dynamic>);
    return v1GetApiKeyResponse(
      apiKey: _apiKey,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['apiKey'] = apiKey.toJson();
    return _json;
  }
}

class v1GetApiKeysRequest {
  /// Unique identifier for a given organization.
  final String organizationId;
  /// Unique identifier for a given user.
  final String? userId;

  const v1GetApiKeysRequest({
    required  this.organizationId,
     this.userId,
  });

  factory v1GetApiKeysRequest.fromJson(Map<String, dynamic> json) {
    final _organizationId = json['organizationId'] as String;
    final _userId = json['userId'] as String?;
    return v1GetApiKeysRequest(
      organizationId: _organizationId,
      userId: _userId,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['organizationId'] = organizationId;
    if (userId != null) {
      _json['userId'] = userId;
    }
    return _json;
  }
}

class v1GetApiKeysResponse {
  /// A list of API keys.
  final List<v1ApiKey> apiKeys;

  const v1GetApiKeysResponse({
    required  this.apiKeys,
  });

  factory v1GetApiKeysResponse.fromJson(Map<String, dynamic> json) {
    final _apiKeys = (json['apiKeys'] as List).map((e) => v1ApiKey.fromJson(e as Map<String, dynamic>)).toList();
    return v1GetApiKeysResponse(
      apiKeys: _apiKeys,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['apiKeys'] = apiKeys.map((e) => e.toJson()).toList();
    return _json;
  }
}

class v1GetAppProofsRequest {
  /// Unique identifier for a given Organization.
  final String organizationId;
  /// Unique identifier for a given activity.
  final String activityId;

  const v1GetAppProofsRequest({
    required  this.organizationId,
    required  this.activityId,
  });

  factory v1GetAppProofsRequest.fromJson(Map<String, dynamic> json) {
    final _organizationId = json['organizationId'] as String;
    final _activityId = json['activityId'] as String;
    return v1GetAppProofsRequest(
      organizationId: _organizationId,
      activityId: _activityId,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['organizationId'] = organizationId;
    _json['activityId'] = activityId;
    return _json;
  }
}

class v1GetAppProofsResponse {
  final List<v1AppProof> appProofs;

  const v1GetAppProofsResponse({
    required  this.appProofs,
  });

  factory v1GetAppProofsResponse.fromJson(Map<String, dynamic> json) {
    final _appProofs = (json['appProofs'] as List).map((e) => v1AppProof.fromJson(e as Map<String, dynamic>)).toList();
    return v1GetAppProofsResponse(
      appProofs: _appProofs,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['appProofs'] = appProofs.map((e) => e.toJson()).toList();
    return _json;
  }
}

class v1GetAttestationDocumentRequest {
  /// Unique identifier for a given organization.
  final String organizationId;
  /// The enclave type, one of: ump, notarizer, signer, evm-parser.
  final String enclaveType;

  const v1GetAttestationDocumentRequest({
    required  this.organizationId,
    required  this.enclaveType,
  });

  factory v1GetAttestationDocumentRequest.fromJson(Map<String, dynamic> json) {
    final _organizationId = json['organizationId'] as String;
    final _enclaveType = json['enclaveType'] as String;
    return v1GetAttestationDocumentRequest(
      organizationId: _organizationId,
      enclaveType: _enclaveType,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['organizationId'] = organizationId;
    _json['enclaveType'] = enclaveType;
    return _json;
  }
}

class v1GetAttestationDocumentResponse {
  /// Raw (CBOR-encoded) attestation document.
  final String attestationDocument;

  const v1GetAttestationDocumentResponse({
    required  this.attestationDocument,
  });

  factory v1GetAttestationDocumentResponse.fromJson(Map<String, dynamic> json) {
    final _attestationDocument = json['attestationDocument'] as String;
    return v1GetAttestationDocumentResponse(
      attestationDocument: _attestationDocument,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['attestationDocument'] = attestationDocument;
    return _json;
  }
}

class v1GetAuthenticatorRequest {
  /// Unique identifier for a given organization.
  final String organizationId;
  /// Unique identifier for a given authenticator.
  final String authenticatorId;

  const v1GetAuthenticatorRequest({
    required  this.organizationId,
    required  this.authenticatorId,
  });

  factory v1GetAuthenticatorRequest.fromJson(Map<String, dynamic> json) {
    final _organizationId = json['organizationId'] as String;
    final _authenticatorId = json['authenticatorId'] as String;
    return v1GetAuthenticatorRequest(
      organizationId: _organizationId,
      authenticatorId: _authenticatorId,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['organizationId'] = organizationId;
    _json['authenticatorId'] = authenticatorId;
    return _json;
  }
}

class v1GetAuthenticatorResponse {
  /// An authenticator.
  final v1Authenticator authenticator;

  const v1GetAuthenticatorResponse({
    required  this.authenticator,
  });

  factory v1GetAuthenticatorResponse.fromJson(Map<String, dynamic> json) {
    final _authenticator = v1Authenticator.fromJson(json['authenticator'] as Map<String, dynamic>);
    return v1GetAuthenticatorResponse(
      authenticator: _authenticator,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['authenticator'] = authenticator.toJson();
    return _json;
  }
}

class v1GetAuthenticatorsRequest {
  /// Unique identifier for a given organization.
  final String organizationId;
  /// Unique identifier for a given user.
  final String userId;

  const v1GetAuthenticatorsRequest({
    required  this.organizationId,
    required  this.userId,
  });

  factory v1GetAuthenticatorsRequest.fromJson(Map<String, dynamic> json) {
    final _organizationId = json['organizationId'] as String;
    final _userId = json['userId'] as String;
    return v1GetAuthenticatorsRequest(
      organizationId: _organizationId,
      userId: _userId,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['organizationId'] = organizationId;
    _json['userId'] = userId;
    return _json;
  }
}

class v1GetAuthenticatorsResponse {
  /// A list of authenticators.
  final List<v1Authenticator> authenticators;

  const v1GetAuthenticatorsResponse({
    required  this.authenticators,
  });

  factory v1GetAuthenticatorsResponse.fromJson(Map<String, dynamic> json) {
    final _authenticators = (json['authenticators'] as List).map((e) => v1Authenticator.fromJson(e as Map<String, dynamic>)).toList();
    return v1GetAuthenticatorsResponse(
      authenticators: _authenticators,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['authenticators'] = authenticators.map((e) => e.toJson()).toList();
    return _json;
  }
}

class v1GetBootProofRequest {
  /// Unique identifier for a given Organization.
  final String organizationId;
  /// Hex encoded ephemeral public key.
  final String ephemeralKey;

  const v1GetBootProofRequest({
    required  this.organizationId,
    required  this.ephemeralKey,
  });

  factory v1GetBootProofRequest.fromJson(Map<String, dynamic> json) {
    final _organizationId = json['organizationId'] as String;
    final _ephemeralKey = json['ephemeralKey'] as String;
    return v1GetBootProofRequest(
      organizationId: _organizationId,
      ephemeralKey: _ephemeralKey,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['organizationId'] = organizationId;
    _json['ephemeralKey'] = ephemeralKey;
    return _json;
  }
}

class v1GetGasUsageRequest {
  /// Unique identifier for a given Organization.
  final String organizationId;

  const v1GetGasUsageRequest({
    required  this.organizationId,
  });

  factory v1GetGasUsageRequest.fromJson(Map<String, dynamic> json) {
    final _organizationId = json['organizationId'] as String;
    return v1GetGasUsageRequest(
      organizationId: _organizationId,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['organizationId'] = organizationId;
    return _json;
  }
}

class v1GetGasUsageResponse {
  /// The window duration (in minutes) for the organization or sub-organization.
  final num windowDurationMinutes;
  /// The window limit (in USD) for the organization or sub-organization.
  final String windowLimitUsd;
  /// The total gas usage (in USD) of all sponsored transactions processed over the last `window_duration_minutes`
  final String usageUsd;

  const v1GetGasUsageResponse({
    required  this.windowDurationMinutes,
    required  this.windowLimitUsd,
    required  this.usageUsd,
  });

  factory v1GetGasUsageResponse.fromJson(Map<String, dynamic> json) {
    final _windowDurationMinutes = json['windowDurationMinutes'] as num;
    final _windowLimitUsd = json['windowLimitUsd'] as String;
    final _usageUsd = json['usageUsd'] as String;
    return v1GetGasUsageResponse(
      windowDurationMinutes: _windowDurationMinutes,
      windowLimitUsd: _windowLimitUsd,
      usageUsd: _usageUsd,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['windowDurationMinutes'] = windowDurationMinutes;
    _json['windowLimitUsd'] = windowLimitUsd;
    _json['usageUsd'] = usageUsd;
    return _json;
  }
}

class v1GetLatestBootProofRequest {
  /// Unique identifier for a given Organization.
  final String organizationId;
  /// Name of enclave app.
  final String appName;

  const v1GetLatestBootProofRequest({
    required  this.organizationId,
    required  this.appName,
  });

  factory v1GetLatestBootProofRequest.fromJson(Map<String, dynamic> json) {
    final _organizationId = json['organizationId'] as String;
    final _appName = json['appName'] as String;
    return v1GetLatestBootProofRequest(
      organizationId: _organizationId,
      appName: _appName,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['organizationId'] = organizationId;
    _json['appName'] = appName;
    return _json;
  }
}

class v1GetNoncesRequest {
  /// Unique identifier for a given Organization.
  final String organizationId;
  /// The Ethereum address to query nonces for.
  final String address;
  /// The network identifier in CAIP-2 format (e.g., 'eip155:1' for Ethereum mainnet).
  final String caip2;
  /// Whether to fetch the standard on-chain nonce.
  final bool? nonce;
  /// Whether to fetch the gas station nonce used for sponsored transactions.
  final bool? gasStationNonce;

  const v1GetNoncesRequest({
    required  this.organizationId,
    required  this.address,
    required  this.caip2,
     this.nonce,
     this.gasStationNonce,
  });

  factory v1GetNoncesRequest.fromJson(Map<String, dynamic> json) {
    final _organizationId = json['organizationId'] as String;
    final _address = json['address'] as String;
    final _caip2 = json['caip2'] as String;
    final _nonce = json['nonce'] as bool?;
    final _gasStationNonce = json['gasStationNonce'] as bool?;
    return v1GetNoncesRequest(
      organizationId: _organizationId,
      address: _address,
      caip2: _caip2,
      nonce: _nonce,
      gasStationNonce: _gasStationNonce,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['organizationId'] = organizationId;
    _json['address'] = address;
    _json['caip2'] = caip2;
    if (nonce != null) {
      _json['nonce'] = nonce;
    }
    if (gasStationNonce != null) {
      _json['gasStationNonce'] = gasStationNonce;
    }
    return _json;
  }
}

class v1GetNoncesResponse {
  /// The standard on-chain nonce for the address, if requested.
  final String? nonce;
  /// The gas station nonce for sponsored transactions, if requested.
  final String? gasStationNonce;

  const v1GetNoncesResponse({
     this.nonce,
     this.gasStationNonce,
  });

  factory v1GetNoncesResponse.fromJson(Map<String, dynamic> json) {
    final _nonce = json['nonce'] as String?;
    final _gasStationNonce = json['gasStationNonce'] as String?;
    return v1GetNoncesResponse(
      nonce: _nonce,
      gasStationNonce: _gasStationNonce,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    if (nonce != null) {
      _json['nonce'] = nonce;
    }
    if (gasStationNonce != null) {
      _json['gasStationNonce'] = gasStationNonce;
    }
    return _json;
  }
}

class v1GetOauth2CredentialRequest {
  /// Unique identifier for a given Organization.
  final String organizationId;
  /// Unique identifier for a given OAuth 2.0 Credential.
  final String oauth2CredentialId;

  const v1GetOauth2CredentialRequest({
    required  this.organizationId,
    required  this.oauth2CredentialId,
  });

  factory v1GetOauth2CredentialRequest.fromJson(Map<String, dynamic> json) {
    final _organizationId = json['organizationId'] as String;
    final _oauth2CredentialId = json['oauth2CredentialId'] as String;
    return v1GetOauth2CredentialRequest(
      organizationId: _organizationId,
      oauth2CredentialId: _oauth2CredentialId,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['organizationId'] = organizationId;
    _json['oauth2CredentialId'] = oauth2CredentialId;
    return _json;
  }
}

class v1GetOauth2CredentialResponse {
  final v1Oauth2Credential oauth2Credential;

  const v1GetOauth2CredentialResponse({
    required  this.oauth2Credential,
  });

  factory v1GetOauth2CredentialResponse.fromJson(Map<String, dynamic> json) {
    final _oauth2Credential = v1Oauth2Credential.fromJson(json['oauth2Credential'] as Map<String, dynamic>);
    return v1GetOauth2CredentialResponse(
      oauth2Credential: _oauth2Credential,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['oauth2Credential'] = oauth2Credential.toJson();
    return _json;
  }
}

class v1GetOauthProvidersRequest {
  /// Unique identifier for a given organization.
  final String organizationId;
  /// Unique identifier for a given user.
  final String? userId;

  const v1GetOauthProvidersRequest({
    required  this.organizationId,
     this.userId,
  });

  factory v1GetOauthProvidersRequest.fromJson(Map<String, dynamic> json) {
    final _organizationId = json['organizationId'] as String;
    final _userId = json['userId'] as String?;
    return v1GetOauthProvidersRequest(
      organizationId: _organizationId,
      userId: _userId,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['organizationId'] = organizationId;
    if (userId != null) {
      _json['userId'] = userId;
    }
    return _json;
  }
}

class v1GetOauthProvidersResponse {
  /// A list of Oauth providers.
  final List<v1OauthProvider> oauthProviders;

  const v1GetOauthProvidersResponse({
    required  this.oauthProviders,
  });

  factory v1GetOauthProvidersResponse.fromJson(Map<String, dynamic> json) {
    final _oauthProviders = (json['oauthProviders'] as List).map((e) => v1OauthProvider.fromJson(e as Map<String, dynamic>)).toList();
    return v1GetOauthProvidersResponse(
      oauthProviders: _oauthProviders,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['oauthProviders'] = oauthProviders.map((e) => e.toJson()).toList();
    return _json;
  }
}

class v1GetOnRampTransactionStatusRequest {
  /// Unique identifier for a given organization.
  final String organizationId;
  /// The unique identifier for the fiat on ramp transaction.
  final String transactionId;
  /// Optional flag to specify if the transaction status should be refreshed from the fiat on ramp provider. Default = false.
  final bool? refresh;

  const v1GetOnRampTransactionStatusRequest({
    required  this.organizationId,
    required  this.transactionId,
     this.refresh,
  });

  factory v1GetOnRampTransactionStatusRequest.fromJson(Map<String, dynamic> json) {
    final _organizationId = json['organizationId'] as String;
    final _transactionId = json['transactionId'] as String;
    final _refresh = json['refresh'] as bool?;
    return v1GetOnRampTransactionStatusRequest(
      organizationId: _organizationId,
      transactionId: _transactionId,
      refresh: _refresh,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['organizationId'] = organizationId;
    _json['transactionId'] = transactionId;
    if (refresh != null) {
      _json['refresh'] = refresh;
    }
    return _json;
  }
}

class v1GetOnRampTransactionStatusResponse {
  /// The status of the fiat on ramp transaction.
  final String transactionStatus;

  const v1GetOnRampTransactionStatusResponse({
    required  this.transactionStatus,
  });

  factory v1GetOnRampTransactionStatusResponse.fromJson(Map<String, dynamic> json) {
    final _transactionStatus = json['transactionStatus'] as String;
    return v1GetOnRampTransactionStatusResponse(
      transactionStatus: _transactionStatus,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['transactionStatus'] = transactionStatus;
    return _json;
  }
}

class v1GetOrganizationConfigsRequest {
  /// Unique identifier for a given organization.
  final String organizationId;

  const v1GetOrganizationConfigsRequest({
    required  this.organizationId,
  });

  factory v1GetOrganizationConfigsRequest.fromJson(Map<String, dynamic> json) {
    final _organizationId = json['organizationId'] as String;
    return v1GetOrganizationConfigsRequest(
      organizationId: _organizationId,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['organizationId'] = organizationId;
    return _json;
  }
}

class v1GetOrganizationConfigsResponse {
  /// Organization configs including quorum settings and organization features.
  final v1Config configs;

  const v1GetOrganizationConfigsResponse({
    required  this.configs,
  });

  factory v1GetOrganizationConfigsResponse.fromJson(Map<String, dynamic> json) {
    final _configs = v1Config.fromJson(json['configs'] as Map<String, dynamic>);
    return v1GetOrganizationConfigsResponse(
      configs: _configs,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['configs'] = configs.toJson();
    return _json;
  }
}

class v1GetOrganizationRequest {
  /// Unique identifier for a given organization.
  final String organizationId;

  const v1GetOrganizationRequest({
    required  this.organizationId,
  });

  factory v1GetOrganizationRequest.fromJson(Map<String, dynamic> json) {
    final _organizationId = json['organizationId'] as String;
    return v1GetOrganizationRequest(
      organizationId: _organizationId,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['organizationId'] = organizationId;
    return _json;
  }
}

class v1GetOrganizationResponse {
  /// Object representing the full current and deleted / disabled collection of users, policies, private keys, and invitations attributable to a particular organization.
  final v1OrganizationData organizationData;

  const v1GetOrganizationResponse({
    required  this.organizationData,
  });

  factory v1GetOrganizationResponse.fromJson(Map<String, dynamic> json) {
    final _organizationData = v1OrganizationData.fromJson(json['organizationData'] as Map<String, dynamic>);
    return v1GetOrganizationResponse(
      organizationData: _organizationData,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['organizationData'] = organizationData.toJson();
    return _json;
  }
}

class v1GetPoliciesRequest {
  /// Unique identifier for a given organization.
  final String organizationId;

  const v1GetPoliciesRequest({
    required  this.organizationId,
  });

  factory v1GetPoliciesRequest.fromJson(Map<String, dynamic> json) {
    final _organizationId = json['organizationId'] as String;
    return v1GetPoliciesRequest(
      organizationId: _organizationId,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['organizationId'] = organizationId;
    return _json;
  }
}

class v1GetPoliciesResponse {
  /// A list of policies.
  final List<v1Policy> policies;

  const v1GetPoliciesResponse({
    required  this.policies,
  });

  factory v1GetPoliciesResponse.fromJson(Map<String, dynamic> json) {
    final _policies = (json['policies'] as List).map((e) => v1Policy.fromJson(e as Map<String, dynamic>)).toList();
    return v1GetPoliciesResponse(
      policies: _policies,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['policies'] = policies.map((e) => e.toJson()).toList();
    return _json;
  }
}

class v1GetPolicyEvaluationsRequest {
  /// Unique identifier for a given organization.
  final String organizationId;
  /// Unique identifier for a given activity.
  final String activityId;

  const v1GetPolicyEvaluationsRequest({
    required  this.organizationId,
    required  this.activityId,
  });

  factory v1GetPolicyEvaluationsRequest.fromJson(Map<String, dynamic> json) {
    final _organizationId = json['organizationId'] as String;
    final _activityId = json['activityId'] as String;
    return v1GetPolicyEvaluationsRequest(
      organizationId: _organizationId,
      activityId: _activityId,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['organizationId'] = organizationId;
    _json['activityId'] = activityId;
    return _json;
  }
}

class v1GetPolicyEvaluationsResponse {
  final List<externalactivityv1PolicyEvaluation> policyEvaluations;

  const v1GetPolicyEvaluationsResponse({
    required  this.policyEvaluations,
  });

  factory v1GetPolicyEvaluationsResponse.fromJson(Map<String, dynamic> json) {
    final _policyEvaluations = (json['policyEvaluations'] as List).map((e) => externalactivityv1PolicyEvaluation.fromJson(e as Map<String, dynamic>)).toList();
    return v1GetPolicyEvaluationsResponse(
      policyEvaluations: _policyEvaluations,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['policyEvaluations'] = policyEvaluations.map((e) => e.toJson()).toList();
    return _json;
  }
}

class v1GetPolicyRequest {
  /// Unique identifier for a given organization.
  final String organizationId;
  /// Unique identifier for a given policy.
  final String policyId;

  const v1GetPolicyRequest({
    required  this.organizationId,
    required  this.policyId,
  });

  factory v1GetPolicyRequest.fromJson(Map<String, dynamic> json) {
    final _organizationId = json['organizationId'] as String;
    final _policyId = json['policyId'] as String;
    return v1GetPolicyRequest(
      organizationId: _organizationId,
      policyId: _policyId,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['organizationId'] = organizationId;
    _json['policyId'] = policyId;
    return _json;
  }
}

class v1GetPolicyResponse {
  /// Object that codifies rules defining the actions that are permissible within an organization.
  final v1Policy policy;

  const v1GetPolicyResponse({
    required  this.policy,
  });

  factory v1GetPolicyResponse.fromJson(Map<String, dynamic> json) {
    final _policy = v1Policy.fromJson(json['policy'] as Map<String, dynamic>);
    return v1GetPolicyResponse(
      policy: _policy,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['policy'] = policy.toJson();
    return _json;
  }
}

class v1GetPrivateKeyRequest {
  /// Unique identifier for a given organization.
  final String organizationId;
  /// Unique identifier for a given private key.
  final String privateKeyId;

  const v1GetPrivateKeyRequest({
    required  this.organizationId,
    required  this.privateKeyId,
  });

  factory v1GetPrivateKeyRequest.fromJson(Map<String, dynamic> json) {
    final _organizationId = json['organizationId'] as String;
    final _privateKeyId = json['privateKeyId'] as String;
    return v1GetPrivateKeyRequest(
      organizationId: _organizationId,
      privateKeyId: _privateKeyId,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['organizationId'] = organizationId;
    _json['privateKeyId'] = privateKeyId;
    return _json;
  }
}

class v1GetPrivateKeyResponse {
  /// Cryptographic public/private key pair that can be used for cryptocurrency needs or more generalized encryption.
  final v1PrivateKey privateKey;

  const v1GetPrivateKeyResponse({
    required  this.privateKey,
  });

  factory v1GetPrivateKeyResponse.fromJson(Map<String, dynamic> json) {
    final _privateKey = v1PrivateKey.fromJson(json['privateKey'] as Map<String, dynamic>);
    return v1GetPrivateKeyResponse(
      privateKey: _privateKey,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['privateKey'] = privateKey.toJson();
    return _json;
  }
}

class v1GetPrivateKeysRequest {
  /// Unique identifier for a given organization.
  final String organizationId;

  const v1GetPrivateKeysRequest({
    required  this.organizationId,
  });

  factory v1GetPrivateKeysRequest.fromJson(Map<String, dynamic> json) {
    final _organizationId = json['organizationId'] as String;
    return v1GetPrivateKeysRequest(
      organizationId: _organizationId,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['organizationId'] = organizationId;
    return _json;
  }
}

class v1GetPrivateKeysResponse {
  /// A list of private keys.
  final List<v1PrivateKey> privateKeys;

  const v1GetPrivateKeysResponse({
    required  this.privateKeys,
  });

  factory v1GetPrivateKeysResponse.fromJson(Map<String, dynamic> json) {
    final _privateKeys = (json['privateKeys'] as List).map((e) => v1PrivateKey.fromJson(e as Map<String, dynamic>)).toList();
    return v1GetPrivateKeysResponse(
      privateKeys: _privateKeys,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['privateKeys'] = privateKeys.map((e) => e.toJson()).toList();
    return _json;
  }
}

class v1GetSendTransactionStatusRequest {
  /// Unique identifier for a given organization.
  final String organizationId;
  /// The unique identifier of a send transaction request.
  final String sendTransactionStatusId;

  const v1GetSendTransactionStatusRequest({
    required  this.organizationId,
    required  this.sendTransactionStatusId,
  });

  factory v1GetSendTransactionStatusRequest.fromJson(Map<String, dynamic> json) {
    final _organizationId = json['organizationId'] as String;
    final _sendTransactionStatusId = json['sendTransactionStatusId'] as String;
    return v1GetSendTransactionStatusRequest(
      organizationId: _organizationId,
      sendTransactionStatusId: _sendTransactionStatusId,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['organizationId'] = organizationId;
    _json['sendTransactionStatusId'] = sendTransactionStatusId;
    return _json;
  }
}

class v1GetSendTransactionStatusResponse {
  /// The current status of the send transaction.
  final String txStatus;
  /// Ethereum-specific transaction status.
  final v1EthSendTransactionStatus? eth;
  /// The error encountered when broadcasting or confirming the transaction, if any.
  final String? txError;
  /// Structured error information including revert details, if available.
  final v1TxError? error;

  const v1GetSendTransactionStatusResponse({
    required  this.txStatus,
     this.eth,
     this.txError,
     this.error,
  });

  factory v1GetSendTransactionStatusResponse.fromJson(Map<String, dynamic> json) {
    final _txStatus = json['txStatus'] as String;
    final _eth = json['eth'] == null ? null : v1EthSendTransactionStatus.fromJson(json['eth'] as Map<String, dynamic>);
    final _txError = json['txError'] as String?;
    final _error = json['error'] == null ? null : v1TxError.fromJson(json['error'] as Map<String, dynamic>);
    return v1GetSendTransactionStatusResponse(
      txStatus: _txStatus,
      eth: _eth,
      txError: _txError,
      error: _error,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['txStatus'] = txStatus;
    if (eth != null) {
      _json['eth'] = eth?.toJson();
    }
    if (txError != null) {
      _json['txError'] = txError;
    }
    if (error != null) {
      _json['error'] = error?.toJson();
    }
    return _json;
  }
}

class v1GetSmartContractInterfaceRequest {
  /// Unique identifier for a given organization.
  final String organizationId;
  /// Unique identifier for a given smart contract interface.
  final String smartContractInterfaceId;

  const v1GetSmartContractInterfaceRequest({
    required  this.organizationId,
    required  this.smartContractInterfaceId,
  });

  factory v1GetSmartContractInterfaceRequest.fromJson(Map<String, dynamic> json) {
    final _organizationId = json['organizationId'] as String;
    final _smartContractInterfaceId = json['smartContractInterfaceId'] as String;
    return v1GetSmartContractInterfaceRequest(
      organizationId: _organizationId,
      smartContractInterfaceId: _smartContractInterfaceId,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['organizationId'] = organizationId;
    _json['smartContractInterfaceId'] = smartContractInterfaceId;
    return _json;
  }
}

class v1GetSmartContractInterfaceResponse {
  /// Object to be used in conjunction with policies to guard transaction signing.
  final externaldatav1SmartContractInterface smartContractInterface;

  const v1GetSmartContractInterfaceResponse({
    required  this.smartContractInterface,
  });

  factory v1GetSmartContractInterfaceResponse.fromJson(Map<String, dynamic> json) {
    final _smartContractInterface = externaldatav1SmartContractInterface.fromJson(json['smartContractInterface'] as Map<String, dynamic>);
    return v1GetSmartContractInterfaceResponse(
      smartContractInterface: _smartContractInterface,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['smartContractInterface'] = smartContractInterface.toJson();
    return _json;
  }
}

class v1GetSmartContractInterfacesRequest {
  /// Unique identifier for a given organization.
  final String organizationId;

  const v1GetSmartContractInterfacesRequest({
    required  this.organizationId,
  });

  factory v1GetSmartContractInterfacesRequest.fromJson(Map<String, dynamic> json) {
    final _organizationId = json['organizationId'] as String;
    return v1GetSmartContractInterfacesRequest(
      organizationId: _organizationId,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['organizationId'] = organizationId;
    return _json;
  }
}

class v1GetSmartContractInterfacesResponse {
  /// A list of smart contract interfaces.
  final List<externaldatav1SmartContractInterface> smartContractInterfaces;

  const v1GetSmartContractInterfacesResponse({
    required  this.smartContractInterfaces,
  });

  factory v1GetSmartContractInterfacesResponse.fromJson(Map<String, dynamic> json) {
    final _smartContractInterfaces = (json['smartContractInterfaces'] as List).map((e) => externaldatav1SmartContractInterface.fromJson(e as Map<String, dynamic>)).toList();
    return v1GetSmartContractInterfacesResponse(
      smartContractInterfaces: _smartContractInterfaces,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['smartContractInterfaces'] = smartContractInterfaces.map((e) => e.toJson()).toList();
    return _json;
  }
}

class v1GetSubOrgIdsRequest {
  /// Unique identifier for the parent organization. This is used to find sub-organizations within it.
  final String organizationId;
  /// Specifies the type of filter to apply, i.e 'CREDENTIAL_ID', 'NAME', 'USERNAME', 'EMAIL', 'PHONE_NUMBER', 'OIDC_TOKEN', 'WALLET_ACCOUNT_ADDRESS' or 'PUBLIC_KEY'
  final String? filterType;
  /// The value of the filter to apply for the specified type. For example, a specific email or name string.
  final String? filterValue;
  /// Parameters used for cursor-based pagination.
  final v1Pagination? paginationOptions;

  const v1GetSubOrgIdsRequest({
    required  this.organizationId,
     this.filterType,
     this.filterValue,
     this.paginationOptions,
  });

  factory v1GetSubOrgIdsRequest.fromJson(Map<String, dynamic> json) {
    final _organizationId = json['organizationId'] as String;
    final _filterType = json['filterType'] as String?;
    final _filterValue = json['filterValue'] as String?;
    final _paginationOptions = json['paginationOptions'] == null ? null : v1Pagination.fromJson(json['paginationOptions'] as Map<String, dynamic>);
    return v1GetSubOrgIdsRequest(
      organizationId: _organizationId,
      filterType: _filterType,
      filterValue: _filterValue,
      paginationOptions: _paginationOptions,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['organizationId'] = organizationId;
    if (filterType != null) {
      _json['filterType'] = filterType;
    }
    if (filterValue != null) {
      _json['filterValue'] = filterValue;
    }
    if (paginationOptions != null) {
      _json['paginationOptions'] = paginationOptions?.toJson();
    }
    return _json;
  }
}

class v1GetSubOrgIdsResponse {
  /// List of unique identifiers for the matching sub-organizations.
  final List<String> organizationIds;

  const v1GetSubOrgIdsResponse({
    required  this.organizationIds,
  });

  factory v1GetSubOrgIdsResponse.fromJson(Map<String, dynamic> json) {
    final _organizationIds = (json['organizationIds'] as List).map((e) => e as String).toList();
    return v1GetSubOrgIdsResponse(
      organizationIds: _organizationIds,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['organizationIds'] = organizationIds;
    return _json;
  }
}

class v1GetTvcAppDeploymentsRequest {
  /// Unique identifier for a given organization.
  final String organizationId;
  /// Unique identifier for a given TVC App.
  final String appId;

  const v1GetTvcAppDeploymentsRequest({
    required  this.organizationId,
    required  this.appId,
  });

  factory v1GetTvcAppDeploymentsRequest.fromJson(Map<String, dynamic> json) {
    final _organizationId = json['organizationId'] as String;
    final _appId = json['appId'] as String;
    return v1GetTvcAppDeploymentsRequest(
      organizationId: _organizationId,
      appId: _appId,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['organizationId'] = organizationId;
    _json['appId'] = appId;
    return _json;
  }
}

class v1GetTvcAppDeploymentsResponse {
  /// List of deployments for this TVC App
  final List<v1TvcDeployment> tvcDeployments;

  const v1GetTvcAppDeploymentsResponse({
    required  this.tvcDeployments,
  });

  factory v1GetTvcAppDeploymentsResponse.fromJson(Map<String, dynamic> json) {
    final _tvcDeployments = (json['tvcDeployments'] as List).map((e) => v1TvcDeployment.fromJson(e as Map<String, dynamic>)).toList();
    return v1GetTvcAppDeploymentsResponse(
      tvcDeployments: _tvcDeployments,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['tvcDeployments'] = tvcDeployments.map((e) => e.toJson()).toList();
    return _json;
  }
}

class v1GetTvcAppRequest {
  /// Unique identifier for a given organization.
  final String organizationId;
  /// Unique identifier for a given TVC App.
  final String tvcAppId;

  const v1GetTvcAppRequest({
    required  this.organizationId,
    required  this.tvcAppId,
  });

  factory v1GetTvcAppRequest.fromJson(Map<String, dynamic> json) {
    final _organizationId = json['organizationId'] as String;
    final _tvcAppId = json['tvcAppId'] as String;
    return v1GetTvcAppRequest(
      organizationId: _organizationId,
      tvcAppId: _tvcAppId,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['organizationId'] = organizationId;
    _json['tvcAppId'] = tvcAppId;
    return _json;
  }
}

class v1GetTvcAppResponse {
  /// Details about a single TVC App
  final v1TvcApp tvcApp;

  const v1GetTvcAppResponse({
    required  this.tvcApp,
  });

  factory v1GetTvcAppResponse.fromJson(Map<String, dynamic> json) {
    final _tvcApp = v1TvcApp.fromJson(json['tvcApp'] as Map<String, dynamic>);
    return v1GetTvcAppResponse(
      tvcApp: _tvcApp,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['tvcApp'] = tvcApp.toJson();
    return _json;
  }
}

class v1GetTvcAppsRequest {
  /// Unique identifier for a given organization.
  final String organizationId;

  const v1GetTvcAppsRequest({
    required  this.organizationId,
  });

  factory v1GetTvcAppsRequest.fromJson(Map<String, dynamic> json) {
    final _organizationId = json['organizationId'] as String;
    return v1GetTvcAppsRequest(
      organizationId: _organizationId,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['organizationId'] = organizationId;
    return _json;
  }
}

class v1GetTvcAppsResponse {
  /// A list of TVC Apps.
  final List<v1TvcApp> tvcApps;

  const v1GetTvcAppsResponse({
    required  this.tvcApps,
  });

  factory v1GetTvcAppsResponse.fromJson(Map<String, dynamic> json) {
    final _tvcApps = (json['tvcApps'] as List).map((e) => v1TvcApp.fromJson(e as Map<String, dynamic>)).toList();
    return v1GetTvcAppsResponse(
      tvcApps: _tvcApps,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['tvcApps'] = tvcApps.map((e) => e.toJson()).toList();
    return _json;
  }
}

class v1GetTvcDeploymentRequest {
  /// Unique identifier for a given organization.
  final String organizationId;
  /// Unique identifier for a given TVC Deployment.
  final String deploymentId;

  const v1GetTvcDeploymentRequest({
    required  this.organizationId,
    required  this.deploymentId,
  });

  factory v1GetTvcDeploymentRequest.fromJson(Map<String, dynamic> json) {
    final _organizationId = json['organizationId'] as String;
    final _deploymentId = json['deploymentId'] as String;
    return v1GetTvcDeploymentRequest(
      organizationId: _organizationId,
      deploymentId: _deploymentId,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['organizationId'] = organizationId;
    _json['deploymentId'] = deploymentId;
    return _json;
  }
}

class v1GetTvcDeploymentResponse {
  /// Details about a single TVC Deployment
  final v1TvcDeployment tvcDeployment;

  const v1GetTvcDeploymentResponse({
    required  this.tvcDeployment,
  });

  factory v1GetTvcDeploymentResponse.fromJson(Map<String, dynamic> json) {
    final _tvcDeployment = v1TvcDeployment.fromJson(json['tvcDeployment'] as Map<String, dynamic>);
    return v1GetTvcDeploymentResponse(
      tvcDeployment: _tvcDeployment,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['tvcDeployment'] = tvcDeployment.toJson();
    return _json;
  }
}

class v1GetUserRequest {
  /// Unique identifier for a given organization.
  final String organizationId;
  /// Unique identifier for a given user.
  final String userId;

  const v1GetUserRequest({
    required  this.organizationId,
    required  this.userId,
  });

  factory v1GetUserRequest.fromJson(Map<String, dynamic> json) {
    final _organizationId = json['organizationId'] as String;
    final _userId = json['userId'] as String;
    return v1GetUserRequest(
      organizationId: _organizationId,
      userId: _userId,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['organizationId'] = organizationId;
    _json['userId'] = userId;
    return _json;
  }
}

class v1GetUserResponse {
  /// Web and/or API user within your organization.
  final v1User user;

  const v1GetUserResponse({
    required  this.user,
  });

  factory v1GetUserResponse.fromJson(Map<String, dynamic> json) {
    final _user = v1User.fromJson(json['user'] as Map<String, dynamic>);
    return v1GetUserResponse(
      user: _user,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['user'] = user.toJson();
    return _json;
  }
}

class v1GetUsersRequest {
  /// Unique identifier for a given organization.
  final String organizationId;

  const v1GetUsersRequest({
    required  this.organizationId,
  });

  factory v1GetUsersRequest.fromJson(Map<String, dynamic> json) {
    final _organizationId = json['organizationId'] as String;
    return v1GetUsersRequest(
      organizationId: _organizationId,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['organizationId'] = organizationId;
    return _json;
  }
}

class v1GetUsersResponse {
  /// A list of users.
  final List<v1User> users;

  const v1GetUsersResponse({
    required  this.users,
  });

  factory v1GetUsersResponse.fromJson(Map<String, dynamic> json) {
    final _users = (json['users'] as List).map((e) => v1User.fromJson(e as Map<String, dynamic>)).toList();
    return v1GetUsersResponse(
      users: _users,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['users'] = users.map((e) => e.toJson()).toList();
    return _json;
  }
}

class v1GetVerifiedSubOrgIdsRequest {
  /// Unique identifier for the parent organization. This is used to find sub-organizations within it.
  final String organizationId;
  /// Specifies the type of filter to apply, i.e 'EMAIL', 'PHONE_NUMBER'.
  final String? filterType;
  /// The value of the filter to apply for the specified type. For example, a specific email or phone number string.
  final String? filterValue;
  /// Parameters used for cursor-based pagination.
  final v1Pagination? paginationOptions;

  const v1GetVerifiedSubOrgIdsRequest({
    required  this.organizationId,
     this.filterType,
     this.filterValue,
     this.paginationOptions,
  });

  factory v1GetVerifiedSubOrgIdsRequest.fromJson(Map<String, dynamic> json) {
    final _organizationId = json['organizationId'] as String;
    final _filterType = json['filterType'] as String?;
    final _filterValue = json['filterValue'] as String?;
    final _paginationOptions = json['paginationOptions'] == null ? null : v1Pagination.fromJson(json['paginationOptions'] as Map<String, dynamic>);
    return v1GetVerifiedSubOrgIdsRequest(
      organizationId: _organizationId,
      filterType: _filterType,
      filterValue: _filterValue,
      paginationOptions: _paginationOptions,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['organizationId'] = organizationId;
    if (filterType != null) {
      _json['filterType'] = filterType;
    }
    if (filterValue != null) {
      _json['filterValue'] = filterValue;
    }
    if (paginationOptions != null) {
      _json['paginationOptions'] = paginationOptions?.toJson();
    }
    return _json;
  }
}

class v1GetVerifiedSubOrgIdsResponse {
  /// List of unique identifiers for the matching sub-organizations.
  final List<String> organizationIds;

  const v1GetVerifiedSubOrgIdsResponse({
    required  this.organizationIds,
  });

  factory v1GetVerifiedSubOrgIdsResponse.fromJson(Map<String, dynamic> json) {
    final _organizationIds = (json['organizationIds'] as List).map((e) => e as String).toList();
    return v1GetVerifiedSubOrgIdsResponse(
      organizationIds: _organizationIds,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['organizationIds'] = organizationIds;
    return _json;
  }
}

class v1GetWalletAccountRequest {
  /// Unique identifier for a given organization.
  final String organizationId;
  /// Unique identifier for a given wallet.
  final String walletId;
  /// Address corresponding to a wallet account.
  final String? address;
  /// Path corresponding to a wallet account.
  final String? path;

  const v1GetWalletAccountRequest({
    required  this.organizationId,
    required  this.walletId,
     this.address,
     this.path,
  });

  factory v1GetWalletAccountRequest.fromJson(Map<String, dynamic> json) {
    final _organizationId = json['organizationId'] as String;
    final _walletId = json['walletId'] as String;
    final _address = json['address'] as String?;
    final _path = json['path'] as String?;
    return v1GetWalletAccountRequest(
      organizationId: _organizationId,
      walletId: _walletId,
      address: _address,
      path: _path,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['organizationId'] = organizationId;
    _json['walletId'] = walletId;
    if (address != null) {
      _json['address'] = address;
    }
    if (path != null) {
      _json['path'] = path;
    }
    return _json;
  }
}

class v1GetWalletAccountResponse {
  /// The resulting wallet account.
  final v1WalletAccount account;

  const v1GetWalletAccountResponse({
    required  this.account,
  });

  factory v1GetWalletAccountResponse.fromJson(Map<String, dynamic> json) {
    final _account = v1WalletAccount.fromJson(json['account'] as Map<String, dynamic>);
    return v1GetWalletAccountResponse(
      account: _account,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['account'] = account.toJson();
    return _json;
  }
}

class v1GetWalletAccountsRequest {
  /// Unique identifier for a given organization.
  final String organizationId;
  /// Unique identifier for a given wallet. If not provided, all accounts for the organization will be returned.
  final String? walletId;
  /// Optional flag to specify if the wallet details should be included in the response. Default = false.
  final bool? includeWalletDetails;
  /// Parameters used for cursor-based pagination.
  final v1Pagination? paginationOptions;

  const v1GetWalletAccountsRequest({
    required  this.organizationId,
     this.walletId,
     this.includeWalletDetails,
     this.paginationOptions,
  });

  factory v1GetWalletAccountsRequest.fromJson(Map<String, dynamic> json) {
    final _organizationId = json['organizationId'] as String;
    final _walletId = json['walletId'] as String?;
    final _includeWalletDetails = json['includeWalletDetails'] as bool?;
    final _paginationOptions = json['paginationOptions'] == null ? null : v1Pagination.fromJson(json['paginationOptions'] as Map<String, dynamic>);
    return v1GetWalletAccountsRequest(
      organizationId: _organizationId,
      walletId: _walletId,
      includeWalletDetails: _includeWalletDetails,
      paginationOptions: _paginationOptions,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['organizationId'] = organizationId;
    if (walletId != null) {
      _json['walletId'] = walletId;
    }
    if (includeWalletDetails != null) {
      _json['includeWalletDetails'] = includeWalletDetails;
    }
    if (paginationOptions != null) {
      _json['paginationOptions'] = paginationOptions?.toJson();
    }
    return _json;
  }
}

class v1GetWalletAccountsResponse {
  /// A list of accounts generated from a wallet that share a common seed.
  final List<v1WalletAccount> accounts;

  const v1GetWalletAccountsResponse({
    required  this.accounts,
  });

  factory v1GetWalletAccountsResponse.fromJson(Map<String, dynamic> json) {
    final _accounts = (json['accounts'] as List).map((e) => v1WalletAccount.fromJson(e as Map<String, dynamic>)).toList();
    return v1GetWalletAccountsResponse(
      accounts: _accounts,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['accounts'] = accounts.map((e) => e.toJson()).toList();
    return _json;
  }
}

class v1GetWalletAddressBalancesRequest {
  /// Unique identifier for a given organization.
  final String organizationId;
  /// Address corresponding to a wallet account.
  final String address;
  /// The network identifier in CAIP-2 format (e.g., 'eip155:1' for Ethereum mainnet).
  final String caip2;

  const v1GetWalletAddressBalancesRequest({
    required  this.organizationId,
    required  this.address,
    required  this.caip2,
  });

  factory v1GetWalletAddressBalancesRequest.fromJson(Map<String, dynamic> json) {
    final _organizationId = json['organizationId'] as String;
    final _address = json['address'] as String;
    final _caip2 = json['caip2'] as String;
    return v1GetWalletAddressBalancesRequest(
      organizationId: _organizationId,
      address: _address,
      caip2: _caip2,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['organizationId'] = organizationId;
    _json['address'] = address;
    _json['caip2'] = caip2;
    return _json;
  }
}

class v1GetWalletAddressBalancesResponse {
  final List<v1AssetBalance>? balances;

  const v1GetWalletAddressBalancesResponse({
     this.balances,
  });

  factory v1GetWalletAddressBalancesResponse.fromJson(Map<String, dynamic> json) {
    final _balances = (json['balances'] as List?)?.map((e) => v1AssetBalance.fromJson(e as Map<String, dynamic>)).toList();
    return v1GetWalletAddressBalancesResponse(
      balances: _balances,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    if (balances != null) {
      _json['balances'] = balances?.map((e) => e.toJson()).toList();
    }
    return _json;
  }
}

class v1GetWalletRequest {
  /// Unique identifier for a given organization.
  final String organizationId;
  /// Unique identifier for a given wallet.
  final String walletId;

  const v1GetWalletRequest({
    required  this.organizationId,
    required  this.walletId,
  });

  factory v1GetWalletRequest.fromJson(Map<String, dynamic> json) {
    final _organizationId = json['organizationId'] as String;
    final _walletId = json['walletId'] as String;
    return v1GetWalletRequest(
      organizationId: _organizationId,
      walletId: _walletId,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['organizationId'] = organizationId;
    _json['walletId'] = walletId;
    return _json;
  }
}

class v1GetWalletResponse {
  /// A collection of deterministically generated cryptographic public / private key pairs that share a common seed.
  final v1Wallet wallet;

  const v1GetWalletResponse({
    required  this.wallet,
  });

  factory v1GetWalletResponse.fromJson(Map<String, dynamic> json) {
    final _wallet = v1Wallet.fromJson(json['wallet'] as Map<String, dynamic>);
    return v1GetWalletResponse(
      wallet: _wallet,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['wallet'] = wallet.toJson();
    return _json;
  }
}

class v1GetWalletsRequest {
  /// Unique identifier for a given organization.
  final String organizationId;

  const v1GetWalletsRequest({
    required  this.organizationId,
  });

  factory v1GetWalletsRequest.fromJson(Map<String, dynamic> json) {
    final _organizationId = json['organizationId'] as String;
    return v1GetWalletsRequest(
      organizationId: _organizationId,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['organizationId'] = organizationId;
    return _json;
  }
}

class v1GetWalletsResponse {
  /// A list of wallets.
  final List<v1Wallet> wallets;

  const v1GetWalletsResponse({
    required  this.wallets,
  });

  factory v1GetWalletsResponse.fromJson(Map<String, dynamic> json) {
    final _wallets = (json['wallets'] as List).map((e) => v1Wallet.fromJson(e as Map<String, dynamic>)).toList();
    return v1GetWalletsResponse(
      wallets: _wallets,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['wallets'] = wallets.map((e) => e.toJson()).toList();
    return _json;
  }
}

class v1GetWhoamiRequest {
  /// Unique identifier for a given organization. If the request is being made by a WebAuthN user and their sub-organization ID is unknown, this can be the parent organization ID; using the sub-organization ID when possible is preferred due to performance reasons.
  final String organizationId;

  const v1GetWhoamiRequest({
    required  this.organizationId,
  });

  factory v1GetWhoamiRequest.fromJson(Map<String, dynamic> json) {
    final _organizationId = json['organizationId'] as String;
    return v1GetWhoamiRequest(
      organizationId: _organizationId,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['organizationId'] = organizationId;
    return _json;
  }
}

class v1GetWhoamiResponse {
  /// Unique identifier for a given organization.
  final String organizationId;
  /// Human-readable name for an organization.
  final String organizationName;
  /// Unique identifier for a given user.
  final String userId;
  /// Human-readable name for a user.
  final String username;

  const v1GetWhoamiResponse({
    required  this.organizationId,
    required  this.organizationName,
    required  this.userId,
    required  this.username,
  });

  factory v1GetWhoamiResponse.fromJson(Map<String, dynamic> json) {
    final _organizationId = json['organizationId'] as String;
    final _organizationName = json['organizationName'] as String;
    final _userId = json['userId'] as String;
    final _username = json['username'] as String;
    return v1GetWhoamiResponse(
      organizationId: _organizationId,
      organizationName: _organizationName,
      userId: _userId,
      username: _username,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['organizationId'] = organizationId;
    _json['organizationName'] = organizationName;
    _json['userId'] = userId;
    _json['username'] = username;
    return _json;
  }
}

class v1ImportPrivateKeyIntent {
  /// The ID of the User importing a Private Key.
  final String userId;
  /// Human-readable name for a Private Key.
  final String privateKeyName;
  /// Bundle containing a raw private key encrypted to the enclave's target public key.
  final String encryptedBundle;
  /// Cryptographic Curve used to generate a given Private Key.
  final v1Curve curve;
  /// Cryptocurrency-specific formats for a derived address (e.g., Ethereum).
  final List<v1AddressFormat> addressFormats;

  const v1ImportPrivateKeyIntent({
    required  this.userId,
    required  this.privateKeyName,
    required  this.encryptedBundle,
    required  this.curve,
    required  this.addressFormats,
  });

  factory v1ImportPrivateKeyIntent.fromJson(Map<String, dynamic> json) {
    final _userId = json['userId'] as String;
    final _privateKeyName = json['privateKeyName'] as String;
    final _encryptedBundle = json['encryptedBundle'] as String;
    final _curve = v1CurveFromJson(json['curve']);
    final _addressFormats = (json['addressFormats'] as List).map((e) => v1AddressFormatFromJson(e)).toList();
    return v1ImportPrivateKeyIntent(
      userId: _userId,
      privateKeyName: _privateKeyName,
      encryptedBundle: _encryptedBundle,
      curve: _curve,
      addressFormats: _addressFormats,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['userId'] = userId;
    _json['privateKeyName'] = privateKeyName;
    _json['encryptedBundle'] = encryptedBundle;
    _json['curve'] = v1CurveToJson(curve);
    _json['addressFormats'] = addressFormats.map((e) => v1AddressFormatToJson(e)).toList();
    return _json;
  }
}

class v1ImportPrivateKeyRequest {
  final String type;
  /// Timestamp (in milliseconds) of the request, used to verify liveness of user requests.
  final String timestampMs;
  /// Unique identifier for a given Organization.
  final String organizationId;
  final v1ImportPrivateKeyIntent parameters;
  final bool? generateAppProofs;

  const v1ImportPrivateKeyRequest({
    required  this.type,
    required  this.timestampMs,
    required  this.organizationId,
    required  this.parameters,
     this.generateAppProofs,
  });

  factory v1ImportPrivateKeyRequest.fromJson(Map<String, dynamic> json) {
    final _type = json['type'] as String;
    final _timestampMs = json['timestampMs'] as String;
    final _organizationId = json['organizationId'] as String;
    final _parameters = v1ImportPrivateKeyIntent.fromJson(json['parameters'] as Map<String, dynamic>);
    final _generateAppProofs = json['generateAppProofs'] as bool?;
    return v1ImportPrivateKeyRequest(
      type: _type,
      timestampMs: _timestampMs,
      organizationId: _organizationId,
      parameters: _parameters,
      generateAppProofs: _generateAppProofs,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['type'] = type;
    _json['timestampMs'] = timestampMs;
    _json['organizationId'] = organizationId;
    _json['parameters'] = parameters.toJson();
    if (generateAppProofs != null) {
      _json['generateAppProofs'] = generateAppProofs;
    }
    return _json;
  }
}

class v1ImportPrivateKeyResult {
  /// Unique identifier for a Private Key.
  final String privateKeyId;
  /// A list of addresses.
  final List<immutableactivityv1Address> addresses;

  const v1ImportPrivateKeyResult({
    required  this.privateKeyId,
    required  this.addresses,
  });

  factory v1ImportPrivateKeyResult.fromJson(Map<String, dynamic> json) {
    final _privateKeyId = json['privateKeyId'] as String;
    final _addresses = (json['addresses'] as List).map((e) => immutableactivityv1Address.fromJson(e as Map<String, dynamic>)).toList();
    return v1ImportPrivateKeyResult(
      privateKeyId: _privateKeyId,
      addresses: _addresses,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['privateKeyId'] = privateKeyId;
    _json['addresses'] = addresses.map((e) => e.toJson()).toList();
    return _json;
  }
}

class v1ImportWalletIntent {
  /// The ID of the User importing a Wallet.
  final String userId;
  /// Human-readable name for a Wallet.
  final String walletName;
  /// Bundle containing a wallet mnemonic encrypted to the enclave's target public key.
  final String encryptedBundle;
  /// A list of wallet Accounts.
  final List<v1WalletAccountParams> accounts;

  const v1ImportWalletIntent({
    required  this.userId,
    required  this.walletName,
    required  this.encryptedBundle,
    required  this.accounts,
  });

  factory v1ImportWalletIntent.fromJson(Map<String, dynamic> json) {
    final _userId = json['userId'] as String;
    final _walletName = json['walletName'] as String;
    final _encryptedBundle = json['encryptedBundle'] as String;
    final _accounts = (json['accounts'] as List).map((e) => v1WalletAccountParams.fromJson(e as Map<String, dynamic>)).toList();
    return v1ImportWalletIntent(
      userId: _userId,
      walletName: _walletName,
      encryptedBundle: _encryptedBundle,
      accounts: _accounts,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['userId'] = userId;
    _json['walletName'] = walletName;
    _json['encryptedBundle'] = encryptedBundle;
    _json['accounts'] = accounts.map((e) => e.toJson()).toList();
    return _json;
  }
}

class v1ImportWalletRequest {
  final String type;
  /// Timestamp (in milliseconds) of the request, used to verify liveness of user requests.
  final String timestampMs;
  /// Unique identifier for a given Organization.
  final String organizationId;
  final v1ImportWalletIntent parameters;
  final bool? generateAppProofs;

  const v1ImportWalletRequest({
    required  this.type,
    required  this.timestampMs,
    required  this.organizationId,
    required  this.parameters,
     this.generateAppProofs,
  });

  factory v1ImportWalletRequest.fromJson(Map<String, dynamic> json) {
    final _type = json['type'] as String;
    final _timestampMs = json['timestampMs'] as String;
    final _organizationId = json['organizationId'] as String;
    final _parameters = v1ImportWalletIntent.fromJson(json['parameters'] as Map<String, dynamic>);
    final _generateAppProofs = json['generateAppProofs'] as bool?;
    return v1ImportWalletRequest(
      type: _type,
      timestampMs: _timestampMs,
      organizationId: _organizationId,
      parameters: _parameters,
      generateAppProofs: _generateAppProofs,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['type'] = type;
    _json['timestampMs'] = timestampMs;
    _json['organizationId'] = organizationId;
    _json['parameters'] = parameters.toJson();
    if (generateAppProofs != null) {
      _json['generateAppProofs'] = generateAppProofs;
    }
    return _json;
  }
}

class v1ImportWalletResult {
  /// Unique identifier for a Wallet.
  final String walletId;
  /// A list of account addresses.
  final List<String> addresses;

  const v1ImportWalletResult({
    required  this.walletId,
    required  this.addresses,
  });

  factory v1ImportWalletResult.fromJson(Map<String, dynamic> json) {
    final _walletId = json['walletId'] as String;
    final _addresses = (json['addresses'] as List).map((e) => e as String).toList();
    return v1ImportWalletResult(
      walletId: _walletId,
      addresses: _addresses,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['walletId'] = walletId;
    _json['addresses'] = addresses;
    return _json;
  }
}

class v1InitFiatOnRampIntent {
  /// Enum to specifiy which on-ramp provider to use
  final v1FiatOnRampProvider onrampProvider;
  /// Destination wallet address for the buy transaction.
  final String walletAddress;
  /// Blockchain network to be used for the transaction, e.g., bitcoin, ethereum. Maps to MoonPay's network or Coinbase's defaultNetwork.
  final v1FiatOnRampBlockchainNetwork network;
  /// Code for the cryptocurrency to be purchased, e.g., btc, eth. Maps to MoonPay's currencyCode or Coinbase's defaultAsset.
  final v1FiatOnRampCryptoCurrency cryptoCurrencyCode;
  /// Code for the fiat currency to be used in the transaction, e.g., USD, EUR.
  final v1FiatOnRampCurrency? fiatCurrencyCode;
  /// Specifies a preset fiat amount for the transaction, e.g., '100'. Must be greater than '20'. If not provided, the user will be prompted to enter an amount.
  final String? fiatCurrencyAmount;
  /// Pre-selected payment method, e.g., CREDIT_DEBIT_CARD, APPLE_PAY. Validated against the chosen provider.
  final v1FiatOnRampPaymentMethod? paymentMethod;
  /// ISO 3166-1 two-digit country code for Coinbase representing the purchasing users country of residence, e.g., US, GB.
  final String? countryCode;
  /// ISO 3166-2 two-digit country subdivision code for Coinbase representing the purchasing users subdivision of residence within their country, e.g. NY. Required if country_code=US.
  final String? countrySubdivisionCode;
  /// Optional flag to indicate whether to use the sandbox mode to simulate transactions for the on-ramp provider. Default is false.
  final bool? sandboxMode;
  /// Optional MoonPay Widget URL to sign when using MoonPay client SDKs with URL Signing enabled.
  final String? urlForSignature;

  const v1InitFiatOnRampIntent({
    required  this.onrampProvider,
    required  this.walletAddress,
    required  this.network,
    required  this.cryptoCurrencyCode,
     this.fiatCurrencyCode,
     this.fiatCurrencyAmount,
     this.paymentMethod,
     this.countryCode,
     this.countrySubdivisionCode,
     this.sandboxMode,
     this.urlForSignature,
  });

  factory v1InitFiatOnRampIntent.fromJson(Map<String, dynamic> json) {
    final _onrampProvider = v1FiatOnRampProviderFromJson(json['onrampProvider']);
    final _walletAddress = json['walletAddress'] as String;
    final _network = v1FiatOnRampBlockchainNetworkFromJson(json['network']);
    final _cryptoCurrencyCode = v1FiatOnRampCryptoCurrencyFromJson(json['cryptoCurrencyCode']);
    final _fiatCurrencyCode = json['fiatCurrencyCode'] == null ? null : v1FiatOnRampCurrencyFromJson(json['fiatCurrencyCode']);
    final _fiatCurrencyAmount = json['fiatCurrencyAmount'] as String?;
    final _paymentMethod = json['paymentMethod'] == null ? null : v1FiatOnRampPaymentMethodFromJson(json['paymentMethod']);
    final _countryCode = json['countryCode'] as String?;
    final _countrySubdivisionCode = json['countrySubdivisionCode'] as String?;
    final _sandboxMode = json['sandboxMode'] as bool?;
    final _urlForSignature = json['urlForSignature'] as String?;
    return v1InitFiatOnRampIntent(
      onrampProvider: _onrampProvider,
      walletAddress: _walletAddress,
      network: _network,
      cryptoCurrencyCode: _cryptoCurrencyCode,
      fiatCurrencyCode: _fiatCurrencyCode,
      fiatCurrencyAmount: _fiatCurrencyAmount,
      paymentMethod: _paymentMethod,
      countryCode: _countryCode,
      countrySubdivisionCode: _countrySubdivisionCode,
      sandboxMode: _sandboxMode,
      urlForSignature: _urlForSignature,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['onrampProvider'] = v1FiatOnRampProviderToJson(onrampProvider);
    _json['walletAddress'] = walletAddress;
    _json['network'] = v1FiatOnRampBlockchainNetworkToJson(network);
    _json['cryptoCurrencyCode'] = v1FiatOnRampCryptoCurrencyToJson(cryptoCurrencyCode);
    if (fiatCurrencyCode != null) {
      _json['fiatCurrencyCode'] = v1FiatOnRampCurrencyToJson(fiatCurrencyCode!);
    }
    if (fiatCurrencyAmount != null) {
      _json['fiatCurrencyAmount'] = fiatCurrencyAmount;
    }
    if (paymentMethod != null) {
      _json['paymentMethod'] = v1FiatOnRampPaymentMethodToJson(paymentMethod!);
    }
    if (countryCode != null) {
      _json['countryCode'] = countryCode;
    }
    if (countrySubdivisionCode != null) {
      _json['countrySubdivisionCode'] = countrySubdivisionCode;
    }
    if (sandboxMode != null) {
      _json['sandboxMode'] = sandboxMode;
    }
    if (urlForSignature != null) {
      _json['urlForSignature'] = urlForSignature;
    }
    return _json;
  }
}

class v1InitFiatOnRampRequest {
  final String type;
  /// Timestamp (in milliseconds) of the request, used to verify liveness of user requests.
  final String timestampMs;
  /// Unique identifier for a given Organization.
  final String organizationId;
  final v1InitFiatOnRampIntent parameters;
  final bool? generateAppProofs;

  const v1InitFiatOnRampRequest({
    required  this.type,
    required  this.timestampMs,
    required  this.organizationId,
    required  this.parameters,
     this.generateAppProofs,
  });

  factory v1InitFiatOnRampRequest.fromJson(Map<String, dynamic> json) {
    final _type = json['type'] as String;
    final _timestampMs = json['timestampMs'] as String;
    final _organizationId = json['organizationId'] as String;
    final _parameters = v1InitFiatOnRampIntent.fromJson(json['parameters'] as Map<String, dynamic>);
    final _generateAppProofs = json['generateAppProofs'] as bool?;
    return v1InitFiatOnRampRequest(
      type: _type,
      timestampMs: _timestampMs,
      organizationId: _organizationId,
      parameters: _parameters,
      generateAppProofs: _generateAppProofs,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['type'] = type;
    _json['timestampMs'] = timestampMs;
    _json['organizationId'] = organizationId;
    _json['parameters'] = parameters.toJson();
    if (generateAppProofs != null) {
      _json['generateAppProofs'] = generateAppProofs;
    }
    return _json;
  }
}

class v1InitFiatOnRampResult {
  /// Unique URL for a given fiat on-ramp flow.
  final String onRampUrl;
  /// Unique identifier used to retrieve transaction statuses for a given fiat on-ramp flow.
  final String onRampTransactionId;
  /// Optional signature of the MoonPay Widget URL. The signature is generated if the Init Fiat On Ramp intent includes the urlForSignature field. The signature can be used to initialize the MoonPay SDKs when URL signing is enabled for your project.
  final String? onRampUrlSignature;

  const v1InitFiatOnRampResult({
    required  this.onRampUrl,
    required  this.onRampTransactionId,
     this.onRampUrlSignature,
  });

  factory v1InitFiatOnRampResult.fromJson(Map<String, dynamic> json) {
    final _onRampUrl = json['onRampUrl'] as String;
    final _onRampTransactionId = json['onRampTransactionId'] as String;
    final _onRampUrlSignature = json['onRampUrlSignature'] as String?;
    return v1InitFiatOnRampResult(
      onRampUrl: _onRampUrl,
      onRampTransactionId: _onRampTransactionId,
      onRampUrlSignature: _onRampUrlSignature,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['onRampUrl'] = onRampUrl;
    _json['onRampTransactionId'] = onRampTransactionId;
    if (onRampUrlSignature != null) {
      _json['onRampUrlSignature'] = onRampUrlSignature;
    }
    return _json;
  }
}

class v1InitImportPrivateKeyIntent {
  /// The ID of the User importing a Private Key.
  final String userId;

  const v1InitImportPrivateKeyIntent({
    required  this.userId,
  });

  factory v1InitImportPrivateKeyIntent.fromJson(Map<String, dynamic> json) {
    final _userId = json['userId'] as String;
    return v1InitImportPrivateKeyIntent(
      userId: _userId,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['userId'] = userId;
    return _json;
  }
}

class v1InitImportPrivateKeyRequest {
  final String type;
  /// Timestamp (in milliseconds) of the request, used to verify liveness of user requests.
  final String timestampMs;
  /// Unique identifier for a given Organization.
  final String organizationId;
  final v1InitImportPrivateKeyIntent parameters;
  final bool? generateAppProofs;

  const v1InitImportPrivateKeyRequest({
    required  this.type,
    required  this.timestampMs,
    required  this.organizationId,
    required  this.parameters,
     this.generateAppProofs,
  });

  factory v1InitImportPrivateKeyRequest.fromJson(Map<String, dynamic> json) {
    final _type = json['type'] as String;
    final _timestampMs = json['timestampMs'] as String;
    final _organizationId = json['organizationId'] as String;
    final _parameters = v1InitImportPrivateKeyIntent.fromJson(json['parameters'] as Map<String, dynamic>);
    final _generateAppProofs = json['generateAppProofs'] as bool?;
    return v1InitImportPrivateKeyRequest(
      type: _type,
      timestampMs: _timestampMs,
      organizationId: _organizationId,
      parameters: _parameters,
      generateAppProofs: _generateAppProofs,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['type'] = type;
    _json['timestampMs'] = timestampMs;
    _json['organizationId'] = organizationId;
    _json['parameters'] = parameters.toJson();
    if (generateAppProofs != null) {
      _json['generateAppProofs'] = generateAppProofs;
    }
    return _json;
  }
}

class v1InitImportPrivateKeyResult {
  /// Import bundle containing a public key and signature to use for importing client data.
  final String importBundle;

  const v1InitImportPrivateKeyResult({
    required  this.importBundle,
  });

  factory v1InitImportPrivateKeyResult.fromJson(Map<String, dynamic> json) {
    final _importBundle = json['importBundle'] as String;
    return v1InitImportPrivateKeyResult(
      importBundle: _importBundle,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['importBundle'] = importBundle;
    return _json;
  }
}

class v1InitImportWalletIntent {
  /// The ID of the User importing a Wallet.
  final String userId;

  const v1InitImportWalletIntent({
    required  this.userId,
  });

  factory v1InitImportWalletIntent.fromJson(Map<String, dynamic> json) {
    final _userId = json['userId'] as String;
    return v1InitImportWalletIntent(
      userId: _userId,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['userId'] = userId;
    return _json;
  }
}

class v1InitImportWalletRequest {
  final String type;
  /// Timestamp (in milliseconds) of the request, used to verify liveness of user requests.
  final String timestampMs;
  /// Unique identifier for a given Organization.
  final String organizationId;
  final v1InitImportWalletIntent parameters;
  final bool? generateAppProofs;

  const v1InitImportWalletRequest({
    required  this.type,
    required  this.timestampMs,
    required  this.organizationId,
    required  this.parameters,
     this.generateAppProofs,
  });

  factory v1InitImportWalletRequest.fromJson(Map<String, dynamic> json) {
    final _type = json['type'] as String;
    final _timestampMs = json['timestampMs'] as String;
    final _organizationId = json['organizationId'] as String;
    final _parameters = v1InitImportWalletIntent.fromJson(json['parameters'] as Map<String, dynamic>);
    final _generateAppProofs = json['generateAppProofs'] as bool?;
    return v1InitImportWalletRequest(
      type: _type,
      timestampMs: _timestampMs,
      organizationId: _organizationId,
      parameters: _parameters,
      generateAppProofs: _generateAppProofs,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['type'] = type;
    _json['timestampMs'] = timestampMs;
    _json['organizationId'] = organizationId;
    _json['parameters'] = parameters.toJson();
    if (generateAppProofs != null) {
      _json['generateAppProofs'] = generateAppProofs;
    }
    return _json;
  }
}

class v1InitImportWalletResult {
  /// Import bundle containing a public key and signature to use for importing client data.
  final String importBundle;

  const v1InitImportWalletResult({
    required  this.importBundle,
  });

  factory v1InitImportWalletResult.fromJson(Map<String, dynamic> json) {
    final _importBundle = json['importBundle'] as String;
    return v1InitImportWalletResult(
      importBundle: _importBundle,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['importBundle'] = importBundle;
    return _json;
  }
}

class v1InitOtpAuthIntent {
  /// Enum to specifiy whether to send OTP via SMS or email
  final String otpType;
  /// Email or phone number to send the OTP code to
  final String contact;
  /// Optional parameters for customizing emails. If not provided, the default email will be used.
  final v1EmailCustomizationParams? emailCustomization;
  /// Optional parameters for customizing SMS message. If not provided, the default sms message will be used.
  final v1SmsCustomizationParams? smsCustomization;
  /// Optional client-generated user identifier to enable per-user rate limiting for SMS auth. We recommend using a hash of the client-side IP address.
  final String? userIdentifier;
  /// Optional custom email address from which to send the OTP email
  final String? sendFromEmailAddress;
  /// Optional custom sender name for use with sendFromEmailAddress; if left empty, will default to 'Notifications'
  final String? sendFromEmailSenderName;
  /// Optional custom email address to use as reply-to
  final String? replyToEmailAddress;

  const v1InitOtpAuthIntent({
    required  this.otpType,
    required  this.contact,
     this.emailCustomization,
     this.smsCustomization,
     this.userIdentifier,
     this.sendFromEmailAddress,
     this.sendFromEmailSenderName,
     this.replyToEmailAddress,
  });

  factory v1InitOtpAuthIntent.fromJson(Map<String, dynamic> json) {
    final _otpType = json['otpType'] as String;
    final _contact = json['contact'] as String;
    final _emailCustomization = json['emailCustomization'] == null ? null : v1EmailCustomizationParams.fromJson(json['emailCustomization'] as Map<String, dynamic>);
    final _smsCustomization = json['smsCustomization'] == null ? null : v1SmsCustomizationParams.fromJson(json['smsCustomization'] as Map<String, dynamic>);
    final _userIdentifier = json['userIdentifier'] as String?;
    final _sendFromEmailAddress = json['sendFromEmailAddress'] as String?;
    final _sendFromEmailSenderName = json['sendFromEmailSenderName'] as String?;
    final _replyToEmailAddress = json['replyToEmailAddress'] as String?;
    return v1InitOtpAuthIntent(
      otpType: _otpType,
      contact: _contact,
      emailCustomization: _emailCustomization,
      smsCustomization: _smsCustomization,
      userIdentifier: _userIdentifier,
      sendFromEmailAddress: _sendFromEmailAddress,
      sendFromEmailSenderName: _sendFromEmailSenderName,
      replyToEmailAddress: _replyToEmailAddress,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['otpType'] = otpType;
    _json['contact'] = contact;
    if (emailCustomization != null) {
      _json['emailCustomization'] = emailCustomization?.toJson();
    }
    if (smsCustomization != null) {
      _json['smsCustomization'] = smsCustomization?.toJson();
    }
    if (userIdentifier != null) {
      _json['userIdentifier'] = userIdentifier;
    }
    if (sendFromEmailAddress != null) {
      _json['sendFromEmailAddress'] = sendFromEmailAddress;
    }
    if (sendFromEmailSenderName != null) {
      _json['sendFromEmailSenderName'] = sendFromEmailSenderName;
    }
    if (replyToEmailAddress != null) {
      _json['replyToEmailAddress'] = replyToEmailAddress;
    }
    return _json;
  }
}

class v1InitOtpAuthIntentV2 {
  /// Enum to specifiy whether to send OTP via SMS or email
  final String otpType;
  /// Email or phone number to send the OTP code to
  final String contact;
  /// Optional length of the OTP code. Default = 9
  final num? otpLength;
  /// Optional parameters for customizing emails. If not provided, the default email will be used.
  final v1EmailCustomizationParams? emailCustomization;
  /// Optional parameters for customizing SMS message. If not provided, the default SMS message will be used.
  final v1SmsCustomizationParams? smsCustomization;
  /// Optional client-generated user identifier to enable per-user rate limiting for SMS auth. We recommend using a hash of the client-side IP address.
  final String? userIdentifier;
  /// Optional custom email address from which to send the OTP email
  final String? sendFromEmailAddress;
  /// Optional flag to specify if the OTP code should be alphanumeric (Crockfords Base32). Default = true
  final bool? alphanumeric;
  /// Optional custom sender name for use with sendFromEmailAddress; if left empty, will default to 'Notifications'
  final String? sendFromEmailSenderName;
  /// Optional custom email address to use as reply-to
  final String? replyToEmailAddress;

  const v1InitOtpAuthIntentV2({
    required  this.otpType,
    required  this.contact,
     this.otpLength,
     this.emailCustomization,
     this.smsCustomization,
     this.userIdentifier,
     this.sendFromEmailAddress,
     this.alphanumeric,
     this.sendFromEmailSenderName,
     this.replyToEmailAddress,
  });

  factory v1InitOtpAuthIntentV2.fromJson(Map<String, dynamic> json) {
    final _otpType = json['otpType'] as String;
    final _contact = json['contact'] as String;
    final _otpLength = json['otpLength'] as num?;
    final _emailCustomization = json['emailCustomization'] == null ? null : v1EmailCustomizationParams.fromJson(json['emailCustomization'] as Map<String, dynamic>);
    final _smsCustomization = json['smsCustomization'] == null ? null : v1SmsCustomizationParams.fromJson(json['smsCustomization'] as Map<String, dynamic>);
    final _userIdentifier = json['userIdentifier'] as String?;
    final _sendFromEmailAddress = json['sendFromEmailAddress'] as String?;
    final _alphanumeric = json['alphanumeric'] as bool?;
    final _sendFromEmailSenderName = json['sendFromEmailSenderName'] as String?;
    final _replyToEmailAddress = json['replyToEmailAddress'] as String?;
    return v1InitOtpAuthIntentV2(
      otpType: _otpType,
      contact: _contact,
      otpLength: _otpLength,
      emailCustomization: _emailCustomization,
      smsCustomization: _smsCustomization,
      userIdentifier: _userIdentifier,
      sendFromEmailAddress: _sendFromEmailAddress,
      alphanumeric: _alphanumeric,
      sendFromEmailSenderName: _sendFromEmailSenderName,
      replyToEmailAddress: _replyToEmailAddress,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['otpType'] = otpType;
    _json['contact'] = contact;
    if (otpLength != null) {
      _json['otpLength'] = otpLength;
    }
    if (emailCustomization != null) {
      _json['emailCustomization'] = emailCustomization?.toJson();
    }
    if (smsCustomization != null) {
      _json['smsCustomization'] = smsCustomization?.toJson();
    }
    if (userIdentifier != null) {
      _json['userIdentifier'] = userIdentifier;
    }
    if (sendFromEmailAddress != null) {
      _json['sendFromEmailAddress'] = sendFromEmailAddress;
    }
    if (alphanumeric != null) {
      _json['alphanumeric'] = alphanumeric;
    }
    if (sendFromEmailSenderName != null) {
      _json['sendFromEmailSenderName'] = sendFromEmailSenderName;
    }
    if (replyToEmailAddress != null) {
      _json['replyToEmailAddress'] = replyToEmailAddress;
    }
    return _json;
  }
}

class v1InitOtpAuthIntentV3 {
  /// Whether to send OTP via SMS or email. Possible values: OTP_TYPE_SMS, OTP_TYPE_EMAIL
  final String otpType;
  /// Email or phone number to send the OTP code to
  final String contact;
  /// Optional length of the OTP code. Default = 9
  final num? otpLength;
  /// The name of the application. This field is required and will be used in email notifications if an email template is not provided.
  final String appName;
  /// Optional parameters for customizing emails. If not provided, the default email will be used.
  final v1EmailCustomizationParamsV2? emailCustomization;
  /// Optional parameters for customizing SMS message. If not provided, the default SMS message will be used.
  final v1SmsCustomizationParams? smsCustomization;
  /// Optional client-generated user identifier to enable per-user rate limiting for SMS auth. We recommend using a hash of the client-side IP address.
  final String? userIdentifier;
  /// Optional custom email address from which to send the OTP email
  final String? sendFromEmailAddress;
  /// Optional flag to specify if the OTP code should be alphanumeric (Crockfords Base32). Default = true
  final bool? alphanumeric;
  /// Optional custom sender name for use with sendFromEmailAddress; if left empty, will default to 'Notifications'
  final String? sendFromEmailSenderName;
  /// Expiration window (in seconds) indicating how long the OTP is valid for. If not provided, a default of 5 minutes will be used. Maximum value is 600 seconds (10 minutes)
  final String? expirationSeconds;
  /// Optional custom email address to use as reply-to
  final String? replyToEmailAddress;

  const v1InitOtpAuthIntentV3({
    required  this.otpType,
    required  this.contact,
     this.otpLength,
    required  this.appName,
     this.emailCustomization,
     this.smsCustomization,
     this.userIdentifier,
     this.sendFromEmailAddress,
     this.alphanumeric,
     this.sendFromEmailSenderName,
     this.expirationSeconds,
     this.replyToEmailAddress,
  });

  factory v1InitOtpAuthIntentV3.fromJson(Map<String, dynamic> json) {
    final _otpType = json['otpType'] as String;
    final _contact = json['contact'] as String;
    final _otpLength = json['otpLength'] as num?;
    final _appName = json['appName'] as String;
    final _emailCustomization = json['emailCustomization'] == null ? null : v1EmailCustomizationParamsV2.fromJson(json['emailCustomization'] as Map<String, dynamic>);
    final _smsCustomization = json['smsCustomization'] == null ? null : v1SmsCustomizationParams.fromJson(json['smsCustomization'] as Map<String, dynamic>);
    final _userIdentifier = json['userIdentifier'] as String?;
    final _sendFromEmailAddress = json['sendFromEmailAddress'] as String?;
    final _alphanumeric = json['alphanumeric'] as bool?;
    final _sendFromEmailSenderName = json['sendFromEmailSenderName'] as String?;
    final _expirationSeconds = json['expirationSeconds'] as String?;
    final _replyToEmailAddress = json['replyToEmailAddress'] as String?;
    return v1InitOtpAuthIntentV3(
      otpType: _otpType,
      contact: _contact,
      otpLength: _otpLength,
      appName: _appName,
      emailCustomization: _emailCustomization,
      smsCustomization: _smsCustomization,
      userIdentifier: _userIdentifier,
      sendFromEmailAddress: _sendFromEmailAddress,
      alphanumeric: _alphanumeric,
      sendFromEmailSenderName: _sendFromEmailSenderName,
      expirationSeconds: _expirationSeconds,
      replyToEmailAddress: _replyToEmailAddress,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['otpType'] = otpType;
    _json['contact'] = contact;
    if (otpLength != null) {
      _json['otpLength'] = otpLength;
    }
    _json['appName'] = appName;
    if (emailCustomization != null) {
      _json['emailCustomization'] = emailCustomization?.toJson();
    }
    if (smsCustomization != null) {
      _json['smsCustomization'] = smsCustomization?.toJson();
    }
    if (userIdentifier != null) {
      _json['userIdentifier'] = userIdentifier;
    }
    if (sendFromEmailAddress != null) {
      _json['sendFromEmailAddress'] = sendFromEmailAddress;
    }
    if (alphanumeric != null) {
      _json['alphanumeric'] = alphanumeric;
    }
    if (sendFromEmailSenderName != null) {
      _json['sendFromEmailSenderName'] = sendFromEmailSenderName;
    }
    if (expirationSeconds != null) {
      _json['expirationSeconds'] = expirationSeconds;
    }
    if (replyToEmailAddress != null) {
      _json['replyToEmailAddress'] = replyToEmailAddress;
    }
    return _json;
  }
}

class v1InitOtpAuthRequest {
  final String type;
  /// Timestamp (in milliseconds) of the request, used to verify liveness of user requests.
  final String timestampMs;
  /// Unique identifier for a given Organization.
  final String organizationId;
  final v1InitOtpAuthIntentV3 parameters;
  final bool? generateAppProofs;

  const v1InitOtpAuthRequest({
    required  this.type,
    required  this.timestampMs,
    required  this.organizationId,
    required  this.parameters,
     this.generateAppProofs,
  });

  factory v1InitOtpAuthRequest.fromJson(Map<String, dynamic> json) {
    final _type = json['type'] as String;
    final _timestampMs = json['timestampMs'] as String;
    final _organizationId = json['organizationId'] as String;
    final _parameters = v1InitOtpAuthIntentV3.fromJson(json['parameters'] as Map<String, dynamic>);
    final _generateAppProofs = json['generateAppProofs'] as bool?;
    return v1InitOtpAuthRequest(
      type: _type,
      timestampMs: _timestampMs,
      organizationId: _organizationId,
      parameters: _parameters,
      generateAppProofs: _generateAppProofs,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['type'] = type;
    _json['timestampMs'] = timestampMs;
    _json['organizationId'] = organizationId;
    _json['parameters'] = parameters.toJson();
    if (generateAppProofs != null) {
      _json['generateAppProofs'] = generateAppProofs;
    }
    return _json;
  }
}

class v1InitOtpAuthResult {
  /// Unique identifier for an OTP authentication
  final String otpId;

  const v1InitOtpAuthResult({
    required  this.otpId,
  });

  factory v1InitOtpAuthResult.fromJson(Map<String, dynamic> json) {
    final _otpId = json['otpId'] as String;
    return v1InitOtpAuthResult(
      otpId: _otpId,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['otpId'] = otpId;
    return _json;
  }
}

class v1InitOtpAuthResultV2 {
  /// Unique identifier for an OTP authentication
  final String otpId;

  const v1InitOtpAuthResultV2({
    required  this.otpId,
  });

  factory v1InitOtpAuthResultV2.fromJson(Map<String, dynamic> json) {
    final _otpId = json['otpId'] as String;
    return v1InitOtpAuthResultV2(
      otpId: _otpId,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['otpId'] = otpId;
    return _json;
  }
}

class v1InitOtpIntent {
  /// Whether to send OTP via SMS or email. Possible values: OTP_TYPE_SMS, OTP_TYPE_EMAIL
  final String otpType;
  /// Email or phone number to send the OTP code to
  final String contact;
  /// Optional length of the OTP code. Default = 9
  final num? otpLength;
  /// Optional parameters for customizing emails. If not provided, the default email will be used.
  final v1EmailCustomizationParams? emailCustomization;
  /// Optional parameters for customizing SMS message. If not provided, the default sms message will be used.
  final v1SmsCustomizationParams? smsCustomization;
  /// Optional client-generated user identifier to enable per-user rate limiting for SMS auth. We recommend using a hash of the client-side IP address.
  final String? userIdentifier;
  /// Optional custom email address from which to send the OTP email
  final String? sendFromEmailAddress;
  /// Optional flag to specify if the OTP code should be alphanumeric (Crockfords Base32). Default = true
  final bool? alphanumeric;
  /// Optional custom sender name for use with sendFromEmailAddress; if left empty, will default to 'Notifications'
  final String? sendFromEmailSenderName;
  /// Expiration window (in seconds) indicating how long the OTP is valid for. If not provided, a default of 5 minutes will be used. Maximum value is 600 seconds (10 minutes)
  final String? expirationSeconds;
  /// Optional custom email address to use as reply-to
  final String? replyToEmailAddress;

  const v1InitOtpIntent({
    required  this.otpType,
    required  this.contact,
     this.otpLength,
     this.emailCustomization,
     this.smsCustomization,
     this.userIdentifier,
     this.sendFromEmailAddress,
     this.alphanumeric,
     this.sendFromEmailSenderName,
     this.expirationSeconds,
     this.replyToEmailAddress,
  });

  factory v1InitOtpIntent.fromJson(Map<String, dynamic> json) {
    final _otpType = json['otpType'] as String;
    final _contact = json['contact'] as String;
    final _otpLength = json['otpLength'] as num?;
    final _emailCustomization = json['emailCustomization'] == null ? null : v1EmailCustomizationParams.fromJson(json['emailCustomization'] as Map<String, dynamic>);
    final _smsCustomization = json['smsCustomization'] == null ? null : v1SmsCustomizationParams.fromJson(json['smsCustomization'] as Map<String, dynamic>);
    final _userIdentifier = json['userIdentifier'] as String?;
    final _sendFromEmailAddress = json['sendFromEmailAddress'] as String?;
    final _alphanumeric = json['alphanumeric'] as bool?;
    final _sendFromEmailSenderName = json['sendFromEmailSenderName'] as String?;
    final _expirationSeconds = json['expirationSeconds'] as String?;
    final _replyToEmailAddress = json['replyToEmailAddress'] as String?;
    return v1InitOtpIntent(
      otpType: _otpType,
      contact: _contact,
      otpLength: _otpLength,
      emailCustomization: _emailCustomization,
      smsCustomization: _smsCustomization,
      userIdentifier: _userIdentifier,
      sendFromEmailAddress: _sendFromEmailAddress,
      alphanumeric: _alphanumeric,
      sendFromEmailSenderName: _sendFromEmailSenderName,
      expirationSeconds: _expirationSeconds,
      replyToEmailAddress: _replyToEmailAddress,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['otpType'] = otpType;
    _json['contact'] = contact;
    if (otpLength != null) {
      _json['otpLength'] = otpLength;
    }
    if (emailCustomization != null) {
      _json['emailCustomization'] = emailCustomization?.toJson();
    }
    if (smsCustomization != null) {
      _json['smsCustomization'] = smsCustomization?.toJson();
    }
    if (userIdentifier != null) {
      _json['userIdentifier'] = userIdentifier;
    }
    if (sendFromEmailAddress != null) {
      _json['sendFromEmailAddress'] = sendFromEmailAddress;
    }
    if (alphanumeric != null) {
      _json['alphanumeric'] = alphanumeric;
    }
    if (sendFromEmailSenderName != null) {
      _json['sendFromEmailSenderName'] = sendFromEmailSenderName;
    }
    if (expirationSeconds != null) {
      _json['expirationSeconds'] = expirationSeconds;
    }
    if (replyToEmailAddress != null) {
      _json['replyToEmailAddress'] = replyToEmailAddress;
    }
    return _json;
  }
}

class v1InitOtpIntentV2 {
  /// Whether to send OTP via SMS or email. Possible values: OTP_TYPE_SMS, OTP_TYPE_EMAIL
  final String otpType;
  /// Email or phone number to send the OTP code to
  final String contact;
  /// Optional length of the OTP code. Default = 9
  final num? otpLength;
  /// The name of the application. This field is required and will be used in email notifications if an email template is not provided.
  final String appName;
  /// Optional parameters for customizing emails. If not provided, the default email will be used.
  final v1EmailCustomizationParamsV2? emailCustomization;
  /// Optional parameters for customizing SMS message. If not provided, the default SMS message will be used.
  final v1SmsCustomizationParams? smsCustomization;
  /// Optional client-generated user identifier to enable per-user rate limiting for SMS auth. We recommend using a hash of the client-side IP address.
  final String? userIdentifier;
  /// Optional custom email address from which to send the OTP email
  final String? sendFromEmailAddress;
  /// Optional flag to specify if the OTP code should be alphanumeric (Crockfords Base32). Default = true
  final bool? alphanumeric;
  /// Optional custom sender name for use with sendFromEmailAddress; if left empty, will default to 'Notifications'
  final String? sendFromEmailSenderName;
  /// Expiration window (in seconds) indicating how long the OTP is valid for. If not provided, a default of 5 minutes will be used. Maximum value is 600 seconds (10 minutes)
  final String? expirationSeconds;
  /// Optional custom email address to use as reply-to
  final String? replyToEmailAddress;

  const v1InitOtpIntentV2({
    required  this.otpType,
    required  this.contact,
     this.otpLength,
    required  this.appName,
     this.emailCustomization,
     this.smsCustomization,
     this.userIdentifier,
     this.sendFromEmailAddress,
     this.alphanumeric,
     this.sendFromEmailSenderName,
     this.expirationSeconds,
     this.replyToEmailAddress,
  });

  factory v1InitOtpIntentV2.fromJson(Map<String, dynamic> json) {
    final _otpType = json['otpType'] as String;
    final _contact = json['contact'] as String;
    final _otpLength = json['otpLength'] as num?;
    final _appName = json['appName'] as String;
    final _emailCustomization = json['emailCustomization'] == null ? null : v1EmailCustomizationParamsV2.fromJson(json['emailCustomization'] as Map<String, dynamic>);
    final _smsCustomization = json['smsCustomization'] == null ? null : v1SmsCustomizationParams.fromJson(json['smsCustomization'] as Map<String, dynamic>);
    final _userIdentifier = json['userIdentifier'] as String?;
    final _sendFromEmailAddress = json['sendFromEmailAddress'] as String?;
    final _alphanumeric = json['alphanumeric'] as bool?;
    final _sendFromEmailSenderName = json['sendFromEmailSenderName'] as String?;
    final _expirationSeconds = json['expirationSeconds'] as String?;
    final _replyToEmailAddress = json['replyToEmailAddress'] as String?;
    return v1InitOtpIntentV2(
      otpType: _otpType,
      contact: _contact,
      otpLength: _otpLength,
      appName: _appName,
      emailCustomization: _emailCustomization,
      smsCustomization: _smsCustomization,
      userIdentifier: _userIdentifier,
      sendFromEmailAddress: _sendFromEmailAddress,
      alphanumeric: _alphanumeric,
      sendFromEmailSenderName: _sendFromEmailSenderName,
      expirationSeconds: _expirationSeconds,
      replyToEmailAddress: _replyToEmailAddress,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['otpType'] = otpType;
    _json['contact'] = contact;
    if (otpLength != null) {
      _json['otpLength'] = otpLength;
    }
    _json['appName'] = appName;
    if (emailCustomization != null) {
      _json['emailCustomization'] = emailCustomization?.toJson();
    }
    if (smsCustomization != null) {
      _json['smsCustomization'] = smsCustomization?.toJson();
    }
    if (userIdentifier != null) {
      _json['userIdentifier'] = userIdentifier;
    }
    if (sendFromEmailAddress != null) {
      _json['sendFromEmailAddress'] = sendFromEmailAddress;
    }
    if (alphanumeric != null) {
      _json['alphanumeric'] = alphanumeric;
    }
    if (sendFromEmailSenderName != null) {
      _json['sendFromEmailSenderName'] = sendFromEmailSenderName;
    }
    if (expirationSeconds != null) {
      _json['expirationSeconds'] = expirationSeconds;
    }
    if (replyToEmailAddress != null) {
      _json['replyToEmailAddress'] = replyToEmailAddress;
    }
    return _json;
  }
}

class v1InitOtpRequest {
  final String type;
  /// Timestamp (in milliseconds) of the request, used to verify liveness of user requests.
  final String timestampMs;
  /// Unique identifier for a given Organization.
  final String organizationId;
  final v1InitOtpIntentV2 parameters;
  final bool? generateAppProofs;

  const v1InitOtpRequest({
    required  this.type,
    required  this.timestampMs,
    required  this.organizationId,
    required  this.parameters,
     this.generateAppProofs,
  });

  factory v1InitOtpRequest.fromJson(Map<String, dynamic> json) {
    final _type = json['type'] as String;
    final _timestampMs = json['timestampMs'] as String;
    final _organizationId = json['organizationId'] as String;
    final _parameters = v1InitOtpIntentV2.fromJson(json['parameters'] as Map<String, dynamic>);
    final _generateAppProofs = json['generateAppProofs'] as bool?;
    return v1InitOtpRequest(
      type: _type,
      timestampMs: _timestampMs,
      organizationId: _organizationId,
      parameters: _parameters,
      generateAppProofs: _generateAppProofs,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['type'] = type;
    _json['timestampMs'] = timestampMs;
    _json['organizationId'] = organizationId;
    _json['parameters'] = parameters.toJson();
    if (generateAppProofs != null) {
      _json['generateAppProofs'] = generateAppProofs;
    }
    return _json;
  }
}

class v1InitOtpResult {
  /// Unique identifier for an OTP authentication
  final String otpId;

  const v1InitOtpResult({
    required  this.otpId,
  });

  factory v1InitOtpResult.fromJson(Map<String, dynamic> json) {
    final _otpId = json['otpId'] as String;
    return v1InitOtpResult(
      otpId: _otpId,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['otpId'] = otpId;
    return _json;
  }
}

class v1InitUserEmailRecoveryIntent {
  /// Email of the user starting recovery
  final String email;
  /// Client-side public key generated by the user, to which the recovery bundle will be encrypted.
  final String targetPublicKey;
  /// Expiration window (in seconds) indicating how long the recovery credential is valid for. If not provided, a default of 15 minutes will be used.
  final String? expirationSeconds;
  /// Optional parameters for customizing emails. If not provided, the default email will be used.
  final v1EmailCustomizationParams? emailCustomization;
  /// Optional custom email address from which to send the OTP email
  final String? sendFromEmailAddress;
  /// Optional custom sender name for use with sendFromEmailAddress; if left empty, will default to 'Notifications'
  final String? sendFromEmailSenderName;
  /// Optional custom email address to use as reply-to
  final String? replyToEmailAddress;

  const v1InitUserEmailRecoveryIntent({
    required  this.email,
    required  this.targetPublicKey,
     this.expirationSeconds,
     this.emailCustomization,
     this.sendFromEmailAddress,
     this.sendFromEmailSenderName,
     this.replyToEmailAddress,
  });

  factory v1InitUserEmailRecoveryIntent.fromJson(Map<String, dynamic> json) {
    final _email = json['email'] as String;
    final _targetPublicKey = json['targetPublicKey'] as String;
    final _expirationSeconds = json['expirationSeconds'] as String?;
    final _emailCustomization = json['emailCustomization'] == null ? null : v1EmailCustomizationParams.fromJson(json['emailCustomization'] as Map<String, dynamic>);
    final _sendFromEmailAddress = json['sendFromEmailAddress'] as String?;
    final _sendFromEmailSenderName = json['sendFromEmailSenderName'] as String?;
    final _replyToEmailAddress = json['replyToEmailAddress'] as String?;
    return v1InitUserEmailRecoveryIntent(
      email: _email,
      targetPublicKey: _targetPublicKey,
      expirationSeconds: _expirationSeconds,
      emailCustomization: _emailCustomization,
      sendFromEmailAddress: _sendFromEmailAddress,
      sendFromEmailSenderName: _sendFromEmailSenderName,
      replyToEmailAddress: _replyToEmailAddress,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['email'] = email;
    _json['targetPublicKey'] = targetPublicKey;
    if (expirationSeconds != null) {
      _json['expirationSeconds'] = expirationSeconds;
    }
    if (emailCustomization != null) {
      _json['emailCustomization'] = emailCustomization?.toJson();
    }
    if (sendFromEmailAddress != null) {
      _json['sendFromEmailAddress'] = sendFromEmailAddress;
    }
    if (sendFromEmailSenderName != null) {
      _json['sendFromEmailSenderName'] = sendFromEmailSenderName;
    }
    if (replyToEmailAddress != null) {
      _json['replyToEmailAddress'] = replyToEmailAddress;
    }
    return _json;
  }
}

class v1InitUserEmailRecoveryIntentV2 {
  /// Email of the user starting recovery
  final String email;
  /// Client-side public key generated by the user, to which the recovery bundle will be encrypted.
  final String targetPublicKey;
  /// Expiration window (in seconds) indicating how long the recovery credential is valid for. If not provided, a default of 15 minutes will be used.
  final String? expirationSeconds;
  /// Parameters for customizing emails. If not provided, the default email will be used. Note that `app_name` is required.
  final v1EmailAuthCustomizationParams emailCustomization;
  /// Optional custom email address from which to send the OTP email
  final String? sendFromEmailAddress;
  /// Optional custom sender name for use with sendFromEmailAddress; if left empty, will default to 'Notifications'
  final String? sendFromEmailSenderName;
  /// Optional custom email address to use as reply-to
  final String? replyToEmailAddress;

  const v1InitUserEmailRecoveryIntentV2({
    required  this.email,
    required  this.targetPublicKey,
     this.expirationSeconds,
    required  this.emailCustomization,
     this.sendFromEmailAddress,
     this.sendFromEmailSenderName,
     this.replyToEmailAddress,
  });

  factory v1InitUserEmailRecoveryIntentV2.fromJson(Map<String, dynamic> json) {
    final _email = json['email'] as String;
    final _targetPublicKey = json['targetPublicKey'] as String;
    final _expirationSeconds = json['expirationSeconds'] as String?;
    final _emailCustomization = v1EmailAuthCustomizationParams.fromJson(json['emailCustomization'] as Map<String, dynamic>);
    final _sendFromEmailAddress = json['sendFromEmailAddress'] as String?;
    final _sendFromEmailSenderName = json['sendFromEmailSenderName'] as String?;
    final _replyToEmailAddress = json['replyToEmailAddress'] as String?;
    return v1InitUserEmailRecoveryIntentV2(
      email: _email,
      targetPublicKey: _targetPublicKey,
      expirationSeconds: _expirationSeconds,
      emailCustomization: _emailCustomization,
      sendFromEmailAddress: _sendFromEmailAddress,
      sendFromEmailSenderName: _sendFromEmailSenderName,
      replyToEmailAddress: _replyToEmailAddress,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['email'] = email;
    _json['targetPublicKey'] = targetPublicKey;
    if (expirationSeconds != null) {
      _json['expirationSeconds'] = expirationSeconds;
    }
    _json['emailCustomization'] = emailCustomization.toJson();
    if (sendFromEmailAddress != null) {
      _json['sendFromEmailAddress'] = sendFromEmailAddress;
    }
    if (sendFromEmailSenderName != null) {
      _json['sendFromEmailSenderName'] = sendFromEmailSenderName;
    }
    if (replyToEmailAddress != null) {
      _json['replyToEmailAddress'] = replyToEmailAddress;
    }
    return _json;
  }
}

class v1InitUserEmailRecoveryRequest {
  final String type;
  /// Timestamp (in milliseconds) of the request, used to verify liveness of user requests.
  final String timestampMs;
  /// Unique identifier for a given Organization.
  final String organizationId;
  final v1InitUserEmailRecoveryIntentV2 parameters;
  final bool? generateAppProofs;

  const v1InitUserEmailRecoveryRequest({
    required  this.type,
    required  this.timestampMs,
    required  this.organizationId,
    required  this.parameters,
     this.generateAppProofs,
  });

  factory v1InitUserEmailRecoveryRequest.fromJson(Map<String, dynamic> json) {
    final _type = json['type'] as String;
    final _timestampMs = json['timestampMs'] as String;
    final _organizationId = json['organizationId'] as String;
    final _parameters = v1InitUserEmailRecoveryIntentV2.fromJson(json['parameters'] as Map<String, dynamic>);
    final _generateAppProofs = json['generateAppProofs'] as bool?;
    return v1InitUserEmailRecoveryRequest(
      type: _type,
      timestampMs: _timestampMs,
      organizationId: _organizationId,
      parameters: _parameters,
      generateAppProofs: _generateAppProofs,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['type'] = type;
    _json['timestampMs'] = timestampMs;
    _json['organizationId'] = organizationId;
    _json['parameters'] = parameters.toJson();
    if (generateAppProofs != null) {
      _json['generateAppProofs'] = generateAppProofs;
    }
    return _json;
  }
}

class v1InitUserEmailRecoveryResult {
  /// Unique identifier for the user being recovered.
  final String userId;

  const v1InitUserEmailRecoveryResult({
    required  this.userId,
  });

  factory v1InitUserEmailRecoveryResult.fromJson(Map<String, dynamic> json) {
    final _userId = json['userId'] as String;
    return v1InitUserEmailRecoveryResult(
      userId: _userId,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['userId'] = userId;
    return _json;
  }
}

class v1Intent {
  final v1CreateOrganizationIntent? createOrganizationIntent;
  final v1CreateAuthenticatorsIntent? createAuthenticatorsIntent;
  final v1CreateUsersIntent? createUsersIntent;
  final v1CreatePrivateKeysIntent? createPrivateKeysIntent;
  final v1SignRawPayloadIntent? signRawPayloadIntent;
  final v1CreateInvitationsIntent? createInvitationsIntent;
  final v1AcceptInvitationIntent? acceptInvitationIntent;
  final v1CreatePolicyIntent? createPolicyIntent;
  final v1DisablePrivateKeyIntent? disablePrivateKeyIntent;
  final v1DeleteUsersIntent? deleteUsersIntent;
  final v1DeleteAuthenticatorsIntent? deleteAuthenticatorsIntent;
  final v1DeleteInvitationIntent? deleteInvitationIntent;
  final v1DeleteOrganizationIntent? deleteOrganizationIntent;
  final v1DeletePolicyIntent? deletePolicyIntent;
  final v1CreateUserTagIntent? createUserTagIntent;
  final v1DeleteUserTagsIntent? deleteUserTagsIntent;
  final v1SignTransactionIntent? signTransactionIntent;
  final v1CreateApiKeysIntent? createApiKeysIntent;
  final v1DeleteApiKeysIntent? deleteApiKeysIntent;
  final v1ApproveActivityIntent? approveActivityIntent;
  final v1RejectActivityIntent? rejectActivityIntent;
  final v1CreatePrivateKeyTagIntent? createPrivateKeyTagIntent;
  final v1DeletePrivateKeyTagsIntent? deletePrivateKeyTagsIntent;
  final v1CreatePolicyIntentV2? createPolicyIntentV2;
  final billingSetPaymentMethodIntent? setPaymentMethodIntent;
  final billingActivateBillingTierIntent? activateBillingTierIntent;
  final billingDeletePaymentMethodIntent? deletePaymentMethodIntent;
  final v1CreatePolicyIntentV3? createPolicyIntentV3;
  final v1CreateApiOnlyUsersIntent? createApiOnlyUsersIntent;
  final v1UpdateRootQuorumIntent? updateRootQuorumIntent;
  final v1UpdateUserTagIntent? updateUserTagIntent;
  final v1UpdatePrivateKeyTagIntent? updatePrivateKeyTagIntent;
  final v1CreateAuthenticatorsIntentV2? createAuthenticatorsIntentV2;
  final v1AcceptInvitationIntentV2? acceptInvitationIntentV2;
  final v1CreateOrganizationIntentV2? createOrganizationIntentV2;
  final v1CreateUsersIntentV2? createUsersIntentV2;
  final v1CreateSubOrganizationIntent? createSubOrganizationIntent;
  final v1CreateSubOrganizationIntentV2? createSubOrganizationIntentV2;
  final v1UpdateAllowedOriginsIntent? updateAllowedOriginsIntent;
  final v1CreatePrivateKeysIntentV2? createPrivateKeysIntentV2;
  final v1UpdateUserIntent? updateUserIntent;
  final v1UpdatePolicyIntent? updatePolicyIntent;
  final billingSetPaymentMethodIntentV2? setPaymentMethodIntentV2;
  final v1CreateSubOrganizationIntentV3? createSubOrganizationIntentV3;
  final v1CreateWalletIntent? createWalletIntent;
  final v1CreateWalletAccountsIntent? createWalletAccountsIntent;
  final v1InitUserEmailRecoveryIntent? initUserEmailRecoveryIntent;
  final v1RecoverUserIntent? recoverUserIntent;
  final v1SetOrganizationFeatureIntent? setOrganizationFeatureIntent;
  final v1RemoveOrganizationFeatureIntent? removeOrganizationFeatureIntent;
  final v1SignRawPayloadIntentV2? signRawPayloadIntentV2;
  final v1SignTransactionIntentV2? signTransactionIntentV2;
  final v1ExportPrivateKeyIntent? exportPrivateKeyIntent;
  final v1ExportWalletIntent? exportWalletIntent;
  final v1CreateSubOrganizationIntentV4? createSubOrganizationIntentV4;
  final v1EmailAuthIntent? emailAuthIntent;
  final v1ExportWalletAccountIntent? exportWalletAccountIntent;
  final v1InitImportWalletIntent? initImportWalletIntent;
  final v1ImportWalletIntent? importWalletIntent;
  final v1InitImportPrivateKeyIntent? initImportPrivateKeyIntent;
  final v1ImportPrivateKeyIntent? importPrivateKeyIntent;
  final v1CreatePoliciesIntent? createPoliciesIntent;
  final v1SignRawPayloadsIntent? signRawPayloadsIntent;
  final v1CreateReadOnlySessionIntent? createReadOnlySessionIntent;
  final v1CreateOauthProvidersIntent? createOauthProvidersIntent;
  final v1DeleteOauthProvidersIntent? deleteOauthProvidersIntent;
  final v1CreateSubOrganizationIntentV5? createSubOrganizationIntentV5;
  final v1OauthIntent? oauthIntent;
  final v1CreateApiKeysIntentV2? createApiKeysIntentV2;
  final v1CreateReadWriteSessionIntent? createReadWriteSessionIntent;
  final v1EmailAuthIntentV2? emailAuthIntentV2;
  final v1CreateSubOrganizationIntentV6? createSubOrganizationIntentV6;
  final v1DeletePrivateKeysIntent? deletePrivateKeysIntent;
  final v1DeleteWalletsIntent? deleteWalletsIntent;
  final v1CreateReadWriteSessionIntentV2? createReadWriteSessionIntentV2;
  final v1DeleteSubOrganizationIntent? deleteSubOrganizationIntent;
  final v1InitOtpAuthIntent? initOtpAuthIntent;
  final v1OtpAuthIntent? otpAuthIntent;
  final v1CreateSubOrganizationIntentV7? createSubOrganizationIntentV7;
  final v1UpdateWalletIntent? updateWalletIntent;
  final v1UpdatePolicyIntentV2? updatePolicyIntentV2;
  final v1CreateUsersIntentV3? createUsersIntentV3;
  final v1InitOtpAuthIntentV2? initOtpAuthIntentV2;
  final v1InitOtpIntent? initOtpIntent;
  final v1VerifyOtpIntent? verifyOtpIntent;
  final v1OtpLoginIntent? otpLoginIntent;
  final v1StampLoginIntent? stampLoginIntent;
  final v1OauthLoginIntent? oauthLoginIntent;
  final v1UpdateUserNameIntent? updateUserNameIntent;
  final v1UpdateUserEmailIntent? updateUserEmailIntent;
  final v1UpdateUserPhoneNumberIntent? updateUserPhoneNumberIntent;
  final v1InitFiatOnRampIntent? initFiatOnRampIntent;
  final v1CreateSmartContractInterfaceIntent? createSmartContractInterfaceIntent;
  final v1DeleteSmartContractInterfaceIntent? deleteSmartContractInterfaceIntent;
  final v1EnableAuthProxyIntent? enableAuthProxyIntent;
  final v1DisableAuthProxyIntent? disableAuthProxyIntent;
  final v1UpdateAuthProxyConfigIntent? updateAuthProxyConfigIntent;
  final v1CreateOauth2CredentialIntent? createOauth2CredentialIntent;
  final v1UpdateOauth2CredentialIntent? updateOauth2CredentialIntent;
  final v1DeleteOauth2CredentialIntent? deleteOauth2CredentialIntent;
  final v1Oauth2AuthenticateIntent? oauth2AuthenticateIntent;
  final v1DeleteWalletAccountsIntent? deleteWalletAccountsIntent;
  final v1DeletePoliciesIntent? deletePoliciesIntent;
  final v1EthSendRawTransactionIntent? ethSendRawTransactionIntent;
  final v1EthSendTransactionIntent? ethSendTransactionIntent;
  final v1CreateFiatOnRampCredentialIntent? createFiatOnRampCredentialIntent;
  final v1UpdateFiatOnRampCredentialIntent? updateFiatOnRampCredentialIntent;
  final v1DeleteFiatOnRampCredentialIntent? deleteFiatOnRampCredentialIntent;
  final v1EmailAuthIntentV3? emailAuthIntentV3;
  final v1InitUserEmailRecoveryIntentV2? initUserEmailRecoveryIntentV2;
  final v1InitOtpIntentV2? initOtpIntentV2;
  final v1InitOtpAuthIntentV3? initOtpAuthIntentV3;
  final v1UpsertGasUsageConfigIntent? upsertGasUsageConfigIntent;
  final v1CreateTvcAppIntent? createTvcAppIntent;
  final v1CreateTvcDeploymentIntent? createTvcDeploymentIntent;
  final v1CreateTvcManifestApprovalsIntent? createTvcManifestApprovalsIntent;
  final v1SolSendTransactionIntent? solSendTransactionIntent;

  const v1Intent({
     this.createOrganizationIntent,
     this.createAuthenticatorsIntent,
     this.createUsersIntent,
     this.createPrivateKeysIntent,
     this.signRawPayloadIntent,
     this.createInvitationsIntent,
     this.acceptInvitationIntent,
     this.createPolicyIntent,
     this.disablePrivateKeyIntent,
     this.deleteUsersIntent,
     this.deleteAuthenticatorsIntent,
     this.deleteInvitationIntent,
     this.deleteOrganizationIntent,
     this.deletePolicyIntent,
     this.createUserTagIntent,
     this.deleteUserTagsIntent,
     this.signTransactionIntent,
     this.createApiKeysIntent,
     this.deleteApiKeysIntent,
     this.approveActivityIntent,
     this.rejectActivityIntent,
     this.createPrivateKeyTagIntent,
     this.deletePrivateKeyTagsIntent,
     this.createPolicyIntentV2,
     this.setPaymentMethodIntent,
     this.activateBillingTierIntent,
     this.deletePaymentMethodIntent,
     this.createPolicyIntentV3,
     this.createApiOnlyUsersIntent,
     this.updateRootQuorumIntent,
     this.updateUserTagIntent,
     this.updatePrivateKeyTagIntent,
     this.createAuthenticatorsIntentV2,
     this.acceptInvitationIntentV2,
     this.createOrganizationIntentV2,
     this.createUsersIntentV2,
     this.createSubOrganizationIntent,
     this.createSubOrganizationIntentV2,
     this.updateAllowedOriginsIntent,
     this.createPrivateKeysIntentV2,
     this.updateUserIntent,
     this.updatePolicyIntent,
     this.setPaymentMethodIntentV2,
     this.createSubOrganizationIntentV3,
     this.createWalletIntent,
     this.createWalletAccountsIntent,
     this.initUserEmailRecoveryIntent,
     this.recoverUserIntent,
     this.setOrganizationFeatureIntent,
     this.removeOrganizationFeatureIntent,
     this.signRawPayloadIntentV2,
     this.signTransactionIntentV2,
     this.exportPrivateKeyIntent,
     this.exportWalletIntent,
     this.createSubOrganizationIntentV4,
     this.emailAuthIntent,
     this.exportWalletAccountIntent,
     this.initImportWalletIntent,
     this.importWalletIntent,
     this.initImportPrivateKeyIntent,
     this.importPrivateKeyIntent,
     this.createPoliciesIntent,
     this.signRawPayloadsIntent,
     this.createReadOnlySessionIntent,
     this.createOauthProvidersIntent,
     this.deleteOauthProvidersIntent,
     this.createSubOrganizationIntentV5,
     this.oauthIntent,
     this.createApiKeysIntentV2,
     this.createReadWriteSessionIntent,
     this.emailAuthIntentV2,
     this.createSubOrganizationIntentV6,
     this.deletePrivateKeysIntent,
     this.deleteWalletsIntent,
     this.createReadWriteSessionIntentV2,
     this.deleteSubOrganizationIntent,
     this.initOtpAuthIntent,
     this.otpAuthIntent,
     this.createSubOrganizationIntentV7,
     this.updateWalletIntent,
     this.updatePolicyIntentV2,
     this.createUsersIntentV3,
     this.initOtpAuthIntentV2,
     this.initOtpIntent,
     this.verifyOtpIntent,
     this.otpLoginIntent,
     this.stampLoginIntent,
     this.oauthLoginIntent,
     this.updateUserNameIntent,
     this.updateUserEmailIntent,
     this.updateUserPhoneNumberIntent,
     this.initFiatOnRampIntent,
     this.createSmartContractInterfaceIntent,
     this.deleteSmartContractInterfaceIntent,
     this.enableAuthProxyIntent,
     this.disableAuthProxyIntent,
     this.updateAuthProxyConfigIntent,
     this.createOauth2CredentialIntent,
     this.updateOauth2CredentialIntent,
     this.deleteOauth2CredentialIntent,
     this.oauth2AuthenticateIntent,
     this.deleteWalletAccountsIntent,
     this.deletePoliciesIntent,
     this.ethSendRawTransactionIntent,
     this.ethSendTransactionIntent,
     this.createFiatOnRampCredentialIntent,
     this.updateFiatOnRampCredentialIntent,
     this.deleteFiatOnRampCredentialIntent,
     this.emailAuthIntentV3,
     this.initUserEmailRecoveryIntentV2,
     this.initOtpIntentV2,
     this.initOtpAuthIntentV3,
     this.upsertGasUsageConfigIntent,
     this.createTvcAppIntent,
     this.createTvcDeploymentIntent,
     this.createTvcManifestApprovalsIntent,
     this.solSendTransactionIntent,
  });

  factory v1Intent.fromJson(Map<String, dynamic> json) {
    final _createOrganizationIntent = json['createOrganizationIntent'] == null ? null : v1CreateOrganizationIntent.fromJson(json['createOrganizationIntent'] as Map<String, dynamic>);
    final _createAuthenticatorsIntent = json['createAuthenticatorsIntent'] == null ? null : v1CreateAuthenticatorsIntent.fromJson(json['createAuthenticatorsIntent'] as Map<String, dynamic>);
    final _createUsersIntent = json['createUsersIntent'] == null ? null : v1CreateUsersIntent.fromJson(json['createUsersIntent'] as Map<String, dynamic>);
    final _createPrivateKeysIntent = json['createPrivateKeysIntent'] == null ? null : v1CreatePrivateKeysIntent.fromJson(json['createPrivateKeysIntent'] as Map<String, dynamic>);
    final _signRawPayloadIntent = json['signRawPayloadIntent'] == null ? null : v1SignRawPayloadIntent.fromJson(json['signRawPayloadIntent'] as Map<String, dynamic>);
    final _createInvitationsIntent = json['createInvitationsIntent'] == null ? null : v1CreateInvitationsIntent.fromJson(json['createInvitationsIntent'] as Map<String, dynamic>);
    final _acceptInvitationIntent = json['acceptInvitationIntent'] == null ? null : v1AcceptInvitationIntent.fromJson(json['acceptInvitationIntent'] as Map<String, dynamic>);
    final _createPolicyIntent = json['createPolicyIntent'] == null ? null : v1CreatePolicyIntent.fromJson(json['createPolicyIntent'] as Map<String, dynamic>);
    final _disablePrivateKeyIntent = json['disablePrivateKeyIntent'] == null ? null : v1DisablePrivateKeyIntent.fromJson(json['disablePrivateKeyIntent'] as Map<String, dynamic>);
    final _deleteUsersIntent = json['deleteUsersIntent'] == null ? null : v1DeleteUsersIntent.fromJson(json['deleteUsersIntent'] as Map<String, dynamic>);
    final _deleteAuthenticatorsIntent = json['deleteAuthenticatorsIntent'] == null ? null : v1DeleteAuthenticatorsIntent.fromJson(json['deleteAuthenticatorsIntent'] as Map<String, dynamic>);
    final _deleteInvitationIntent = json['deleteInvitationIntent'] == null ? null : v1DeleteInvitationIntent.fromJson(json['deleteInvitationIntent'] as Map<String, dynamic>);
    final _deleteOrganizationIntent = json['deleteOrganizationIntent'] == null ? null : v1DeleteOrganizationIntent.fromJson(json['deleteOrganizationIntent'] as Map<String, dynamic>);
    final _deletePolicyIntent = json['deletePolicyIntent'] == null ? null : v1DeletePolicyIntent.fromJson(json['deletePolicyIntent'] as Map<String, dynamic>);
    final _createUserTagIntent = json['createUserTagIntent'] == null ? null : v1CreateUserTagIntent.fromJson(json['createUserTagIntent'] as Map<String, dynamic>);
    final _deleteUserTagsIntent = json['deleteUserTagsIntent'] == null ? null : v1DeleteUserTagsIntent.fromJson(json['deleteUserTagsIntent'] as Map<String, dynamic>);
    final _signTransactionIntent = json['signTransactionIntent'] == null ? null : v1SignTransactionIntent.fromJson(json['signTransactionIntent'] as Map<String, dynamic>);
    final _createApiKeysIntent = json['createApiKeysIntent'] == null ? null : v1CreateApiKeysIntent.fromJson(json['createApiKeysIntent'] as Map<String, dynamic>);
    final _deleteApiKeysIntent = json['deleteApiKeysIntent'] == null ? null : v1DeleteApiKeysIntent.fromJson(json['deleteApiKeysIntent'] as Map<String, dynamic>);
    final _approveActivityIntent = json['approveActivityIntent'] == null ? null : v1ApproveActivityIntent.fromJson(json['approveActivityIntent'] as Map<String, dynamic>);
    final _rejectActivityIntent = json['rejectActivityIntent'] == null ? null : v1RejectActivityIntent.fromJson(json['rejectActivityIntent'] as Map<String, dynamic>);
    final _createPrivateKeyTagIntent = json['createPrivateKeyTagIntent'] == null ? null : v1CreatePrivateKeyTagIntent.fromJson(json['createPrivateKeyTagIntent'] as Map<String, dynamic>);
    final _deletePrivateKeyTagsIntent = json['deletePrivateKeyTagsIntent'] == null ? null : v1DeletePrivateKeyTagsIntent.fromJson(json['deletePrivateKeyTagsIntent'] as Map<String, dynamic>);
    final _createPolicyIntentV2 = json['createPolicyIntentV2'] == null ? null : v1CreatePolicyIntentV2.fromJson(json['createPolicyIntentV2'] as Map<String, dynamic>);
    final _setPaymentMethodIntent = json['setPaymentMethodIntent'] == null ? null : billingSetPaymentMethodIntent.fromJson(json['setPaymentMethodIntent'] as Map<String, dynamic>);
    final _activateBillingTierIntent = json['activateBillingTierIntent'] == null ? null : billingActivateBillingTierIntent.fromJson(json['activateBillingTierIntent'] as Map<String, dynamic>);
    final _deletePaymentMethodIntent = json['deletePaymentMethodIntent'] == null ? null : billingDeletePaymentMethodIntent.fromJson(json['deletePaymentMethodIntent'] as Map<String, dynamic>);
    final _createPolicyIntentV3 = json['createPolicyIntentV3'] == null ? null : v1CreatePolicyIntentV3.fromJson(json['createPolicyIntentV3'] as Map<String, dynamic>);
    final _createApiOnlyUsersIntent = json['createApiOnlyUsersIntent'] == null ? null : v1CreateApiOnlyUsersIntent.fromJson(json['createApiOnlyUsersIntent'] as Map<String, dynamic>);
    final _updateRootQuorumIntent = json['updateRootQuorumIntent'] == null ? null : v1UpdateRootQuorumIntent.fromJson(json['updateRootQuorumIntent'] as Map<String, dynamic>);
    final _updateUserTagIntent = json['updateUserTagIntent'] == null ? null : v1UpdateUserTagIntent.fromJson(json['updateUserTagIntent'] as Map<String, dynamic>);
    final _updatePrivateKeyTagIntent = json['updatePrivateKeyTagIntent'] == null ? null : v1UpdatePrivateKeyTagIntent.fromJson(json['updatePrivateKeyTagIntent'] as Map<String, dynamic>);
    final _createAuthenticatorsIntentV2 = json['createAuthenticatorsIntentV2'] == null ? null : v1CreateAuthenticatorsIntentV2.fromJson(json['createAuthenticatorsIntentV2'] as Map<String, dynamic>);
    final _acceptInvitationIntentV2 = json['acceptInvitationIntentV2'] == null ? null : v1AcceptInvitationIntentV2.fromJson(json['acceptInvitationIntentV2'] as Map<String, dynamic>);
    final _createOrganizationIntentV2 = json['createOrganizationIntentV2'] == null ? null : v1CreateOrganizationIntentV2.fromJson(json['createOrganizationIntentV2'] as Map<String, dynamic>);
    final _createUsersIntentV2 = json['createUsersIntentV2'] == null ? null : v1CreateUsersIntentV2.fromJson(json['createUsersIntentV2'] as Map<String, dynamic>);
    final _createSubOrganizationIntent = json['createSubOrganizationIntent'] == null ? null : v1CreateSubOrganizationIntent.fromJson(json['createSubOrganizationIntent'] as Map<String, dynamic>);
    final _createSubOrganizationIntentV2 = json['createSubOrganizationIntentV2'] == null ? null : v1CreateSubOrganizationIntentV2.fromJson(json['createSubOrganizationIntentV2'] as Map<String, dynamic>);
    final _updateAllowedOriginsIntent = json['updateAllowedOriginsIntent'] == null ? null : v1UpdateAllowedOriginsIntent.fromJson(json['updateAllowedOriginsIntent'] as Map<String, dynamic>);
    final _createPrivateKeysIntentV2 = json['createPrivateKeysIntentV2'] == null ? null : v1CreatePrivateKeysIntentV2.fromJson(json['createPrivateKeysIntentV2'] as Map<String, dynamic>);
    final _updateUserIntent = json['updateUserIntent'] == null ? null : v1UpdateUserIntent.fromJson(json['updateUserIntent'] as Map<String, dynamic>);
    final _updatePolicyIntent = json['updatePolicyIntent'] == null ? null : v1UpdatePolicyIntent.fromJson(json['updatePolicyIntent'] as Map<String, dynamic>);
    final _setPaymentMethodIntentV2 = json['setPaymentMethodIntentV2'] == null ? null : billingSetPaymentMethodIntentV2.fromJson(json['setPaymentMethodIntentV2'] as Map<String, dynamic>);
    final _createSubOrganizationIntentV3 = json['createSubOrganizationIntentV3'] == null ? null : v1CreateSubOrganizationIntentV3.fromJson(json['createSubOrganizationIntentV3'] as Map<String, dynamic>);
    final _createWalletIntent = json['createWalletIntent'] == null ? null : v1CreateWalletIntent.fromJson(json['createWalletIntent'] as Map<String, dynamic>);
    final _createWalletAccountsIntent = json['createWalletAccountsIntent'] == null ? null : v1CreateWalletAccountsIntent.fromJson(json['createWalletAccountsIntent'] as Map<String, dynamic>);
    final _initUserEmailRecoveryIntent = json['initUserEmailRecoveryIntent'] == null ? null : v1InitUserEmailRecoveryIntent.fromJson(json['initUserEmailRecoveryIntent'] as Map<String, dynamic>);
    final _recoverUserIntent = json['recoverUserIntent'] == null ? null : v1RecoverUserIntent.fromJson(json['recoverUserIntent'] as Map<String, dynamic>);
    final _setOrganizationFeatureIntent = json['setOrganizationFeatureIntent'] == null ? null : v1SetOrganizationFeatureIntent.fromJson(json['setOrganizationFeatureIntent'] as Map<String, dynamic>);
    final _removeOrganizationFeatureIntent = json['removeOrganizationFeatureIntent'] == null ? null : v1RemoveOrganizationFeatureIntent.fromJson(json['removeOrganizationFeatureIntent'] as Map<String, dynamic>);
    final _signRawPayloadIntentV2 = json['signRawPayloadIntentV2'] == null ? null : v1SignRawPayloadIntentV2.fromJson(json['signRawPayloadIntentV2'] as Map<String, dynamic>);
    final _signTransactionIntentV2 = json['signTransactionIntentV2'] == null ? null : v1SignTransactionIntentV2.fromJson(json['signTransactionIntentV2'] as Map<String, dynamic>);
    final _exportPrivateKeyIntent = json['exportPrivateKeyIntent'] == null ? null : v1ExportPrivateKeyIntent.fromJson(json['exportPrivateKeyIntent'] as Map<String, dynamic>);
    final _exportWalletIntent = json['exportWalletIntent'] == null ? null : v1ExportWalletIntent.fromJson(json['exportWalletIntent'] as Map<String, dynamic>);
    final _createSubOrganizationIntentV4 = json['createSubOrganizationIntentV4'] == null ? null : v1CreateSubOrganizationIntentV4.fromJson(json['createSubOrganizationIntentV4'] as Map<String, dynamic>);
    final _emailAuthIntent = json['emailAuthIntent'] == null ? null : v1EmailAuthIntent.fromJson(json['emailAuthIntent'] as Map<String, dynamic>);
    final _exportWalletAccountIntent = json['exportWalletAccountIntent'] == null ? null : v1ExportWalletAccountIntent.fromJson(json['exportWalletAccountIntent'] as Map<String, dynamic>);
    final _initImportWalletIntent = json['initImportWalletIntent'] == null ? null : v1InitImportWalletIntent.fromJson(json['initImportWalletIntent'] as Map<String, dynamic>);
    final _importWalletIntent = json['importWalletIntent'] == null ? null : v1ImportWalletIntent.fromJson(json['importWalletIntent'] as Map<String, dynamic>);
    final _initImportPrivateKeyIntent = json['initImportPrivateKeyIntent'] == null ? null : v1InitImportPrivateKeyIntent.fromJson(json['initImportPrivateKeyIntent'] as Map<String, dynamic>);
    final _importPrivateKeyIntent = json['importPrivateKeyIntent'] == null ? null : v1ImportPrivateKeyIntent.fromJson(json['importPrivateKeyIntent'] as Map<String, dynamic>);
    final _createPoliciesIntent = json['createPoliciesIntent'] == null ? null : v1CreatePoliciesIntent.fromJson(json['createPoliciesIntent'] as Map<String, dynamic>);
    final _signRawPayloadsIntent = json['signRawPayloadsIntent'] == null ? null : v1SignRawPayloadsIntent.fromJson(json['signRawPayloadsIntent'] as Map<String, dynamic>);
    final _createReadOnlySessionIntent = json['createReadOnlySessionIntent'] == null ? null : v1CreateReadOnlySessionIntent.fromJson(json['createReadOnlySessionIntent'] as Map<String, dynamic>);
    final _createOauthProvidersIntent = json['createOauthProvidersIntent'] == null ? null : v1CreateOauthProvidersIntent.fromJson(json['createOauthProvidersIntent'] as Map<String, dynamic>);
    final _deleteOauthProvidersIntent = json['deleteOauthProvidersIntent'] == null ? null : v1DeleteOauthProvidersIntent.fromJson(json['deleteOauthProvidersIntent'] as Map<String, dynamic>);
    final _createSubOrganizationIntentV5 = json['createSubOrganizationIntentV5'] == null ? null : v1CreateSubOrganizationIntentV5.fromJson(json['createSubOrganizationIntentV5'] as Map<String, dynamic>);
    final _oauthIntent = json['oauthIntent'] == null ? null : v1OauthIntent.fromJson(json['oauthIntent'] as Map<String, dynamic>);
    final _createApiKeysIntentV2 = json['createApiKeysIntentV2'] == null ? null : v1CreateApiKeysIntentV2.fromJson(json['createApiKeysIntentV2'] as Map<String, dynamic>);
    final _createReadWriteSessionIntent = json['createReadWriteSessionIntent'] == null ? null : v1CreateReadWriteSessionIntent.fromJson(json['createReadWriteSessionIntent'] as Map<String, dynamic>);
    final _emailAuthIntentV2 = json['emailAuthIntentV2'] == null ? null : v1EmailAuthIntentV2.fromJson(json['emailAuthIntentV2'] as Map<String, dynamic>);
    final _createSubOrganizationIntentV6 = json['createSubOrganizationIntentV6'] == null ? null : v1CreateSubOrganizationIntentV6.fromJson(json['createSubOrganizationIntentV6'] as Map<String, dynamic>);
    final _deletePrivateKeysIntent = json['deletePrivateKeysIntent'] == null ? null : v1DeletePrivateKeysIntent.fromJson(json['deletePrivateKeysIntent'] as Map<String, dynamic>);
    final _deleteWalletsIntent = json['deleteWalletsIntent'] == null ? null : v1DeleteWalletsIntent.fromJson(json['deleteWalletsIntent'] as Map<String, dynamic>);
    final _createReadWriteSessionIntentV2 = json['createReadWriteSessionIntentV2'] == null ? null : v1CreateReadWriteSessionIntentV2.fromJson(json['createReadWriteSessionIntentV2'] as Map<String, dynamic>);
    final _deleteSubOrganizationIntent = json['deleteSubOrganizationIntent'] == null ? null : v1DeleteSubOrganizationIntent.fromJson(json['deleteSubOrganizationIntent'] as Map<String, dynamic>);
    final _initOtpAuthIntent = json['initOtpAuthIntent'] == null ? null : v1InitOtpAuthIntent.fromJson(json['initOtpAuthIntent'] as Map<String, dynamic>);
    final _otpAuthIntent = json['otpAuthIntent'] == null ? null : v1OtpAuthIntent.fromJson(json['otpAuthIntent'] as Map<String, dynamic>);
    final _createSubOrganizationIntentV7 = json['createSubOrganizationIntentV7'] == null ? null : v1CreateSubOrganizationIntentV7.fromJson(json['createSubOrganizationIntentV7'] as Map<String, dynamic>);
    final _updateWalletIntent = json['updateWalletIntent'] == null ? null : v1UpdateWalletIntent.fromJson(json['updateWalletIntent'] as Map<String, dynamic>);
    final _updatePolicyIntentV2 = json['updatePolicyIntentV2'] == null ? null : v1UpdatePolicyIntentV2.fromJson(json['updatePolicyIntentV2'] as Map<String, dynamic>);
    final _createUsersIntentV3 = json['createUsersIntentV3'] == null ? null : v1CreateUsersIntentV3.fromJson(json['createUsersIntentV3'] as Map<String, dynamic>);
    final _initOtpAuthIntentV2 = json['initOtpAuthIntentV2'] == null ? null : v1InitOtpAuthIntentV2.fromJson(json['initOtpAuthIntentV2'] as Map<String, dynamic>);
    final _initOtpIntent = json['initOtpIntent'] == null ? null : v1InitOtpIntent.fromJson(json['initOtpIntent'] as Map<String, dynamic>);
    final _verifyOtpIntent = json['verifyOtpIntent'] == null ? null : v1VerifyOtpIntent.fromJson(json['verifyOtpIntent'] as Map<String, dynamic>);
    final _otpLoginIntent = json['otpLoginIntent'] == null ? null : v1OtpLoginIntent.fromJson(json['otpLoginIntent'] as Map<String, dynamic>);
    final _stampLoginIntent = json['stampLoginIntent'] == null ? null : v1StampLoginIntent.fromJson(json['stampLoginIntent'] as Map<String, dynamic>);
    final _oauthLoginIntent = json['oauthLoginIntent'] == null ? null : v1OauthLoginIntent.fromJson(json['oauthLoginIntent'] as Map<String, dynamic>);
    final _updateUserNameIntent = json['updateUserNameIntent'] == null ? null : v1UpdateUserNameIntent.fromJson(json['updateUserNameIntent'] as Map<String, dynamic>);
    final _updateUserEmailIntent = json['updateUserEmailIntent'] == null ? null : v1UpdateUserEmailIntent.fromJson(json['updateUserEmailIntent'] as Map<String, dynamic>);
    final _updateUserPhoneNumberIntent = json['updateUserPhoneNumberIntent'] == null ? null : v1UpdateUserPhoneNumberIntent.fromJson(json['updateUserPhoneNumberIntent'] as Map<String, dynamic>);
    final _initFiatOnRampIntent = json['initFiatOnRampIntent'] == null ? null : v1InitFiatOnRampIntent.fromJson(json['initFiatOnRampIntent'] as Map<String, dynamic>);
    final _createSmartContractInterfaceIntent = json['createSmartContractInterfaceIntent'] == null ? null : v1CreateSmartContractInterfaceIntent.fromJson(json['createSmartContractInterfaceIntent'] as Map<String, dynamic>);
    final _deleteSmartContractInterfaceIntent = json['deleteSmartContractInterfaceIntent'] == null ? null : v1DeleteSmartContractInterfaceIntent.fromJson(json['deleteSmartContractInterfaceIntent'] as Map<String, dynamic>);
    final _enableAuthProxyIntent = json['enableAuthProxyIntent'] == null ? null : v1EnableAuthProxyIntent.fromJson(json['enableAuthProxyIntent'] as Map<String, dynamic>);
    final _disableAuthProxyIntent = json['disableAuthProxyIntent'] == null ? null : v1DisableAuthProxyIntent.fromJson(json['disableAuthProxyIntent'] as Map<String, dynamic>);
    final _updateAuthProxyConfigIntent = json['updateAuthProxyConfigIntent'] == null ? null : v1UpdateAuthProxyConfigIntent.fromJson(json['updateAuthProxyConfigIntent'] as Map<String, dynamic>);
    final _createOauth2CredentialIntent = json['createOauth2CredentialIntent'] == null ? null : v1CreateOauth2CredentialIntent.fromJson(json['createOauth2CredentialIntent'] as Map<String, dynamic>);
    final _updateOauth2CredentialIntent = json['updateOauth2CredentialIntent'] == null ? null : v1UpdateOauth2CredentialIntent.fromJson(json['updateOauth2CredentialIntent'] as Map<String, dynamic>);
    final _deleteOauth2CredentialIntent = json['deleteOauth2CredentialIntent'] == null ? null : v1DeleteOauth2CredentialIntent.fromJson(json['deleteOauth2CredentialIntent'] as Map<String, dynamic>);
    final _oauth2AuthenticateIntent = json['oauth2AuthenticateIntent'] == null ? null : v1Oauth2AuthenticateIntent.fromJson(json['oauth2AuthenticateIntent'] as Map<String, dynamic>);
    final _deleteWalletAccountsIntent = json['deleteWalletAccountsIntent'] == null ? null : v1DeleteWalletAccountsIntent.fromJson(json['deleteWalletAccountsIntent'] as Map<String, dynamic>);
    final _deletePoliciesIntent = json['deletePoliciesIntent'] == null ? null : v1DeletePoliciesIntent.fromJson(json['deletePoliciesIntent'] as Map<String, dynamic>);
    final _ethSendRawTransactionIntent = json['ethSendRawTransactionIntent'] == null ? null : v1EthSendRawTransactionIntent.fromJson(json['ethSendRawTransactionIntent'] as Map<String, dynamic>);
    final _ethSendTransactionIntent = json['ethSendTransactionIntent'] == null ? null : v1EthSendTransactionIntent.fromJson(json['ethSendTransactionIntent'] as Map<String, dynamic>);
    final _createFiatOnRampCredentialIntent = json['createFiatOnRampCredentialIntent'] == null ? null : v1CreateFiatOnRampCredentialIntent.fromJson(json['createFiatOnRampCredentialIntent'] as Map<String, dynamic>);
    final _updateFiatOnRampCredentialIntent = json['updateFiatOnRampCredentialIntent'] == null ? null : v1UpdateFiatOnRampCredentialIntent.fromJson(json['updateFiatOnRampCredentialIntent'] as Map<String, dynamic>);
    final _deleteFiatOnRampCredentialIntent = json['deleteFiatOnRampCredentialIntent'] == null ? null : v1DeleteFiatOnRampCredentialIntent.fromJson(json['deleteFiatOnRampCredentialIntent'] as Map<String, dynamic>);
    final _emailAuthIntentV3 = json['emailAuthIntentV3'] == null ? null : v1EmailAuthIntentV3.fromJson(json['emailAuthIntentV3'] as Map<String, dynamic>);
    final _initUserEmailRecoveryIntentV2 = json['initUserEmailRecoveryIntentV2'] == null ? null : v1InitUserEmailRecoveryIntentV2.fromJson(json['initUserEmailRecoveryIntentV2'] as Map<String, dynamic>);
    final _initOtpIntentV2 = json['initOtpIntentV2'] == null ? null : v1InitOtpIntentV2.fromJson(json['initOtpIntentV2'] as Map<String, dynamic>);
    final _initOtpAuthIntentV3 = json['initOtpAuthIntentV3'] == null ? null : v1InitOtpAuthIntentV3.fromJson(json['initOtpAuthIntentV3'] as Map<String, dynamic>);
    final _upsertGasUsageConfigIntent = json['upsertGasUsageConfigIntent'] == null ? null : v1UpsertGasUsageConfigIntent.fromJson(json['upsertGasUsageConfigIntent'] as Map<String, dynamic>);
    final _createTvcAppIntent = json['createTvcAppIntent'] == null ? null : v1CreateTvcAppIntent.fromJson(json['createTvcAppIntent'] as Map<String, dynamic>);
    final _createTvcDeploymentIntent = json['createTvcDeploymentIntent'] == null ? null : v1CreateTvcDeploymentIntent.fromJson(json['createTvcDeploymentIntent'] as Map<String, dynamic>);
    final _createTvcManifestApprovalsIntent = json['createTvcManifestApprovalsIntent'] == null ? null : v1CreateTvcManifestApprovalsIntent.fromJson(json['createTvcManifestApprovalsIntent'] as Map<String, dynamic>);
    final _solSendTransactionIntent = json['solSendTransactionIntent'] == null ? null : v1SolSendTransactionIntent.fromJson(json['solSendTransactionIntent'] as Map<String, dynamic>);
    return v1Intent(
      createOrganizationIntent: _createOrganizationIntent,
      createAuthenticatorsIntent: _createAuthenticatorsIntent,
      createUsersIntent: _createUsersIntent,
      createPrivateKeysIntent: _createPrivateKeysIntent,
      signRawPayloadIntent: _signRawPayloadIntent,
      createInvitationsIntent: _createInvitationsIntent,
      acceptInvitationIntent: _acceptInvitationIntent,
      createPolicyIntent: _createPolicyIntent,
      disablePrivateKeyIntent: _disablePrivateKeyIntent,
      deleteUsersIntent: _deleteUsersIntent,
      deleteAuthenticatorsIntent: _deleteAuthenticatorsIntent,
      deleteInvitationIntent: _deleteInvitationIntent,
      deleteOrganizationIntent: _deleteOrganizationIntent,
      deletePolicyIntent: _deletePolicyIntent,
      createUserTagIntent: _createUserTagIntent,
      deleteUserTagsIntent: _deleteUserTagsIntent,
      signTransactionIntent: _signTransactionIntent,
      createApiKeysIntent: _createApiKeysIntent,
      deleteApiKeysIntent: _deleteApiKeysIntent,
      approveActivityIntent: _approveActivityIntent,
      rejectActivityIntent: _rejectActivityIntent,
      createPrivateKeyTagIntent: _createPrivateKeyTagIntent,
      deletePrivateKeyTagsIntent: _deletePrivateKeyTagsIntent,
      createPolicyIntentV2: _createPolicyIntentV2,
      setPaymentMethodIntent: _setPaymentMethodIntent,
      activateBillingTierIntent: _activateBillingTierIntent,
      deletePaymentMethodIntent: _deletePaymentMethodIntent,
      createPolicyIntentV3: _createPolicyIntentV3,
      createApiOnlyUsersIntent: _createApiOnlyUsersIntent,
      updateRootQuorumIntent: _updateRootQuorumIntent,
      updateUserTagIntent: _updateUserTagIntent,
      updatePrivateKeyTagIntent: _updatePrivateKeyTagIntent,
      createAuthenticatorsIntentV2: _createAuthenticatorsIntentV2,
      acceptInvitationIntentV2: _acceptInvitationIntentV2,
      createOrganizationIntentV2: _createOrganizationIntentV2,
      createUsersIntentV2: _createUsersIntentV2,
      createSubOrganizationIntent: _createSubOrganizationIntent,
      createSubOrganizationIntentV2: _createSubOrganizationIntentV2,
      updateAllowedOriginsIntent: _updateAllowedOriginsIntent,
      createPrivateKeysIntentV2: _createPrivateKeysIntentV2,
      updateUserIntent: _updateUserIntent,
      updatePolicyIntent: _updatePolicyIntent,
      setPaymentMethodIntentV2: _setPaymentMethodIntentV2,
      createSubOrganizationIntentV3: _createSubOrganizationIntentV3,
      createWalletIntent: _createWalletIntent,
      createWalletAccountsIntent: _createWalletAccountsIntent,
      initUserEmailRecoveryIntent: _initUserEmailRecoveryIntent,
      recoverUserIntent: _recoverUserIntent,
      setOrganizationFeatureIntent: _setOrganizationFeatureIntent,
      removeOrganizationFeatureIntent: _removeOrganizationFeatureIntent,
      signRawPayloadIntentV2: _signRawPayloadIntentV2,
      signTransactionIntentV2: _signTransactionIntentV2,
      exportPrivateKeyIntent: _exportPrivateKeyIntent,
      exportWalletIntent: _exportWalletIntent,
      createSubOrganizationIntentV4: _createSubOrganizationIntentV4,
      emailAuthIntent: _emailAuthIntent,
      exportWalletAccountIntent: _exportWalletAccountIntent,
      initImportWalletIntent: _initImportWalletIntent,
      importWalletIntent: _importWalletIntent,
      initImportPrivateKeyIntent: _initImportPrivateKeyIntent,
      importPrivateKeyIntent: _importPrivateKeyIntent,
      createPoliciesIntent: _createPoliciesIntent,
      signRawPayloadsIntent: _signRawPayloadsIntent,
      createReadOnlySessionIntent: _createReadOnlySessionIntent,
      createOauthProvidersIntent: _createOauthProvidersIntent,
      deleteOauthProvidersIntent: _deleteOauthProvidersIntent,
      createSubOrganizationIntentV5: _createSubOrganizationIntentV5,
      oauthIntent: _oauthIntent,
      createApiKeysIntentV2: _createApiKeysIntentV2,
      createReadWriteSessionIntent: _createReadWriteSessionIntent,
      emailAuthIntentV2: _emailAuthIntentV2,
      createSubOrganizationIntentV6: _createSubOrganizationIntentV6,
      deletePrivateKeysIntent: _deletePrivateKeysIntent,
      deleteWalletsIntent: _deleteWalletsIntent,
      createReadWriteSessionIntentV2: _createReadWriteSessionIntentV2,
      deleteSubOrganizationIntent: _deleteSubOrganizationIntent,
      initOtpAuthIntent: _initOtpAuthIntent,
      otpAuthIntent: _otpAuthIntent,
      createSubOrganizationIntentV7: _createSubOrganizationIntentV7,
      updateWalletIntent: _updateWalletIntent,
      updatePolicyIntentV2: _updatePolicyIntentV2,
      createUsersIntentV3: _createUsersIntentV3,
      initOtpAuthIntentV2: _initOtpAuthIntentV2,
      initOtpIntent: _initOtpIntent,
      verifyOtpIntent: _verifyOtpIntent,
      otpLoginIntent: _otpLoginIntent,
      stampLoginIntent: _stampLoginIntent,
      oauthLoginIntent: _oauthLoginIntent,
      updateUserNameIntent: _updateUserNameIntent,
      updateUserEmailIntent: _updateUserEmailIntent,
      updateUserPhoneNumberIntent: _updateUserPhoneNumberIntent,
      initFiatOnRampIntent: _initFiatOnRampIntent,
      createSmartContractInterfaceIntent: _createSmartContractInterfaceIntent,
      deleteSmartContractInterfaceIntent: _deleteSmartContractInterfaceIntent,
      enableAuthProxyIntent: _enableAuthProxyIntent,
      disableAuthProxyIntent: _disableAuthProxyIntent,
      updateAuthProxyConfigIntent: _updateAuthProxyConfigIntent,
      createOauth2CredentialIntent: _createOauth2CredentialIntent,
      updateOauth2CredentialIntent: _updateOauth2CredentialIntent,
      deleteOauth2CredentialIntent: _deleteOauth2CredentialIntent,
      oauth2AuthenticateIntent: _oauth2AuthenticateIntent,
      deleteWalletAccountsIntent: _deleteWalletAccountsIntent,
      deletePoliciesIntent: _deletePoliciesIntent,
      ethSendRawTransactionIntent: _ethSendRawTransactionIntent,
      ethSendTransactionIntent: _ethSendTransactionIntent,
      createFiatOnRampCredentialIntent: _createFiatOnRampCredentialIntent,
      updateFiatOnRampCredentialIntent: _updateFiatOnRampCredentialIntent,
      deleteFiatOnRampCredentialIntent: _deleteFiatOnRampCredentialIntent,
      emailAuthIntentV3: _emailAuthIntentV3,
      initUserEmailRecoveryIntentV2: _initUserEmailRecoveryIntentV2,
      initOtpIntentV2: _initOtpIntentV2,
      initOtpAuthIntentV3: _initOtpAuthIntentV3,
      upsertGasUsageConfigIntent: _upsertGasUsageConfigIntent,
      createTvcAppIntent: _createTvcAppIntent,
      createTvcDeploymentIntent: _createTvcDeploymentIntent,
      createTvcManifestApprovalsIntent: _createTvcManifestApprovalsIntent,
      solSendTransactionIntent: _solSendTransactionIntent,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    if (createOrganizationIntent != null) {
      _json['createOrganizationIntent'] = createOrganizationIntent?.toJson();
    }
    if (createAuthenticatorsIntent != null) {
      _json['createAuthenticatorsIntent'] = createAuthenticatorsIntent?.toJson();
    }
    if (createUsersIntent != null) {
      _json['createUsersIntent'] = createUsersIntent?.toJson();
    }
    if (createPrivateKeysIntent != null) {
      _json['createPrivateKeysIntent'] = createPrivateKeysIntent?.toJson();
    }
    if (signRawPayloadIntent != null) {
      _json['signRawPayloadIntent'] = signRawPayloadIntent?.toJson();
    }
    if (createInvitationsIntent != null) {
      _json['createInvitationsIntent'] = createInvitationsIntent?.toJson();
    }
    if (acceptInvitationIntent != null) {
      _json['acceptInvitationIntent'] = acceptInvitationIntent?.toJson();
    }
    if (createPolicyIntent != null) {
      _json['createPolicyIntent'] = createPolicyIntent?.toJson();
    }
    if (disablePrivateKeyIntent != null) {
      _json['disablePrivateKeyIntent'] = disablePrivateKeyIntent?.toJson();
    }
    if (deleteUsersIntent != null) {
      _json['deleteUsersIntent'] = deleteUsersIntent?.toJson();
    }
    if (deleteAuthenticatorsIntent != null) {
      _json['deleteAuthenticatorsIntent'] = deleteAuthenticatorsIntent?.toJson();
    }
    if (deleteInvitationIntent != null) {
      _json['deleteInvitationIntent'] = deleteInvitationIntent?.toJson();
    }
    if (deleteOrganizationIntent != null) {
      _json['deleteOrganizationIntent'] = deleteOrganizationIntent?.toJson();
    }
    if (deletePolicyIntent != null) {
      _json['deletePolicyIntent'] = deletePolicyIntent?.toJson();
    }
    if (createUserTagIntent != null) {
      _json['createUserTagIntent'] = createUserTagIntent?.toJson();
    }
    if (deleteUserTagsIntent != null) {
      _json['deleteUserTagsIntent'] = deleteUserTagsIntent?.toJson();
    }
    if (signTransactionIntent != null) {
      _json['signTransactionIntent'] = signTransactionIntent?.toJson();
    }
    if (createApiKeysIntent != null) {
      _json['createApiKeysIntent'] = createApiKeysIntent?.toJson();
    }
    if (deleteApiKeysIntent != null) {
      _json['deleteApiKeysIntent'] = deleteApiKeysIntent?.toJson();
    }
    if (approveActivityIntent != null) {
      _json['approveActivityIntent'] = approveActivityIntent?.toJson();
    }
    if (rejectActivityIntent != null) {
      _json['rejectActivityIntent'] = rejectActivityIntent?.toJson();
    }
    if (createPrivateKeyTagIntent != null) {
      _json['createPrivateKeyTagIntent'] = createPrivateKeyTagIntent?.toJson();
    }
    if (deletePrivateKeyTagsIntent != null) {
      _json['deletePrivateKeyTagsIntent'] = deletePrivateKeyTagsIntent?.toJson();
    }
    if (createPolicyIntentV2 != null) {
      _json['createPolicyIntentV2'] = createPolicyIntentV2?.toJson();
    }
    if (setPaymentMethodIntent != null) {
      _json['setPaymentMethodIntent'] = setPaymentMethodIntent?.toJson();
    }
    if (activateBillingTierIntent != null) {
      _json['activateBillingTierIntent'] = activateBillingTierIntent?.toJson();
    }
    if (deletePaymentMethodIntent != null) {
      _json['deletePaymentMethodIntent'] = deletePaymentMethodIntent?.toJson();
    }
    if (createPolicyIntentV3 != null) {
      _json['createPolicyIntentV3'] = createPolicyIntentV3?.toJson();
    }
    if (createApiOnlyUsersIntent != null) {
      _json['createApiOnlyUsersIntent'] = createApiOnlyUsersIntent?.toJson();
    }
    if (updateRootQuorumIntent != null) {
      _json['updateRootQuorumIntent'] = updateRootQuorumIntent?.toJson();
    }
    if (updateUserTagIntent != null) {
      _json['updateUserTagIntent'] = updateUserTagIntent?.toJson();
    }
    if (updatePrivateKeyTagIntent != null) {
      _json['updatePrivateKeyTagIntent'] = updatePrivateKeyTagIntent?.toJson();
    }
    if (createAuthenticatorsIntentV2 != null) {
      _json['createAuthenticatorsIntentV2'] = createAuthenticatorsIntentV2?.toJson();
    }
    if (acceptInvitationIntentV2 != null) {
      _json['acceptInvitationIntentV2'] = acceptInvitationIntentV2?.toJson();
    }
    if (createOrganizationIntentV2 != null) {
      _json['createOrganizationIntentV2'] = createOrganizationIntentV2?.toJson();
    }
    if (createUsersIntentV2 != null) {
      _json['createUsersIntentV2'] = createUsersIntentV2?.toJson();
    }
    if (createSubOrganizationIntent != null) {
      _json['createSubOrganizationIntent'] = createSubOrganizationIntent?.toJson();
    }
    if (createSubOrganizationIntentV2 != null) {
      _json['createSubOrganizationIntentV2'] = createSubOrganizationIntentV2?.toJson();
    }
    if (updateAllowedOriginsIntent != null) {
      _json['updateAllowedOriginsIntent'] = updateAllowedOriginsIntent?.toJson();
    }
    if (createPrivateKeysIntentV2 != null) {
      _json['createPrivateKeysIntentV2'] = createPrivateKeysIntentV2?.toJson();
    }
    if (updateUserIntent != null) {
      _json['updateUserIntent'] = updateUserIntent?.toJson();
    }
    if (updatePolicyIntent != null) {
      _json['updatePolicyIntent'] = updatePolicyIntent?.toJson();
    }
    if (setPaymentMethodIntentV2 != null) {
      _json['setPaymentMethodIntentV2'] = setPaymentMethodIntentV2?.toJson();
    }
    if (createSubOrganizationIntentV3 != null) {
      _json['createSubOrganizationIntentV3'] = createSubOrganizationIntentV3?.toJson();
    }
    if (createWalletIntent != null) {
      _json['createWalletIntent'] = createWalletIntent?.toJson();
    }
    if (createWalletAccountsIntent != null) {
      _json['createWalletAccountsIntent'] = createWalletAccountsIntent?.toJson();
    }
    if (initUserEmailRecoveryIntent != null) {
      _json['initUserEmailRecoveryIntent'] = initUserEmailRecoveryIntent?.toJson();
    }
    if (recoverUserIntent != null) {
      _json['recoverUserIntent'] = recoverUserIntent?.toJson();
    }
    if (setOrganizationFeatureIntent != null) {
      _json['setOrganizationFeatureIntent'] = setOrganizationFeatureIntent?.toJson();
    }
    if (removeOrganizationFeatureIntent != null) {
      _json['removeOrganizationFeatureIntent'] = removeOrganizationFeatureIntent?.toJson();
    }
    if (signRawPayloadIntentV2 != null) {
      _json['signRawPayloadIntentV2'] = signRawPayloadIntentV2?.toJson();
    }
    if (signTransactionIntentV2 != null) {
      _json['signTransactionIntentV2'] = signTransactionIntentV2?.toJson();
    }
    if (exportPrivateKeyIntent != null) {
      _json['exportPrivateKeyIntent'] = exportPrivateKeyIntent?.toJson();
    }
    if (exportWalletIntent != null) {
      _json['exportWalletIntent'] = exportWalletIntent?.toJson();
    }
    if (createSubOrganizationIntentV4 != null) {
      _json['createSubOrganizationIntentV4'] = createSubOrganizationIntentV4?.toJson();
    }
    if (emailAuthIntent != null) {
      _json['emailAuthIntent'] = emailAuthIntent?.toJson();
    }
    if (exportWalletAccountIntent != null) {
      _json['exportWalletAccountIntent'] = exportWalletAccountIntent?.toJson();
    }
    if (initImportWalletIntent != null) {
      _json['initImportWalletIntent'] = initImportWalletIntent?.toJson();
    }
    if (importWalletIntent != null) {
      _json['importWalletIntent'] = importWalletIntent?.toJson();
    }
    if (initImportPrivateKeyIntent != null) {
      _json['initImportPrivateKeyIntent'] = initImportPrivateKeyIntent?.toJson();
    }
    if (importPrivateKeyIntent != null) {
      _json['importPrivateKeyIntent'] = importPrivateKeyIntent?.toJson();
    }
    if (createPoliciesIntent != null) {
      _json['createPoliciesIntent'] = createPoliciesIntent?.toJson();
    }
    if (signRawPayloadsIntent != null) {
      _json['signRawPayloadsIntent'] = signRawPayloadsIntent?.toJson();
    }
    if (createReadOnlySessionIntent != null) {
      _json['createReadOnlySessionIntent'] = createReadOnlySessionIntent?.toJson();
    }
    if (createOauthProvidersIntent != null) {
      _json['createOauthProvidersIntent'] = createOauthProvidersIntent?.toJson();
    }
    if (deleteOauthProvidersIntent != null) {
      _json['deleteOauthProvidersIntent'] = deleteOauthProvidersIntent?.toJson();
    }
    if (createSubOrganizationIntentV5 != null) {
      _json['createSubOrganizationIntentV5'] = createSubOrganizationIntentV5?.toJson();
    }
    if (oauthIntent != null) {
      _json['oauthIntent'] = oauthIntent?.toJson();
    }
    if (createApiKeysIntentV2 != null) {
      _json['createApiKeysIntentV2'] = createApiKeysIntentV2?.toJson();
    }
    if (createReadWriteSessionIntent != null) {
      _json['createReadWriteSessionIntent'] = createReadWriteSessionIntent?.toJson();
    }
    if (emailAuthIntentV2 != null) {
      _json['emailAuthIntentV2'] = emailAuthIntentV2?.toJson();
    }
    if (createSubOrganizationIntentV6 != null) {
      _json['createSubOrganizationIntentV6'] = createSubOrganizationIntentV6?.toJson();
    }
    if (deletePrivateKeysIntent != null) {
      _json['deletePrivateKeysIntent'] = deletePrivateKeysIntent?.toJson();
    }
    if (deleteWalletsIntent != null) {
      _json['deleteWalletsIntent'] = deleteWalletsIntent?.toJson();
    }
    if (createReadWriteSessionIntentV2 != null) {
      _json['createReadWriteSessionIntentV2'] = createReadWriteSessionIntentV2?.toJson();
    }
    if (deleteSubOrganizationIntent != null) {
      _json['deleteSubOrganizationIntent'] = deleteSubOrganizationIntent?.toJson();
    }
    if (initOtpAuthIntent != null) {
      _json['initOtpAuthIntent'] = initOtpAuthIntent?.toJson();
    }
    if (otpAuthIntent != null) {
      _json['otpAuthIntent'] = otpAuthIntent?.toJson();
    }
    if (createSubOrganizationIntentV7 != null) {
      _json['createSubOrganizationIntentV7'] = createSubOrganizationIntentV7?.toJson();
    }
    if (updateWalletIntent != null) {
      _json['updateWalletIntent'] = updateWalletIntent?.toJson();
    }
    if (updatePolicyIntentV2 != null) {
      _json['updatePolicyIntentV2'] = updatePolicyIntentV2?.toJson();
    }
    if (createUsersIntentV3 != null) {
      _json['createUsersIntentV3'] = createUsersIntentV3?.toJson();
    }
    if (initOtpAuthIntentV2 != null) {
      _json['initOtpAuthIntentV2'] = initOtpAuthIntentV2?.toJson();
    }
    if (initOtpIntent != null) {
      _json['initOtpIntent'] = initOtpIntent?.toJson();
    }
    if (verifyOtpIntent != null) {
      _json['verifyOtpIntent'] = verifyOtpIntent?.toJson();
    }
    if (otpLoginIntent != null) {
      _json['otpLoginIntent'] = otpLoginIntent?.toJson();
    }
    if (stampLoginIntent != null) {
      _json['stampLoginIntent'] = stampLoginIntent?.toJson();
    }
    if (oauthLoginIntent != null) {
      _json['oauthLoginIntent'] = oauthLoginIntent?.toJson();
    }
    if (updateUserNameIntent != null) {
      _json['updateUserNameIntent'] = updateUserNameIntent?.toJson();
    }
    if (updateUserEmailIntent != null) {
      _json['updateUserEmailIntent'] = updateUserEmailIntent?.toJson();
    }
    if (updateUserPhoneNumberIntent != null) {
      _json['updateUserPhoneNumberIntent'] = updateUserPhoneNumberIntent?.toJson();
    }
    if (initFiatOnRampIntent != null) {
      _json['initFiatOnRampIntent'] = initFiatOnRampIntent?.toJson();
    }
    if (createSmartContractInterfaceIntent != null) {
      _json['createSmartContractInterfaceIntent'] = createSmartContractInterfaceIntent?.toJson();
    }
    if (deleteSmartContractInterfaceIntent != null) {
      _json['deleteSmartContractInterfaceIntent'] = deleteSmartContractInterfaceIntent?.toJson();
    }
    if (enableAuthProxyIntent != null) {
      _json['enableAuthProxyIntent'] = enableAuthProxyIntent?.toJson();
    }
    if (disableAuthProxyIntent != null) {
      _json['disableAuthProxyIntent'] = disableAuthProxyIntent?.toJson();
    }
    if (updateAuthProxyConfigIntent != null) {
      _json['updateAuthProxyConfigIntent'] = updateAuthProxyConfigIntent?.toJson();
    }
    if (createOauth2CredentialIntent != null) {
      _json['createOauth2CredentialIntent'] = createOauth2CredentialIntent?.toJson();
    }
    if (updateOauth2CredentialIntent != null) {
      _json['updateOauth2CredentialIntent'] = updateOauth2CredentialIntent?.toJson();
    }
    if (deleteOauth2CredentialIntent != null) {
      _json['deleteOauth2CredentialIntent'] = deleteOauth2CredentialIntent?.toJson();
    }
    if (oauth2AuthenticateIntent != null) {
      _json['oauth2AuthenticateIntent'] = oauth2AuthenticateIntent?.toJson();
    }
    if (deleteWalletAccountsIntent != null) {
      _json['deleteWalletAccountsIntent'] = deleteWalletAccountsIntent?.toJson();
    }
    if (deletePoliciesIntent != null) {
      _json['deletePoliciesIntent'] = deletePoliciesIntent?.toJson();
    }
    if (ethSendRawTransactionIntent != null) {
      _json['ethSendRawTransactionIntent'] = ethSendRawTransactionIntent?.toJson();
    }
    if (ethSendTransactionIntent != null) {
      _json['ethSendTransactionIntent'] = ethSendTransactionIntent?.toJson();
    }
    if (createFiatOnRampCredentialIntent != null) {
      _json['createFiatOnRampCredentialIntent'] = createFiatOnRampCredentialIntent?.toJson();
    }
    if (updateFiatOnRampCredentialIntent != null) {
      _json['updateFiatOnRampCredentialIntent'] = updateFiatOnRampCredentialIntent?.toJson();
    }
    if (deleteFiatOnRampCredentialIntent != null) {
      _json['deleteFiatOnRampCredentialIntent'] = deleteFiatOnRampCredentialIntent?.toJson();
    }
    if (emailAuthIntentV3 != null) {
      _json['emailAuthIntentV3'] = emailAuthIntentV3?.toJson();
    }
    if (initUserEmailRecoveryIntentV2 != null) {
      _json['initUserEmailRecoveryIntentV2'] = initUserEmailRecoveryIntentV2?.toJson();
    }
    if (initOtpIntentV2 != null) {
      _json['initOtpIntentV2'] = initOtpIntentV2?.toJson();
    }
    if (initOtpAuthIntentV3 != null) {
      _json['initOtpAuthIntentV3'] = initOtpAuthIntentV3?.toJson();
    }
    if (upsertGasUsageConfigIntent != null) {
      _json['upsertGasUsageConfigIntent'] = upsertGasUsageConfigIntent?.toJson();
    }
    if (createTvcAppIntent != null) {
      _json['createTvcAppIntent'] = createTvcAppIntent?.toJson();
    }
    if (createTvcDeploymentIntent != null) {
      _json['createTvcDeploymentIntent'] = createTvcDeploymentIntent?.toJson();
    }
    if (createTvcManifestApprovalsIntent != null) {
      _json['createTvcManifestApprovalsIntent'] = createTvcManifestApprovalsIntent?.toJson();
    }
    if (solSendTransactionIntent != null) {
      _json['solSendTransactionIntent'] = solSendTransactionIntent?.toJson();
    }
    return _json;
  }
}

class v1Invitation {
  /// Unique identifier for a given Invitation object.
  final String invitationId;
  /// The name of the intended Invitation recipient.
  final String receiverUserName;
  /// The email address of the intended Invitation recipient.
  final String receiverEmail;
  /// A list of tags assigned to the Invitation recipient.
  final List<String> receiverUserTags;
  /// The User's permissible access method(s).
  final v1AccessType accessType;
  /// The current processing status of a specified Invitation.
  final v1InvitationStatus status;
  final externaldatav1Timestamp createdAt;
  final externaldatav1Timestamp updatedAt;
  /// Unique identifier for the Sender of an Invitation.
  final String senderUserId;

  const v1Invitation({
    required  this.invitationId,
    required  this.receiverUserName,
    required  this.receiverEmail,
    required  this.receiverUserTags,
    required  this.accessType,
    required  this.status,
    required  this.createdAt,
    required  this.updatedAt,
    required  this.senderUserId,
  });

  factory v1Invitation.fromJson(Map<String, dynamic> json) {
    final _invitationId = json['invitationId'] as String;
    final _receiverUserName = json['receiverUserName'] as String;
    final _receiverEmail = json['receiverEmail'] as String;
    final _receiverUserTags = (json['receiverUserTags'] as List).map((e) => e as String).toList();
    final _accessType = v1AccessTypeFromJson(json['accessType']);
    final _status = v1InvitationStatusFromJson(json['status']);
    final _createdAt = externaldatav1Timestamp.fromJson(json['createdAt'] as Map<String, dynamic>);
    final _updatedAt = externaldatav1Timestamp.fromJson(json['updatedAt'] as Map<String, dynamic>);
    final _senderUserId = json['senderUserId'] as String;
    return v1Invitation(
      invitationId: _invitationId,
      receiverUserName: _receiverUserName,
      receiverEmail: _receiverEmail,
      receiverUserTags: _receiverUserTags,
      accessType: _accessType,
      status: _status,
      createdAt: _createdAt,
      updatedAt: _updatedAt,
      senderUserId: _senderUserId,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['invitationId'] = invitationId;
    _json['receiverUserName'] = receiverUserName;
    _json['receiverEmail'] = receiverEmail;
    _json['receiverUserTags'] = receiverUserTags;
    _json['accessType'] = v1AccessTypeToJson(accessType);
    _json['status'] = v1InvitationStatusToJson(status);
    _json['createdAt'] = createdAt.toJson();
    _json['updatedAt'] = updatedAt.toJson();
    _json['senderUserId'] = senderUserId;
    return _json;
  }
}

class v1InvitationParams {
  /// The name of the intended Invitation recipient.
  final String receiverUserName;
  /// The email address of the intended Invitation recipient.
  final String receiverUserEmail;
  /// A list of tags assigned to the Invitation recipient. This field, if not needed, should be an empty array in your request body.
  final List<String> receiverUserTags;
  /// The User's permissible access method(s).
  final v1AccessType accessType;
  /// Unique identifier for the Sender of an Invitation.
  final String senderUserId;

  const v1InvitationParams({
    required  this.receiverUserName,
    required  this.receiverUserEmail,
    required  this.receiverUserTags,
    required  this.accessType,
    required  this.senderUserId,
  });

  factory v1InvitationParams.fromJson(Map<String, dynamic> json) {
    final _receiverUserName = json['receiverUserName'] as String;
    final _receiverUserEmail = json['receiverUserEmail'] as String;
    final _receiverUserTags = (json['receiverUserTags'] as List).map((e) => e as String).toList();
    final _accessType = v1AccessTypeFromJson(json['accessType']);
    final _senderUserId = json['senderUserId'] as String;
    return v1InvitationParams(
      receiverUserName: _receiverUserName,
      receiverUserEmail: _receiverUserEmail,
      receiverUserTags: _receiverUserTags,
      accessType: _accessType,
      senderUserId: _senderUserId,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['receiverUserName'] = receiverUserName;
    _json['receiverUserEmail'] = receiverUserEmail;
    _json['receiverUserTags'] = receiverUserTags;
    _json['accessType'] = v1AccessTypeToJson(accessType);
    _json['senderUserId'] = senderUserId;
    return _json;
  }
}

class v1ListFiatOnRampCredentialsRequest {
  /// Unique identifier for a given Organization.
  final String organizationId;

  const v1ListFiatOnRampCredentialsRequest({
    required  this.organizationId,
  });

  factory v1ListFiatOnRampCredentialsRequest.fromJson(Map<String, dynamic> json) {
    final _organizationId = json['organizationId'] as String;
    return v1ListFiatOnRampCredentialsRequest(
      organizationId: _organizationId,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['organizationId'] = organizationId;
    return _json;
  }
}

class v1ListFiatOnRampCredentialsResponse {
  final List<v1FiatOnRampCredential> fiatOnRampCredentials;

  const v1ListFiatOnRampCredentialsResponse({
    required  this.fiatOnRampCredentials,
  });

  factory v1ListFiatOnRampCredentialsResponse.fromJson(Map<String, dynamic> json) {
    final _fiatOnRampCredentials = (json['fiatOnRampCredentials'] as List).map((e) => v1FiatOnRampCredential.fromJson(e as Map<String, dynamic>)).toList();
    return v1ListFiatOnRampCredentialsResponse(
      fiatOnRampCredentials: _fiatOnRampCredentials,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['fiatOnRampCredentials'] = fiatOnRampCredentials.map((e) => e.toJson()).toList();
    return _json;
  }
}

class v1ListOauth2CredentialsRequest {
  /// Unique identifier for a given Organization.
  final String organizationId;

  const v1ListOauth2CredentialsRequest({
    required  this.organizationId,
  });

  factory v1ListOauth2CredentialsRequest.fromJson(Map<String, dynamic> json) {
    final _organizationId = json['organizationId'] as String;
    return v1ListOauth2CredentialsRequest(
      organizationId: _organizationId,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['organizationId'] = organizationId;
    return _json;
  }
}

class v1ListOauth2CredentialsResponse {
  final List<v1Oauth2Credential> oauth2Credentials;

  const v1ListOauth2CredentialsResponse({
    required  this.oauth2Credentials,
  });

  factory v1ListOauth2CredentialsResponse.fromJson(Map<String, dynamic> json) {
    final _oauth2Credentials = (json['oauth2Credentials'] as List).map((e) => v1Oauth2Credential.fromJson(e as Map<String, dynamic>)).toList();
    return v1ListOauth2CredentialsResponse(
      oauth2Credentials: _oauth2Credentials,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['oauth2Credentials'] = oauth2Credentials.map((e) => e.toJson()).toList();
    return _json;
  }
}

class v1ListPrivateKeyTagsRequest {
  /// Unique identifier for a given organization.
  final String organizationId;

  const v1ListPrivateKeyTagsRequest({
    required  this.organizationId,
  });

  factory v1ListPrivateKeyTagsRequest.fromJson(Map<String, dynamic> json) {
    final _organizationId = json['organizationId'] as String;
    return v1ListPrivateKeyTagsRequest(
      organizationId: _organizationId,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['organizationId'] = organizationId;
    return _json;
  }
}

class v1ListPrivateKeyTagsResponse {
  /// A list of private key tags.
  final List<datav1Tag> privateKeyTags;

  const v1ListPrivateKeyTagsResponse({
    required  this.privateKeyTags,
  });

  factory v1ListPrivateKeyTagsResponse.fromJson(Map<String, dynamic> json) {
    final _privateKeyTags = (json['privateKeyTags'] as List).map((e) => datav1Tag.fromJson(e as Map<String, dynamic>)).toList();
    return v1ListPrivateKeyTagsResponse(
      privateKeyTags: _privateKeyTags,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['privateKeyTags'] = privateKeyTags.map((e) => e.toJson()).toList();
    return _json;
  }
}

class v1ListUserTagsRequest {
  /// Unique identifier for a given organization.
  final String organizationId;

  const v1ListUserTagsRequest({
    required  this.organizationId,
  });

  factory v1ListUserTagsRequest.fromJson(Map<String, dynamic> json) {
    final _organizationId = json['organizationId'] as String;
    return v1ListUserTagsRequest(
      organizationId: _organizationId,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['organizationId'] = organizationId;
    return _json;
  }
}

class v1ListUserTagsResponse {
  /// A list of user tags.
  final List<datav1Tag> userTags;

  const v1ListUserTagsResponse({
    required  this.userTags,
  });

  factory v1ListUserTagsResponse.fromJson(Map<String, dynamic> json) {
    final _userTags = (json['userTags'] as List).map((e) => datav1Tag.fromJson(e as Map<String, dynamic>)).toList();
    return v1ListUserTagsResponse(
      userTags: _userTags,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['userTags'] = userTags.map((e) => e.toJson()).toList();
    return _json;
  }
}

class v1LoginUsage {
  /// Public key for authentication
  final String publicKey;

  const v1LoginUsage({
    required  this.publicKey,
  });

  factory v1LoginUsage.fromJson(Map<String, dynamic> json) {
    final _publicKey = json['publicKey'] as String;
    return v1LoginUsage(
      publicKey: _publicKey,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['publicKey'] = publicKey;
    return _json;
  }
}

class v1NOOPCodegenAnchorResponse {
  final v1WebAuthnStamp stamp;
  final v1TokenUsage? tokenUsage;

  const v1NOOPCodegenAnchorResponse({
    required  this.stamp,
     this.tokenUsage,
  });

  factory v1NOOPCodegenAnchorResponse.fromJson(Map<String, dynamic> json) {
    final _stamp = v1WebAuthnStamp.fromJson(json['stamp'] as Map<String, dynamic>);
    final _tokenUsage = json['tokenUsage'] == null ? null : v1TokenUsage.fromJson(json['tokenUsage'] as Map<String, dynamic>);
    return v1NOOPCodegenAnchorResponse(
      stamp: _stamp,
      tokenUsage: _tokenUsage,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['stamp'] = stamp.toJson();
    if (tokenUsage != null) {
      _json['tokenUsage'] = tokenUsage?.toJson();
    }
    return _json;
  }
}

class v1NativeRevertError {
  /// The type of native error: 'error_string', 'panic', or 'execution_reverted'.
  final String? nativeType;
  /// The error message for Error(string) reverts.
  final String? message;
  /// The panic code for Panic(uint256) reverts.
  final String? panicCode;

  const v1NativeRevertError({
     this.nativeType,
     this.message,
     this.panicCode,
  });

  factory v1NativeRevertError.fromJson(Map<String, dynamic> json) {
    final _nativeType = json['nativeType'] as String?;
    final _message = json['message'] as String?;
    final _panicCode = json['panicCode'] as String?;
    return v1NativeRevertError(
      nativeType: _nativeType,
      message: _message,
      panicCode: _panicCode,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    if (nativeType != null) {
      _json['nativeType'] = nativeType;
    }
    if (message != null) {
      _json['message'] = message;
    }
    if (panicCode != null) {
      _json['panicCode'] = panicCode;
    }
    return _json;
  }
}

class v1Oauth2AuthenticateIntent {
  /// The OAuth 2.0 credential id whose client_id and client_secret will be used in the OAuth 2.0 flow
  final String oauth2CredentialId;
  /// The auth_code provided by the OAuth 2.0 provider to the end user to be exchanged for a Bearer token in the OAuth 2.0 flow
  final String authCode;
  /// The URI the user is redirected to after they have authenticated with the OAuth 2.0 provider
  final String redirectUri;
  /// The code verifier used by OAuth 2.0 PKCE providers
  final String codeVerifier;
  /// An optional nonce used by the client to prevent replay/substitution of an ID token
  final String? nonce;
  /// An optional P256 public key to which, if provided, the bearer token will be encrypted and returned via the `encrypted_bearer_token` claim of the OIDC Token
  final String? bearerTokenTargetPublicKey;

  const v1Oauth2AuthenticateIntent({
    required  this.oauth2CredentialId,
    required  this.authCode,
    required  this.redirectUri,
    required  this.codeVerifier,
     this.nonce,
     this.bearerTokenTargetPublicKey,
  });

  factory v1Oauth2AuthenticateIntent.fromJson(Map<String, dynamic> json) {
    final _oauth2CredentialId = json['oauth2CredentialId'] as String;
    final _authCode = json['authCode'] as String;
    final _redirectUri = json['redirectUri'] as String;
    final _codeVerifier = json['codeVerifier'] as String;
    final _nonce = json['nonce'] as String?;
    final _bearerTokenTargetPublicKey = json['bearerTokenTargetPublicKey'] as String?;
    return v1Oauth2AuthenticateIntent(
      oauth2CredentialId: _oauth2CredentialId,
      authCode: _authCode,
      redirectUri: _redirectUri,
      codeVerifier: _codeVerifier,
      nonce: _nonce,
      bearerTokenTargetPublicKey: _bearerTokenTargetPublicKey,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['oauth2CredentialId'] = oauth2CredentialId;
    _json['authCode'] = authCode;
    _json['redirectUri'] = redirectUri;
    _json['codeVerifier'] = codeVerifier;
    if (nonce != null) {
      _json['nonce'] = nonce;
    }
    if (bearerTokenTargetPublicKey != null) {
      _json['bearerTokenTargetPublicKey'] = bearerTokenTargetPublicKey;
    }
    return _json;
  }
}

class v1Oauth2AuthenticateRequest {
  final String type;
  /// Timestamp (in milliseconds) of the request, used to verify liveness of user requests.
  final String timestampMs;
  /// Unique identifier for a given Organization.
  final String organizationId;
  final v1Oauth2AuthenticateIntent parameters;
  final bool? generateAppProofs;

  const v1Oauth2AuthenticateRequest({
    required  this.type,
    required  this.timestampMs,
    required  this.organizationId,
    required  this.parameters,
     this.generateAppProofs,
  });

  factory v1Oauth2AuthenticateRequest.fromJson(Map<String, dynamic> json) {
    final _type = json['type'] as String;
    final _timestampMs = json['timestampMs'] as String;
    final _organizationId = json['organizationId'] as String;
    final _parameters = v1Oauth2AuthenticateIntent.fromJson(json['parameters'] as Map<String, dynamic>);
    final _generateAppProofs = json['generateAppProofs'] as bool?;
    return v1Oauth2AuthenticateRequest(
      type: _type,
      timestampMs: _timestampMs,
      organizationId: _organizationId,
      parameters: _parameters,
      generateAppProofs: _generateAppProofs,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['type'] = type;
    _json['timestampMs'] = timestampMs;
    _json['organizationId'] = organizationId;
    _json['parameters'] = parameters.toJson();
    if (generateAppProofs != null) {
      _json['generateAppProofs'] = generateAppProofs;
    }
    return _json;
  }
}

class v1Oauth2AuthenticateResult {
  /// Base64 encoded OIDC token issued by Turnkey to be used with the LoginWithOAuth activity
  final String oidcToken;

  const v1Oauth2AuthenticateResult({
    required  this.oidcToken,
  });

  factory v1Oauth2AuthenticateResult.fromJson(Map<String, dynamic> json) {
    final _oidcToken = json['oidcToken'] as String;
    return v1Oauth2AuthenticateResult(
      oidcToken: _oidcToken,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['oidcToken'] = oidcToken;
    return _json;
  }
}

class v1Oauth2Credential {
  /// Unique identifier for a given OAuth 2.0 Credential.
  final String oauth2CredentialId;
  /// Unique identifier for an Organization.
  final String organizationId;
  /// The provider for a given OAuth 2.0 Credential.
  final v1Oauth2Provider provider;
  /// The client id for a given OAuth 2.0 Credential.
  final String clientId;
  /// The encrypted client secret for a given OAuth 2.0 Credential encrypted to the TLS Fetcher quorum key.
  final String encryptedClientSecret;
  final externaldatav1Timestamp createdAt;
  final externaldatav1Timestamp updatedAt;

  const v1Oauth2Credential({
    required  this.oauth2CredentialId,
    required  this.organizationId,
    required  this.provider,
    required  this.clientId,
    required  this.encryptedClientSecret,
    required  this.createdAt,
    required  this.updatedAt,
  });

  factory v1Oauth2Credential.fromJson(Map<String, dynamic> json) {
    final _oauth2CredentialId = json['oauth2CredentialId'] as String;
    final _organizationId = json['organizationId'] as String;
    final _provider = v1Oauth2ProviderFromJson(json['provider']);
    final _clientId = json['clientId'] as String;
    final _encryptedClientSecret = json['encryptedClientSecret'] as String;
    final _createdAt = externaldatav1Timestamp.fromJson(json['createdAt'] as Map<String, dynamic>);
    final _updatedAt = externaldatav1Timestamp.fromJson(json['updatedAt'] as Map<String, dynamic>);
    return v1Oauth2Credential(
      oauth2CredentialId: _oauth2CredentialId,
      organizationId: _organizationId,
      provider: _provider,
      clientId: _clientId,
      encryptedClientSecret: _encryptedClientSecret,
      createdAt: _createdAt,
      updatedAt: _updatedAt,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['oauth2CredentialId'] = oauth2CredentialId;
    _json['organizationId'] = organizationId;
    _json['provider'] = v1Oauth2ProviderToJson(provider);
    _json['clientId'] = clientId;
    _json['encryptedClientSecret'] = encryptedClientSecret;
    _json['createdAt'] = createdAt.toJson();
    _json['updatedAt'] = updatedAt.toJson();
    return _json;
  }
}

class v1OauthIntent {
  /// Base64 encoded OIDC token
  final String oidcToken;
  /// Client-side public key generated by the user, to which the oauth bundle (credentials) will be encrypted.
  final String targetPublicKey;
  /// Optional human-readable name for an API Key. If none provided, default to Oauth - <Timestamp>
  final String? apiKeyName;
  /// Expiration window (in seconds) indicating how long the API key is valid for. If not provided, a default of 15 minutes will be used.
  final String? expirationSeconds;
  /// Invalidate all other previously generated Oauth API keys
  final bool? invalidateExisting;

  const v1OauthIntent({
    required  this.oidcToken,
    required  this.targetPublicKey,
     this.apiKeyName,
     this.expirationSeconds,
     this.invalidateExisting,
  });

  factory v1OauthIntent.fromJson(Map<String, dynamic> json) {
    final _oidcToken = json['oidcToken'] as String;
    final _targetPublicKey = json['targetPublicKey'] as String;
    final _apiKeyName = json['apiKeyName'] as String?;
    final _expirationSeconds = json['expirationSeconds'] as String?;
    final _invalidateExisting = json['invalidateExisting'] as bool?;
    return v1OauthIntent(
      oidcToken: _oidcToken,
      targetPublicKey: _targetPublicKey,
      apiKeyName: _apiKeyName,
      expirationSeconds: _expirationSeconds,
      invalidateExisting: _invalidateExisting,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['oidcToken'] = oidcToken;
    _json['targetPublicKey'] = targetPublicKey;
    if (apiKeyName != null) {
      _json['apiKeyName'] = apiKeyName;
    }
    if (expirationSeconds != null) {
      _json['expirationSeconds'] = expirationSeconds;
    }
    if (invalidateExisting != null) {
      _json['invalidateExisting'] = invalidateExisting;
    }
    return _json;
  }
}

class v1OauthLoginIntent {
  /// Base64 encoded OIDC token
  final String oidcToken;
  /// Client-side public key generated by the user, which will be conditionally added to org data based on the validity of the oidc token associated with this request
  final String publicKey;
  /// Expiration window (in seconds) indicating how long the Session is valid for. If not provided, a default of 15 minutes will be used.
  final String? expirationSeconds;
  /// Invalidate all other previously generated Login API keys
  final bool? invalidateExisting;

  const v1OauthLoginIntent({
    required  this.oidcToken,
    required  this.publicKey,
     this.expirationSeconds,
     this.invalidateExisting,
  });

  factory v1OauthLoginIntent.fromJson(Map<String, dynamic> json) {
    final _oidcToken = json['oidcToken'] as String;
    final _publicKey = json['publicKey'] as String;
    final _expirationSeconds = json['expirationSeconds'] as String?;
    final _invalidateExisting = json['invalidateExisting'] as bool?;
    return v1OauthLoginIntent(
      oidcToken: _oidcToken,
      publicKey: _publicKey,
      expirationSeconds: _expirationSeconds,
      invalidateExisting: _invalidateExisting,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['oidcToken'] = oidcToken;
    _json['publicKey'] = publicKey;
    if (expirationSeconds != null) {
      _json['expirationSeconds'] = expirationSeconds;
    }
    if (invalidateExisting != null) {
      _json['invalidateExisting'] = invalidateExisting;
    }
    return _json;
  }
}

class v1OauthLoginRequest {
  final String type;
  /// Timestamp (in milliseconds) of the request, used to verify liveness of user requests.
  final String timestampMs;
  /// Unique identifier for a given Organization.
  final String organizationId;
  final v1OauthLoginIntent parameters;
  final bool? generateAppProofs;

  const v1OauthLoginRequest({
    required  this.type,
    required  this.timestampMs,
    required  this.organizationId,
    required  this.parameters,
     this.generateAppProofs,
  });

  factory v1OauthLoginRequest.fromJson(Map<String, dynamic> json) {
    final _type = json['type'] as String;
    final _timestampMs = json['timestampMs'] as String;
    final _organizationId = json['organizationId'] as String;
    final _parameters = v1OauthLoginIntent.fromJson(json['parameters'] as Map<String, dynamic>);
    final _generateAppProofs = json['generateAppProofs'] as bool?;
    return v1OauthLoginRequest(
      type: _type,
      timestampMs: _timestampMs,
      organizationId: _organizationId,
      parameters: _parameters,
      generateAppProofs: _generateAppProofs,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['type'] = type;
    _json['timestampMs'] = timestampMs;
    _json['organizationId'] = organizationId;
    _json['parameters'] = parameters.toJson();
    if (generateAppProofs != null) {
      _json['generateAppProofs'] = generateAppProofs;
    }
    return _json;
  }
}

class v1OauthLoginResult {
  /// Signed JWT containing an expiry, public key, session type, user id, and organization id
  final String session;

  const v1OauthLoginResult({
    required  this.session,
  });

  factory v1OauthLoginResult.fromJson(Map<String, dynamic> json) {
    final _session = json['session'] as String;
    return v1OauthLoginResult(
      session: _session,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['session'] = session;
    return _json;
  }
}

class v1OauthProvider {
  /// Unique identifier for an OAuth Provider
  final String providerId;
  /// Human-readable name to identify a Provider.
  final String providerName;
  /// The issuer of the token, typically a URL indicating the authentication server, e.g https://accounts.google.com
  final String issuer;
  /// Expected audience ('aud' attribute of the signed token) which represents the app ID
  final String audience;
  /// Expected subject ('sub' attribute of the signed token) which represents the user ID
  final String subject;
  final externaldatav1Timestamp createdAt;
  final externaldatav1Timestamp updatedAt;

  const v1OauthProvider({
    required  this.providerId,
    required  this.providerName,
    required  this.issuer,
    required  this.audience,
    required  this.subject,
    required  this.createdAt,
    required  this.updatedAt,
  });

  factory v1OauthProvider.fromJson(Map<String, dynamic> json) {
    final _providerId = json['providerId'] as String;
    final _providerName = json['providerName'] as String;
    final _issuer = json['issuer'] as String;
    final _audience = json['audience'] as String;
    final _subject = json['subject'] as String;
    final _createdAt = externaldatav1Timestamp.fromJson(json['createdAt'] as Map<String, dynamic>);
    final _updatedAt = externaldatav1Timestamp.fromJson(json['updatedAt'] as Map<String, dynamic>);
    return v1OauthProvider(
      providerId: _providerId,
      providerName: _providerName,
      issuer: _issuer,
      audience: _audience,
      subject: _subject,
      createdAt: _createdAt,
      updatedAt: _updatedAt,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['providerId'] = providerId;
    _json['providerName'] = providerName;
    _json['issuer'] = issuer;
    _json['audience'] = audience;
    _json['subject'] = subject;
    _json['createdAt'] = createdAt.toJson();
    _json['updatedAt'] = updatedAt.toJson();
    return _json;
  }
}

class v1OauthProviderParams {
  /// Human-readable name to identify a Provider.
  final String providerName;
  /// Base64 encoded OIDC token
  final String oidcToken;

  const v1OauthProviderParams({
    required  this.providerName,
    required  this.oidcToken,
  });

  factory v1OauthProviderParams.fromJson(Map<String, dynamic> json) {
    final _providerName = json['providerName'] as String;
    final _oidcToken = json['oidcToken'] as String;
    return v1OauthProviderParams(
      providerName: _providerName,
      oidcToken: _oidcToken,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['providerName'] = providerName;
    _json['oidcToken'] = oidcToken;
    return _json;
  }
}

class v1OauthRequest {
  final String type;
  /// Timestamp (in milliseconds) of the request, used to verify liveness of user requests.
  final String timestampMs;
  /// Unique identifier for a given Organization.
  final String organizationId;
  final v1OauthIntent parameters;
  final bool? generateAppProofs;

  const v1OauthRequest({
    required  this.type,
    required  this.timestampMs,
    required  this.organizationId,
    required  this.parameters,
     this.generateAppProofs,
  });

  factory v1OauthRequest.fromJson(Map<String, dynamic> json) {
    final _type = json['type'] as String;
    final _timestampMs = json['timestampMs'] as String;
    final _organizationId = json['organizationId'] as String;
    final _parameters = v1OauthIntent.fromJson(json['parameters'] as Map<String, dynamic>);
    final _generateAppProofs = json['generateAppProofs'] as bool?;
    return v1OauthRequest(
      type: _type,
      timestampMs: _timestampMs,
      organizationId: _organizationId,
      parameters: _parameters,
      generateAppProofs: _generateAppProofs,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['type'] = type;
    _json['timestampMs'] = timestampMs;
    _json['organizationId'] = organizationId;
    _json['parameters'] = parameters.toJson();
    if (generateAppProofs != null) {
      _json['generateAppProofs'] = generateAppProofs;
    }
    return _json;
  }
}

class v1OauthResult {
  /// Unique identifier for the authenticating User.
  final String userId;
  /// Unique identifier for the created API key.
  final String apiKeyId;
  /// HPKE encrypted credential bundle
  final String credentialBundle;

  const v1OauthResult({
    required  this.userId,
    required  this.apiKeyId,
    required  this.credentialBundle,
  });

  factory v1OauthResult.fromJson(Map<String, dynamic> json) {
    final _userId = json['userId'] as String;
    final _apiKeyId = json['apiKeyId'] as String;
    final _credentialBundle = json['credentialBundle'] as String;
    return v1OauthResult(
      userId: _userId,
      apiKeyId: _apiKeyId,
      credentialBundle: _credentialBundle,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['userId'] = userId;
    _json['apiKeyId'] = apiKeyId;
    _json['credentialBundle'] = credentialBundle;
    return _json;
  }
}

class v1OrganizationData {
  final String? organizationId;
  final String? name;
  final List<v1User>? users;
  final List<v1Policy>? policies;
  final List<v1PrivateKey>? privateKeys;
  final List<v1Invitation>? invitations;
  final List<datav1Tag>? tags;
  final externaldatav1Quorum? rootQuorum;
  final List<v1Feature>? features;
  final List<v1Wallet>? wallets;
  final List<v1SmartContractInterfaceReference>? smartContractInterfaceReferences;

  const v1OrganizationData({
     this.organizationId,
     this.name,
     this.users,
     this.policies,
     this.privateKeys,
     this.invitations,
     this.tags,
     this.rootQuorum,
     this.features,
     this.wallets,
     this.smartContractInterfaceReferences,
  });

  factory v1OrganizationData.fromJson(Map<String, dynamic> json) {
    final _organizationId = json['organizationId'] as String?;
    final _name = json['name'] as String?;
    final _users = (json['users'] as List?)?.map((e) => v1User.fromJson(e as Map<String, dynamic>)).toList();
    final _policies = (json['policies'] as List?)?.map((e) => v1Policy.fromJson(e as Map<String, dynamic>)).toList();
    final _privateKeys = (json['privateKeys'] as List?)?.map((e) => v1PrivateKey.fromJson(e as Map<String, dynamic>)).toList();
    final _invitations = (json['invitations'] as List?)?.map((e) => v1Invitation.fromJson(e as Map<String, dynamic>)).toList();
    final _tags = (json['tags'] as List?)?.map((e) => datav1Tag.fromJson(e as Map<String, dynamic>)).toList();
    final _rootQuorum = json['rootQuorum'] == null ? null : externaldatav1Quorum.fromJson(json['rootQuorum'] as Map<String, dynamic>);
    final _features = (json['features'] as List?)?.map((e) => v1Feature.fromJson(e as Map<String, dynamic>)).toList();
    final _wallets = (json['wallets'] as List?)?.map((e) => v1Wallet.fromJson(e as Map<String, dynamic>)).toList();
    final _smartContractInterfaceReferences = (json['smartContractInterfaceReferences'] as List?)?.map((e) => v1SmartContractInterfaceReference.fromJson(e as Map<String, dynamic>)).toList();
    return v1OrganizationData(
      organizationId: _organizationId,
      name: _name,
      users: _users,
      policies: _policies,
      privateKeys: _privateKeys,
      invitations: _invitations,
      tags: _tags,
      rootQuorum: _rootQuorum,
      features: _features,
      wallets: _wallets,
      smartContractInterfaceReferences: _smartContractInterfaceReferences,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    if (organizationId != null) {
      _json['organizationId'] = organizationId;
    }
    if (name != null) {
      _json['name'] = name;
    }
    if (users != null) {
      _json['users'] = users?.map((e) => e.toJson()).toList();
    }
    if (policies != null) {
      _json['policies'] = policies?.map((e) => e.toJson()).toList();
    }
    if (privateKeys != null) {
      _json['privateKeys'] = privateKeys?.map((e) => e.toJson()).toList();
    }
    if (invitations != null) {
      _json['invitations'] = invitations?.map((e) => e.toJson()).toList();
    }
    if (tags != null) {
      _json['tags'] = tags?.map((e) => e.toJson()).toList();
    }
    if (rootQuorum != null) {
      _json['rootQuorum'] = rootQuorum?.toJson();
    }
    if (features != null) {
      _json['features'] = features?.map((e) => e.toJson()).toList();
    }
    if (wallets != null) {
      _json['wallets'] = wallets?.map((e) => e.toJson()).toList();
    }
    if (smartContractInterfaceReferences != null) {
      _json['smartContractInterfaceReferences'] = smartContractInterfaceReferences?.map((e) => e.toJson()).toList();
    }
    return _json;
  }
}

class v1OtpAuthIntent {
  /// ID representing the result of an init OTP activity.
  final String otpId;
  /// OTP sent out to a user's contact (email or SMS)
  final String otpCode;
  /// Client-side public key generated by the user, to which the OTP bundle (credentials) will be encrypted.
  final String targetPublicKey;
  /// Optional human-readable name for an API Key. If none provided, default to OTP Auth - <Timestamp>
  final String? apiKeyName;
  /// Expiration window (in seconds) indicating how long the API key is valid for. If not provided, a default of 15 minutes will be used.
  final String? expirationSeconds;
  /// Invalidate all other previously generated OTP Auth API keys
  final bool? invalidateExisting;

  const v1OtpAuthIntent({
    required  this.otpId,
    required  this.otpCode,
    required  this.targetPublicKey,
     this.apiKeyName,
     this.expirationSeconds,
     this.invalidateExisting,
  });

  factory v1OtpAuthIntent.fromJson(Map<String, dynamic> json) {
    final _otpId = json['otpId'] as String;
    final _otpCode = json['otpCode'] as String;
    final _targetPublicKey = json['targetPublicKey'] as String;
    final _apiKeyName = json['apiKeyName'] as String?;
    final _expirationSeconds = json['expirationSeconds'] as String?;
    final _invalidateExisting = json['invalidateExisting'] as bool?;
    return v1OtpAuthIntent(
      otpId: _otpId,
      otpCode: _otpCode,
      targetPublicKey: _targetPublicKey,
      apiKeyName: _apiKeyName,
      expirationSeconds: _expirationSeconds,
      invalidateExisting: _invalidateExisting,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['otpId'] = otpId;
    _json['otpCode'] = otpCode;
    _json['targetPublicKey'] = targetPublicKey;
    if (apiKeyName != null) {
      _json['apiKeyName'] = apiKeyName;
    }
    if (expirationSeconds != null) {
      _json['expirationSeconds'] = expirationSeconds;
    }
    if (invalidateExisting != null) {
      _json['invalidateExisting'] = invalidateExisting;
    }
    return _json;
  }
}

class v1OtpAuthRequest {
  final String type;
  /// Timestamp (in milliseconds) of the request, used to verify liveness of user requests.
  final String timestampMs;
  /// Unique identifier for a given Organization.
  final String organizationId;
  final v1OtpAuthIntent parameters;
  final bool? generateAppProofs;

  const v1OtpAuthRequest({
    required  this.type,
    required  this.timestampMs,
    required  this.organizationId,
    required  this.parameters,
     this.generateAppProofs,
  });

  factory v1OtpAuthRequest.fromJson(Map<String, dynamic> json) {
    final _type = json['type'] as String;
    final _timestampMs = json['timestampMs'] as String;
    final _organizationId = json['organizationId'] as String;
    final _parameters = v1OtpAuthIntent.fromJson(json['parameters'] as Map<String, dynamic>);
    final _generateAppProofs = json['generateAppProofs'] as bool?;
    return v1OtpAuthRequest(
      type: _type,
      timestampMs: _timestampMs,
      organizationId: _organizationId,
      parameters: _parameters,
      generateAppProofs: _generateAppProofs,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['type'] = type;
    _json['timestampMs'] = timestampMs;
    _json['organizationId'] = organizationId;
    _json['parameters'] = parameters.toJson();
    if (generateAppProofs != null) {
      _json['generateAppProofs'] = generateAppProofs;
    }
    return _json;
  }
}

class v1OtpAuthResult {
  /// Unique identifier for the authenticating User.
  final String userId;
  /// Unique identifier for the created API key.
  final String? apiKeyId;
  /// HPKE encrypted credential bundle
  final String? credentialBundle;

  const v1OtpAuthResult({
    required  this.userId,
     this.apiKeyId,
     this.credentialBundle,
  });

  factory v1OtpAuthResult.fromJson(Map<String, dynamic> json) {
    final _userId = json['userId'] as String;
    final _apiKeyId = json['apiKeyId'] as String?;
    final _credentialBundle = json['credentialBundle'] as String?;
    return v1OtpAuthResult(
      userId: _userId,
      apiKeyId: _apiKeyId,
      credentialBundle: _credentialBundle,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['userId'] = userId;
    if (apiKeyId != null) {
      _json['apiKeyId'] = apiKeyId;
    }
    if (credentialBundle != null) {
      _json['credentialBundle'] = credentialBundle;
    }
    return _json;
  }
}

class v1OtpLoginIntent {
  /// Signed JWT containing a unique id, expiry, verification type, contact
  final String verificationToken;
  /// Client-side public key generated by the user, which will be conditionally added to org data based on the validity of the verification token
  final String publicKey;
  /// Expiration window (in seconds) indicating how long the Session is valid for. If not provided, a default of 15 minutes will be used.
  final String? expirationSeconds;
  /// Invalidate all other previously generated Login API keys
  final bool? invalidateExisting;
  /// Optional signature proving authorization for this login. The signature is over the verification token ID and the public key. Only required if a public key was provided during the verification step.
  final v1ClientSignature? clientSignature;

  const v1OtpLoginIntent({
    required  this.verificationToken,
    required  this.publicKey,
     this.expirationSeconds,
     this.invalidateExisting,
     this.clientSignature,
  });

  factory v1OtpLoginIntent.fromJson(Map<String, dynamic> json) {
    final _verificationToken = json['verificationToken'] as String;
    final _publicKey = json['publicKey'] as String;
    final _expirationSeconds = json['expirationSeconds'] as String?;
    final _invalidateExisting = json['invalidateExisting'] as bool?;
    final _clientSignature = json['clientSignature'] == null ? null : v1ClientSignature.fromJson(json['clientSignature'] as Map<String, dynamic>);
    return v1OtpLoginIntent(
      verificationToken: _verificationToken,
      publicKey: _publicKey,
      expirationSeconds: _expirationSeconds,
      invalidateExisting: _invalidateExisting,
      clientSignature: _clientSignature,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['verificationToken'] = verificationToken;
    _json['publicKey'] = publicKey;
    if (expirationSeconds != null) {
      _json['expirationSeconds'] = expirationSeconds;
    }
    if (invalidateExisting != null) {
      _json['invalidateExisting'] = invalidateExisting;
    }
    if (clientSignature != null) {
      _json['clientSignature'] = clientSignature?.toJson();
    }
    return _json;
  }
}

class v1OtpLoginRequest {
  final String type;
  /// Timestamp (in milliseconds) of the request, used to verify liveness of user requests.
  final String timestampMs;
  /// Unique identifier for a given Organization.
  final String organizationId;
  final v1OtpLoginIntent parameters;
  final bool? generateAppProofs;

  const v1OtpLoginRequest({
    required  this.type,
    required  this.timestampMs,
    required  this.organizationId,
    required  this.parameters,
     this.generateAppProofs,
  });

  factory v1OtpLoginRequest.fromJson(Map<String, dynamic> json) {
    final _type = json['type'] as String;
    final _timestampMs = json['timestampMs'] as String;
    final _organizationId = json['organizationId'] as String;
    final _parameters = v1OtpLoginIntent.fromJson(json['parameters'] as Map<String, dynamic>);
    final _generateAppProofs = json['generateAppProofs'] as bool?;
    return v1OtpLoginRequest(
      type: _type,
      timestampMs: _timestampMs,
      organizationId: _organizationId,
      parameters: _parameters,
      generateAppProofs: _generateAppProofs,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['type'] = type;
    _json['timestampMs'] = timestampMs;
    _json['organizationId'] = organizationId;
    _json['parameters'] = parameters.toJson();
    if (generateAppProofs != null) {
      _json['generateAppProofs'] = generateAppProofs;
    }
    return _json;
  }
}

class v1OtpLoginResult {
  /// Signed JWT containing an expiry, public key, session type, user id, and organization id
  final String session;

  const v1OtpLoginResult({
    required  this.session,
  });

  factory v1OtpLoginResult.fromJson(Map<String, dynamic> json) {
    final _session = json['session'] as String;
    return v1OtpLoginResult(
      session: _session,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['session'] = session;
    return _json;
  }
}

class v1Pagination {
  /// A limit of the number of object to be returned, between 1 and 100. Defaults to 10.
  final String? limit;
  /// A pagination cursor. This is an object ID that enables you to fetch all objects before this ID.
  final String? before;
  /// A pagination cursor. This is an object ID that enables you to fetch all objects after this ID.
  final String? after;

  const v1Pagination({
     this.limit,
     this.before,
     this.after,
  });

  factory v1Pagination.fromJson(Map<String, dynamic> json) {
    final _limit = json['limit'] as String?;
    final _before = json['before'] as String?;
    final _after = json['after'] as String?;
    return v1Pagination(
      limit: _limit,
      before: _before,
      after: _after,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    if (limit != null) {
      _json['limit'] = limit;
    }
    if (before != null) {
      _json['before'] = before;
    }
    if (after != null) {
      _json['after'] = after;
    }
    return _json;
  }
}

class v1Policy {
  /// Unique identifier for a given Policy.
  final String policyId;
  /// Human-readable name for a Policy.
  final String policyName;
  /// The instruction to DENY or ALLOW a particular activity following policy selector(s).
  final v1Effect effect;
  final externaldatav1Timestamp createdAt;
  final externaldatav1Timestamp updatedAt;
  /// Human-readable notes added by a User to describe a particular policy.
  final String notes;
  /// A consensus expression that evalutes to true or false.
  final String consensus;
  /// A condition expression that evalutes to true or false.
  final String condition;

  const v1Policy({
    required  this.policyId,
    required  this.policyName,
    required  this.effect,
    required  this.createdAt,
    required  this.updatedAt,
    required  this.notes,
    required  this.consensus,
    required  this.condition,
  });

  factory v1Policy.fromJson(Map<String, dynamic> json) {
    final _policyId = json['policyId'] as String;
    final _policyName = json['policyName'] as String;
    final _effect = v1EffectFromJson(json['effect']);
    final _createdAt = externaldatav1Timestamp.fromJson(json['createdAt'] as Map<String, dynamic>);
    final _updatedAt = externaldatav1Timestamp.fromJson(json['updatedAt'] as Map<String, dynamic>);
    final _notes = json['notes'] as String;
    final _consensus = json['consensus'] as String;
    final _condition = json['condition'] as String;
    return v1Policy(
      policyId: _policyId,
      policyName: _policyName,
      effect: _effect,
      createdAt: _createdAt,
      updatedAt: _updatedAt,
      notes: _notes,
      consensus: _consensus,
      condition: _condition,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['policyId'] = policyId;
    _json['policyName'] = policyName;
    _json['effect'] = v1EffectToJson(effect);
    _json['createdAt'] = createdAt.toJson();
    _json['updatedAt'] = updatedAt.toJson();
    _json['notes'] = notes;
    _json['consensus'] = consensus;
    _json['condition'] = condition;
    return _json;
  }
}

class v1PrivateKey {
  /// Unique identifier for a given Private Key.
  final String privateKeyId;
  /// The public component of a cryptographic key pair used to sign messages and transactions.
  final String publicKey;
  /// Human-readable name for a Private Key.
  final String privateKeyName;
  /// Cryptographic Curve used to generate a given Private Key.
  final v1Curve curve;
  /// Derived cryptocurrency addresses for a given Private Key.
  final List<externaldatav1Address> addresses;
  /// A list of Private Key Tag IDs.
  final List<String> privateKeyTags;
  final externaldatav1Timestamp createdAt;
  final externaldatav1Timestamp updatedAt;
  /// True when a given Private Key is exported, false otherwise.
  final bool exported;
  /// True when a given Private Key is imported, false otherwise.
  final bool imported;

  const v1PrivateKey({
    required  this.privateKeyId,
    required  this.publicKey,
    required  this.privateKeyName,
    required  this.curve,
    required  this.addresses,
    required  this.privateKeyTags,
    required  this.createdAt,
    required  this.updatedAt,
    required  this.exported,
    required  this.imported,
  });

  factory v1PrivateKey.fromJson(Map<String, dynamic> json) {
    final _privateKeyId = json['privateKeyId'] as String;
    final _publicKey = json['publicKey'] as String;
    final _privateKeyName = json['privateKeyName'] as String;
    final _curve = v1CurveFromJson(json['curve']);
    final _addresses = (json['addresses'] as List).map((e) => externaldatav1Address.fromJson(e as Map<String, dynamic>)).toList();
    final _privateKeyTags = (json['privateKeyTags'] as List).map((e) => e as String).toList();
    final _createdAt = externaldatav1Timestamp.fromJson(json['createdAt'] as Map<String, dynamic>);
    final _updatedAt = externaldatav1Timestamp.fromJson(json['updatedAt'] as Map<String, dynamic>);
    final _exported = json['exported'] as bool;
    final _imported = json['imported'] as bool;
    return v1PrivateKey(
      privateKeyId: _privateKeyId,
      publicKey: _publicKey,
      privateKeyName: _privateKeyName,
      curve: _curve,
      addresses: _addresses,
      privateKeyTags: _privateKeyTags,
      createdAt: _createdAt,
      updatedAt: _updatedAt,
      exported: _exported,
      imported: _imported,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['privateKeyId'] = privateKeyId;
    _json['publicKey'] = publicKey;
    _json['privateKeyName'] = privateKeyName;
    _json['curve'] = v1CurveToJson(curve);
    _json['addresses'] = addresses.map((e) => e.toJson()).toList();
    _json['privateKeyTags'] = privateKeyTags;
    _json['createdAt'] = createdAt.toJson();
    _json['updatedAt'] = updatedAt.toJson();
    _json['exported'] = exported;
    _json['imported'] = imported;
    return _json;
  }
}

class v1PrivateKeyParams {
  /// Human-readable name for a Private Key.
  final String privateKeyName;
  /// Cryptographic Curve used to generate a given Private Key.
  final v1Curve curve;
  /// A list of Private Key Tag IDs. This field, if not needed, should be an empty array in your request body.
  final List<String> privateKeyTags;
  /// Cryptocurrency-specific formats for a derived address (e.g., Ethereum).
  final List<v1AddressFormat> addressFormats;

  const v1PrivateKeyParams({
    required  this.privateKeyName,
    required  this.curve,
    required  this.privateKeyTags,
    required  this.addressFormats,
  });

  factory v1PrivateKeyParams.fromJson(Map<String, dynamic> json) {
    final _privateKeyName = json['privateKeyName'] as String;
    final _curve = v1CurveFromJson(json['curve']);
    final _privateKeyTags = (json['privateKeyTags'] as List).map((e) => e as String).toList();
    final _addressFormats = (json['addressFormats'] as List).map((e) => v1AddressFormatFromJson(e)).toList();
    return v1PrivateKeyParams(
      privateKeyName: _privateKeyName,
      curve: _curve,
      privateKeyTags: _privateKeyTags,
      addressFormats: _addressFormats,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['privateKeyName'] = privateKeyName;
    _json['curve'] = v1CurveToJson(curve);
    _json['privateKeyTags'] = privateKeyTags;
    _json['addressFormats'] = addressFormats.map((e) => v1AddressFormatToJson(e)).toList();
    return _json;
  }
}

class v1PrivateKeyResult {
  final String? privateKeyId;
  final List<immutableactivityv1Address>? addresses;

  const v1PrivateKeyResult({
     this.privateKeyId,
     this.addresses,
  });

  factory v1PrivateKeyResult.fromJson(Map<String, dynamic> json) {
    final _privateKeyId = json['privateKeyId'] as String?;
    final _addresses = (json['addresses'] as List?)?.map((e) => immutableactivityv1Address.fromJson(e as Map<String, dynamic>)).toList();
    return v1PrivateKeyResult(
      privateKeyId: _privateKeyId,
      addresses: _addresses,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    if (privateKeyId != null) {
      _json['privateKeyId'] = privateKeyId;
    }
    if (addresses != null) {
      _json['addresses'] = addresses?.map((e) => e.toJson()).toList();
    }
    return _json;
  }
}

class v1PublicKeyCredentialWithAttestation {
  final String id;
  final String type;
  final String rawId;
  final String? authenticatorAttachment;
  final v1AuthenticatorAttestationResponse response;
  final v1SimpleClientExtensionResults clientExtensionResults;

  const v1PublicKeyCredentialWithAttestation({
    required  this.id,
    required  this.type,
    required  this.rawId,
     this.authenticatorAttachment,
    required  this.response,
    required  this.clientExtensionResults,
  });

  factory v1PublicKeyCredentialWithAttestation.fromJson(Map<String, dynamic> json) {
    final _id = json['id'] as String;
    final _type = json['type'] as String;
    final _rawId = json['rawId'] as String;
    final _authenticatorAttachment = json['authenticatorAttachment'] as String?;
    final _response = v1AuthenticatorAttestationResponse.fromJson(json['response'] as Map<String, dynamic>);
    final _clientExtensionResults = v1SimpleClientExtensionResults.fromJson(json['clientExtensionResults'] as Map<String, dynamic>);
    return v1PublicKeyCredentialWithAttestation(
      id: _id,
      type: _type,
      rawId: _rawId,
      authenticatorAttachment: _authenticatorAttachment,
      response: _response,
      clientExtensionResults: _clientExtensionResults,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['id'] = id;
    _json['type'] = type;
    _json['rawId'] = rawId;
    if (authenticatorAttachment != null) {
      _json['authenticatorAttachment'] = authenticatorAttachment;
    }
    _json['response'] = response.toJson();
    _json['clientExtensionResults'] = clientExtensionResults.toJson();
    return _json;
  }
}

class v1RecoverUserIntent {
  /// The new authenticator to register.
  final v1AuthenticatorParamsV2 authenticator;
  /// Unique identifier for the user performing recovery.
  final String userId;

  const v1RecoverUserIntent({
    required  this.authenticator,
    required  this.userId,
  });

  factory v1RecoverUserIntent.fromJson(Map<String, dynamic> json) {
    final _authenticator = v1AuthenticatorParamsV2.fromJson(json['authenticator'] as Map<String, dynamic>);
    final _userId = json['userId'] as String;
    return v1RecoverUserIntent(
      authenticator: _authenticator,
      userId: _userId,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['authenticator'] = authenticator.toJson();
    _json['userId'] = userId;
    return _json;
  }
}

class v1RecoverUserRequest {
  final String type;
  /// Timestamp (in milliseconds) of the request, used to verify liveness of user requests.
  final String timestampMs;
  /// Unique identifier for a given Organization.
  final String organizationId;
  final v1RecoverUserIntent parameters;
  final bool? generateAppProofs;

  const v1RecoverUserRequest({
    required  this.type,
    required  this.timestampMs,
    required  this.organizationId,
    required  this.parameters,
     this.generateAppProofs,
  });

  factory v1RecoverUserRequest.fromJson(Map<String, dynamic> json) {
    final _type = json['type'] as String;
    final _timestampMs = json['timestampMs'] as String;
    final _organizationId = json['organizationId'] as String;
    final _parameters = v1RecoverUserIntent.fromJson(json['parameters'] as Map<String, dynamic>);
    final _generateAppProofs = json['generateAppProofs'] as bool?;
    return v1RecoverUserRequest(
      type: _type,
      timestampMs: _timestampMs,
      organizationId: _organizationId,
      parameters: _parameters,
      generateAppProofs: _generateAppProofs,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['type'] = type;
    _json['timestampMs'] = timestampMs;
    _json['organizationId'] = organizationId;
    _json['parameters'] = parameters.toJson();
    if (generateAppProofs != null) {
      _json['generateAppProofs'] = generateAppProofs;
    }
    return _json;
  }
}

class v1RecoverUserResult {
  /// ID of the authenticator created.
  final List<String> authenticatorId;

  const v1RecoverUserResult({
    required  this.authenticatorId,
  });

  factory v1RecoverUserResult.fromJson(Map<String, dynamic> json) {
    final _authenticatorId = (json['authenticatorId'] as List).map((e) => e as String).toList();
    return v1RecoverUserResult(
      authenticatorId: _authenticatorId,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['authenticatorId'] = authenticatorId;
    return _json;
  }
}

class v1RefreshFeatureFlagsRequest {
  const v1RefreshFeatureFlagsRequest();
  factory v1RefreshFeatureFlagsRequest.fromJson(Map<String, dynamic> json) => const v1RefreshFeatureFlagsRequest();
  Map<String, dynamic> toJson() => {};
}

class v1RefreshFeatureFlagsResponse {
  const v1RefreshFeatureFlagsResponse();
  factory v1RefreshFeatureFlagsResponse.fromJson(Map<String, dynamic> json) => const v1RefreshFeatureFlagsResponse();
  Map<String, dynamic> toJson() => {};
}

class v1RejectActivityIntent {
  /// An artifact verifying a User's action.
  final String fingerprint;

  const v1RejectActivityIntent({
    required  this.fingerprint,
  });

  factory v1RejectActivityIntent.fromJson(Map<String, dynamic> json) {
    final _fingerprint = json['fingerprint'] as String;
    return v1RejectActivityIntent(
      fingerprint: _fingerprint,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['fingerprint'] = fingerprint;
    return _json;
  }
}

class v1RejectActivityRequest {
  final String type;
  /// Timestamp (in milliseconds) of the request, used to verify liveness of user requests.
  final String timestampMs;
  /// Unique identifier for a given Organization.
  final String organizationId;
  final v1RejectActivityIntent parameters;
  final bool? generateAppProofs;

  const v1RejectActivityRequest({
    required  this.type,
    required  this.timestampMs,
    required  this.organizationId,
    required  this.parameters,
     this.generateAppProofs,
  });

  factory v1RejectActivityRequest.fromJson(Map<String, dynamic> json) {
    final _type = json['type'] as String;
    final _timestampMs = json['timestampMs'] as String;
    final _organizationId = json['organizationId'] as String;
    final _parameters = v1RejectActivityIntent.fromJson(json['parameters'] as Map<String, dynamic>);
    final _generateAppProofs = json['generateAppProofs'] as bool?;
    return v1RejectActivityRequest(
      type: _type,
      timestampMs: _timestampMs,
      organizationId: _organizationId,
      parameters: _parameters,
      generateAppProofs: _generateAppProofs,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['type'] = type;
    _json['timestampMs'] = timestampMs;
    _json['organizationId'] = organizationId;
    _json['parameters'] = parameters.toJson();
    if (generateAppProofs != null) {
      _json['generateAppProofs'] = generateAppProofs;
    }
    return _json;
  }
}

class v1RemoveOrganizationFeatureIntent {
  /// Name of the feature to remove
  final v1FeatureName name;

  const v1RemoveOrganizationFeatureIntent({
    required  this.name,
  });

  factory v1RemoveOrganizationFeatureIntent.fromJson(Map<String, dynamic> json) {
    final _name = v1FeatureNameFromJson(json['name']);
    return v1RemoveOrganizationFeatureIntent(
      name: _name,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['name'] = v1FeatureNameToJson(name);
    return _json;
  }
}

class v1RemoveOrganizationFeatureRequest {
  final String type;
  /// Timestamp (in milliseconds) of the request, used to verify liveness of user requests.
  final String timestampMs;
  /// Unique identifier for a given Organization.
  final String organizationId;
  final v1RemoveOrganizationFeatureIntent parameters;
  final bool? generateAppProofs;

  const v1RemoveOrganizationFeatureRequest({
    required  this.type,
    required  this.timestampMs,
    required  this.organizationId,
    required  this.parameters,
     this.generateAppProofs,
  });

  factory v1RemoveOrganizationFeatureRequest.fromJson(Map<String, dynamic> json) {
    final _type = json['type'] as String;
    final _timestampMs = json['timestampMs'] as String;
    final _organizationId = json['organizationId'] as String;
    final _parameters = v1RemoveOrganizationFeatureIntent.fromJson(json['parameters'] as Map<String, dynamic>);
    final _generateAppProofs = json['generateAppProofs'] as bool?;
    return v1RemoveOrganizationFeatureRequest(
      type: _type,
      timestampMs: _timestampMs,
      organizationId: _organizationId,
      parameters: _parameters,
      generateAppProofs: _generateAppProofs,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['type'] = type;
    _json['timestampMs'] = timestampMs;
    _json['organizationId'] = organizationId;
    _json['parameters'] = parameters.toJson();
    if (generateAppProofs != null) {
      _json['generateAppProofs'] = generateAppProofs;
    }
    return _json;
  }
}

class v1RemoveOrganizationFeatureResult {
  /// Resulting list of organization features.
  final List<v1Feature> features;

  const v1RemoveOrganizationFeatureResult({
    required  this.features,
  });

  factory v1RemoveOrganizationFeatureResult.fromJson(Map<String, dynamic> json) {
    final _features = (json['features'] as List).map((e) => v1Feature.fromJson(e as Map<String, dynamic>)).toList();
    return v1RemoveOrganizationFeatureResult(
      features: _features,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['features'] = features.map((e) => e.toJson()).toList();
    return _json;
  }
}

class v1Result {
  final v1CreateOrganizationResult? createOrganizationResult;
  final v1CreateAuthenticatorsResult? createAuthenticatorsResult;
  final v1CreateUsersResult? createUsersResult;
  final v1CreatePrivateKeysResult? createPrivateKeysResult;
  final v1CreateInvitationsResult? createInvitationsResult;
  final v1AcceptInvitationResult? acceptInvitationResult;
  final v1SignRawPayloadResult? signRawPayloadResult;
  final v1CreatePolicyResult? createPolicyResult;
  final v1DisablePrivateKeyResult? disablePrivateKeyResult;
  final v1DeleteUsersResult? deleteUsersResult;
  final v1DeleteAuthenticatorsResult? deleteAuthenticatorsResult;
  final v1DeleteInvitationResult? deleteInvitationResult;
  final v1DeleteOrganizationResult? deleteOrganizationResult;
  final v1DeletePolicyResult? deletePolicyResult;
  final v1CreateUserTagResult? createUserTagResult;
  final v1DeleteUserTagsResult? deleteUserTagsResult;
  final v1SignTransactionResult? signTransactionResult;
  final v1DeleteApiKeysResult? deleteApiKeysResult;
  final v1CreateApiKeysResult? createApiKeysResult;
  final v1CreatePrivateKeyTagResult? createPrivateKeyTagResult;
  final v1DeletePrivateKeyTagsResult? deletePrivateKeyTagsResult;
  final billingSetPaymentMethodResult? setPaymentMethodResult;
  final billingActivateBillingTierResult? activateBillingTierResult;
  final billingDeletePaymentMethodResult? deletePaymentMethodResult;
  final v1CreateApiOnlyUsersResult? createApiOnlyUsersResult;
  final v1UpdateRootQuorumResult? updateRootQuorumResult;
  final v1UpdateUserTagResult? updateUserTagResult;
  final v1UpdatePrivateKeyTagResult? updatePrivateKeyTagResult;
  final v1CreateSubOrganizationResult? createSubOrganizationResult;
  final v1UpdateAllowedOriginsResult? updateAllowedOriginsResult;
  final v1CreatePrivateKeysResultV2? createPrivateKeysResultV2;
  final v1UpdateUserResult? updateUserResult;
  final v1UpdatePolicyResult? updatePolicyResult;
  final v1CreateSubOrganizationResultV3? createSubOrganizationResultV3;
  final v1CreateWalletResult? createWalletResult;
  final v1CreateWalletAccountsResult? createWalletAccountsResult;
  final v1InitUserEmailRecoveryResult? initUserEmailRecoveryResult;
  final v1RecoverUserResult? recoverUserResult;
  final v1SetOrganizationFeatureResult? setOrganizationFeatureResult;
  final v1RemoveOrganizationFeatureResult? removeOrganizationFeatureResult;
  final v1ExportPrivateKeyResult? exportPrivateKeyResult;
  final v1ExportWalletResult? exportWalletResult;
  final v1CreateSubOrganizationResultV4? createSubOrganizationResultV4;
  final v1EmailAuthResult? emailAuthResult;
  final v1ExportWalletAccountResult? exportWalletAccountResult;
  final v1InitImportWalletResult? initImportWalletResult;
  final v1ImportWalletResult? importWalletResult;
  final v1InitImportPrivateKeyResult? initImportPrivateKeyResult;
  final v1ImportPrivateKeyResult? importPrivateKeyResult;
  final v1CreatePoliciesResult? createPoliciesResult;
  final v1SignRawPayloadsResult? signRawPayloadsResult;
  final v1CreateReadOnlySessionResult? createReadOnlySessionResult;
  final v1CreateOauthProvidersResult? createOauthProvidersResult;
  final v1DeleteOauthProvidersResult? deleteOauthProvidersResult;
  final v1CreateSubOrganizationResultV5? createSubOrganizationResultV5;
  final v1OauthResult? oauthResult;
  final v1CreateReadWriteSessionResult? createReadWriteSessionResult;
  final v1CreateSubOrganizationResultV6? createSubOrganizationResultV6;
  final v1DeletePrivateKeysResult? deletePrivateKeysResult;
  final v1DeleteWalletsResult? deleteWalletsResult;
  final v1CreateReadWriteSessionResultV2? createReadWriteSessionResultV2;
  final v1DeleteSubOrganizationResult? deleteSubOrganizationResult;
  final v1InitOtpAuthResult? initOtpAuthResult;
  final v1OtpAuthResult? otpAuthResult;
  final v1CreateSubOrganizationResultV7? createSubOrganizationResultV7;
  final v1UpdateWalletResult? updateWalletResult;
  final v1UpdatePolicyResultV2? updatePolicyResultV2;
  final v1InitOtpAuthResultV2? initOtpAuthResultV2;
  final v1InitOtpResult? initOtpResult;
  final v1VerifyOtpResult? verifyOtpResult;
  final v1OtpLoginResult? otpLoginResult;
  final v1StampLoginResult? stampLoginResult;
  final v1OauthLoginResult? oauthLoginResult;
  final v1UpdateUserNameResult? updateUserNameResult;
  final v1UpdateUserEmailResult? updateUserEmailResult;
  final v1UpdateUserPhoneNumberResult? updateUserPhoneNumberResult;
  final v1InitFiatOnRampResult? initFiatOnRampResult;
  final v1CreateSmartContractInterfaceResult? createSmartContractInterfaceResult;
  final v1DeleteSmartContractInterfaceResult? deleteSmartContractInterfaceResult;
  final v1EnableAuthProxyResult? enableAuthProxyResult;
  final v1DisableAuthProxyResult? disableAuthProxyResult;
  final v1UpdateAuthProxyConfigResult? updateAuthProxyConfigResult;
  final v1CreateOauth2CredentialResult? createOauth2CredentialResult;
  final v1UpdateOauth2CredentialResult? updateOauth2CredentialResult;
  final v1DeleteOauth2CredentialResult? deleteOauth2CredentialResult;
  final v1Oauth2AuthenticateResult? oauth2AuthenticateResult;
  final v1DeleteWalletAccountsResult? deleteWalletAccountsResult;
  final v1DeletePoliciesResult? deletePoliciesResult;
  final v1EthSendRawTransactionResult? ethSendRawTransactionResult;
  final v1CreateFiatOnRampCredentialResult? createFiatOnRampCredentialResult;
  final v1UpdateFiatOnRampCredentialResult? updateFiatOnRampCredentialResult;
  final v1DeleteFiatOnRampCredentialResult? deleteFiatOnRampCredentialResult;
  final v1EthSendTransactionResult? ethSendTransactionResult;
  final v1UpsertGasUsageConfigResult? upsertGasUsageConfigResult;
  final v1CreateTvcAppResult? createTvcAppResult;
  final v1CreateTvcDeploymentResult? createTvcDeploymentResult;
  final v1CreateTvcManifestApprovalsResult? createTvcManifestApprovalsResult;
  final v1SolSendTransactionResult? solSendTransactionResult;

  const v1Result({
     this.createOrganizationResult,
     this.createAuthenticatorsResult,
     this.createUsersResult,
     this.createPrivateKeysResult,
     this.createInvitationsResult,
     this.acceptInvitationResult,
     this.signRawPayloadResult,
     this.createPolicyResult,
     this.disablePrivateKeyResult,
     this.deleteUsersResult,
     this.deleteAuthenticatorsResult,
     this.deleteInvitationResult,
     this.deleteOrganizationResult,
     this.deletePolicyResult,
     this.createUserTagResult,
     this.deleteUserTagsResult,
     this.signTransactionResult,
     this.deleteApiKeysResult,
     this.createApiKeysResult,
     this.createPrivateKeyTagResult,
     this.deletePrivateKeyTagsResult,
     this.setPaymentMethodResult,
     this.activateBillingTierResult,
     this.deletePaymentMethodResult,
     this.createApiOnlyUsersResult,
     this.updateRootQuorumResult,
     this.updateUserTagResult,
     this.updatePrivateKeyTagResult,
     this.createSubOrganizationResult,
     this.updateAllowedOriginsResult,
     this.createPrivateKeysResultV2,
     this.updateUserResult,
     this.updatePolicyResult,
     this.createSubOrganizationResultV3,
     this.createWalletResult,
     this.createWalletAccountsResult,
     this.initUserEmailRecoveryResult,
     this.recoverUserResult,
     this.setOrganizationFeatureResult,
     this.removeOrganizationFeatureResult,
     this.exportPrivateKeyResult,
     this.exportWalletResult,
     this.createSubOrganizationResultV4,
     this.emailAuthResult,
     this.exportWalletAccountResult,
     this.initImportWalletResult,
     this.importWalletResult,
     this.initImportPrivateKeyResult,
     this.importPrivateKeyResult,
     this.createPoliciesResult,
     this.signRawPayloadsResult,
     this.createReadOnlySessionResult,
     this.createOauthProvidersResult,
     this.deleteOauthProvidersResult,
     this.createSubOrganizationResultV5,
     this.oauthResult,
     this.createReadWriteSessionResult,
     this.createSubOrganizationResultV6,
     this.deletePrivateKeysResult,
     this.deleteWalletsResult,
     this.createReadWriteSessionResultV2,
     this.deleteSubOrganizationResult,
     this.initOtpAuthResult,
     this.otpAuthResult,
     this.createSubOrganizationResultV7,
     this.updateWalletResult,
     this.updatePolicyResultV2,
     this.initOtpAuthResultV2,
     this.initOtpResult,
     this.verifyOtpResult,
     this.otpLoginResult,
     this.stampLoginResult,
     this.oauthLoginResult,
     this.updateUserNameResult,
     this.updateUserEmailResult,
     this.updateUserPhoneNumberResult,
     this.initFiatOnRampResult,
     this.createSmartContractInterfaceResult,
     this.deleteSmartContractInterfaceResult,
     this.enableAuthProxyResult,
     this.disableAuthProxyResult,
     this.updateAuthProxyConfigResult,
     this.createOauth2CredentialResult,
     this.updateOauth2CredentialResult,
     this.deleteOauth2CredentialResult,
     this.oauth2AuthenticateResult,
     this.deleteWalletAccountsResult,
     this.deletePoliciesResult,
     this.ethSendRawTransactionResult,
     this.createFiatOnRampCredentialResult,
     this.updateFiatOnRampCredentialResult,
     this.deleteFiatOnRampCredentialResult,
     this.ethSendTransactionResult,
     this.upsertGasUsageConfigResult,
     this.createTvcAppResult,
     this.createTvcDeploymentResult,
     this.createTvcManifestApprovalsResult,
     this.solSendTransactionResult,
  });

  factory v1Result.fromJson(Map<String, dynamic> json) {
    final _createOrganizationResult = json['createOrganizationResult'] == null ? null : v1CreateOrganizationResult.fromJson(json['createOrganizationResult'] as Map<String, dynamic>);
    final _createAuthenticatorsResult = json['createAuthenticatorsResult'] == null ? null : v1CreateAuthenticatorsResult.fromJson(json['createAuthenticatorsResult'] as Map<String, dynamic>);
    final _createUsersResult = json['createUsersResult'] == null ? null : v1CreateUsersResult.fromJson(json['createUsersResult'] as Map<String, dynamic>);
    final _createPrivateKeysResult = json['createPrivateKeysResult'] == null ? null : v1CreatePrivateKeysResult.fromJson(json['createPrivateKeysResult'] as Map<String, dynamic>);
    final _createInvitationsResult = json['createInvitationsResult'] == null ? null : v1CreateInvitationsResult.fromJson(json['createInvitationsResult'] as Map<String, dynamic>);
    final _acceptInvitationResult = json['acceptInvitationResult'] == null ? null : v1AcceptInvitationResult.fromJson(json['acceptInvitationResult'] as Map<String, dynamic>);
    final _signRawPayloadResult = json['signRawPayloadResult'] == null ? null : v1SignRawPayloadResult.fromJson(json['signRawPayloadResult'] as Map<String, dynamic>);
    final _createPolicyResult = json['createPolicyResult'] == null ? null : v1CreatePolicyResult.fromJson(json['createPolicyResult'] as Map<String, dynamic>);
    final _disablePrivateKeyResult = json['disablePrivateKeyResult'] == null ? null : v1DisablePrivateKeyResult.fromJson(json['disablePrivateKeyResult'] as Map<String, dynamic>);
    final _deleteUsersResult = json['deleteUsersResult'] == null ? null : v1DeleteUsersResult.fromJson(json['deleteUsersResult'] as Map<String, dynamic>);
    final _deleteAuthenticatorsResult = json['deleteAuthenticatorsResult'] == null ? null : v1DeleteAuthenticatorsResult.fromJson(json['deleteAuthenticatorsResult'] as Map<String, dynamic>);
    final _deleteInvitationResult = json['deleteInvitationResult'] == null ? null : v1DeleteInvitationResult.fromJson(json['deleteInvitationResult'] as Map<String, dynamic>);
    final _deleteOrganizationResult = json['deleteOrganizationResult'] == null ? null : v1DeleteOrganizationResult.fromJson(json['deleteOrganizationResult'] as Map<String, dynamic>);
    final _deletePolicyResult = json['deletePolicyResult'] == null ? null : v1DeletePolicyResult.fromJson(json['deletePolicyResult'] as Map<String, dynamic>);
    final _createUserTagResult = json['createUserTagResult'] == null ? null : v1CreateUserTagResult.fromJson(json['createUserTagResult'] as Map<String, dynamic>);
    final _deleteUserTagsResult = json['deleteUserTagsResult'] == null ? null : v1DeleteUserTagsResult.fromJson(json['deleteUserTagsResult'] as Map<String, dynamic>);
    final _signTransactionResult = json['signTransactionResult'] == null ? null : v1SignTransactionResult.fromJson(json['signTransactionResult'] as Map<String, dynamic>);
    final _deleteApiKeysResult = json['deleteApiKeysResult'] == null ? null : v1DeleteApiKeysResult.fromJson(json['deleteApiKeysResult'] as Map<String, dynamic>);
    final _createApiKeysResult = json['createApiKeysResult'] == null ? null : v1CreateApiKeysResult.fromJson(json['createApiKeysResult'] as Map<String, dynamic>);
    final _createPrivateKeyTagResult = json['createPrivateKeyTagResult'] == null ? null : v1CreatePrivateKeyTagResult.fromJson(json['createPrivateKeyTagResult'] as Map<String, dynamic>);
    final _deletePrivateKeyTagsResult = json['deletePrivateKeyTagsResult'] == null ? null : v1DeletePrivateKeyTagsResult.fromJson(json['deletePrivateKeyTagsResult'] as Map<String, dynamic>);
    final _setPaymentMethodResult = json['setPaymentMethodResult'] == null ? null : billingSetPaymentMethodResult.fromJson(json['setPaymentMethodResult'] as Map<String, dynamic>);
    final _activateBillingTierResult = json['activateBillingTierResult'] == null ? null : billingActivateBillingTierResult.fromJson(json['activateBillingTierResult'] as Map<String, dynamic>);
    final _deletePaymentMethodResult = json['deletePaymentMethodResult'] == null ? null : billingDeletePaymentMethodResult.fromJson(json['deletePaymentMethodResult'] as Map<String, dynamic>);
    final _createApiOnlyUsersResult = json['createApiOnlyUsersResult'] == null ? null : v1CreateApiOnlyUsersResult.fromJson(json['createApiOnlyUsersResult'] as Map<String, dynamic>);
    final _updateRootQuorumResult = json['updateRootQuorumResult'] == null ? null : v1UpdateRootQuorumResult.fromJson(json['updateRootQuorumResult'] as Map<String, dynamic>);
    final _updateUserTagResult = json['updateUserTagResult'] == null ? null : v1UpdateUserTagResult.fromJson(json['updateUserTagResult'] as Map<String, dynamic>);
    final _updatePrivateKeyTagResult = json['updatePrivateKeyTagResult'] == null ? null : v1UpdatePrivateKeyTagResult.fromJson(json['updatePrivateKeyTagResult'] as Map<String, dynamic>);
    final _createSubOrganizationResult = json['createSubOrganizationResult'] == null ? null : v1CreateSubOrganizationResult.fromJson(json['createSubOrganizationResult'] as Map<String, dynamic>);
    final _updateAllowedOriginsResult = json['updateAllowedOriginsResult'] == null ? null : v1UpdateAllowedOriginsResult.fromJson(json['updateAllowedOriginsResult'] as Map<String, dynamic>);
    final _createPrivateKeysResultV2 = json['createPrivateKeysResultV2'] == null ? null : v1CreatePrivateKeysResultV2.fromJson(json['createPrivateKeysResultV2'] as Map<String, dynamic>);
    final _updateUserResult = json['updateUserResult'] == null ? null : v1UpdateUserResult.fromJson(json['updateUserResult'] as Map<String, dynamic>);
    final _updatePolicyResult = json['updatePolicyResult'] == null ? null : v1UpdatePolicyResult.fromJson(json['updatePolicyResult'] as Map<String, dynamic>);
    final _createSubOrganizationResultV3 = json['createSubOrganizationResultV3'] == null ? null : v1CreateSubOrganizationResultV3.fromJson(json['createSubOrganizationResultV3'] as Map<String, dynamic>);
    final _createWalletResult = json['createWalletResult'] == null ? null : v1CreateWalletResult.fromJson(json['createWalletResult'] as Map<String, dynamic>);
    final _createWalletAccountsResult = json['createWalletAccountsResult'] == null ? null : v1CreateWalletAccountsResult.fromJson(json['createWalletAccountsResult'] as Map<String, dynamic>);
    final _initUserEmailRecoveryResult = json['initUserEmailRecoveryResult'] == null ? null : v1InitUserEmailRecoveryResult.fromJson(json['initUserEmailRecoveryResult'] as Map<String, dynamic>);
    final _recoverUserResult = json['recoverUserResult'] == null ? null : v1RecoverUserResult.fromJson(json['recoverUserResult'] as Map<String, dynamic>);
    final _setOrganizationFeatureResult = json['setOrganizationFeatureResult'] == null ? null : v1SetOrganizationFeatureResult.fromJson(json['setOrganizationFeatureResult'] as Map<String, dynamic>);
    final _removeOrganizationFeatureResult = json['removeOrganizationFeatureResult'] == null ? null : v1RemoveOrganizationFeatureResult.fromJson(json['removeOrganizationFeatureResult'] as Map<String, dynamic>);
    final _exportPrivateKeyResult = json['exportPrivateKeyResult'] == null ? null : v1ExportPrivateKeyResult.fromJson(json['exportPrivateKeyResult'] as Map<String, dynamic>);
    final _exportWalletResult = json['exportWalletResult'] == null ? null : v1ExportWalletResult.fromJson(json['exportWalletResult'] as Map<String, dynamic>);
    final _createSubOrganizationResultV4 = json['createSubOrganizationResultV4'] == null ? null : v1CreateSubOrganizationResultV4.fromJson(json['createSubOrganizationResultV4'] as Map<String, dynamic>);
    final _emailAuthResult = json['emailAuthResult'] == null ? null : v1EmailAuthResult.fromJson(json['emailAuthResult'] as Map<String, dynamic>);
    final _exportWalletAccountResult = json['exportWalletAccountResult'] == null ? null : v1ExportWalletAccountResult.fromJson(json['exportWalletAccountResult'] as Map<String, dynamic>);
    final _initImportWalletResult = json['initImportWalletResult'] == null ? null : v1InitImportWalletResult.fromJson(json['initImportWalletResult'] as Map<String, dynamic>);
    final _importWalletResult = json['importWalletResult'] == null ? null : v1ImportWalletResult.fromJson(json['importWalletResult'] as Map<String, dynamic>);
    final _initImportPrivateKeyResult = json['initImportPrivateKeyResult'] == null ? null : v1InitImportPrivateKeyResult.fromJson(json['initImportPrivateKeyResult'] as Map<String, dynamic>);
    final _importPrivateKeyResult = json['importPrivateKeyResult'] == null ? null : v1ImportPrivateKeyResult.fromJson(json['importPrivateKeyResult'] as Map<String, dynamic>);
    final _createPoliciesResult = json['createPoliciesResult'] == null ? null : v1CreatePoliciesResult.fromJson(json['createPoliciesResult'] as Map<String, dynamic>);
    final _signRawPayloadsResult = json['signRawPayloadsResult'] == null ? null : v1SignRawPayloadsResult.fromJson(json['signRawPayloadsResult'] as Map<String, dynamic>);
    final _createReadOnlySessionResult = json['createReadOnlySessionResult'] == null ? null : v1CreateReadOnlySessionResult.fromJson(json['createReadOnlySessionResult'] as Map<String, dynamic>);
    final _createOauthProvidersResult = json['createOauthProvidersResult'] == null ? null : v1CreateOauthProvidersResult.fromJson(json['createOauthProvidersResult'] as Map<String, dynamic>);
    final _deleteOauthProvidersResult = json['deleteOauthProvidersResult'] == null ? null : v1DeleteOauthProvidersResult.fromJson(json['deleteOauthProvidersResult'] as Map<String, dynamic>);
    final _createSubOrganizationResultV5 = json['createSubOrganizationResultV5'] == null ? null : v1CreateSubOrganizationResultV5.fromJson(json['createSubOrganizationResultV5'] as Map<String, dynamic>);
    final _oauthResult = json['oauthResult'] == null ? null : v1OauthResult.fromJson(json['oauthResult'] as Map<String, dynamic>);
    final _createReadWriteSessionResult = json['createReadWriteSessionResult'] == null ? null : v1CreateReadWriteSessionResult.fromJson(json['createReadWriteSessionResult'] as Map<String, dynamic>);
    final _createSubOrganizationResultV6 = json['createSubOrganizationResultV6'] == null ? null : v1CreateSubOrganizationResultV6.fromJson(json['createSubOrganizationResultV6'] as Map<String, dynamic>);
    final _deletePrivateKeysResult = json['deletePrivateKeysResult'] == null ? null : v1DeletePrivateKeysResult.fromJson(json['deletePrivateKeysResult'] as Map<String, dynamic>);
    final _deleteWalletsResult = json['deleteWalletsResult'] == null ? null : v1DeleteWalletsResult.fromJson(json['deleteWalletsResult'] as Map<String, dynamic>);
    final _createReadWriteSessionResultV2 = json['createReadWriteSessionResultV2'] == null ? null : v1CreateReadWriteSessionResultV2.fromJson(json['createReadWriteSessionResultV2'] as Map<String, dynamic>);
    final _deleteSubOrganizationResult = json['deleteSubOrganizationResult'] == null ? null : v1DeleteSubOrganizationResult.fromJson(json['deleteSubOrganizationResult'] as Map<String, dynamic>);
    final _initOtpAuthResult = json['initOtpAuthResult'] == null ? null : v1InitOtpAuthResult.fromJson(json['initOtpAuthResult'] as Map<String, dynamic>);
    final _otpAuthResult = json['otpAuthResult'] == null ? null : v1OtpAuthResult.fromJson(json['otpAuthResult'] as Map<String, dynamic>);
    final _createSubOrganizationResultV7 = json['createSubOrganizationResultV7'] == null ? null : v1CreateSubOrganizationResultV7.fromJson(json['createSubOrganizationResultV7'] as Map<String, dynamic>);
    final _updateWalletResult = json['updateWalletResult'] == null ? null : v1UpdateWalletResult.fromJson(json['updateWalletResult'] as Map<String, dynamic>);
    final _updatePolicyResultV2 = json['updatePolicyResultV2'] == null ? null : v1UpdatePolicyResultV2.fromJson(json['updatePolicyResultV2'] as Map<String, dynamic>);
    final _initOtpAuthResultV2 = json['initOtpAuthResultV2'] == null ? null : v1InitOtpAuthResultV2.fromJson(json['initOtpAuthResultV2'] as Map<String, dynamic>);
    final _initOtpResult = json['initOtpResult'] == null ? null : v1InitOtpResult.fromJson(json['initOtpResult'] as Map<String, dynamic>);
    final _verifyOtpResult = json['verifyOtpResult'] == null ? null : v1VerifyOtpResult.fromJson(json['verifyOtpResult'] as Map<String, dynamic>);
    final _otpLoginResult = json['otpLoginResult'] == null ? null : v1OtpLoginResult.fromJson(json['otpLoginResult'] as Map<String, dynamic>);
    final _stampLoginResult = json['stampLoginResult'] == null ? null : v1StampLoginResult.fromJson(json['stampLoginResult'] as Map<String, dynamic>);
    final _oauthLoginResult = json['oauthLoginResult'] == null ? null : v1OauthLoginResult.fromJson(json['oauthLoginResult'] as Map<String, dynamic>);
    final _updateUserNameResult = json['updateUserNameResult'] == null ? null : v1UpdateUserNameResult.fromJson(json['updateUserNameResult'] as Map<String, dynamic>);
    final _updateUserEmailResult = json['updateUserEmailResult'] == null ? null : v1UpdateUserEmailResult.fromJson(json['updateUserEmailResult'] as Map<String, dynamic>);
    final _updateUserPhoneNumberResult = json['updateUserPhoneNumberResult'] == null ? null : v1UpdateUserPhoneNumberResult.fromJson(json['updateUserPhoneNumberResult'] as Map<String, dynamic>);
    final _initFiatOnRampResult = json['initFiatOnRampResult'] == null ? null : v1InitFiatOnRampResult.fromJson(json['initFiatOnRampResult'] as Map<String, dynamic>);
    final _createSmartContractInterfaceResult = json['createSmartContractInterfaceResult'] == null ? null : v1CreateSmartContractInterfaceResult.fromJson(json['createSmartContractInterfaceResult'] as Map<String, dynamic>);
    final _deleteSmartContractInterfaceResult = json['deleteSmartContractInterfaceResult'] == null ? null : v1DeleteSmartContractInterfaceResult.fromJson(json['deleteSmartContractInterfaceResult'] as Map<String, dynamic>);
    final _enableAuthProxyResult = json['enableAuthProxyResult'] == null ? null : v1EnableAuthProxyResult.fromJson(json['enableAuthProxyResult'] as Map<String, dynamic>);
    final _disableAuthProxyResult = json['disableAuthProxyResult'] == null ? null : v1DisableAuthProxyResult.fromJson(json['disableAuthProxyResult'] as Map<String, dynamic>);
    final _updateAuthProxyConfigResult = json['updateAuthProxyConfigResult'] == null ? null : v1UpdateAuthProxyConfigResult.fromJson(json['updateAuthProxyConfigResult'] as Map<String, dynamic>);
    final _createOauth2CredentialResult = json['createOauth2CredentialResult'] == null ? null : v1CreateOauth2CredentialResult.fromJson(json['createOauth2CredentialResult'] as Map<String, dynamic>);
    final _updateOauth2CredentialResult = json['updateOauth2CredentialResult'] == null ? null : v1UpdateOauth2CredentialResult.fromJson(json['updateOauth2CredentialResult'] as Map<String, dynamic>);
    final _deleteOauth2CredentialResult = json['deleteOauth2CredentialResult'] == null ? null : v1DeleteOauth2CredentialResult.fromJson(json['deleteOauth2CredentialResult'] as Map<String, dynamic>);
    final _oauth2AuthenticateResult = json['oauth2AuthenticateResult'] == null ? null : v1Oauth2AuthenticateResult.fromJson(json['oauth2AuthenticateResult'] as Map<String, dynamic>);
    final _deleteWalletAccountsResult = json['deleteWalletAccountsResult'] == null ? null : v1DeleteWalletAccountsResult.fromJson(json['deleteWalletAccountsResult'] as Map<String, dynamic>);
    final _deletePoliciesResult = json['deletePoliciesResult'] == null ? null : v1DeletePoliciesResult.fromJson(json['deletePoliciesResult'] as Map<String, dynamic>);
    final _ethSendRawTransactionResult = json['ethSendRawTransactionResult'] == null ? null : v1EthSendRawTransactionResult.fromJson(json['ethSendRawTransactionResult'] as Map<String, dynamic>);
    final _createFiatOnRampCredentialResult = json['createFiatOnRampCredentialResult'] == null ? null : v1CreateFiatOnRampCredentialResult.fromJson(json['createFiatOnRampCredentialResult'] as Map<String, dynamic>);
    final _updateFiatOnRampCredentialResult = json['updateFiatOnRampCredentialResult'] == null ? null : v1UpdateFiatOnRampCredentialResult.fromJson(json['updateFiatOnRampCredentialResult'] as Map<String, dynamic>);
    final _deleteFiatOnRampCredentialResult = json['deleteFiatOnRampCredentialResult'] == null ? null : v1DeleteFiatOnRampCredentialResult.fromJson(json['deleteFiatOnRampCredentialResult'] as Map<String, dynamic>);
    final _ethSendTransactionResult = json['ethSendTransactionResult'] == null ? null : v1EthSendTransactionResult.fromJson(json['ethSendTransactionResult'] as Map<String, dynamic>);
    final _upsertGasUsageConfigResult = json['upsertGasUsageConfigResult'] == null ? null : v1UpsertGasUsageConfigResult.fromJson(json['upsertGasUsageConfigResult'] as Map<String, dynamic>);
    final _createTvcAppResult = json['createTvcAppResult'] == null ? null : v1CreateTvcAppResult.fromJson(json['createTvcAppResult'] as Map<String, dynamic>);
    final _createTvcDeploymentResult = json['createTvcDeploymentResult'] == null ? null : v1CreateTvcDeploymentResult.fromJson(json['createTvcDeploymentResult'] as Map<String, dynamic>);
    final _createTvcManifestApprovalsResult = json['createTvcManifestApprovalsResult'] == null ? null : v1CreateTvcManifestApprovalsResult.fromJson(json['createTvcManifestApprovalsResult'] as Map<String, dynamic>);
    final _solSendTransactionResult = json['solSendTransactionResult'] == null ? null : v1SolSendTransactionResult.fromJson(json['solSendTransactionResult'] as Map<String, dynamic>);
    return v1Result(
      createOrganizationResult: _createOrganizationResult,
      createAuthenticatorsResult: _createAuthenticatorsResult,
      createUsersResult: _createUsersResult,
      createPrivateKeysResult: _createPrivateKeysResult,
      createInvitationsResult: _createInvitationsResult,
      acceptInvitationResult: _acceptInvitationResult,
      signRawPayloadResult: _signRawPayloadResult,
      createPolicyResult: _createPolicyResult,
      disablePrivateKeyResult: _disablePrivateKeyResult,
      deleteUsersResult: _deleteUsersResult,
      deleteAuthenticatorsResult: _deleteAuthenticatorsResult,
      deleteInvitationResult: _deleteInvitationResult,
      deleteOrganizationResult: _deleteOrganizationResult,
      deletePolicyResult: _deletePolicyResult,
      createUserTagResult: _createUserTagResult,
      deleteUserTagsResult: _deleteUserTagsResult,
      signTransactionResult: _signTransactionResult,
      deleteApiKeysResult: _deleteApiKeysResult,
      createApiKeysResult: _createApiKeysResult,
      createPrivateKeyTagResult: _createPrivateKeyTagResult,
      deletePrivateKeyTagsResult: _deletePrivateKeyTagsResult,
      setPaymentMethodResult: _setPaymentMethodResult,
      activateBillingTierResult: _activateBillingTierResult,
      deletePaymentMethodResult: _deletePaymentMethodResult,
      createApiOnlyUsersResult: _createApiOnlyUsersResult,
      updateRootQuorumResult: _updateRootQuorumResult,
      updateUserTagResult: _updateUserTagResult,
      updatePrivateKeyTagResult: _updatePrivateKeyTagResult,
      createSubOrganizationResult: _createSubOrganizationResult,
      updateAllowedOriginsResult: _updateAllowedOriginsResult,
      createPrivateKeysResultV2: _createPrivateKeysResultV2,
      updateUserResult: _updateUserResult,
      updatePolicyResult: _updatePolicyResult,
      createSubOrganizationResultV3: _createSubOrganizationResultV3,
      createWalletResult: _createWalletResult,
      createWalletAccountsResult: _createWalletAccountsResult,
      initUserEmailRecoveryResult: _initUserEmailRecoveryResult,
      recoverUserResult: _recoverUserResult,
      setOrganizationFeatureResult: _setOrganizationFeatureResult,
      removeOrganizationFeatureResult: _removeOrganizationFeatureResult,
      exportPrivateKeyResult: _exportPrivateKeyResult,
      exportWalletResult: _exportWalletResult,
      createSubOrganizationResultV4: _createSubOrganizationResultV4,
      emailAuthResult: _emailAuthResult,
      exportWalletAccountResult: _exportWalletAccountResult,
      initImportWalletResult: _initImportWalletResult,
      importWalletResult: _importWalletResult,
      initImportPrivateKeyResult: _initImportPrivateKeyResult,
      importPrivateKeyResult: _importPrivateKeyResult,
      createPoliciesResult: _createPoliciesResult,
      signRawPayloadsResult: _signRawPayloadsResult,
      createReadOnlySessionResult: _createReadOnlySessionResult,
      createOauthProvidersResult: _createOauthProvidersResult,
      deleteOauthProvidersResult: _deleteOauthProvidersResult,
      createSubOrganizationResultV5: _createSubOrganizationResultV5,
      oauthResult: _oauthResult,
      createReadWriteSessionResult: _createReadWriteSessionResult,
      createSubOrganizationResultV6: _createSubOrganizationResultV6,
      deletePrivateKeysResult: _deletePrivateKeysResult,
      deleteWalletsResult: _deleteWalletsResult,
      createReadWriteSessionResultV2: _createReadWriteSessionResultV2,
      deleteSubOrganizationResult: _deleteSubOrganizationResult,
      initOtpAuthResult: _initOtpAuthResult,
      otpAuthResult: _otpAuthResult,
      createSubOrganizationResultV7: _createSubOrganizationResultV7,
      updateWalletResult: _updateWalletResult,
      updatePolicyResultV2: _updatePolicyResultV2,
      initOtpAuthResultV2: _initOtpAuthResultV2,
      initOtpResult: _initOtpResult,
      verifyOtpResult: _verifyOtpResult,
      otpLoginResult: _otpLoginResult,
      stampLoginResult: _stampLoginResult,
      oauthLoginResult: _oauthLoginResult,
      updateUserNameResult: _updateUserNameResult,
      updateUserEmailResult: _updateUserEmailResult,
      updateUserPhoneNumberResult: _updateUserPhoneNumberResult,
      initFiatOnRampResult: _initFiatOnRampResult,
      createSmartContractInterfaceResult: _createSmartContractInterfaceResult,
      deleteSmartContractInterfaceResult: _deleteSmartContractInterfaceResult,
      enableAuthProxyResult: _enableAuthProxyResult,
      disableAuthProxyResult: _disableAuthProxyResult,
      updateAuthProxyConfigResult: _updateAuthProxyConfigResult,
      createOauth2CredentialResult: _createOauth2CredentialResult,
      updateOauth2CredentialResult: _updateOauth2CredentialResult,
      deleteOauth2CredentialResult: _deleteOauth2CredentialResult,
      oauth2AuthenticateResult: _oauth2AuthenticateResult,
      deleteWalletAccountsResult: _deleteWalletAccountsResult,
      deletePoliciesResult: _deletePoliciesResult,
      ethSendRawTransactionResult: _ethSendRawTransactionResult,
      createFiatOnRampCredentialResult: _createFiatOnRampCredentialResult,
      updateFiatOnRampCredentialResult: _updateFiatOnRampCredentialResult,
      deleteFiatOnRampCredentialResult: _deleteFiatOnRampCredentialResult,
      ethSendTransactionResult: _ethSendTransactionResult,
      upsertGasUsageConfigResult: _upsertGasUsageConfigResult,
      createTvcAppResult: _createTvcAppResult,
      createTvcDeploymentResult: _createTvcDeploymentResult,
      createTvcManifestApprovalsResult: _createTvcManifestApprovalsResult,
      solSendTransactionResult: _solSendTransactionResult,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    if (createOrganizationResult != null) {
      _json['createOrganizationResult'] = createOrganizationResult?.toJson();
    }
    if (createAuthenticatorsResult != null) {
      _json['createAuthenticatorsResult'] = createAuthenticatorsResult?.toJson();
    }
    if (createUsersResult != null) {
      _json['createUsersResult'] = createUsersResult?.toJson();
    }
    if (createPrivateKeysResult != null) {
      _json['createPrivateKeysResult'] = createPrivateKeysResult?.toJson();
    }
    if (createInvitationsResult != null) {
      _json['createInvitationsResult'] = createInvitationsResult?.toJson();
    }
    if (acceptInvitationResult != null) {
      _json['acceptInvitationResult'] = acceptInvitationResult?.toJson();
    }
    if (signRawPayloadResult != null) {
      _json['signRawPayloadResult'] = signRawPayloadResult?.toJson();
    }
    if (createPolicyResult != null) {
      _json['createPolicyResult'] = createPolicyResult?.toJson();
    }
    if (disablePrivateKeyResult != null) {
      _json['disablePrivateKeyResult'] = disablePrivateKeyResult?.toJson();
    }
    if (deleteUsersResult != null) {
      _json['deleteUsersResult'] = deleteUsersResult?.toJson();
    }
    if (deleteAuthenticatorsResult != null) {
      _json['deleteAuthenticatorsResult'] = deleteAuthenticatorsResult?.toJson();
    }
    if (deleteInvitationResult != null) {
      _json['deleteInvitationResult'] = deleteInvitationResult?.toJson();
    }
    if (deleteOrganizationResult != null) {
      _json['deleteOrganizationResult'] = deleteOrganizationResult?.toJson();
    }
    if (deletePolicyResult != null) {
      _json['deletePolicyResult'] = deletePolicyResult?.toJson();
    }
    if (createUserTagResult != null) {
      _json['createUserTagResult'] = createUserTagResult?.toJson();
    }
    if (deleteUserTagsResult != null) {
      _json['deleteUserTagsResult'] = deleteUserTagsResult?.toJson();
    }
    if (signTransactionResult != null) {
      _json['signTransactionResult'] = signTransactionResult?.toJson();
    }
    if (deleteApiKeysResult != null) {
      _json['deleteApiKeysResult'] = deleteApiKeysResult?.toJson();
    }
    if (createApiKeysResult != null) {
      _json['createApiKeysResult'] = createApiKeysResult?.toJson();
    }
    if (createPrivateKeyTagResult != null) {
      _json['createPrivateKeyTagResult'] = createPrivateKeyTagResult?.toJson();
    }
    if (deletePrivateKeyTagsResult != null) {
      _json['deletePrivateKeyTagsResult'] = deletePrivateKeyTagsResult?.toJson();
    }
    if (setPaymentMethodResult != null) {
      _json['setPaymentMethodResult'] = setPaymentMethodResult?.toJson();
    }
    if (activateBillingTierResult != null) {
      _json['activateBillingTierResult'] = activateBillingTierResult?.toJson();
    }
    if (deletePaymentMethodResult != null) {
      _json['deletePaymentMethodResult'] = deletePaymentMethodResult?.toJson();
    }
    if (createApiOnlyUsersResult != null) {
      _json['createApiOnlyUsersResult'] = createApiOnlyUsersResult?.toJson();
    }
    if (updateRootQuorumResult != null) {
      _json['updateRootQuorumResult'] = updateRootQuorumResult?.toJson();
    }
    if (updateUserTagResult != null) {
      _json['updateUserTagResult'] = updateUserTagResult?.toJson();
    }
    if (updatePrivateKeyTagResult != null) {
      _json['updatePrivateKeyTagResult'] = updatePrivateKeyTagResult?.toJson();
    }
    if (createSubOrganizationResult != null) {
      _json['createSubOrganizationResult'] = createSubOrganizationResult?.toJson();
    }
    if (updateAllowedOriginsResult != null) {
      _json['updateAllowedOriginsResult'] = updateAllowedOriginsResult?.toJson();
    }
    if (createPrivateKeysResultV2 != null) {
      _json['createPrivateKeysResultV2'] = createPrivateKeysResultV2?.toJson();
    }
    if (updateUserResult != null) {
      _json['updateUserResult'] = updateUserResult?.toJson();
    }
    if (updatePolicyResult != null) {
      _json['updatePolicyResult'] = updatePolicyResult?.toJson();
    }
    if (createSubOrganizationResultV3 != null) {
      _json['createSubOrganizationResultV3'] = createSubOrganizationResultV3?.toJson();
    }
    if (createWalletResult != null) {
      _json['createWalletResult'] = createWalletResult?.toJson();
    }
    if (createWalletAccountsResult != null) {
      _json['createWalletAccountsResult'] = createWalletAccountsResult?.toJson();
    }
    if (initUserEmailRecoveryResult != null) {
      _json['initUserEmailRecoveryResult'] = initUserEmailRecoveryResult?.toJson();
    }
    if (recoverUserResult != null) {
      _json['recoverUserResult'] = recoverUserResult?.toJson();
    }
    if (setOrganizationFeatureResult != null) {
      _json['setOrganizationFeatureResult'] = setOrganizationFeatureResult?.toJson();
    }
    if (removeOrganizationFeatureResult != null) {
      _json['removeOrganizationFeatureResult'] = removeOrganizationFeatureResult?.toJson();
    }
    if (exportPrivateKeyResult != null) {
      _json['exportPrivateKeyResult'] = exportPrivateKeyResult?.toJson();
    }
    if (exportWalletResult != null) {
      _json['exportWalletResult'] = exportWalletResult?.toJson();
    }
    if (createSubOrganizationResultV4 != null) {
      _json['createSubOrganizationResultV4'] = createSubOrganizationResultV4?.toJson();
    }
    if (emailAuthResult != null) {
      _json['emailAuthResult'] = emailAuthResult?.toJson();
    }
    if (exportWalletAccountResult != null) {
      _json['exportWalletAccountResult'] = exportWalletAccountResult?.toJson();
    }
    if (initImportWalletResult != null) {
      _json['initImportWalletResult'] = initImportWalletResult?.toJson();
    }
    if (importWalletResult != null) {
      _json['importWalletResult'] = importWalletResult?.toJson();
    }
    if (initImportPrivateKeyResult != null) {
      _json['initImportPrivateKeyResult'] = initImportPrivateKeyResult?.toJson();
    }
    if (importPrivateKeyResult != null) {
      _json['importPrivateKeyResult'] = importPrivateKeyResult?.toJson();
    }
    if (createPoliciesResult != null) {
      _json['createPoliciesResult'] = createPoliciesResult?.toJson();
    }
    if (signRawPayloadsResult != null) {
      _json['signRawPayloadsResult'] = signRawPayloadsResult?.toJson();
    }
    if (createReadOnlySessionResult != null) {
      _json['createReadOnlySessionResult'] = createReadOnlySessionResult?.toJson();
    }
    if (createOauthProvidersResult != null) {
      _json['createOauthProvidersResult'] = createOauthProvidersResult?.toJson();
    }
    if (deleteOauthProvidersResult != null) {
      _json['deleteOauthProvidersResult'] = deleteOauthProvidersResult?.toJson();
    }
    if (createSubOrganizationResultV5 != null) {
      _json['createSubOrganizationResultV5'] = createSubOrganizationResultV5?.toJson();
    }
    if (oauthResult != null) {
      _json['oauthResult'] = oauthResult?.toJson();
    }
    if (createReadWriteSessionResult != null) {
      _json['createReadWriteSessionResult'] = createReadWriteSessionResult?.toJson();
    }
    if (createSubOrganizationResultV6 != null) {
      _json['createSubOrganizationResultV6'] = createSubOrganizationResultV6?.toJson();
    }
    if (deletePrivateKeysResult != null) {
      _json['deletePrivateKeysResult'] = deletePrivateKeysResult?.toJson();
    }
    if (deleteWalletsResult != null) {
      _json['deleteWalletsResult'] = deleteWalletsResult?.toJson();
    }
    if (createReadWriteSessionResultV2 != null) {
      _json['createReadWriteSessionResultV2'] = createReadWriteSessionResultV2?.toJson();
    }
    if (deleteSubOrganizationResult != null) {
      _json['deleteSubOrganizationResult'] = deleteSubOrganizationResult?.toJson();
    }
    if (initOtpAuthResult != null) {
      _json['initOtpAuthResult'] = initOtpAuthResult?.toJson();
    }
    if (otpAuthResult != null) {
      _json['otpAuthResult'] = otpAuthResult?.toJson();
    }
    if (createSubOrganizationResultV7 != null) {
      _json['createSubOrganizationResultV7'] = createSubOrganizationResultV7?.toJson();
    }
    if (updateWalletResult != null) {
      _json['updateWalletResult'] = updateWalletResult?.toJson();
    }
    if (updatePolicyResultV2 != null) {
      _json['updatePolicyResultV2'] = updatePolicyResultV2?.toJson();
    }
    if (initOtpAuthResultV2 != null) {
      _json['initOtpAuthResultV2'] = initOtpAuthResultV2?.toJson();
    }
    if (initOtpResult != null) {
      _json['initOtpResult'] = initOtpResult?.toJson();
    }
    if (verifyOtpResult != null) {
      _json['verifyOtpResult'] = verifyOtpResult?.toJson();
    }
    if (otpLoginResult != null) {
      _json['otpLoginResult'] = otpLoginResult?.toJson();
    }
    if (stampLoginResult != null) {
      _json['stampLoginResult'] = stampLoginResult?.toJson();
    }
    if (oauthLoginResult != null) {
      _json['oauthLoginResult'] = oauthLoginResult?.toJson();
    }
    if (updateUserNameResult != null) {
      _json['updateUserNameResult'] = updateUserNameResult?.toJson();
    }
    if (updateUserEmailResult != null) {
      _json['updateUserEmailResult'] = updateUserEmailResult?.toJson();
    }
    if (updateUserPhoneNumberResult != null) {
      _json['updateUserPhoneNumberResult'] = updateUserPhoneNumberResult?.toJson();
    }
    if (initFiatOnRampResult != null) {
      _json['initFiatOnRampResult'] = initFiatOnRampResult?.toJson();
    }
    if (createSmartContractInterfaceResult != null) {
      _json['createSmartContractInterfaceResult'] = createSmartContractInterfaceResult?.toJson();
    }
    if (deleteSmartContractInterfaceResult != null) {
      _json['deleteSmartContractInterfaceResult'] = deleteSmartContractInterfaceResult?.toJson();
    }
    if (enableAuthProxyResult != null) {
      _json['enableAuthProxyResult'] = enableAuthProxyResult?.toJson();
    }
    if (disableAuthProxyResult != null) {
      _json['disableAuthProxyResult'] = disableAuthProxyResult?.toJson();
    }
    if (updateAuthProxyConfigResult != null) {
      _json['updateAuthProxyConfigResult'] = updateAuthProxyConfigResult?.toJson();
    }
    if (createOauth2CredentialResult != null) {
      _json['createOauth2CredentialResult'] = createOauth2CredentialResult?.toJson();
    }
    if (updateOauth2CredentialResult != null) {
      _json['updateOauth2CredentialResult'] = updateOauth2CredentialResult?.toJson();
    }
    if (deleteOauth2CredentialResult != null) {
      _json['deleteOauth2CredentialResult'] = deleteOauth2CredentialResult?.toJson();
    }
    if (oauth2AuthenticateResult != null) {
      _json['oauth2AuthenticateResult'] = oauth2AuthenticateResult?.toJson();
    }
    if (deleteWalletAccountsResult != null) {
      _json['deleteWalletAccountsResult'] = deleteWalletAccountsResult?.toJson();
    }
    if (deletePoliciesResult != null) {
      _json['deletePoliciesResult'] = deletePoliciesResult?.toJson();
    }
    if (ethSendRawTransactionResult != null) {
      _json['ethSendRawTransactionResult'] = ethSendRawTransactionResult?.toJson();
    }
    if (createFiatOnRampCredentialResult != null) {
      _json['createFiatOnRampCredentialResult'] = createFiatOnRampCredentialResult?.toJson();
    }
    if (updateFiatOnRampCredentialResult != null) {
      _json['updateFiatOnRampCredentialResult'] = updateFiatOnRampCredentialResult?.toJson();
    }
    if (deleteFiatOnRampCredentialResult != null) {
      _json['deleteFiatOnRampCredentialResult'] = deleteFiatOnRampCredentialResult?.toJson();
    }
    if (ethSendTransactionResult != null) {
      _json['ethSendTransactionResult'] = ethSendTransactionResult?.toJson();
    }
    if (upsertGasUsageConfigResult != null) {
      _json['upsertGasUsageConfigResult'] = upsertGasUsageConfigResult?.toJson();
    }
    if (createTvcAppResult != null) {
      _json['createTvcAppResult'] = createTvcAppResult?.toJson();
    }
    if (createTvcDeploymentResult != null) {
      _json['createTvcDeploymentResult'] = createTvcDeploymentResult?.toJson();
    }
    if (createTvcManifestApprovalsResult != null) {
      _json['createTvcManifestApprovalsResult'] = createTvcManifestApprovalsResult?.toJson();
    }
    if (solSendTransactionResult != null) {
      _json['solSendTransactionResult'] = solSendTransactionResult?.toJson();
    }
    return _json;
  }
}

class v1RevertChainEntry {
  /// The contract address where the revert occurred.
  final String? address;
  /// Type of error: 'unknown', 'native', or 'custom'.
  final String? errorType;
  /// Human-readable message describing this revert.
  final String? displayMessage;
  /// Details for unknown error types.
  final v1UnknownRevertError? unknown;
  /// Details for native Solidity errors (Error, Panic, execution reverted).
  final v1NativeRevertError? native;
  /// Details for custom contract errors.
  final v1CustomRevertError? custom;

  const v1RevertChainEntry({
     this.address,
     this.errorType,
     this.displayMessage,
     this.unknown,
     this.native,
     this.custom,
  });

  factory v1RevertChainEntry.fromJson(Map<String, dynamic> json) {
    final _address = json['address'] as String?;
    final _errorType = json['errorType'] as String?;
    final _displayMessage = json['displayMessage'] as String?;
    final _unknown = json['unknown'] == null ? null : v1UnknownRevertError.fromJson(json['unknown'] as Map<String, dynamic>);
    final _native = json['native'] == null ? null : v1NativeRevertError.fromJson(json['native'] as Map<String, dynamic>);
    final _custom = json['custom'] == null ? null : v1CustomRevertError.fromJson(json['custom'] as Map<String, dynamic>);
    return v1RevertChainEntry(
      address: _address,
      errorType: _errorType,
      displayMessage: _displayMessage,
      unknown: _unknown,
      native: _native,
      custom: _custom,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    if (address != null) {
      _json['address'] = address;
    }
    if (errorType != null) {
      _json['errorType'] = errorType;
    }
    if (displayMessage != null) {
      _json['displayMessage'] = displayMessage;
    }
    if (unknown != null) {
      _json['unknown'] = unknown?.toJson();
    }
    if (native != null) {
      _json['native'] = native?.toJson();
    }
    if (custom != null) {
      _json['custom'] = custom?.toJson();
    }
    return _json;
  }
}

class v1RootUserParams {
  /// Human-readable name for a User.
  final String userName;
  /// The user's email address.
  final String? userEmail;
  /// A list of API Key parameters. This field, if not needed, should be an empty array in your request body.
  final List<apiApiKeyParams> apiKeys;
  /// A list of Authenticator parameters. This field, if not needed, should be an empty array in your request body.
  final List<v1AuthenticatorParamsV2> authenticators;

  const v1RootUserParams({
    required  this.userName,
     this.userEmail,
    required  this.apiKeys,
    required  this.authenticators,
  });

  factory v1RootUserParams.fromJson(Map<String, dynamic> json) {
    final _userName = json['userName'] as String;
    final _userEmail = json['userEmail'] as String?;
    final _apiKeys = (json['apiKeys'] as List).map((e) => apiApiKeyParams.fromJson(e as Map<String, dynamic>)).toList();
    final _authenticators = (json['authenticators'] as List).map((e) => v1AuthenticatorParamsV2.fromJson(e as Map<String, dynamic>)).toList();
    return v1RootUserParams(
      userName: _userName,
      userEmail: _userEmail,
      apiKeys: _apiKeys,
      authenticators: _authenticators,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['userName'] = userName;
    if (userEmail != null) {
      _json['userEmail'] = userEmail;
    }
    _json['apiKeys'] = apiKeys.map((e) => e.toJson()).toList();
    _json['authenticators'] = authenticators.map((e) => e.toJson()).toList();
    return _json;
  }
}

class v1RootUserParamsV2 {
  /// Human-readable name for a User.
  final String userName;
  /// The user's email address.
  final String? userEmail;
  /// A list of API Key parameters. This field, if not needed, should be an empty array in your request body.
  final List<apiApiKeyParams> apiKeys;
  /// A list of Authenticator parameters. This field, if not needed, should be an empty array in your request body.
  final List<v1AuthenticatorParamsV2> authenticators;
  /// A list of Oauth providers. This field, if not needed, should be an empty array in your request body.
  final List<v1OauthProviderParams> oauthProviders;

  const v1RootUserParamsV2({
    required  this.userName,
     this.userEmail,
    required  this.apiKeys,
    required  this.authenticators,
    required  this.oauthProviders,
  });

  factory v1RootUserParamsV2.fromJson(Map<String, dynamic> json) {
    final _userName = json['userName'] as String;
    final _userEmail = json['userEmail'] as String?;
    final _apiKeys = (json['apiKeys'] as List).map((e) => apiApiKeyParams.fromJson(e as Map<String, dynamic>)).toList();
    final _authenticators = (json['authenticators'] as List).map((e) => v1AuthenticatorParamsV2.fromJson(e as Map<String, dynamic>)).toList();
    final _oauthProviders = (json['oauthProviders'] as List).map((e) => v1OauthProviderParams.fromJson(e as Map<String, dynamic>)).toList();
    return v1RootUserParamsV2(
      userName: _userName,
      userEmail: _userEmail,
      apiKeys: _apiKeys,
      authenticators: _authenticators,
      oauthProviders: _oauthProviders,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['userName'] = userName;
    if (userEmail != null) {
      _json['userEmail'] = userEmail;
    }
    _json['apiKeys'] = apiKeys.map((e) => e.toJson()).toList();
    _json['authenticators'] = authenticators.map((e) => e.toJson()).toList();
    _json['oauthProviders'] = oauthProviders.map((e) => e.toJson()).toList();
    return _json;
  }
}

class v1RootUserParamsV3 {
  /// Human-readable name for a User.
  final String userName;
  /// The user's email address.
  final String? userEmail;
  /// A list of API Key parameters. This field, if not needed, should be an empty array in your request body.
  final List<v1ApiKeyParamsV2> apiKeys;
  /// A list of Authenticator parameters. This field, if not needed, should be an empty array in your request body.
  final List<v1AuthenticatorParamsV2> authenticators;
  /// A list of Oauth providers. This field, if not needed, should be an empty array in your request body.
  final List<v1OauthProviderParams> oauthProviders;

  const v1RootUserParamsV3({
    required  this.userName,
     this.userEmail,
    required  this.apiKeys,
    required  this.authenticators,
    required  this.oauthProviders,
  });

  factory v1RootUserParamsV3.fromJson(Map<String, dynamic> json) {
    final _userName = json['userName'] as String;
    final _userEmail = json['userEmail'] as String?;
    final _apiKeys = (json['apiKeys'] as List).map((e) => v1ApiKeyParamsV2.fromJson(e as Map<String, dynamic>)).toList();
    final _authenticators = (json['authenticators'] as List).map((e) => v1AuthenticatorParamsV2.fromJson(e as Map<String, dynamic>)).toList();
    final _oauthProviders = (json['oauthProviders'] as List).map((e) => v1OauthProviderParams.fromJson(e as Map<String, dynamic>)).toList();
    return v1RootUserParamsV3(
      userName: _userName,
      userEmail: _userEmail,
      apiKeys: _apiKeys,
      authenticators: _authenticators,
      oauthProviders: _oauthProviders,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['userName'] = userName;
    if (userEmail != null) {
      _json['userEmail'] = userEmail;
    }
    _json['apiKeys'] = apiKeys.map((e) => e.toJson()).toList();
    _json['authenticators'] = authenticators.map((e) => e.toJson()).toList();
    _json['oauthProviders'] = oauthProviders.map((e) => e.toJson()).toList();
    return _json;
  }
}

class v1RootUserParamsV4 {
  /// Human-readable name for a User.
  final String userName;
  /// The user's email address.
  final String? userEmail;
  /// The user's phone number in E.164 format e.g. +13214567890
  final String? userPhoneNumber;
  /// A list of API Key parameters. This field, if not needed, should be an empty array in your request body.
  final List<v1ApiKeyParamsV2> apiKeys;
  /// A list of Authenticator parameters. This field, if not needed, should be an empty array in your request body.
  final List<v1AuthenticatorParamsV2> authenticators;
  /// A list of Oauth providers. This field, if not needed, should be an empty array in your request body.
  final List<v1OauthProviderParams> oauthProviders;

  const v1RootUserParamsV4({
    required  this.userName,
     this.userEmail,
     this.userPhoneNumber,
    required  this.apiKeys,
    required  this.authenticators,
    required  this.oauthProviders,
  });

  factory v1RootUserParamsV4.fromJson(Map<String, dynamic> json) {
    final _userName = json['userName'] as String;
    final _userEmail = json['userEmail'] as String?;
    final _userPhoneNumber = json['userPhoneNumber'] as String?;
    final _apiKeys = (json['apiKeys'] as List).map((e) => v1ApiKeyParamsV2.fromJson(e as Map<String, dynamic>)).toList();
    final _authenticators = (json['authenticators'] as List).map((e) => v1AuthenticatorParamsV2.fromJson(e as Map<String, dynamic>)).toList();
    final _oauthProviders = (json['oauthProviders'] as List).map((e) => v1OauthProviderParams.fromJson(e as Map<String, dynamic>)).toList();
    return v1RootUserParamsV4(
      userName: _userName,
      userEmail: _userEmail,
      userPhoneNumber: _userPhoneNumber,
      apiKeys: _apiKeys,
      authenticators: _authenticators,
      oauthProviders: _oauthProviders,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['userName'] = userName;
    if (userEmail != null) {
      _json['userEmail'] = userEmail;
    }
    if (userPhoneNumber != null) {
      _json['userPhoneNumber'] = userPhoneNumber;
    }
    _json['apiKeys'] = apiKeys.map((e) => e.toJson()).toList();
    _json['authenticators'] = authenticators.map((e) => e.toJson()).toList();
    _json['oauthProviders'] = oauthProviders.map((e) => e.toJson()).toList();
    return _json;
  }
}

class v1Selector {
  final String? subject;
  final v1Operator? operator;
  final String? target;

  const v1Selector({
     this.subject,
     this.operator,
     this.target,
  });

  factory v1Selector.fromJson(Map<String, dynamic> json) {
    final _subject = json['subject'] as String?;
    final _operator = json['operator'] == null ? null : v1OperatorFromJson(json['operator']);
    final _target = json['target'] as String?;
    return v1Selector(
      subject: _subject,
      operator: _operator,
      target: _target,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    if (subject != null) {
      _json['subject'] = subject;
    }
    if (operator != null) {
      _json['operator'] = v1OperatorToJson(operator!);
    }
    if (target != null) {
      _json['target'] = target;
    }
    return _json;
  }
}

class v1SelectorV2 {
  final String? subject;
  final v1Operator? operator;
  final List<String>? targets;

  const v1SelectorV2({
     this.subject,
     this.operator,
     this.targets,
  });

  factory v1SelectorV2.fromJson(Map<String, dynamic> json) {
    final _subject = json['subject'] as String?;
    final _operator = json['operator'] == null ? null : v1OperatorFromJson(json['operator']);
    final _targets = (json['targets'] as List?)?.map((e) => e as String).toList();
    return v1SelectorV2(
      subject: _subject,
      operator: _operator,
      targets: _targets,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    if (subject != null) {
      _json['subject'] = subject;
    }
    if (operator != null) {
      _json['operator'] = v1OperatorToJson(operator!);
    }
    if (targets != null) {
      _json['targets'] = targets;
    }
    return _json;
  }
}

class v1SetOrganizationFeatureIntent {
  /// Name of the feature to set
  final v1FeatureName name;
  /// Optional value for the feature. Will override existing values if feature is already set.
  final String value;

  const v1SetOrganizationFeatureIntent({
    required  this.name,
    required  this.value,
  });

  factory v1SetOrganizationFeatureIntent.fromJson(Map<String, dynamic> json) {
    final _name = v1FeatureNameFromJson(json['name']);
    final _value = json['value'] as String;
    return v1SetOrganizationFeatureIntent(
      name: _name,
      value: _value,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['name'] = v1FeatureNameToJson(name);
    _json['value'] = value;
    return _json;
  }
}

class v1SetOrganizationFeatureRequest {
  final String type;
  /// Timestamp (in milliseconds) of the request, used to verify liveness of user requests.
  final String timestampMs;
  /// Unique identifier for a given Organization.
  final String organizationId;
  final v1SetOrganizationFeatureIntent parameters;
  final bool? generateAppProofs;

  const v1SetOrganizationFeatureRequest({
    required  this.type,
    required  this.timestampMs,
    required  this.organizationId,
    required  this.parameters,
     this.generateAppProofs,
  });

  factory v1SetOrganizationFeatureRequest.fromJson(Map<String, dynamic> json) {
    final _type = json['type'] as String;
    final _timestampMs = json['timestampMs'] as String;
    final _organizationId = json['organizationId'] as String;
    final _parameters = v1SetOrganizationFeatureIntent.fromJson(json['parameters'] as Map<String, dynamic>);
    final _generateAppProofs = json['generateAppProofs'] as bool?;
    return v1SetOrganizationFeatureRequest(
      type: _type,
      timestampMs: _timestampMs,
      organizationId: _organizationId,
      parameters: _parameters,
      generateAppProofs: _generateAppProofs,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['type'] = type;
    _json['timestampMs'] = timestampMs;
    _json['organizationId'] = organizationId;
    _json['parameters'] = parameters.toJson();
    if (generateAppProofs != null) {
      _json['generateAppProofs'] = generateAppProofs;
    }
    return _json;
  }
}

class v1SetOrganizationFeatureResult {
  /// Resulting list of organization features.
  final List<v1Feature> features;

  const v1SetOrganizationFeatureResult({
    required  this.features,
  });

  factory v1SetOrganizationFeatureResult.fromJson(Map<String, dynamic> json) {
    final _features = (json['features'] as List).map((e) => v1Feature.fromJson(e as Map<String, dynamic>)).toList();
    return v1SetOrganizationFeatureResult(
      features: _features,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['features'] = features.map((e) => e.toJson()).toList();
    return _json;
  }
}

class v1SignRawPayloadIntent {
  /// Unique identifier for a given Private Key.
  final String privateKeyId;
  /// Raw unsigned payload to be signed.
  final String payload;
  /// Encoding of the `payload` string. Turnkey uses this information to convert `payload` into bytes with the correct decoder (e.g. hex, utf8).
  final v1PayloadEncoding encoding;
  /// Hash function to apply to payload bytes before signing. This field must be set to HASH_FUNCTION_NOT_APPLICABLE for EdDSA/ed25519 signature requests; configurable payload hashing is not supported by RFC 8032.
  final v1HashFunction hashFunction;

  const v1SignRawPayloadIntent({
    required  this.privateKeyId,
    required  this.payload,
    required  this.encoding,
    required  this.hashFunction,
  });

  factory v1SignRawPayloadIntent.fromJson(Map<String, dynamic> json) {
    final _privateKeyId = json['privateKeyId'] as String;
    final _payload = json['payload'] as String;
    final _encoding = v1PayloadEncodingFromJson(json['encoding']);
    final _hashFunction = v1HashFunctionFromJson(json['hashFunction']);
    return v1SignRawPayloadIntent(
      privateKeyId: _privateKeyId,
      payload: _payload,
      encoding: _encoding,
      hashFunction: _hashFunction,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['privateKeyId'] = privateKeyId;
    _json['payload'] = payload;
    _json['encoding'] = v1PayloadEncodingToJson(encoding);
    _json['hashFunction'] = v1HashFunctionToJson(hashFunction);
    return _json;
  }
}

class v1SignRawPayloadIntentV2 {
  /// A Wallet account address, Private Key address, or Private Key identifier.
  final String signWith;
  /// Raw unsigned payload to be signed.
  final String payload;
  /// Encoding of the `payload` string. Turnkey uses this information to convert `payload` into bytes with the correct decoder (e.g. hex, utf8).
  final v1PayloadEncoding encoding;
  /// Hash function to apply to payload bytes before signing. This field must be set to HASH_FUNCTION_NOT_APPLICABLE for EdDSA/ed25519 signature requests; configurable payload hashing is not supported by RFC 8032.
  final v1HashFunction hashFunction;

  const v1SignRawPayloadIntentV2({
    required  this.signWith,
    required  this.payload,
    required  this.encoding,
    required  this.hashFunction,
  });

  factory v1SignRawPayloadIntentV2.fromJson(Map<String, dynamic> json) {
    final _signWith = json['signWith'] as String;
    final _payload = json['payload'] as String;
    final _encoding = v1PayloadEncodingFromJson(json['encoding']);
    final _hashFunction = v1HashFunctionFromJson(json['hashFunction']);
    return v1SignRawPayloadIntentV2(
      signWith: _signWith,
      payload: _payload,
      encoding: _encoding,
      hashFunction: _hashFunction,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['signWith'] = signWith;
    _json['payload'] = payload;
    _json['encoding'] = v1PayloadEncodingToJson(encoding);
    _json['hashFunction'] = v1HashFunctionToJson(hashFunction);
    return _json;
  }
}

class v1SignRawPayloadRequest {
  final String type;
  /// Timestamp (in milliseconds) of the request, used to verify liveness of user requests.
  final String timestampMs;
  /// Unique identifier for a given Organization.
  final String organizationId;
  final v1SignRawPayloadIntentV2 parameters;
  final bool? generateAppProofs;

  const v1SignRawPayloadRequest({
    required  this.type,
    required  this.timestampMs,
    required  this.organizationId,
    required  this.parameters,
     this.generateAppProofs,
  });

  factory v1SignRawPayloadRequest.fromJson(Map<String, dynamic> json) {
    final _type = json['type'] as String;
    final _timestampMs = json['timestampMs'] as String;
    final _organizationId = json['organizationId'] as String;
    final _parameters = v1SignRawPayloadIntentV2.fromJson(json['parameters'] as Map<String, dynamic>);
    final _generateAppProofs = json['generateAppProofs'] as bool?;
    return v1SignRawPayloadRequest(
      type: _type,
      timestampMs: _timestampMs,
      organizationId: _organizationId,
      parameters: _parameters,
      generateAppProofs: _generateAppProofs,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['type'] = type;
    _json['timestampMs'] = timestampMs;
    _json['organizationId'] = organizationId;
    _json['parameters'] = parameters.toJson();
    if (generateAppProofs != null) {
      _json['generateAppProofs'] = generateAppProofs;
    }
    return _json;
  }
}

class v1SignRawPayloadResult {
  /// Component of an ECSDA signature.
  final String r;
  /// Component of an ECSDA signature.
  final String s;
  /// Component of an ECSDA signature.
  final String v;

  const v1SignRawPayloadResult({
    required  this.r,
    required  this.s,
    required  this.v,
  });

  factory v1SignRawPayloadResult.fromJson(Map<String, dynamic> json) {
    final _r = json['r'] as String;
    final _s = json['s'] as String;
    final _v = json['v'] as String;
    return v1SignRawPayloadResult(
      r: _r,
      s: _s,
      v: _v,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['r'] = r;
    _json['s'] = s;
    _json['v'] = v;
    return _json;
  }
}

class v1SignRawPayloadsIntent {
  /// A Wallet account address, Private Key address, or Private Key identifier.
  final String signWith;
  /// An array of raw unsigned payloads to be signed.
  final List<String> payloads;
  /// Encoding of the `payload` string. Turnkey uses this information to convert `payload` into bytes with the correct decoder (e.g. hex, utf8).
  final v1PayloadEncoding encoding;
  /// Hash function to apply to payload bytes before signing. This field must be set to HASH_FUNCTION_NOT_APPLICABLE for EdDSA/ed25519 signature requests; configurable payload hashing is not supported by RFC 8032.
  final v1HashFunction hashFunction;

  const v1SignRawPayloadsIntent({
    required  this.signWith,
    required  this.payloads,
    required  this.encoding,
    required  this.hashFunction,
  });

  factory v1SignRawPayloadsIntent.fromJson(Map<String, dynamic> json) {
    final _signWith = json['signWith'] as String;
    final _payloads = (json['payloads'] as List).map((e) => e as String).toList();
    final _encoding = v1PayloadEncodingFromJson(json['encoding']);
    final _hashFunction = v1HashFunctionFromJson(json['hashFunction']);
    return v1SignRawPayloadsIntent(
      signWith: _signWith,
      payloads: _payloads,
      encoding: _encoding,
      hashFunction: _hashFunction,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['signWith'] = signWith;
    _json['payloads'] = payloads;
    _json['encoding'] = v1PayloadEncodingToJson(encoding);
    _json['hashFunction'] = v1HashFunctionToJson(hashFunction);
    return _json;
  }
}

class v1SignRawPayloadsRequest {
  final String type;
  /// Timestamp (in milliseconds) of the request, used to verify liveness of user requests.
  final String timestampMs;
  /// Unique identifier for a given Organization.
  final String organizationId;
  final v1SignRawPayloadsIntent parameters;
  final bool? generateAppProofs;

  const v1SignRawPayloadsRequest({
    required  this.type,
    required  this.timestampMs,
    required  this.organizationId,
    required  this.parameters,
     this.generateAppProofs,
  });

  factory v1SignRawPayloadsRequest.fromJson(Map<String, dynamic> json) {
    final _type = json['type'] as String;
    final _timestampMs = json['timestampMs'] as String;
    final _organizationId = json['organizationId'] as String;
    final _parameters = v1SignRawPayloadsIntent.fromJson(json['parameters'] as Map<String, dynamic>);
    final _generateAppProofs = json['generateAppProofs'] as bool?;
    return v1SignRawPayloadsRequest(
      type: _type,
      timestampMs: _timestampMs,
      organizationId: _organizationId,
      parameters: _parameters,
      generateAppProofs: _generateAppProofs,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['type'] = type;
    _json['timestampMs'] = timestampMs;
    _json['organizationId'] = organizationId;
    _json['parameters'] = parameters.toJson();
    if (generateAppProofs != null) {
      _json['generateAppProofs'] = generateAppProofs;
    }
    return _json;
  }
}

class v1SignRawPayloadsResult {
  final List<v1SignRawPayloadResult>? signatures;

  const v1SignRawPayloadsResult({
     this.signatures,
  });

  factory v1SignRawPayloadsResult.fromJson(Map<String, dynamic> json) {
    final _signatures = (json['signatures'] as List?)?.map((e) => v1SignRawPayloadResult.fromJson(e as Map<String, dynamic>)).toList();
    return v1SignRawPayloadsResult(
      signatures: _signatures,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    if (signatures != null) {
      _json['signatures'] = signatures?.map((e) => e.toJson()).toList();
    }
    return _json;
  }
}

class v1SignTransactionIntent {
  /// Unique identifier for a given Private Key.
  final String privateKeyId;
  /// Raw unsigned transaction to be signed by a particular Private Key.
  final String unsignedTransaction;
  final v1TransactionType type;

  const v1SignTransactionIntent({
    required  this.privateKeyId,
    required  this.unsignedTransaction,
    required  this.type,
  });

  factory v1SignTransactionIntent.fromJson(Map<String, dynamic> json) {
    final _privateKeyId = json['privateKeyId'] as String;
    final _unsignedTransaction = json['unsignedTransaction'] as String;
    final _type = v1TransactionTypeFromJson(json['type']);
    return v1SignTransactionIntent(
      privateKeyId: _privateKeyId,
      unsignedTransaction: _unsignedTransaction,
      type: _type,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['privateKeyId'] = privateKeyId;
    _json['unsignedTransaction'] = unsignedTransaction;
    _json['type'] = v1TransactionTypeToJson(type);
    return _json;
  }
}

class v1SignTransactionIntentV2 {
  /// A Wallet account address, Private Key address, or Private Key identifier.
  final String signWith;
  /// Raw unsigned transaction to be signed
  final String unsignedTransaction;
  final v1TransactionType type;

  const v1SignTransactionIntentV2({
    required  this.signWith,
    required  this.unsignedTransaction,
    required  this.type,
  });

  factory v1SignTransactionIntentV2.fromJson(Map<String, dynamic> json) {
    final _signWith = json['signWith'] as String;
    final _unsignedTransaction = json['unsignedTransaction'] as String;
    final _type = v1TransactionTypeFromJson(json['type']);
    return v1SignTransactionIntentV2(
      signWith: _signWith,
      unsignedTransaction: _unsignedTransaction,
      type: _type,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['signWith'] = signWith;
    _json['unsignedTransaction'] = unsignedTransaction;
    _json['type'] = v1TransactionTypeToJson(type);
    return _json;
  }
}

class v1SignTransactionRequest {
  final String type;
  /// Timestamp (in milliseconds) of the request, used to verify liveness of user requests.
  final String timestampMs;
  /// Unique identifier for a given Organization.
  final String organizationId;
  final v1SignTransactionIntentV2 parameters;
  final bool? generateAppProofs;

  const v1SignTransactionRequest({
    required  this.type,
    required  this.timestampMs,
    required  this.organizationId,
    required  this.parameters,
     this.generateAppProofs,
  });

  factory v1SignTransactionRequest.fromJson(Map<String, dynamic> json) {
    final _type = json['type'] as String;
    final _timestampMs = json['timestampMs'] as String;
    final _organizationId = json['organizationId'] as String;
    final _parameters = v1SignTransactionIntentV2.fromJson(json['parameters'] as Map<String, dynamic>);
    final _generateAppProofs = json['generateAppProofs'] as bool?;
    return v1SignTransactionRequest(
      type: _type,
      timestampMs: _timestampMs,
      organizationId: _organizationId,
      parameters: _parameters,
      generateAppProofs: _generateAppProofs,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['type'] = type;
    _json['timestampMs'] = timestampMs;
    _json['organizationId'] = organizationId;
    _json['parameters'] = parameters.toJson();
    if (generateAppProofs != null) {
      _json['generateAppProofs'] = generateAppProofs;
    }
    return _json;
  }
}

class v1SignTransactionResult {
  final String signedTransaction;

  const v1SignTransactionResult({
    required  this.signedTransaction,
  });

  factory v1SignTransactionResult.fromJson(Map<String, dynamic> json) {
    final _signedTransaction = json['signedTransaction'] as String;
    return v1SignTransactionResult(
      signedTransaction: _signedTransaction,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['signedTransaction'] = signedTransaction;
    return _json;
  }
}

class v1SignupUsage {
  final String? email;
  final String? phoneNumber;
  final List<v1ApiKeyParamsV2>? apiKeys;
  final List<v1AuthenticatorParamsV2>? authenticators;
  final List<v1OauthProviderParams>? oauthProviders;

  const v1SignupUsage({
     this.email,
     this.phoneNumber,
     this.apiKeys,
     this.authenticators,
     this.oauthProviders,
  });

  factory v1SignupUsage.fromJson(Map<String, dynamic> json) {
    final _email = json['email'] as String?;
    final _phoneNumber = json['phoneNumber'] as String?;
    final _apiKeys = (json['apiKeys'] as List?)?.map((e) => v1ApiKeyParamsV2.fromJson(e as Map<String, dynamic>)).toList();
    final _authenticators = (json['authenticators'] as List?)?.map((e) => v1AuthenticatorParamsV2.fromJson(e as Map<String, dynamic>)).toList();
    final _oauthProviders = (json['oauthProviders'] as List?)?.map((e) => v1OauthProviderParams.fromJson(e as Map<String, dynamic>)).toList();
    return v1SignupUsage(
      email: _email,
      phoneNumber: _phoneNumber,
      apiKeys: _apiKeys,
      authenticators: _authenticators,
      oauthProviders: _oauthProviders,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    if (email != null) {
      _json['email'] = email;
    }
    if (phoneNumber != null) {
      _json['phoneNumber'] = phoneNumber;
    }
    if (apiKeys != null) {
      _json['apiKeys'] = apiKeys?.map((e) => e.toJson()).toList();
    }
    if (authenticators != null) {
      _json['authenticators'] = authenticators?.map((e) => e.toJson()).toList();
    }
    if (oauthProviders != null) {
      _json['oauthProviders'] = oauthProviders?.map((e) => e.toJson()).toList();
    }
    return _json;
  }
}

class v1SimpleClientExtensionResults {
  final bool? appid;
  final bool? appidExclude;
  final v1CredPropsAuthenticationExtensionsClientOutputs? credProps;

  const v1SimpleClientExtensionResults({
     this.appid,
     this.appidExclude,
     this.credProps,
  });

  factory v1SimpleClientExtensionResults.fromJson(Map<String, dynamic> json) {
    final _appid = json['appid'] as bool?;
    final _appidExclude = json['appidExclude'] as bool?;
    final _credProps = json['credProps'] == null ? null : v1CredPropsAuthenticationExtensionsClientOutputs.fromJson(json['credProps'] as Map<String, dynamic>);
    return v1SimpleClientExtensionResults(
      appid: _appid,
      appidExclude: _appidExclude,
      credProps: _credProps,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    if (appid != null) {
      _json['appid'] = appid;
    }
    if (appidExclude != null) {
      _json['appidExclude'] = appidExclude;
    }
    if (credProps != null) {
      _json['credProps'] = credProps?.toJson();
    }
    return _json;
  }
}

class v1SmartContractInterfaceReference {
  final String? smartContractInterfaceId;
  final String? smartContractAddress;
  final String? digest;

  const v1SmartContractInterfaceReference({
     this.smartContractInterfaceId,
     this.smartContractAddress,
     this.digest,
  });

  factory v1SmartContractInterfaceReference.fromJson(Map<String, dynamic> json) {
    final _smartContractInterfaceId = json['smartContractInterfaceId'] as String?;
    final _smartContractAddress = json['smartContractAddress'] as String?;
    final _digest = json['digest'] as String?;
    return v1SmartContractInterfaceReference(
      smartContractInterfaceId: _smartContractInterfaceId,
      smartContractAddress: _smartContractAddress,
      digest: _digest,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    if (smartContractInterfaceId != null) {
      _json['smartContractInterfaceId'] = smartContractInterfaceId;
    }
    if (smartContractAddress != null) {
      _json['smartContractAddress'] = smartContractAddress;
    }
    if (digest != null) {
      _json['digest'] = digest;
    }
    return _json;
  }
}

class v1SmsCustomizationParams {
  /// Template containing references to .OtpCode i.e Your OTP is {{.OtpCode}}
  final String? template;

  const v1SmsCustomizationParams({
     this.template,
  });

  factory v1SmsCustomizationParams.fromJson(Map<String, dynamic> json) {
    final _template = json['template'] as String?;
    return v1SmsCustomizationParams(
      template: _template,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    if (template != null) {
      _json['template'] = template;
    }
    return _json;
  }
}

class v1SolSendTransactionIntent {
  /// Base64-encoded serialized unsigned Solana transaction
  final String unsignedTransaction;
  /// A wallet or private key address to sign with. This does not support private key IDs.
  final String signWith;
  /// Whether to sponsor this transaction via Gas Station.
  final bool? sponsor;
  /// CAIP-2 chain ID (e.g., 'solana:5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp' for Solana mainnet).
  final String caip2;
  /// user-provided blockhash for replay protection / deadline control. If omitted and sponsor=true, we fetch a fresh blockhash during execution
  final String? recentBlockhash;

  const v1SolSendTransactionIntent({
    required  this.unsignedTransaction,
    required  this.signWith,
     this.sponsor,
    required  this.caip2,
     this.recentBlockhash,
  });

  factory v1SolSendTransactionIntent.fromJson(Map<String, dynamic> json) {
    final _unsignedTransaction = json['unsignedTransaction'] as String;
    final _signWith = json['signWith'] as String;
    final _sponsor = json['sponsor'] as bool?;
    final _caip2 = json['caip2'] as String;
    final _recentBlockhash = json['recentBlockhash'] as String?;
    return v1SolSendTransactionIntent(
      unsignedTransaction: _unsignedTransaction,
      signWith: _signWith,
      sponsor: _sponsor,
      caip2: _caip2,
      recentBlockhash: _recentBlockhash,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['unsignedTransaction'] = unsignedTransaction;
    _json['signWith'] = signWith;
    if (sponsor != null) {
      _json['sponsor'] = sponsor;
    }
    _json['caip2'] = caip2;
    if (recentBlockhash != null) {
      _json['recentBlockhash'] = recentBlockhash;
    }
    return _json;
  }
}

class v1SolSendTransactionRequest {
  final String type;
  /// Timestamp (in milliseconds) of the request, used to verify liveness of user requests.
  final String timestampMs;
  /// Unique identifier for a given Organization.
  final String organizationId;
  final v1SolSendTransactionIntent parameters;
  final bool? generateAppProofs;

  const v1SolSendTransactionRequest({
    required  this.type,
    required  this.timestampMs,
    required  this.organizationId,
    required  this.parameters,
     this.generateAppProofs,
  });

  factory v1SolSendTransactionRequest.fromJson(Map<String, dynamic> json) {
    final _type = json['type'] as String;
    final _timestampMs = json['timestampMs'] as String;
    final _organizationId = json['organizationId'] as String;
    final _parameters = v1SolSendTransactionIntent.fromJson(json['parameters'] as Map<String, dynamic>);
    final _generateAppProofs = json['generateAppProofs'] as bool?;
    return v1SolSendTransactionRequest(
      type: _type,
      timestampMs: _timestampMs,
      organizationId: _organizationId,
      parameters: _parameters,
      generateAppProofs: _generateAppProofs,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['type'] = type;
    _json['timestampMs'] = timestampMs;
    _json['organizationId'] = organizationId;
    _json['parameters'] = parameters.toJson();
    if (generateAppProofs != null) {
      _json['generateAppProofs'] = generateAppProofs;
    }
    return _json;
  }
}

class v1SolSendTransactionResult {
  /// The send_transaction_status ID associated with the transaction submission
  final String sendTransactionStatusId;

  const v1SolSendTransactionResult({
    required  this.sendTransactionStatusId,
  });

  factory v1SolSendTransactionResult.fromJson(Map<String, dynamic> json) {
    final _sendTransactionStatusId = json['sendTransactionStatusId'] as String;
    return v1SolSendTransactionResult(
      sendTransactionStatusId: _sendTransactionStatusId,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['sendTransactionStatusId'] = sendTransactionStatusId;
    return _json;
  }
}

class v1StampLoginIntent {
  /// Client-side public key generated by the user, which will be conditionally added to org data based on the passkey stamp associated with this request
  final String publicKey;
  /// Expiration window (in seconds) indicating how long the Session is valid for. If not provided, a default of 15 minutes will be used.
  final String? expirationSeconds;
  /// Invalidate all other previously generated Login API keys
  final bool? invalidateExisting;

  const v1StampLoginIntent({
    required  this.publicKey,
     this.expirationSeconds,
     this.invalidateExisting,
  });

  factory v1StampLoginIntent.fromJson(Map<String, dynamic> json) {
    final _publicKey = json['publicKey'] as String;
    final _expirationSeconds = json['expirationSeconds'] as String?;
    final _invalidateExisting = json['invalidateExisting'] as bool?;
    return v1StampLoginIntent(
      publicKey: _publicKey,
      expirationSeconds: _expirationSeconds,
      invalidateExisting: _invalidateExisting,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['publicKey'] = publicKey;
    if (expirationSeconds != null) {
      _json['expirationSeconds'] = expirationSeconds;
    }
    if (invalidateExisting != null) {
      _json['invalidateExisting'] = invalidateExisting;
    }
    return _json;
  }
}

class v1StampLoginRequest {
  final String type;
  /// Timestamp (in milliseconds) of the request, used to verify liveness of user requests.
  final String timestampMs;
  /// Unique identifier for a given Organization.
  final String organizationId;
  final v1StampLoginIntent parameters;
  final bool? generateAppProofs;

  const v1StampLoginRequest({
    required  this.type,
    required  this.timestampMs,
    required  this.organizationId,
    required  this.parameters,
     this.generateAppProofs,
  });

  factory v1StampLoginRequest.fromJson(Map<String, dynamic> json) {
    final _type = json['type'] as String;
    final _timestampMs = json['timestampMs'] as String;
    final _organizationId = json['organizationId'] as String;
    final _parameters = v1StampLoginIntent.fromJson(json['parameters'] as Map<String, dynamic>);
    final _generateAppProofs = json['generateAppProofs'] as bool?;
    return v1StampLoginRequest(
      type: _type,
      timestampMs: _timestampMs,
      organizationId: _organizationId,
      parameters: _parameters,
      generateAppProofs: _generateAppProofs,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['type'] = type;
    _json['timestampMs'] = timestampMs;
    _json['organizationId'] = organizationId;
    _json['parameters'] = parameters.toJson();
    if (generateAppProofs != null) {
      _json['generateAppProofs'] = generateAppProofs;
    }
    return _json;
  }
}

class v1StampLoginResult {
  /// Signed JWT containing an expiry, public key, session type, user id, and organization id
  final String session;

  const v1StampLoginResult({
    required  this.session,
  });

  factory v1StampLoginResult.fromJson(Map<String, dynamic> json) {
    final _session = json['session'] as String;
    return v1StampLoginResult(
      session: _session,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['session'] = session;
    return _json;
  }
}

class v1TestRateLimitsRequest {
  /// Unique identifier for a given organization. If the request is being made by a WebAuthN user and their sub-organization ID is unknown, this can be the parent organization ID; using the sub-organization ID when possible is preferred due to performance reasons.
  final String organizationId;
  /// Whether or not to set a limit on this request.
  final bool isSetLimit;
  /// Rate limit to set for org, if is_set_limit is set to true.
  final num limit;

  const v1TestRateLimitsRequest({
    required  this.organizationId,
    required  this.isSetLimit,
    required  this.limit,
  });

  factory v1TestRateLimitsRequest.fromJson(Map<String, dynamic> json) {
    final _organizationId = json['organizationId'] as String;
    final _isSetLimit = json['isSetLimit'] as bool;
    final _limit = json['limit'] as num;
    return v1TestRateLimitsRequest(
      organizationId: _organizationId,
      isSetLimit: _isSetLimit,
      limit: _limit,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['organizationId'] = organizationId;
    _json['isSetLimit'] = isSetLimit;
    _json['limit'] = limit;
    return _json;
  }
}

class v1TestRateLimitsResponse {
  const v1TestRateLimitsResponse();
  factory v1TestRateLimitsResponse.fromJson(Map<String, dynamic> json) => const v1TestRateLimitsResponse();
  Map<String, dynamic> toJson() => {};
}

class v1TokenUsage {
  /// Type of token usage
  final v1UsageType type;
  /// Unique identifier for the verification token
  final String tokenId;
  final v1SignupUsage? signup;
  final v1LoginUsage? login;

  const v1TokenUsage({
    required  this.type,
    required  this.tokenId,
     this.signup,
     this.login,
  });

  factory v1TokenUsage.fromJson(Map<String, dynamic> json) {
    final _type = v1UsageTypeFromJson(json['type']);
    final _tokenId = json['tokenId'] as String;
    final _signup = json['signup'] == null ? null : v1SignupUsage.fromJson(json['signup'] as Map<String, dynamic>);
    final _login = json['login'] == null ? null : v1LoginUsage.fromJson(json['login'] as Map<String, dynamic>);
    return v1TokenUsage(
      type: _type,
      tokenId: _tokenId,
      signup: _signup,
      login: _login,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['type'] = v1UsageTypeToJson(type);
    _json['tokenId'] = tokenId;
    if (signup != null) {
      _json['signup'] = signup?.toJson();
    }
    if (login != null) {
      _json['login'] = login?.toJson();
    }
    return _json;
  }
}

class v1TvcApp {
  /// Unique Identifier for this TVC App.
  final String id;
  /// Unique Identifier of the Organization for this TVC App
  final String organizationId;
  /// Name for this TVC App.
  final String name;
  /// Public key for the Quorum Key associated with this TVC App
  final String quorumPublicKey;
  /// Manifest Set (people who can approve manifests)
  final v1TvcOperatorSet manifestSet;
  /// Share Set (people who have a share of the Quorum Key)
  final v1TvcOperatorSet shareSet;
  /// Whether or not this TVC App has external connectivity enabled.
  final bool externalConnectivity;
  final externaldatav1Timestamp createdAt;
  final externaldatav1Timestamp updatedAt;

  const v1TvcApp({
    required  this.id,
    required  this.organizationId,
    required  this.name,
    required  this.quorumPublicKey,
    required  this.manifestSet,
    required  this.shareSet,
    required  this.externalConnectivity,
    required  this.createdAt,
    required  this.updatedAt,
  });

  factory v1TvcApp.fromJson(Map<String, dynamic> json) {
    final _id = json['id'] as String;
    final _organizationId = json['organizationId'] as String;
    final _name = json['name'] as String;
    final _quorumPublicKey = json['quorumPublicKey'] as String;
    final _manifestSet = v1TvcOperatorSet.fromJson(json['manifestSet'] as Map<String, dynamic>);
    final _shareSet = v1TvcOperatorSet.fromJson(json['shareSet'] as Map<String, dynamic>);
    final _externalConnectivity = json['externalConnectivity'] as bool;
    final _createdAt = externaldatav1Timestamp.fromJson(json['createdAt'] as Map<String, dynamic>);
    final _updatedAt = externaldatav1Timestamp.fromJson(json['updatedAt'] as Map<String, dynamic>);
    return v1TvcApp(
      id: _id,
      organizationId: _organizationId,
      name: _name,
      quorumPublicKey: _quorumPublicKey,
      manifestSet: _manifestSet,
      shareSet: _shareSet,
      externalConnectivity: _externalConnectivity,
      createdAt: _createdAt,
      updatedAt: _updatedAt,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['id'] = id;
    _json['organizationId'] = organizationId;
    _json['name'] = name;
    _json['quorumPublicKey'] = quorumPublicKey;
    _json['manifestSet'] = manifestSet.toJson();
    _json['shareSet'] = shareSet.toJson();
    _json['externalConnectivity'] = externalConnectivity;
    _json['createdAt'] = createdAt.toJson();
    _json['updatedAt'] = updatedAt.toJson();
    return _json;
  }
}

class v1TvcContainerSpec {
  /// The URL for this container image.
  final String containerUrl;
  /// The path (in-container) to the executable binary.
  final String path;
  /// The arguments to pass to the executable.
  final List<String> args;
  /// Whether or not this container requires a pull secret to access.
  final bool hasPullSecret;

  const v1TvcContainerSpec({
    required  this.containerUrl,
    required  this.path,
    required  this.args,
    required  this.hasPullSecret,
  });

  factory v1TvcContainerSpec.fromJson(Map<String, dynamic> json) {
    final _containerUrl = json['containerUrl'] as String;
    final _path = json['path'] as String;
    final _args = (json['args'] as List).map((e) => e as String).toList();
    final _hasPullSecret = json['hasPullSecret'] as bool;
    return v1TvcContainerSpec(
      containerUrl: _containerUrl,
      path: _path,
      args: _args,
      hasPullSecret: _hasPullSecret,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['containerUrl'] = containerUrl;
    _json['path'] = path;
    _json['args'] = args;
    _json['hasPullSecret'] = hasPullSecret;
    return _json;
  }
}

class v1TvcDeployment {
  /// Unique Identifier for this TVC Deployment.
  final String id;
  /// Unique Identifier of the Organization for this TVC Deployment
  final String organizationId;
  /// Unique Identifier of the TVC App for this deployment
  final String appId;
  /// Set of TVC operators who can approve this deployment
  final v1TvcOperatorSet manifestSet;
  /// Set of TVC operators who have a share of the Quorum Key
  final v1TvcOperatorSet shareSet;
  /// The manifest used for this deployment
  final v1TvcManifest manifest;
  /// List of operator approvals for this manifest
  final List<v1TvcOperatorApproval> manifestApprovals;
  /// QOS Version used for this deployment
  final String qosVersion;
  /// The pivot container spec for this deployment
  final v1TvcContainerSpec pivotContainer;
  /// The pivot container spec for this deployment
  final v1TvcContainerSpec hostContainer;
  /// Current stage for this deployment
  final v1TvcDeploymentStage stage;
  final externaldatav1Timestamp createdAt;
  final externaldatav1Timestamp updatedAt;

  const v1TvcDeployment({
    required  this.id,
    required  this.organizationId,
    required  this.appId,
    required  this.manifestSet,
    required  this.shareSet,
    required  this.manifest,
    required  this.manifestApprovals,
    required  this.qosVersion,
    required  this.pivotContainer,
    required  this.hostContainer,
    required  this.stage,
    required  this.createdAt,
    required  this.updatedAt,
  });

  factory v1TvcDeployment.fromJson(Map<String, dynamic> json) {
    final _id = json['id'] as String;
    final _organizationId = json['organizationId'] as String;
    final _appId = json['appId'] as String;
    final _manifestSet = v1TvcOperatorSet.fromJson(json['manifestSet'] as Map<String, dynamic>);
    final _shareSet = v1TvcOperatorSet.fromJson(json['shareSet'] as Map<String, dynamic>);
    final _manifest = v1TvcManifest.fromJson(json['manifest'] as Map<String, dynamic>);
    final _manifestApprovals = (json['manifestApprovals'] as List).map((e) => v1TvcOperatorApproval.fromJson(e as Map<String, dynamic>)).toList();
    final _qosVersion = json['qosVersion'] as String;
    final _pivotContainer = v1TvcContainerSpec.fromJson(json['pivotContainer'] as Map<String, dynamic>);
    final _hostContainer = v1TvcContainerSpec.fromJson(json['hostContainer'] as Map<String, dynamic>);
    final _stage = v1TvcDeploymentStageFromJson(json['stage']);
    final _createdAt = externaldatav1Timestamp.fromJson(json['createdAt'] as Map<String, dynamic>);
    final _updatedAt = externaldatav1Timestamp.fromJson(json['updatedAt'] as Map<String, dynamic>);
    return v1TvcDeployment(
      id: _id,
      organizationId: _organizationId,
      appId: _appId,
      manifestSet: _manifestSet,
      shareSet: _shareSet,
      manifest: _manifest,
      manifestApprovals: _manifestApprovals,
      qosVersion: _qosVersion,
      pivotContainer: _pivotContainer,
      hostContainer: _hostContainer,
      stage: _stage,
      createdAt: _createdAt,
      updatedAt: _updatedAt,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['id'] = id;
    _json['organizationId'] = organizationId;
    _json['appId'] = appId;
    _json['manifestSet'] = manifestSet.toJson();
    _json['shareSet'] = shareSet.toJson();
    _json['manifest'] = manifest.toJson();
    _json['manifestApprovals'] = manifestApprovals.map((e) => e.toJson()).toList();
    _json['qosVersion'] = qosVersion;
    _json['pivotContainer'] = pivotContainer.toJson();
    _json['hostContainer'] = hostContainer.toJson();
    _json['stage'] = v1TvcDeploymentStageToJson(stage);
    _json['createdAt'] = createdAt.toJson();
    _json['updatedAt'] = updatedAt.toJson();
    return _json;
  }
}

class v1TvcManifest {
  /// Unique Identifier for this TVC Manifest.
  final String id;
  /// The manifest content (raw UTF-8 JSON bytes)
  final String manifest;
  final externaldatav1Timestamp createdAt;
  final externaldatav1Timestamp updatedAt;

  const v1TvcManifest({
    required  this.id,
    required  this.manifest,
    required  this.createdAt,
    required  this.updatedAt,
  });

  factory v1TvcManifest.fromJson(Map<String, dynamic> json) {
    final _id = json['id'] as String;
    final _manifest = json['manifest'] as String;
    final _createdAt = externaldatav1Timestamp.fromJson(json['createdAt'] as Map<String, dynamic>);
    final _updatedAt = externaldatav1Timestamp.fromJson(json['updatedAt'] as Map<String, dynamic>);
    return v1TvcManifest(
      id: _id,
      manifest: _manifest,
      createdAt: _createdAt,
      updatedAt: _updatedAt,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['id'] = id;
    _json['manifest'] = manifest;
    _json['createdAt'] = createdAt.toJson();
    _json['updatedAt'] = updatedAt.toJson();
    return _json;
  }
}

class v1TvcManifestApproval {
  /// Unique identifier of the operator providing this approval
  final String operatorId;
  /// Signature from the operator approving the manifest
  final String signature;

  const v1TvcManifestApproval({
    required  this.operatorId,
    required  this.signature,
  });

  factory v1TvcManifestApproval.fromJson(Map<String, dynamic> json) {
    final _operatorId = json['operatorId'] as String;
    final _signature = json['signature'] as String;
    return v1TvcManifestApproval(
      operatorId: _operatorId,
      signature: _signature,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['operatorId'] = operatorId;
    _json['signature'] = signature;
    return _json;
  }
}

class v1TvcOperator {
  /// Unique Identifier for this TVC Operator.
  final String id;
  /// Name of this TVC Operator.
  final String name;
  /// Public key for this TVC Operator.
  final String publicKey;
  final externaldatav1Timestamp createdAt;
  final externaldatav1Timestamp updatedAt;

  const v1TvcOperator({
    required  this.id,
    required  this.name,
    required  this.publicKey,
    required  this.createdAt,
    required  this.updatedAt,
  });

  factory v1TvcOperator.fromJson(Map<String, dynamic> json) {
    final _id = json['id'] as String;
    final _name = json['name'] as String;
    final _publicKey = json['publicKey'] as String;
    final _createdAt = externaldatav1Timestamp.fromJson(json['createdAt'] as Map<String, dynamic>);
    final _updatedAt = externaldatav1Timestamp.fromJson(json['updatedAt'] as Map<String, dynamic>);
    return v1TvcOperator(
      id: _id,
      name: _name,
      publicKey: _publicKey,
      createdAt: _createdAt,
      updatedAt: _updatedAt,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['id'] = id;
    _json['name'] = name;
    _json['publicKey'] = publicKey;
    _json['createdAt'] = createdAt.toJson();
    _json['updatedAt'] = updatedAt.toJson();
    return _json;
  }
}

class v1TvcOperatorApproval {
  /// Unique ID for this approval
  final String id;
  /// Unique Identifier of the TVC Manifest being approved
  final String manifestId;
  /// The TVC Operator who made this approval
  final v1TvcOperator operator;
  /// Signature of the operator over the deployment manifest
  final String approval;
  final externaldatav1Timestamp createdAt;
  final externaldatav1Timestamp updatedAt;

  const v1TvcOperatorApproval({
    required  this.id,
    required  this.manifestId,
    required  this.operator,
    required  this.approval,
    required  this.createdAt,
    required  this.updatedAt,
  });

  factory v1TvcOperatorApproval.fromJson(Map<String, dynamic> json) {
    final _id = json['id'] as String;
    final _manifestId = json['manifestId'] as String;
    final _operator = v1TvcOperator.fromJson(json['operator'] as Map<String, dynamic>);
    final _approval = json['approval'] as String;
    final _createdAt = externaldatav1Timestamp.fromJson(json['createdAt'] as Map<String, dynamic>);
    final _updatedAt = externaldatav1Timestamp.fromJson(json['updatedAt'] as Map<String, dynamic>);
    return v1TvcOperatorApproval(
      id: _id,
      manifestId: _manifestId,
      operator: _operator,
      approval: _approval,
      createdAt: _createdAt,
      updatedAt: _updatedAt,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['id'] = id;
    _json['manifestId'] = manifestId;
    _json['operator'] = operator.toJson();
    _json['approval'] = approval;
    _json['createdAt'] = createdAt.toJson();
    _json['updatedAt'] = updatedAt.toJson();
    return _json;
  }
}

class v1TvcOperatorParams {
  /// The name for this new operator
  final String name;
  /// Public key for this operator
  final String publicKey;

  const v1TvcOperatorParams({
    required  this.name,
    required  this.publicKey,
  });

  factory v1TvcOperatorParams.fromJson(Map<String, dynamic> json) {
    final _name = json['name'] as String;
    final _publicKey = json['publicKey'] as String;
    return v1TvcOperatorParams(
      name: _name,
      publicKey: _publicKey,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['name'] = name;
    _json['publicKey'] = publicKey;
    return _json;
  }
}

class v1TvcOperatorSet {
  /// Unique Identifier for this TVC Operator Set.
  final String id;
  /// Name of this TVC Operator Set.
  final String name;
  /// Unique Identifier of the Organization for this TVC Operator Set
  final String organizationId;
  /// List of TVC Operators in this set
  final List<v1TvcOperator> operators;
  /// Threshold number of operators required for quorum.
  final num threshold;
  final externaldatav1Timestamp createdAt;
  final externaldatav1Timestamp updatedAt;

  const v1TvcOperatorSet({
    required  this.id,
    required  this.name,
    required  this.organizationId,
    required  this.operators,
    required  this.threshold,
    required  this.createdAt,
    required  this.updatedAt,
  });

  factory v1TvcOperatorSet.fromJson(Map<String, dynamic> json) {
    final _id = json['id'] as String;
    final _name = json['name'] as String;
    final _organizationId = json['organizationId'] as String;
    final _operators = (json['operators'] as List).map((e) => v1TvcOperator.fromJson(e as Map<String, dynamic>)).toList();
    final _threshold = json['threshold'] as num;
    final _createdAt = externaldatav1Timestamp.fromJson(json['createdAt'] as Map<String, dynamic>);
    final _updatedAt = externaldatav1Timestamp.fromJson(json['updatedAt'] as Map<String, dynamic>);
    return v1TvcOperatorSet(
      id: _id,
      name: _name,
      organizationId: _organizationId,
      operators: _operators,
      threshold: _threshold,
      createdAt: _createdAt,
      updatedAt: _updatedAt,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['id'] = id;
    _json['name'] = name;
    _json['organizationId'] = organizationId;
    _json['operators'] = operators.map((e) => e.toJson()).toList();
    _json['threshold'] = threshold;
    _json['createdAt'] = createdAt.toJson();
    _json['updatedAt'] = updatedAt.toJson();
    return _json;
  }
}

class v1TvcOperatorSetParams {
  /// Short description for this new operator set
  final String name;
  /// Operators to create as part of this new operator set
  final List<v1TvcOperatorParams>? newOperators;
  /// Existing operators to use as part of this new operator set
  final List<String>? existingOperatorIds;
  /// The threshold of operators needed to reach consensus in this new Operator Set
  final num threshold;

  const v1TvcOperatorSetParams({
    required  this.name,
     this.newOperators,
     this.existingOperatorIds,
    required  this.threshold,
  });

  factory v1TvcOperatorSetParams.fromJson(Map<String, dynamic> json) {
    final _name = json['name'] as String;
    final _newOperators = (json['newOperators'] as List?)?.map((e) => v1TvcOperatorParams.fromJson(e as Map<String, dynamic>)).toList();
    final _existingOperatorIds = (json['existingOperatorIds'] as List?)?.map((e) => e as String).toList();
    final _threshold = json['threshold'] as num;
    return v1TvcOperatorSetParams(
      name: _name,
      newOperators: _newOperators,
      existingOperatorIds: _existingOperatorIds,
      threshold: _threshold,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['name'] = name;
    if (newOperators != null) {
      _json['newOperators'] = newOperators?.map((e) => e.toJson()).toList();
    }
    if (existingOperatorIds != null) {
      _json['existingOperatorIds'] = existingOperatorIds;
    }
    _json['threshold'] = threshold;
    return _json;
  }
}

class v1TxError {
  /// Human-readable error message describing what went wrong.
  final String? message;
  /// Chain of revert errors from nested contract calls, ordered from outermost to innermost.
  final List<v1RevertChainEntry>? revertChain;

  const v1TxError({
     this.message,
     this.revertChain,
  });

  factory v1TxError.fromJson(Map<String, dynamic> json) {
    final _message = json['message'] as String?;
    final _revertChain = (json['revertChain'] as List?)?.map((e) => v1RevertChainEntry.fromJson(e as Map<String, dynamic>)).toList();
    return v1TxError(
      message: _message,
      revertChain: _revertChain,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    if (message != null) {
      _json['message'] = message;
    }
    if (revertChain != null) {
      _json['revertChain'] = revertChain?.map((e) => e.toJson()).toList();
    }
    return _json;
  }
}

class v1UnknownRevertError {
  /// The 4-byte error selector, if available.
  final String? selector;
  /// The raw error data, hex-encoded.
  final String? data;

  const v1UnknownRevertError({
     this.selector,
     this.data,
  });

  factory v1UnknownRevertError.fromJson(Map<String, dynamic> json) {
    final _selector = json['selector'] as String?;
    final _data = json['data'] as String?;
    return v1UnknownRevertError(
      selector: _selector,
      data: _data,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    if (selector != null) {
      _json['selector'] = selector;
    }
    if (data != null) {
      _json['data'] = data;
    }
    return _json;
  }
}

class v1UpdateAllowedOriginsIntent {
  /// Additional origins requests are allowed from besides Turnkey origins
  final List<String> allowedOrigins;

  const v1UpdateAllowedOriginsIntent({
    required  this.allowedOrigins,
  });

  factory v1UpdateAllowedOriginsIntent.fromJson(Map<String, dynamic> json) {
    final _allowedOrigins = (json['allowedOrigins'] as List).map((e) => e as String).toList();
    return v1UpdateAllowedOriginsIntent(
      allowedOrigins: _allowedOrigins,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['allowedOrigins'] = allowedOrigins;
    return _json;
  }
}

class v1UpdateAllowedOriginsResult {
  const v1UpdateAllowedOriginsResult();
  factory v1UpdateAllowedOriginsResult.fromJson(Map<String, dynamic> json) => const v1UpdateAllowedOriginsResult();
  Map<String, dynamic> toJson() => {};
}

class v1UpdateAuthProxyConfigIntent {
  /// Updated list of allowed origins for CORS.
  final List<String>? allowedOrigins;
  /// Updated list of allowed proxy authentication methods.
  final List<String>? allowedAuthMethods;
  /// Custom 'from' address for auth-related emails.
  final String? sendFromEmailAddress;
  /// Custom reply-to address for auth-related emails.
  final String? replyToEmailAddress;
  /// Template ID for email-auth messages.
  final String? emailAuthTemplateId;
  /// Template ID for OTP SMS messages.
  final String? otpTemplateId;
  /// Optional parameters for customizing emails. If not provided, the default email will be used.
  final v1EmailCustomizationParams? emailCustomizationParams;
  /// Overrides for auth-related SMS content.
  final v1SmsCustomizationParams? smsCustomizationParams;
  /// Overrides for react wallet kit related settings.
  final v1WalletKitSettingsParams? walletKitSettings;
  /// OTP code lifetime in seconds.
  final num? otpExpirationSeconds;
  /// Verification-token lifetime in seconds.
  final num? verificationTokenExpirationSeconds;
  /// Session lifetime in seconds.
  final num? sessionExpirationSeconds;
  /// Enable alphanumeric OTP codes.
  final bool? otpAlphanumeric;
  /// Desired OTP code length (69).
  final num? otpLength;
  /// Custom 'from' email sender for auth-related emails.
  final String? sendFromEmailSenderName;
  /// Verification token required for get account with PII (email/phone number). Default false.
  final bool? verificationTokenRequiredForGetAccountPii;

  const v1UpdateAuthProxyConfigIntent({
     this.allowedOrigins,
     this.allowedAuthMethods,
     this.sendFromEmailAddress,
     this.replyToEmailAddress,
     this.emailAuthTemplateId,
     this.otpTemplateId,
     this.emailCustomizationParams,
     this.smsCustomizationParams,
     this.walletKitSettings,
     this.otpExpirationSeconds,
     this.verificationTokenExpirationSeconds,
     this.sessionExpirationSeconds,
     this.otpAlphanumeric,
     this.otpLength,
     this.sendFromEmailSenderName,
     this.verificationTokenRequiredForGetAccountPii,
  });

  factory v1UpdateAuthProxyConfigIntent.fromJson(Map<String, dynamic> json) {
    final _allowedOrigins = (json['allowedOrigins'] as List?)?.map((e) => e as String).toList();
    final _allowedAuthMethods = (json['allowedAuthMethods'] as List?)?.map((e) => e as String).toList();
    final _sendFromEmailAddress = json['sendFromEmailAddress'] as String?;
    final _replyToEmailAddress = json['replyToEmailAddress'] as String?;
    final _emailAuthTemplateId = json['emailAuthTemplateId'] as String?;
    final _otpTemplateId = json['otpTemplateId'] as String?;
    final _emailCustomizationParams = json['emailCustomizationParams'] == null ? null : v1EmailCustomizationParams.fromJson(json['emailCustomizationParams'] as Map<String, dynamic>);
    final _smsCustomizationParams = json['smsCustomizationParams'] == null ? null : v1SmsCustomizationParams.fromJson(json['smsCustomizationParams'] as Map<String, dynamic>);
    final _walletKitSettings = json['walletKitSettings'] == null ? null : v1WalletKitSettingsParams.fromJson(json['walletKitSettings'] as Map<String, dynamic>);
    final _otpExpirationSeconds = json['otpExpirationSeconds'] as num?;
    final _verificationTokenExpirationSeconds = json['verificationTokenExpirationSeconds'] as num?;
    final _sessionExpirationSeconds = json['sessionExpirationSeconds'] as num?;
    final _otpAlphanumeric = json['otpAlphanumeric'] as bool?;
    final _otpLength = json['otpLength'] as num?;
    final _sendFromEmailSenderName = json['sendFromEmailSenderName'] as String?;
    final _verificationTokenRequiredForGetAccountPii = json['verificationTokenRequiredForGetAccountPii'] as bool?;
    return v1UpdateAuthProxyConfigIntent(
      allowedOrigins: _allowedOrigins,
      allowedAuthMethods: _allowedAuthMethods,
      sendFromEmailAddress: _sendFromEmailAddress,
      replyToEmailAddress: _replyToEmailAddress,
      emailAuthTemplateId: _emailAuthTemplateId,
      otpTemplateId: _otpTemplateId,
      emailCustomizationParams: _emailCustomizationParams,
      smsCustomizationParams: _smsCustomizationParams,
      walletKitSettings: _walletKitSettings,
      otpExpirationSeconds: _otpExpirationSeconds,
      verificationTokenExpirationSeconds: _verificationTokenExpirationSeconds,
      sessionExpirationSeconds: _sessionExpirationSeconds,
      otpAlphanumeric: _otpAlphanumeric,
      otpLength: _otpLength,
      sendFromEmailSenderName: _sendFromEmailSenderName,
      verificationTokenRequiredForGetAccountPii: _verificationTokenRequiredForGetAccountPii,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    if (allowedOrigins != null) {
      _json['allowedOrigins'] = allowedOrigins;
    }
    if (allowedAuthMethods != null) {
      _json['allowedAuthMethods'] = allowedAuthMethods;
    }
    if (sendFromEmailAddress != null) {
      _json['sendFromEmailAddress'] = sendFromEmailAddress;
    }
    if (replyToEmailAddress != null) {
      _json['replyToEmailAddress'] = replyToEmailAddress;
    }
    if (emailAuthTemplateId != null) {
      _json['emailAuthTemplateId'] = emailAuthTemplateId;
    }
    if (otpTemplateId != null) {
      _json['otpTemplateId'] = otpTemplateId;
    }
    if (emailCustomizationParams != null) {
      _json['emailCustomizationParams'] = emailCustomizationParams?.toJson();
    }
    if (smsCustomizationParams != null) {
      _json['smsCustomizationParams'] = smsCustomizationParams?.toJson();
    }
    if (walletKitSettings != null) {
      _json['walletKitSettings'] = walletKitSettings?.toJson();
    }
    if (otpExpirationSeconds != null) {
      _json['otpExpirationSeconds'] = otpExpirationSeconds;
    }
    if (verificationTokenExpirationSeconds != null) {
      _json['verificationTokenExpirationSeconds'] = verificationTokenExpirationSeconds;
    }
    if (sessionExpirationSeconds != null) {
      _json['sessionExpirationSeconds'] = sessionExpirationSeconds;
    }
    if (otpAlphanumeric != null) {
      _json['otpAlphanumeric'] = otpAlphanumeric;
    }
    if (otpLength != null) {
      _json['otpLength'] = otpLength;
    }
    if (sendFromEmailSenderName != null) {
      _json['sendFromEmailSenderName'] = sendFromEmailSenderName;
    }
    if (verificationTokenRequiredForGetAccountPii != null) {
      _json['verificationTokenRequiredForGetAccountPii'] = verificationTokenRequiredForGetAccountPii;
    }
    return _json;
  }
}

class v1UpdateAuthProxyConfigResult {
  /// Unique identifier for a given User. (representing the turnkey signer user id)
  final String? configId;

  const v1UpdateAuthProxyConfigResult({
     this.configId,
  });

  factory v1UpdateAuthProxyConfigResult.fromJson(Map<String, dynamic> json) {
    final _configId = json['configId'] as String?;
    return v1UpdateAuthProxyConfigResult(
      configId: _configId,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    if (configId != null) {
      _json['configId'] = configId;
    }
    return _json;
  }
}

class v1UpdateFiatOnRampCredentialIntent {
  /// The ID of the fiat on-ramp credential to update
  final String fiatOnrampCredentialId;
  /// The fiat on-ramp provider
  final v1FiatOnRampProvider onrampProvider;
  /// Project ID for the on-ramp provider. Some providers, like Coinbase, require this additional identifier.
  final String? projectId;
  /// Publishable API key for the on-ramp provider
  final String publishableApiKey;
  /// Secret API key for the on-ramp provider encrypted to our on-ramp encryption public key
  final String encryptedSecretApiKey;
  /// Private API key for the on-ramp provider encrypted to our on-ramp encryption public key. Some providers, like Coinbase, require this additional key.
  final String? encryptedPrivateApiKey;

  const v1UpdateFiatOnRampCredentialIntent({
    required  this.fiatOnrampCredentialId,
    required  this.onrampProvider,
     this.projectId,
    required  this.publishableApiKey,
    required  this.encryptedSecretApiKey,
     this.encryptedPrivateApiKey,
  });

  factory v1UpdateFiatOnRampCredentialIntent.fromJson(Map<String, dynamic> json) {
    final _fiatOnrampCredentialId = json['fiatOnrampCredentialId'] as String;
    final _onrampProvider = v1FiatOnRampProviderFromJson(json['onrampProvider']);
    final _projectId = json['projectId'] as String?;
    final _publishableApiKey = json['publishableApiKey'] as String;
    final _encryptedSecretApiKey = json['encryptedSecretApiKey'] as String;
    final _encryptedPrivateApiKey = json['encryptedPrivateApiKey'] as String?;
    return v1UpdateFiatOnRampCredentialIntent(
      fiatOnrampCredentialId: _fiatOnrampCredentialId,
      onrampProvider: _onrampProvider,
      projectId: _projectId,
      publishableApiKey: _publishableApiKey,
      encryptedSecretApiKey: _encryptedSecretApiKey,
      encryptedPrivateApiKey: _encryptedPrivateApiKey,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['fiatOnrampCredentialId'] = fiatOnrampCredentialId;
    _json['onrampProvider'] = v1FiatOnRampProviderToJson(onrampProvider);
    if (projectId != null) {
      _json['projectId'] = projectId;
    }
    _json['publishableApiKey'] = publishableApiKey;
    _json['encryptedSecretApiKey'] = encryptedSecretApiKey;
    if (encryptedPrivateApiKey != null) {
      _json['encryptedPrivateApiKey'] = encryptedPrivateApiKey;
    }
    return _json;
  }
}

class v1UpdateFiatOnRampCredentialRequest {
  final String type;
  /// Timestamp (in milliseconds) of the request, used to verify liveness of user requests.
  final String timestampMs;
  /// Unique identifier for a given Organization.
  final String organizationId;
  final v1UpdateFiatOnRampCredentialIntent parameters;
  final bool? generateAppProofs;

  const v1UpdateFiatOnRampCredentialRequest({
    required  this.type,
    required  this.timestampMs,
    required  this.organizationId,
    required  this.parameters,
     this.generateAppProofs,
  });

  factory v1UpdateFiatOnRampCredentialRequest.fromJson(Map<String, dynamic> json) {
    final _type = json['type'] as String;
    final _timestampMs = json['timestampMs'] as String;
    final _organizationId = json['organizationId'] as String;
    final _parameters = v1UpdateFiatOnRampCredentialIntent.fromJson(json['parameters'] as Map<String, dynamic>);
    final _generateAppProofs = json['generateAppProofs'] as bool?;
    return v1UpdateFiatOnRampCredentialRequest(
      type: _type,
      timestampMs: _timestampMs,
      organizationId: _organizationId,
      parameters: _parameters,
      generateAppProofs: _generateAppProofs,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['type'] = type;
    _json['timestampMs'] = timestampMs;
    _json['organizationId'] = organizationId;
    _json['parameters'] = parameters.toJson();
    if (generateAppProofs != null) {
      _json['generateAppProofs'] = generateAppProofs;
    }
    return _json;
  }
}

class v1UpdateFiatOnRampCredentialResult {
  /// Unique identifier of the Fiat On-Ramp credential that was updated
  final String fiatOnRampCredentialId;

  const v1UpdateFiatOnRampCredentialResult({
    required  this.fiatOnRampCredentialId,
  });

  factory v1UpdateFiatOnRampCredentialResult.fromJson(Map<String, dynamic> json) {
    final _fiatOnRampCredentialId = json['fiatOnRampCredentialId'] as String;
    return v1UpdateFiatOnRampCredentialResult(
      fiatOnRampCredentialId: _fiatOnRampCredentialId,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['fiatOnRampCredentialId'] = fiatOnRampCredentialId;
    return _json;
  }
}

class v1UpdateOauth2CredentialIntent {
  /// The ID of the OAuth 2.0 credential to update
  final String oauth2CredentialId;
  /// The OAuth 2.0 provider
  final v1Oauth2Provider provider;
  /// The Client ID issued by the OAuth 2.0 provider
  final String clientId;
  /// The client secret issued by the OAuth 2.0 provider encrypted to the TLS Fetcher quorum key
  final String encryptedClientSecret;

  const v1UpdateOauth2CredentialIntent({
    required  this.oauth2CredentialId,
    required  this.provider,
    required  this.clientId,
    required  this.encryptedClientSecret,
  });

  factory v1UpdateOauth2CredentialIntent.fromJson(Map<String, dynamic> json) {
    final _oauth2CredentialId = json['oauth2CredentialId'] as String;
    final _provider = v1Oauth2ProviderFromJson(json['provider']);
    final _clientId = json['clientId'] as String;
    final _encryptedClientSecret = json['encryptedClientSecret'] as String;
    return v1UpdateOauth2CredentialIntent(
      oauth2CredentialId: _oauth2CredentialId,
      provider: _provider,
      clientId: _clientId,
      encryptedClientSecret: _encryptedClientSecret,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['oauth2CredentialId'] = oauth2CredentialId;
    _json['provider'] = v1Oauth2ProviderToJson(provider);
    _json['clientId'] = clientId;
    _json['encryptedClientSecret'] = encryptedClientSecret;
    return _json;
  }
}

class v1UpdateOauth2CredentialRequest {
  final String type;
  /// Timestamp (in milliseconds) of the request, used to verify liveness of user requests.
  final String timestampMs;
  /// Unique identifier for a given Organization.
  final String organizationId;
  final v1UpdateOauth2CredentialIntent parameters;
  final bool? generateAppProofs;

  const v1UpdateOauth2CredentialRequest({
    required  this.type,
    required  this.timestampMs,
    required  this.organizationId,
    required  this.parameters,
     this.generateAppProofs,
  });

  factory v1UpdateOauth2CredentialRequest.fromJson(Map<String, dynamic> json) {
    final _type = json['type'] as String;
    final _timestampMs = json['timestampMs'] as String;
    final _organizationId = json['organizationId'] as String;
    final _parameters = v1UpdateOauth2CredentialIntent.fromJson(json['parameters'] as Map<String, dynamic>);
    final _generateAppProofs = json['generateAppProofs'] as bool?;
    return v1UpdateOauth2CredentialRequest(
      type: _type,
      timestampMs: _timestampMs,
      organizationId: _organizationId,
      parameters: _parameters,
      generateAppProofs: _generateAppProofs,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['type'] = type;
    _json['timestampMs'] = timestampMs;
    _json['organizationId'] = organizationId;
    _json['parameters'] = parameters.toJson();
    if (generateAppProofs != null) {
      _json['generateAppProofs'] = generateAppProofs;
    }
    return _json;
  }
}

class v1UpdateOauth2CredentialResult {
  /// Unique identifier of the OAuth 2.0 credential that was updated
  final String oauth2CredentialId;

  const v1UpdateOauth2CredentialResult({
    required  this.oauth2CredentialId,
  });

  factory v1UpdateOauth2CredentialResult.fromJson(Map<String, dynamic> json) {
    final _oauth2CredentialId = json['oauth2CredentialId'] as String;
    return v1UpdateOauth2CredentialResult(
      oauth2CredentialId: _oauth2CredentialId,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['oauth2CredentialId'] = oauth2CredentialId;
    return _json;
  }
}

class v1UpdatePolicyIntent {
  /// Unique identifier for a given Policy.
  final String policyId;
  /// Human-readable name for a Policy.
  final String? policyName;
  /// The instruction to DENY or ALLOW an activity (optional).
  final v1Effect? policyEffect;
  /// The condition expression that triggers the Effect (optional).
  final String? policyCondition;
  /// The consensus expression that triggers the Effect (optional).
  final String? policyConsensus;
  /// Accompanying notes for a Policy (optional).
  final String? policyNotes;

  const v1UpdatePolicyIntent({
    required  this.policyId,
     this.policyName,
     this.policyEffect,
     this.policyCondition,
     this.policyConsensus,
     this.policyNotes,
  });

  factory v1UpdatePolicyIntent.fromJson(Map<String, dynamic> json) {
    final _policyId = json['policyId'] as String;
    final _policyName = json['policyName'] as String?;
    final _policyEffect = json['policyEffect'] == null ? null : v1EffectFromJson(json['policyEffect']);
    final _policyCondition = json['policyCondition'] as String?;
    final _policyConsensus = json['policyConsensus'] as String?;
    final _policyNotes = json['policyNotes'] as String?;
    return v1UpdatePolicyIntent(
      policyId: _policyId,
      policyName: _policyName,
      policyEffect: _policyEffect,
      policyCondition: _policyCondition,
      policyConsensus: _policyConsensus,
      policyNotes: _policyNotes,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['policyId'] = policyId;
    if (policyName != null) {
      _json['policyName'] = policyName;
    }
    if (policyEffect != null) {
      _json['policyEffect'] = v1EffectToJson(policyEffect!);
    }
    if (policyCondition != null) {
      _json['policyCondition'] = policyCondition;
    }
    if (policyConsensus != null) {
      _json['policyConsensus'] = policyConsensus;
    }
    if (policyNotes != null) {
      _json['policyNotes'] = policyNotes;
    }
    return _json;
  }
}

class v1UpdatePolicyIntentV2 {
  /// Unique identifier for a given Policy.
  final String policyId;
  /// Human-readable name for a Policy.
  final String? policyName;
  /// The instruction to DENY or ALLOW an activity (optional).
  final v1Effect? policyEffect;
  /// The condition expression that triggers the Effect (optional).
  final String? policyCondition;
  /// The consensus expression that triggers the Effect (optional).
  final String? policyConsensus;
  /// Accompanying notes for a Policy (optional).
  final String? policyNotes;

  const v1UpdatePolicyIntentV2({
    required  this.policyId,
     this.policyName,
     this.policyEffect,
     this.policyCondition,
     this.policyConsensus,
     this.policyNotes,
  });

  factory v1UpdatePolicyIntentV2.fromJson(Map<String, dynamic> json) {
    final _policyId = json['policyId'] as String;
    final _policyName = json['policyName'] as String?;
    final _policyEffect = json['policyEffect'] == null ? null : v1EffectFromJson(json['policyEffect']);
    final _policyCondition = json['policyCondition'] as String?;
    final _policyConsensus = json['policyConsensus'] as String?;
    final _policyNotes = json['policyNotes'] as String?;
    return v1UpdatePolicyIntentV2(
      policyId: _policyId,
      policyName: _policyName,
      policyEffect: _policyEffect,
      policyCondition: _policyCondition,
      policyConsensus: _policyConsensus,
      policyNotes: _policyNotes,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['policyId'] = policyId;
    if (policyName != null) {
      _json['policyName'] = policyName;
    }
    if (policyEffect != null) {
      _json['policyEffect'] = v1EffectToJson(policyEffect!);
    }
    if (policyCondition != null) {
      _json['policyCondition'] = policyCondition;
    }
    if (policyConsensus != null) {
      _json['policyConsensus'] = policyConsensus;
    }
    if (policyNotes != null) {
      _json['policyNotes'] = policyNotes;
    }
    return _json;
  }
}

class v1UpdatePolicyRequest {
  final String type;
  /// Timestamp (in milliseconds) of the request, used to verify liveness of user requests.
  final String timestampMs;
  /// Unique identifier for a given Organization.
  final String organizationId;
  final v1UpdatePolicyIntentV2 parameters;
  final bool? generateAppProofs;

  const v1UpdatePolicyRequest({
    required  this.type,
    required  this.timestampMs,
    required  this.organizationId,
    required  this.parameters,
     this.generateAppProofs,
  });

  factory v1UpdatePolicyRequest.fromJson(Map<String, dynamic> json) {
    final _type = json['type'] as String;
    final _timestampMs = json['timestampMs'] as String;
    final _organizationId = json['organizationId'] as String;
    final _parameters = v1UpdatePolicyIntentV2.fromJson(json['parameters'] as Map<String, dynamic>);
    final _generateAppProofs = json['generateAppProofs'] as bool?;
    return v1UpdatePolicyRequest(
      type: _type,
      timestampMs: _timestampMs,
      organizationId: _organizationId,
      parameters: _parameters,
      generateAppProofs: _generateAppProofs,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['type'] = type;
    _json['timestampMs'] = timestampMs;
    _json['organizationId'] = organizationId;
    _json['parameters'] = parameters.toJson();
    if (generateAppProofs != null) {
      _json['generateAppProofs'] = generateAppProofs;
    }
    return _json;
  }
}

class v1UpdatePolicyResult {
  /// Unique identifier for a given Policy.
  final String policyId;

  const v1UpdatePolicyResult({
    required  this.policyId,
  });

  factory v1UpdatePolicyResult.fromJson(Map<String, dynamic> json) {
    final _policyId = json['policyId'] as String;
    return v1UpdatePolicyResult(
      policyId: _policyId,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['policyId'] = policyId;
    return _json;
  }
}

class v1UpdatePolicyResultV2 {
  /// Unique identifier for a given Policy.
  final String policyId;

  const v1UpdatePolicyResultV2({
    required  this.policyId,
  });

  factory v1UpdatePolicyResultV2.fromJson(Map<String, dynamic> json) {
    final _policyId = json['policyId'] as String;
    return v1UpdatePolicyResultV2(
      policyId: _policyId,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['policyId'] = policyId;
    return _json;
  }
}

class v1UpdatePrivateKeyTagIntent {
  /// Unique identifier for a given Private Key Tag.
  final String privateKeyTagId;
  /// The new, human-readable name for the tag with the given ID.
  final String? newPrivateKeyTagName;
  /// A list of Private Keys IDs to add this tag to.
  final List<String> addPrivateKeyIds;
  /// A list of Private Key IDs to remove this tag from.
  final List<String> removePrivateKeyIds;

  const v1UpdatePrivateKeyTagIntent({
    required  this.privateKeyTagId,
     this.newPrivateKeyTagName,
    required  this.addPrivateKeyIds,
    required  this.removePrivateKeyIds,
  });

  factory v1UpdatePrivateKeyTagIntent.fromJson(Map<String, dynamic> json) {
    final _privateKeyTagId = json['privateKeyTagId'] as String;
    final _newPrivateKeyTagName = json['newPrivateKeyTagName'] as String?;
    final _addPrivateKeyIds = (json['addPrivateKeyIds'] as List).map((e) => e as String).toList();
    final _removePrivateKeyIds = (json['removePrivateKeyIds'] as List).map((e) => e as String).toList();
    return v1UpdatePrivateKeyTagIntent(
      privateKeyTagId: _privateKeyTagId,
      newPrivateKeyTagName: _newPrivateKeyTagName,
      addPrivateKeyIds: _addPrivateKeyIds,
      removePrivateKeyIds: _removePrivateKeyIds,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['privateKeyTagId'] = privateKeyTagId;
    if (newPrivateKeyTagName != null) {
      _json['newPrivateKeyTagName'] = newPrivateKeyTagName;
    }
    _json['addPrivateKeyIds'] = addPrivateKeyIds;
    _json['removePrivateKeyIds'] = removePrivateKeyIds;
    return _json;
  }
}

class v1UpdatePrivateKeyTagRequest {
  final String type;
  /// Timestamp (in milliseconds) of the request, used to verify liveness of user requests.
  final String timestampMs;
  /// Unique identifier for a given Organization.
  final String organizationId;
  final v1UpdatePrivateKeyTagIntent parameters;
  final bool? generateAppProofs;

  const v1UpdatePrivateKeyTagRequest({
    required  this.type,
    required  this.timestampMs,
    required  this.organizationId,
    required  this.parameters,
     this.generateAppProofs,
  });

  factory v1UpdatePrivateKeyTagRequest.fromJson(Map<String, dynamic> json) {
    final _type = json['type'] as String;
    final _timestampMs = json['timestampMs'] as String;
    final _organizationId = json['organizationId'] as String;
    final _parameters = v1UpdatePrivateKeyTagIntent.fromJson(json['parameters'] as Map<String, dynamic>);
    final _generateAppProofs = json['generateAppProofs'] as bool?;
    return v1UpdatePrivateKeyTagRequest(
      type: _type,
      timestampMs: _timestampMs,
      organizationId: _organizationId,
      parameters: _parameters,
      generateAppProofs: _generateAppProofs,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['type'] = type;
    _json['timestampMs'] = timestampMs;
    _json['organizationId'] = organizationId;
    _json['parameters'] = parameters.toJson();
    if (generateAppProofs != null) {
      _json['generateAppProofs'] = generateAppProofs;
    }
    return _json;
  }
}

class v1UpdatePrivateKeyTagResult {
  /// Unique identifier for a given Private Key Tag.
  final String privateKeyTagId;

  const v1UpdatePrivateKeyTagResult({
    required  this.privateKeyTagId,
  });

  factory v1UpdatePrivateKeyTagResult.fromJson(Map<String, dynamic> json) {
    final _privateKeyTagId = json['privateKeyTagId'] as String;
    return v1UpdatePrivateKeyTagResult(
      privateKeyTagId: _privateKeyTagId,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['privateKeyTagId'] = privateKeyTagId;
    return _json;
  }
}

class v1UpdateRootQuorumIntent {
  /// The threshold of unique approvals to reach quorum.
  final num threshold;
  /// The unique identifiers of users who comprise the quorum set.
  final List<String> userIds;

  const v1UpdateRootQuorumIntent({
    required  this.threshold,
    required  this.userIds,
  });

  factory v1UpdateRootQuorumIntent.fromJson(Map<String, dynamic> json) {
    final _threshold = json['threshold'] as num;
    final _userIds = (json['userIds'] as List).map((e) => e as String).toList();
    return v1UpdateRootQuorumIntent(
      threshold: _threshold,
      userIds: _userIds,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['threshold'] = threshold;
    _json['userIds'] = userIds;
    return _json;
  }
}

class v1UpdateRootQuorumRequest {
  final String type;
  /// Timestamp (in milliseconds) of the request, used to verify liveness of user requests.
  final String timestampMs;
  /// Unique identifier for a given Organization.
  final String organizationId;
  final v1UpdateRootQuorumIntent parameters;
  final bool? generateAppProofs;

  const v1UpdateRootQuorumRequest({
    required  this.type,
    required  this.timestampMs,
    required  this.organizationId,
    required  this.parameters,
     this.generateAppProofs,
  });

  factory v1UpdateRootQuorumRequest.fromJson(Map<String, dynamic> json) {
    final _type = json['type'] as String;
    final _timestampMs = json['timestampMs'] as String;
    final _organizationId = json['organizationId'] as String;
    final _parameters = v1UpdateRootQuorumIntent.fromJson(json['parameters'] as Map<String, dynamic>);
    final _generateAppProofs = json['generateAppProofs'] as bool?;
    return v1UpdateRootQuorumRequest(
      type: _type,
      timestampMs: _timestampMs,
      organizationId: _organizationId,
      parameters: _parameters,
      generateAppProofs: _generateAppProofs,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['type'] = type;
    _json['timestampMs'] = timestampMs;
    _json['organizationId'] = organizationId;
    _json['parameters'] = parameters.toJson();
    if (generateAppProofs != null) {
      _json['generateAppProofs'] = generateAppProofs;
    }
    return _json;
  }
}

class v1UpdateRootQuorumResult {
  const v1UpdateRootQuorumResult();
  factory v1UpdateRootQuorumResult.fromJson(Map<String, dynamic> json) => const v1UpdateRootQuorumResult();
  Map<String, dynamic> toJson() => {};
}

class v1UpdateUserEmailIntent {
  /// Unique identifier for a given User.
  final String userId;
  /// The user's email address. Setting this to an empty string will remove the user's email.
  final String userEmail;
  /// Signed JWT containing a unique id, expiry, verification type, contact
  final String? verificationToken;

  const v1UpdateUserEmailIntent({
    required  this.userId,
    required  this.userEmail,
     this.verificationToken,
  });

  factory v1UpdateUserEmailIntent.fromJson(Map<String, dynamic> json) {
    final _userId = json['userId'] as String;
    final _userEmail = json['userEmail'] as String;
    final _verificationToken = json['verificationToken'] as String?;
    return v1UpdateUserEmailIntent(
      userId: _userId,
      userEmail: _userEmail,
      verificationToken: _verificationToken,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['userId'] = userId;
    _json['userEmail'] = userEmail;
    if (verificationToken != null) {
      _json['verificationToken'] = verificationToken;
    }
    return _json;
  }
}

class v1UpdateUserEmailRequest {
  final String type;
  /// Timestamp (in milliseconds) of the request, used to verify liveness of user requests.
  final String timestampMs;
  /// Unique identifier for a given Organization.
  final String organizationId;
  final v1UpdateUserEmailIntent parameters;
  final bool? generateAppProofs;

  const v1UpdateUserEmailRequest({
    required  this.type,
    required  this.timestampMs,
    required  this.organizationId,
    required  this.parameters,
     this.generateAppProofs,
  });

  factory v1UpdateUserEmailRequest.fromJson(Map<String, dynamic> json) {
    final _type = json['type'] as String;
    final _timestampMs = json['timestampMs'] as String;
    final _organizationId = json['organizationId'] as String;
    final _parameters = v1UpdateUserEmailIntent.fromJson(json['parameters'] as Map<String, dynamic>);
    final _generateAppProofs = json['generateAppProofs'] as bool?;
    return v1UpdateUserEmailRequest(
      type: _type,
      timestampMs: _timestampMs,
      organizationId: _organizationId,
      parameters: _parameters,
      generateAppProofs: _generateAppProofs,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['type'] = type;
    _json['timestampMs'] = timestampMs;
    _json['organizationId'] = organizationId;
    _json['parameters'] = parameters.toJson();
    if (generateAppProofs != null) {
      _json['generateAppProofs'] = generateAppProofs;
    }
    return _json;
  }
}

class v1UpdateUserEmailResult {
  /// Unique identifier of the User whose email was updated.
  final String userId;

  const v1UpdateUserEmailResult({
    required  this.userId,
  });

  factory v1UpdateUserEmailResult.fromJson(Map<String, dynamic> json) {
    final _userId = json['userId'] as String;
    return v1UpdateUserEmailResult(
      userId: _userId,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['userId'] = userId;
    return _json;
  }
}

class v1UpdateUserIntent {
  /// Unique identifier for a given User.
  final String userId;
  /// Human-readable name for a User.
  final String? userName;
  /// The user's email address.
  final String? userEmail;
  /// An updated list of User Tags to apply to this User. This field, if not needed, should be an empty array in your request body.
  final List<String>? userTagIds;
  /// The user's phone number in E.164 format e.g. +13214567890
  final String? userPhoneNumber;

  const v1UpdateUserIntent({
    required  this.userId,
     this.userName,
     this.userEmail,
     this.userTagIds,
     this.userPhoneNumber,
  });

  factory v1UpdateUserIntent.fromJson(Map<String, dynamic> json) {
    final _userId = json['userId'] as String;
    final _userName = json['userName'] as String?;
    final _userEmail = json['userEmail'] as String?;
    final _userTagIds = (json['userTagIds'] as List?)?.map((e) => e as String).toList();
    final _userPhoneNumber = json['userPhoneNumber'] as String?;
    return v1UpdateUserIntent(
      userId: _userId,
      userName: _userName,
      userEmail: _userEmail,
      userTagIds: _userTagIds,
      userPhoneNumber: _userPhoneNumber,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['userId'] = userId;
    if (userName != null) {
      _json['userName'] = userName;
    }
    if (userEmail != null) {
      _json['userEmail'] = userEmail;
    }
    if (userTagIds != null) {
      _json['userTagIds'] = userTagIds;
    }
    if (userPhoneNumber != null) {
      _json['userPhoneNumber'] = userPhoneNumber;
    }
    return _json;
  }
}

class v1UpdateUserNameIntent {
  /// Unique identifier for a given User.
  final String userId;
  /// Human-readable name for a User.
  final String userName;

  const v1UpdateUserNameIntent({
    required  this.userId,
    required  this.userName,
  });

  factory v1UpdateUserNameIntent.fromJson(Map<String, dynamic> json) {
    final _userId = json['userId'] as String;
    final _userName = json['userName'] as String;
    return v1UpdateUserNameIntent(
      userId: _userId,
      userName: _userName,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['userId'] = userId;
    _json['userName'] = userName;
    return _json;
  }
}

class v1UpdateUserNameRequest {
  final String type;
  /// Timestamp (in milliseconds) of the request, used to verify liveness of user requests.
  final String timestampMs;
  /// Unique identifier for a given Organization.
  final String organizationId;
  final v1UpdateUserNameIntent parameters;
  final bool? generateAppProofs;

  const v1UpdateUserNameRequest({
    required  this.type,
    required  this.timestampMs,
    required  this.organizationId,
    required  this.parameters,
     this.generateAppProofs,
  });

  factory v1UpdateUserNameRequest.fromJson(Map<String, dynamic> json) {
    final _type = json['type'] as String;
    final _timestampMs = json['timestampMs'] as String;
    final _organizationId = json['organizationId'] as String;
    final _parameters = v1UpdateUserNameIntent.fromJson(json['parameters'] as Map<String, dynamic>);
    final _generateAppProofs = json['generateAppProofs'] as bool?;
    return v1UpdateUserNameRequest(
      type: _type,
      timestampMs: _timestampMs,
      organizationId: _organizationId,
      parameters: _parameters,
      generateAppProofs: _generateAppProofs,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['type'] = type;
    _json['timestampMs'] = timestampMs;
    _json['organizationId'] = organizationId;
    _json['parameters'] = parameters.toJson();
    if (generateAppProofs != null) {
      _json['generateAppProofs'] = generateAppProofs;
    }
    return _json;
  }
}

class v1UpdateUserNameResult {
  /// Unique identifier of the User whose name was updated.
  final String userId;

  const v1UpdateUserNameResult({
    required  this.userId,
  });

  factory v1UpdateUserNameResult.fromJson(Map<String, dynamic> json) {
    final _userId = json['userId'] as String;
    return v1UpdateUserNameResult(
      userId: _userId,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['userId'] = userId;
    return _json;
  }
}

class v1UpdateUserPhoneNumberIntent {
  /// Unique identifier for a given User.
  final String userId;
  /// The user's phone number in E.164 format e.g. +13214567890. Setting this to an empty string will remove the user's phone number.
  final String userPhoneNumber;
  /// Signed JWT containing a unique id, expiry, verification type, contact
  final String? verificationToken;

  const v1UpdateUserPhoneNumberIntent({
    required  this.userId,
    required  this.userPhoneNumber,
     this.verificationToken,
  });

  factory v1UpdateUserPhoneNumberIntent.fromJson(Map<String, dynamic> json) {
    final _userId = json['userId'] as String;
    final _userPhoneNumber = json['userPhoneNumber'] as String;
    final _verificationToken = json['verificationToken'] as String?;
    return v1UpdateUserPhoneNumberIntent(
      userId: _userId,
      userPhoneNumber: _userPhoneNumber,
      verificationToken: _verificationToken,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['userId'] = userId;
    _json['userPhoneNumber'] = userPhoneNumber;
    if (verificationToken != null) {
      _json['verificationToken'] = verificationToken;
    }
    return _json;
  }
}

class v1UpdateUserPhoneNumberRequest {
  final String type;
  /// Timestamp (in milliseconds) of the request, used to verify liveness of user requests.
  final String timestampMs;
  /// Unique identifier for a given Organization.
  final String organizationId;
  final v1UpdateUserPhoneNumberIntent parameters;
  final bool? generateAppProofs;

  const v1UpdateUserPhoneNumberRequest({
    required  this.type,
    required  this.timestampMs,
    required  this.organizationId,
    required  this.parameters,
     this.generateAppProofs,
  });

  factory v1UpdateUserPhoneNumberRequest.fromJson(Map<String, dynamic> json) {
    final _type = json['type'] as String;
    final _timestampMs = json['timestampMs'] as String;
    final _organizationId = json['organizationId'] as String;
    final _parameters = v1UpdateUserPhoneNumberIntent.fromJson(json['parameters'] as Map<String, dynamic>);
    final _generateAppProofs = json['generateAppProofs'] as bool?;
    return v1UpdateUserPhoneNumberRequest(
      type: _type,
      timestampMs: _timestampMs,
      organizationId: _organizationId,
      parameters: _parameters,
      generateAppProofs: _generateAppProofs,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['type'] = type;
    _json['timestampMs'] = timestampMs;
    _json['organizationId'] = organizationId;
    _json['parameters'] = parameters.toJson();
    if (generateAppProofs != null) {
      _json['generateAppProofs'] = generateAppProofs;
    }
    return _json;
  }
}

class v1UpdateUserPhoneNumberResult {
  /// Unique identifier of the User whose phone number was updated.
  final String userId;

  const v1UpdateUserPhoneNumberResult({
    required  this.userId,
  });

  factory v1UpdateUserPhoneNumberResult.fromJson(Map<String, dynamic> json) {
    final _userId = json['userId'] as String;
    return v1UpdateUserPhoneNumberResult(
      userId: _userId,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['userId'] = userId;
    return _json;
  }
}

class v1UpdateUserRequest {
  final String type;
  /// Timestamp (in milliseconds) of the request, used to verify liveness of user requests.
  final String timestampMs;
  /// Unique identifier for a given Organization.
  final String organizationId;
  final v1UpdateUserIntent parameters;
  final bool? generateAppProofs;

  const v1UpdateUserRequest({
    required  this.type,
    required  this.timestampMs,
    required  this.organizationId,
    required  this.parameters,
     this.generateAppProofs,
  });

  factory v1UpdateUserRequest.fromJson(Map<String, dynamic> json) {
    final _type = json['type'] as String;
    final _timestampMs = json['timestampMs'] as String;
    final _organizationId = json['organizationId'] as String;
    final _parameters = v1UpdateUserIntent.fromJson(json['parameters'] as Map<String, dynamic>);
    final _generateAppProofs = json['generateAppProofs'] as bool?;
    return v1UpdateUserRequest(
      type: _type,
      timestampMs: _timestampMs,
      organizationId: _organizationId,
      parameters: _parameters,
      generateAppProofs: _generateAppProofs,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['type'] = type;
    _json['timestampMs'] = timestampMs;
    _json['organizationId'] = organizationId;
    _json['parameters'] = parameters.toJson();
    if (generateAppProofs != null) {
      _json['generateAppProofs'] = generateAppProofs;
    }
    return _json;
  }
}

class v1UpdateUserResult {
  /// A User ID.
  final String userId;

  const v1UpdateUserResult({
    required  this.userId,
  });

  factory v1UpdateUserResult.fromJson(Map<String, dynamic> json) {
    final _userId = json['userId'] as String;
    return v1UpdateUserResult(
      userId: _userId,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['userId'] = userId;
    return _json;
  }
}

class v1UpdateUserTagIntent {
  /// Unique identifier for a given User Tag.
  final String userTagId;
  /// The new, human-readable name for the tag with the given ID.
  final String? newUserTagName;
  /// A list of User IDs to add this tag to.
  final List<String> addUserIds;
  /// A list of User IDs to remove this tag from.
  final List<String> removeUserIds;

  const v1UpdateUserTagIntent({
    required  this.userTagId,
     this.newUserTagName,
    required  this.addUserIds,
    required  this.removeUserIds,
  });

  factory v1UpdateUserTagIntent.fromJson(Map<String, dynamic> json) {
    final _userTagId = json['userTagId'] as String;
    final _newUserTagName = json['newUserTagName'] as String?;
    final _addUserIds = (json['addUserIds'] as List).map((e) => e as String).toList();
    final _removeUserIds = (json['removeUserIds'] as List).map((e) => e as String).toList();
    return v1UpdateUserTagIntent(
      userTagId: _userTagId,
      newUserTagName: _newUserTagName,
      addUserIds: _addUserIds,
      removeUserIds: _removeUserIds,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['userTagId'] = userTagId;
    if (newUserTagName != null) {
      _json['newUserTagName'] = newUserTagName;
    }
    _json['addUserIds'] = addUserIds;
    _json['removeUserIds'] = removeUserIds;
    return _json;
  }
}

class v1UpdateUserTagRequest {
  final String type;
  /// Timestamp (in milliseconds) of the request, used to verify liveness of user requests.
  final String timestampMs;
  /// Unique identifier for a given Organization.
  final String organizationId;
  final v1UpdateUserTagIntent parameters;
  final bool? generateAppProofs;

  const v1UpdateUserTagRequest({
    required  this.type,
    required  this.timestampMs,
    required  this.organizationId,
    required  this.parameters,
     this.generateAppProofs,
  });

  factory v1UpdateUserTagRequest.fromJson(Map<String, dynamic> json) {
    final _type = json['type'] as String;
    final _timestampMs = json['timestampMs'] as String;
    final _organizationId = json['organizationId'] as String;
    final _parameters = v1UpdateUserTagIntent.fromJson(json['parameters'] as Map<String, dynamic>);
    final _generateAppProofs = json['generateAppProofs'] as bool?;
    return v1UpdateUserTagRequest(
      type: _type,
      timestampMs: _timestampMs,
      organizationId: _organizationId,
      parameters: _parameters,
      generateAppProofs: _generateAppProofs,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['type'] = type;
    _json['timestampMs'] = timestampMs;
    _json['organizationId'] = organizationId;
    _json['parameters'] = parameters.toJson();
    if (generateAppProofs != null) {
      _json['generateAppProofs'] = generateAppProofs;
    }
    return _json;
  }
}

class v1UpdateUserTagResult {
  /// Unique identifier for a given User Tag.
  final String userTagId;

  const v1UpdateUserTagResult({
    required  this.userTagId,
  });

  factory v1UpdateUserTagResult.fromJson(Map<String, dynamic> json) {
    final _userTagId = json['userTagId'] as String;
    return v1UpdateUserTagResult(
      userTagId: _userTagId,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['userTagId'] = userTagId;
    return _json;
  }
}

class v1UpdateWalletIntent {
  /// Unique identifier for a given Wallet.
  final String walletId;
  /// Human-readable name for a Wallet.
  final String? walletName;

  const v1UpdateWalletIntent({
    required  this.walletId,
     this.walletName,
  });

  factory v1UpdateWalletIntent.fromJson(Map<String, dynamic> json) {
    final _walletId = json['walletId'] as String;
    final _walletName = json['walletName'] as String?;
    return v1UpdateWalletIntent(
      walletId: _walletId,
      walletName: _walletName,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['walletId'] = walletId;
    if (walletName != null) {
      _json['walletName'] = walletName;
    }
    return _json;
  }
}

class v1UpdateWalletRequest {
  final String type;
  /// Timestamp (in milliseconds) of the request, used to verify liveness of user requests.
  final String timestampMs;
  /// Unique identifier for a given Organization.
  final String organizationId;
  final v1UpdateWalletIntent parameters;
  final bool? generateAppProofs;

  const v1UpdateWalletRequest({
    required  this.type,
    required  this.timestampMs,
    required  this.organizationId,
    required  this.parameters,
     this.generateAppProofs,
  });

  factory v1UpdateWalletRequest.fromJson(Map<String, dynamic> json) {
    final _type = json['type'] as String;
    final _timestampMs = json['timestampMs'] as String;
    final _organizationId = json['organizationId'] as String;
    final _parameters = v1UpdateWalletIntent.fromJson(json['parameters'] as Map<String, dynamic>);
    final _generateAppProofs = json['generateAppProofs'] as bool?;
    return v1UpdateWalletRequest(
      type: _type,
      timestampMs: _timestampMs,
      organizationId: _organizationId,
      parameters: _parameters,
      generateAppProofs: _generateAppProofs,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['type'] = type;
    _json['timestampMs'] = timestampMs;
    _json['organizationId'] = organizationId;
    _json['parameters'] = parameters.toJson();
    if (generateAppProofs != null) {
      _json['generateAppProofs'] = generateAppProofs;
    }
    return _json;
  }
}

class v1UpdateWalletResult {
  /// A Wallet ID.
  final String walletId;

  const v1UpdateWalletResult({
    required  this.walletId,
  });

  factory v1UpdateWalletResult.fromJson(Map<String, dynamic> json) {
    final _walletId = json['walletId'] as String;
    return v1UpdateWalletResult(
      walletId: _walletId,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['walletId'] = walletId;
    return _json;
  }
}

class v1UpsertGasUsageConfigIntent {
  /// Gas sponsorship USD limit for the billing organization window.
  final String orgWindowLimitUsd;
  /// Gas sponsorship USD limit for sub-organizations under the billing organization.
  final String subOrgWindowLimitUsd;
  /// Rolling sponsorship window duration, expressed in minutes.
  final String windowDurationMinutes;

  const v1UpsertGasUsageConfigIntent({
    required  this.orgWindowLimitUsd,
    required  this.subOrgWindowLimitUsd,
    required  this.windowDurationMinutes,
  });

  factory v1UpsertGasUsageConfigIntent.fromJson(Map<String, dynamic> json) {
    final _orgWindowLimitUsd = json['orgWindowLimitUsd'] as String;
    final _subOrgWindowLimitUsd = json['subOrgWindowLimitUsd'] as String;
    final _windowDurationMinutes = json['windowDurationMinutes'] as String;
    return v1UpsertGasUsageConfigIntent(
      orgWindowLimitUsd: _orgWindowLimitUsd,
      subOrgWindowLimitUsd: _subOrgWindowLimitUsd,
      windowDurationMinutes: _windowDurationMinutes,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['orgWindowLimitUsd'] = orgWindowLimitUsd;
    _json['subOrgWindowLimitUsd'] = subOrgWindowLimitUsd;
    _json['windowDurationMinutes'] = windowDurationMinutes;
    return _json;
  }
}

class v1UpsertGasUsageConfigResult {
  /// Unique identifier for the gas usage configuration that was created or updated.
  final String gasUsageConfigId;

  const v1UpsertGasUsageConfigResult({
    required  this.gasUsageConfigId,
  });

  factory v1UpsertGasUsageConfigResult.fromJson(Map<String, dynamic> json) {
    final _gasUsageConfigId = json['gasUsageConfigId'] as String;
    return v1UpsertGasUsageConfigResult(
      gasUsageConfigId: _gasUsageConfigId,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['gasUsageConfigId'] = gasUsageConfigId;
    return _json;
  }
}

class v1User {
  /// Unique identifier for a given User.
  final String userId;
  /// Human-readable name for a User.
  final String userName;
  /// The user's email address.
  final String? userEmail;
  /// The user's phone number in E.164 format e.g. +13214567890
  final String? userPhoneNumber;
  /// A list of Authenticator parameters.
  final List<v1Authenticator> authenticators;
  /// A list of API Key parameters. This field, if not needed, should be an empty array in your request body.
  final List<v1ApiKey> apiKeys;
  /// A list of User Tag IDs.
  final List<String> userTags;
  /// A list of Oauth Providers.
  final List<v1OauthProvider> oauthProviders;
  final externaldatav1Timestamp createdAt;
  final externaldatav1Timestamp updatedAt;

  const v1User({
    required  this.userId,
    required  this.userName,
     this.userEmail,
     this.userPhoneNumber,
    required  this.authenticators,
    required  this.apiKeys,
    required  this.userTags,
    required  this.oauthProviders,
    required  this.createdAt,
    required  this.updatedAt,
  });

  factory v1User.fromJson(Map<String, dynamic> json) {
    final _userId = json['userId'] as String;
    final _userName = json['userName'] as String;
    final _userEmail = json['userEmail'] as String?;
    final _userPhoneNumber = json['userPhoneNumber'] as String?;
    final _authenticators = (json['authenticators'] as List).map((e) => v1Authenticator.fromJson(e as Map<String, dynamic>)).toList();
    final _apiKeys = (json['apiKeys'] as List).map((e) => v1ApiKey.fromJson(e as Map<String, dynamic>)).toList();
    final _userTags = (json['userTags'] as List).map((e) => e as String).toList();
    final _oauthProviders = (json['oauthProviders'] as List).map((e) => v1OauthProvider.fromJson(e as Map<String, dynamic>)).toList();
    final _createdAt = externaldatav1Timestamp.fromJson(json['createdAt'] as Map<String, dynamic>);
    final _updatedAt = externaldatav1Timestamp.fromJson(json['updatedAt'] as Map<String, dynamic>);
    return v1User(
      userId: _userId,
      userName: _userName,
      userEmail: _userEmail,
      userPhoneNumber: _userPhoneNumber,
      authenticators: _authenticators,
      apiKeys: _apiKeys,
      userTags: _userTags,
      oauthProviders: _oauthProviders,
      createdAt: _createdAt,
      updatedAt: _updatedAt,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['userId'] = userId;
    _json['userName'] = userName;
    if (userEmail != null) {
      _json['userEmail'] = userEmail;
    }
    if (userPhoneNumber != null) {
      _json['userPhoneNumber'] = userPhoneNumber;
    }
    _json['authenticators'] = authenticators.map((e) => e.toJson()).toList();
    _json['apiKeys'] = apiKeys.map((e) => e.toJson()).toList();
    _json['userTags'] = userTags;
    _json['oauthProviders'] = oauthProviders.map((e) => e.toJson()).toList();
    _json['createdAt'] = createdAt.toJson();
    _json['updatedAt'] = updatedAt.toJson();
    return _json;
  }
}

class v1UserParams {
  /// Human-readable name for a User.
  final String userName;
  /// The user's email address.
  final String? userEmail;
  /// The User's permissible access method(s).
  final v1AccessType accessType;
  /// A list of API Key parameters. This field, if not needed, should be an empty array in your request body.
  final List<apiApiKeyParams> apiKeys;
  /// A list of Authenticator parameters. This field, if not needed, should be an empty array in your request body.
  final List<v1AuthenticatorParams> authenticators;
  /// A list of User Tag IDs. This field, if not needed, should be an empty array in your request body.
  final List<String> userTags;

  const v1UserParams({
    required  this.userName,
     this.userEmail,
    required  this.accessType,
    required  this.apiKeys,
    required  this.authenticators,
    required  this.userTags,
  });

  factory v1UserParams.fromJson(Map<String, dynamic> json) {
    final _userName = json['userName'] as String;
    final _userEmail = json['userEmail'] as String?;
    final _accessType = v1AccessTypeFromJson(json['accessType']);
    final _apiKeys = (json['apiKeys'] as List).map((e) => apiApiKeyParams.fromJson(e as Map<String, dynamic>)).toList();
    final _authenticators = (json['authenticators'] as List).map((e) => v1AuthenticatorParams.fromJson(e as Map<String, dynamic>)).toList();
    final _userTags = (json['userTags'] as List).map((e) => e as String).toList();
    return v1UserParams(
      userName: _userName,
      userEmail: _userEmail,
      accessType: _accessType,
      apiKeys: _apiKeys,
      authenticators: _authenticators,
      userTags: _userTags,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['userName'] = userName;
    if (userEmail != null) {
      _json['userEmail'] = userEmail;
    }
    _json['accessType'] = v1AccessTypeToJson(accessType);
    _json['apiKeys'] = apiKeys.map((e) => e.toJson()).toList();
    _json['authenticators'] = authenticators.map((e) => e.toJson()).toList();
    _json['userTags'] = userTags;
    return _json;
  }
}

class v1UserParamsV2 {
  /// Human-readable name for a User.
  final String userName;
  /// The user's email address.
  final String? userEmail;
  /// A list of API Key parameters. This field, if not needed, should be an empty array in your request body.
  final List<apiApiKeyParams> apiKeys;
  /// A list of Authenticator parameters. This field, if not needed, should be an empty array in your request body.
  final List<v1AuthenticatorParamsV2> authenticators;
  /// A list of User Tag IDs. This field, if not needed, should be an empty array in your request body.
  final List<String> userTags;

  const v1UserParamsV2({
    required  this.userName,
     this.userEmail,
    required  this.apiKeys,
    required  this.authenticators,
    required  this.userTags,
  });

  factory v1UserParamsV2.fromJson(Map<String, dynamic> json) {
    final _userName = json['userName'] as String;
    final _userEmail = json['userEmail'] as String?;
    final _apiKeys = (json['apiKeys'] as List).map((e) => apiApiKeyParams.fromJson(e as Map<String, dynamic>)).toList();
    final _authenticators = (json['authenticators'] as List).map((e) => v1AuthenticatorParamsV2.fromJson(e as Map<String, dynamic>)).toList();
    final _userTags = (json['userTags'] as List).map((e) => e as String).toList();
    return v1UserParamsV2(
      userName: _userName,
      userEmail: _userEmail,
      apiKeys: _apiKeys,
      authenticators: _authenticators,
      userTags: _userTags,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['userName'] = userName;
    if (userEmail != null) {
      _json['userEmail'] = userEmail;
    }
    _json['apiKeys'] = apiKeys.map((e) => e.toJson()).toList();
    _json['authenticators'] = authenticators.map((e) => e.toJson()).toList();
    _json['userTags'] = userTags;
    return _json;
  }
}

class v1UserParamsV3 {
  /// Human-readable name for a User.
  final String userName;
  /// The user's email address.
  final String? userEmail;
  /// The user's phone number in E.164 format e.g. +13214567890
  final String? userPhoneNumber;
  /// A list of API Key parameters. This field, if not needed, should be an empty array in your request body.
  final List<v1ApiKeyParamsV2> apiKeys;
  /// A list of Authenticator parameters. This field, if not needed, should be an empty array in your request body.
  final List<v1AuthenticatorParamsV2> authenticators;
  /// A list of Oauth providers. This field, if not needed, should be an empty array in your request body.
  final List<v1OauthProviderParams> oauthProviders;
  /// A list of User Tag IDs. This field, if not needed, should be an empty array in your request body.
  final List<String> userTags;

  const v1UserParamsV3({
    required  this.userName,
     this.userEmail,
     this.userPhoneNumber,
    required  this.apiKeys,
    required  this.authenticators,
    required  this.oauthProviders,
    required  this.userTags,
  });

  factory v1UserParamsV3.fromJson(Map<String, dynamic> json) {
    final _userName = json['userName'] as String;
    final _userEmail = json['userEmail'] as String?;
    final _userPhoneNumber = json['userPhoneNumber'] as String?;
    final _apiKeys = (json['apiKeys'] as List).map((e) => v1ApiKeyParamsV2.fromJson(e as Map<String, dynamic>)).toList();
    final _authenticators = (json['authenticators'] as List).map((e) => v1AuthenticatorParamsV2.fromJson(e as Map<String, dynamic>)).toList();
    final _oauthProviders = (json['oauthProviders'] as List).map((e) => v1OauthProviderParams.fromJson(e as Map<String, dynamic>)).toList();
    final _userTags = (json['userTags'] as List).map((e) => e as String).toList();
    return v1UserParamsV3(
      userName: _userName,
      userEmail: _userEmail,
      userPhoneNumber: _userPhoneNumber,
      apiKeys: _apiKeys,
      authenticators: _authenticators,
      oauthProviders: _oauthProviders,
      userTags: _userTags,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['userName'] = userName;
    if (userEmail != null) {
      _json['userEmail'] = userEmail;
    }
    if (userPhoneNumber != null) {
      _json['userPhoneNumber'] = userPhoneNumber;
    }
    _json['apiKeys'] = apiKeys.map((e) => e.toJson()).toList();
    _json['authenticators'] = authenticators.map((e) => e.toJson()).toList();
    _json['oauthProviders'] = oauthProviders.map((e) => e.toJson()).toList();
    _json['userTags'] = userTags;
    return _json;
  }
}

class v1VerifyOtpIntent {
  /// ID representing the result of an init OTP activity.
  final String otpId;
  /// OTP sent out to a user's contact (email or SMS)
  final String otpCode;
  /// Expiration window (in seconds) indicating how long the verification token is valid for. If not provided, a default of 1 hour will be used. Maximum value is 86400 seconds (24 hours)
  final String? expirationSeconds;
  /// Client-side public key generated by the user, which will be added to the JWT response and verified in subsequent requests via a client proof signature
  final String? publicKey;

  const v1VerifyOtpIntent({
    required  this.otpId,
    required  this.otpCode,
     this.expirationSeconds,
     this.publicKey,
  });

  factory v1VerifyOtpIntent.fromJson(Map<String, dynamic> json) {
    final _otpId = json['otpId'] as String;
    final _otpCode = json['otpCode'] as String;
    final _expirationSeconds = json['expirationSeconds'] as String?;
    final _publicKey = json['publicKey'] as String?;
    return v1VerifyOtpIntent(
      otpId: _otpId,
      otpCode: _otpCode,
      expirationSeconds: _expirationSeconds,
      publicKey: _publicKey,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['otpId'] = otpId;
    _json['otpCode'] = otpCode;
    if (expirationSeconds != null) {
      _json['expirationSeconds'] = expirationSeconds;
    }
    if (publicKey != null) {
      _json['publicKey'] = publicKey;
    }
    return _json;
  }
}

class v1VerifyOtpRequest {
  final String type;
  /// Timestamp (in milliseconds) of the request, used to verify liveness of user requests.
  final String timestampMs;
  /// Unique identifier for a given Organization.
  final String organizationId;
  final v1VerifyOtpIntent parameters;
  final bool? generateAppProofs;

  const v1VerifyOtpRequest({
    required  this.type,
    required  this.timestampMs,
    required  this.organizationId,
    required  this.parameters,
     this.generateAppProofs,
  });

  factory v1VerifyOtpRequest.fromJson(Map<String, dynamic> json) {
    final _type = json['type'] as String;
    final _timestampMs = json['timestampMs'] as String;
    final _organizationId = json['organizationId'] as String;
    final _parameters = v1VerifyOtpIntent.fromJson(json['parameters'] as Map<String, dynamic>);
    final _generateAppProofs = json['generateAppProofs'] as bool?;
    return v1VerifyOtpRequest(
      type: _type,
      timestampMs: _timestampMs,
      organizationId: _organizationId,
      parameters: _parameters,
      generateAppProofs: _generateAppProofs,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['type'] = type;
    _json['timestampMs'] = timestampMs;
    _json['organizationId'] = organizationId;
    _json['parameters'] = parameters.toJson();
    if (generateAppProofs != null) {
      _json['generateAppProofs'] = generateAppProofs;
    }
    return _json;
  }
}

class v1VerifyOtpResult {
  /// Signed JWT containing a unique id, expiry, verification type, contact. Verification status of a user is updated when the token is consumed (in OTP_LOGIN requests)
  final String verificationToken;

  const v1VerifyOtpResult({
    required  this.verificationToken,
  });

  factory v1VerifyOtpResult.fromJson(Map<String, dynamic> json) {
    final _verificationToken = json['verificationToken'] as String;
    return v1VerifyOtpResult(
      verificationToken: _verificationToken,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['verificationToken'] = verificationToken;
    return _json;
  }
}

class v1Vote {
  /// Unique identifier for a given Vote object.
  final String id;
  /// Unique identifier for a given User.
  final String userId;
  /// Web and/or API user within your Organization.
  final v1User user;
  /// Unique identifier for a given Activity object.
  final String activityId;
  final String selection;
  /// The raw message being signed within a Vote.
  final String message;
  /// The public component of a cryptographic key pair used to sign messages and transactions.
  final String publicKey;
  /// The signature applied to a particular vote.
  final String signature;
  /// Method used to produce a signature.
  final String scheme;
  final externaldatav1Timestamp createdAt;

  const v1Vote({
    required  this.id,
    required  this.userId,
    required  this.user,
    required  this.activityId,
    required  this.selection,
    required  this.message,
    required  this.publicKey,
    required  this.signature,
    required  this.scheme,
    required  this.createdAt,
  });

  factory v1Vote.fromJson(Map<String, dynamic> json) {
    final _id = json['id'] as String;
    final _userId = json['userId'] as String;
    final _user = v1User.fromJson(json['user'] as Map<String, dynamic>);
    final _activityId = json['activityId'] as String;
    final _selection = json['selection'] as String;
    final _message = json['message'] as String;
    final _publicKey = json['publicKey'] as String;
    final _signature = json['signature'] as String;
    final _scheme = json['scheme'] as String;
    final _createdAt = externaldatav1Timestamp.fromJson(json['createdAt'] as Map<String, dynamic>);
    return v1Vote(
      id: _id,
      userId: _userId,
      user: _user,
      activityId: _activityId,
      selection: _selection,
      message: _message,
      publicKey: _publicKey,
      signature: _signature,
      scheme: _scheme,
      createdAt: _createdAt,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['id'] = id;
    _json['userId'] = userId;
    _json['user'] = user.toJson();
    _json['activityId'] = activityId;
    _json['selection'] = selection;
    _json['message'] = message;
    _json['publicKey'] = publicKey;
    _json['signature'] = signature;
    _json['scheme'] = scheme;
    _json['createdAt'] = createdAt.toJson();
    return _json;
  }
}

class v1Wallet {
  /// Unique identifier for a given Wallet.
  final String walletId;
  /// Human-readable name for a Wallet.
  final String walletName;
  final externaldatav1Timestamp createdAt;
  final externaldatav1Timestamp updatedAt;
  /// True when a given Wallet is exported, false otherwise.
  final bool exported;
  /// True when a given Wallet is imported, false otherwise.
  final bool imported;

  const v1Wallet({
    required  this.walletId,
    required  this.walletName,
    required  this.createdAt,
    required  this.updatedAt,
    required  this.exported,
    required  this.imported,
  });

  factory v1Wallet.fromJson(Map<String, dynamic> json) {
    final _walletId = json['walletId'] as String;
    final _walletName = json['walletName'] as String;
    final _createdAt = externaldatav1Timestamp.fromJson(json['createdAt'] as Map<String, dynamic>);
    final _updatedAt = externaldatav1Timestamp.fromJson(json['updatedAt'] as Map<String, dynamic>);
    final _exported = json['exported'] as bool;
    final _imported = json['imported'] as bool;
    return v1Wallet(
      walletId: _walletId,
      walletName: _walletName,
      createdAt: _createdAt,
      updatedAt: _updatedAt,
      exported: _exported,
      imported: _imported,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['walletId'] = walletId;
    _json['walletName'] = walletName;
    _json['createdAt'] = createdAt.toJson();
    _json['updatedAt'] = updatedAt.toJson();
    _json['exported'] = exported;
    _json['imported'] = imported;
    return _json;
  }
}

class v1WalletAccount {
  /// Unique identifier for a given Wallet Account.
  final String walletAccountId;
  /// The Organization the Account belongs to.
  final String organizationId;
  /// The Wallet the Account was derived from.
  final String walletId;
  /// Cryptographic curve used to generate the Account.
  final v1Curve curve;
  /// Path format used to generate the Account.
  final v1PathFormat pathFormat;
  /// Path used to generate the Account.
  final String path;
  /// Address format used to generate the Account.
  final v1AddressFormat addressFormat;
  /// Address generated using the Wallet seed and Account parameters.
  final String address;
  final externaldatav1Timestamp createdAt;
  final externaldatav1Timestamp updatedAt;
  /// The public component of this wallet account's underlying cryptographic key pair.
  final String? publicKey;
  /// Wallet details for this account. This is only present when include_wallet_details=true.
  final v1Wallet? walletDetails;

  const v1WalletAccount({
    required  this.walletAccountId,
    required  this.organizationId,
    required  this.walletId,
    required  this.curve,
    required  this.pathFormat,
    required  this.path,
    required  this.addressFormat,
    required  this.address,
    required  this.createdAt,
    required  this.updatedAt,
     this.publicKey,
     this.walletDetails,
  });

  factory v1WalletAccount.fromJson(Map<String, dynamic> json) {
    final _walletAccountId = json['walletAccountId'] as String;
    final _organizationId = json['organizationId'] as String;
    final _walletId = json['walletId'] as String;
    final _curve = v1CurveFromJson(json['curve']);
    final _pathFormat = v1PathFormatFromJson(json['pathFormat']);
    final _path = json['path'] as String;
    final _addressFormat = v1AddressFormatFromJson(json['addressFormat']);
    final _address = json['address'] as String;
    final _createdAt = externaldatav1Timestamp.fromJson(json['createdAt'] as Map<String, dynamic>);
    final _updatedAt = externaldatav1Timestamp.fromJson(json['updatedAt'] as Map<String, dynamic>);
    final _publicKey = json['publicKey'] as String?;
    final _walletDetails = json['walletDetails'] == null ? null : v1Wallet.fromJson(json['walletDetails'] as Map<String, dynamic>);
    return v1WalletAccount(
      walletAccountId: _walletAccountId,
      organizationId: _organizationId,
      walletId: _walletId,
      curve: _curve,
      pathFormat: _pathFormat,
      path: _path,
      addressFormat: _addressFormat,
      address: _address,
      createdAt: _createdAt,
      updatedAt: _updatedAt,
      publicKey: _publicKey,
      walletDetails: _walletDetails,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['walletAccountId'] = walletAccountId;
    _json['organizationId'] = organizationId;
    _json['walletId'] = walletId;
    _json['curve'] = v1CurveToJson(curve);
    _json['pathFormat'] = v1PathFormatToJson(pathFormat);
    _json['path'] = path;
    _json['addressFormat'] = v1AddressFormatToJson(addressFormat);
    _json['address'] = address;
    _json['createdAt'] = createdAt.toJson();
    _json['updatedAt'] = updatedAt.toJson();
    if (publicKey != null) {
      _json['publicKey'] = publicKey;
    }
    if (walletDetails != null) {
      _json['walletDetails'] = walletDetails?.toJson();
    }
    return _json;
  }
}

class v1WalletAccountParams {
  /// Cryptographic curve used to generate a wallet Account.
  final v1Curve curve;
  /// Path format used to generate a wallet Account.
  final v1PathFormat pathFormat;
  /// Path used to generate a wallet Account.
  final String path;
  /// Address format used to generate a wallet Acccount.
  final v1AddressFormat addressFormat;

  const v1WalletAccountParams({
    required  this.curve,
    required  this.pathFormat,
    required  this.path,
    required  this.addressFormat,
  });

  factory v1WalletAccountParams.fromJson(Map<String, dynamic> json) {
    final _curve = v1CurveFromJson(json['curve']);
    final _pathFormat = v1PathFormatFromJson(json['pathFormat']);
    final _path = json['path'] as String;
    final _addressFormat = v1AddressFormatFromJson(json['addressFormat']);
    return v1WalletAccountParams(
      curve: _curve,
      pathFormat: _pathFormat,
      path: _path,
      addressFormat: _addressFormat,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['curve'] = v1CurveToJson(curve);
    _json['pathFormat'] = v1PathFormatToJson(pathFormat);
    _json['path'] = path;
    _json['addressFormat'] = v1AddressFormatToJson(addressFormat);
    return _json;
  }
}

class v1WalletKitSettingsParams {
  /// List of enabled social login providers (e.g., 'apple', 'google', 'facebook')
  final List<String>? enabledSocialProviders;
  /// Mapping of social login providers to their Oauth client IDs.
  final Map<String, dynamic>? oauthClientIds;
  /// Oauth redirect URL to be used for social login flows.
  final String? oauthRedirectUrl;

  const v1WalletKitSettingsParams({
     this.enabledSocialProviders,
     this.oauthClientIds,
     this.oauthRedirectUrl,
  });

  factory v1WalletKitSettingsParams.fromJson(Map<String, dynamic> json) {
    final _enabledSocialProviders = (json['enabledSocialProviders'] as List?)?.map((e) => e as String).toList();
    final _oauthClientIds = json['oauthClientIds'] as Map<String, dynamic>?;
    final _oauthRedirectUrl = json['oauthRedirectUrl'] as String?;
    return v1WalletKitSettingsParams(
      enabledSocialProviders: _enabledSocialProviders,
      oauthClientIds: _oauthClientIds,
      oauthRedirectUrl: _oauthRedirectUrl,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    if (enabledSocialProviders != null) {
      _json['enabledSocialProviders'] = enabledSocialProviders;
    }
    if (oauthClientIds != null) {
      _json['oauthClientIds'] = oauthClientIds;
    }
    if (oauthRedirectUrl != null) {
      _json['oauthRedirectUrl'] = oauthRedirectUrl;
    }
    return _json;
  }
}

class v1WalletParams {
  /// Human-readable name for a Wallet.
  final String walletName;
  /// A list of wallet Accounts. This field, if not needed, should be an empty array in your request body.
  final List<v1WalletAccountParams> accounts;
  /// Length of mnemonic to generate the Wallet seed. Defaults to 12. Accepted values: 12, 15, 18, 21, 24.
  final num? mnemonicLength;

  const v1WalletParams({
    required  this.walletName,
    required  this.accounts,
     this.mnemonicLength,
  });

  factory v1WalletParams.fromJson(Map<String, dynamic> json) {
    final _walletName = json['walletName'] as String;
    final _accounts = (json['accounts'] as List).map((e) => v1WalletAccountParams.fromJson(e as Map<String, dynamic>)).toList();
    final _mnemonicLength = json['mnemonicLength'] as num?;
    return v1WalletParams(
      walletName: _walletName,
      accounts: _accounts,
      mnemonicLength: _mnemonicLength,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['walletName'] = walletName;
    _json['accounts'] = accounts.map((e) => e.toJson()).toList();
    if (mnemonicLength != null) {
      _json['mnemonicLength'] = mnemonicLength;
    }
    return _json;
  }
}

class v1WalletResult {
  final String walletId;
  /// A list of account addresses.
  final List<String> addresses;

  const v1WalletResult({
    required  this.walletId,
    required  this.addresses,
  });

  factory v1WalletResult.fromJson(Map<String, dynamic> json) {
    final _walletId = json['walletId'] as String;
    final _addresses = (json['addresses'] as List).map((e) => e as String).toList();
    return v1WalletResult(
      walletId: _walletId,
      addresses: _addresses,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['walletId'] = walletId;
    _json['addresses'] = addresses;
    return _json;
  }
}

class v1WebAuthnStamp {
  /// A base64 url encoded Unique identifier for a given credential.
  final String credentialId;
  /// A base64 encoded payload containing metadata about the signing context and the challenge.
  final String clientDataJson;
  /// A base64 encoded payload containing metadata about the authenticator.
  final String authenticatorData;
  /// The base64 url encoded signature bytes contained within the WebAuthn assertion response.
  final String signature;

  const v1WebAuthnStamp({
    required  this.credentialId,
    required  this.clientDataJson,
    required  this.authenticatorData,
    required  this.signature,
  });

  factory v1WebAuthnStamp.fromJson(Map<String, dynamic> json) {
    final _credentialId = json['credentialId'] as String;
    final _clientDataJson = json['clientDataJson'] as String;
    final _authenticatorData = json['authenticatorData'] as String;
    final _signature = json['signature'] as String;
    return v1WebAuthnStamp(
      credentialId: _credentialId,
      clientDataJson: _clientDataJson,
      authenticatorData: _authenticatorData,
      signature: _signature,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['credentialId'] = credentialId;
    _json['clientDataJson'] = clientDataJson;
    _json['authenticatorData'] = authenticatorData;
    _json['signature'] = signature;
    return _json;
  }
}

// --- API shapes ---

class TGetActivityResponse {
  /// An action that can be taken within the Turnkey infrastructure.
  final v1Activity activity;

  const TGetActivityResponse({
    required  this.activity,
  });

  factory TGetActivityResponse.fromJson(Map<String, dynamic> json) {
    final _activity = v1Activity.fromJson(json['activity'] as Map<String, dynamic>);
    return TGetActivityResponse(
      activity: _activity,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['activity'] = activity.toJson();
    return _json;
  }
}

class TGetActivityBody {
  final String? organizationId;
  /// Unique identifier for a given activity object.
  final String activityId;

  const TGetActivityBody({
     this.organizationId,
    required  this.activityId,
  });
  factory TGetActivityBody.fromJson(Map<String, dynamic> json) {
    final _organizationId = json['organizationId'] as String?;
    final _activityId = json['activityId'] as String;
    return TGetActivityBody(
      organizationId: _organizationId,
      activityId: _activityId,
    );
  }
  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    if (organizationId != null) {
      _json['organizationId'] = organizationId;
    }
    _json['activityId'] = activityId;
    return _json;
  }
}

class TGetActivityInput {
  final TGetActivityBody body;
  const TGetActivityInput({required this.body});
  factory TGetActivityInput.fromJson(Map<String, dynamic> json) => TGetActivityInput(body: TGetActivityBody.fromJson(json['body'] as Map<String, dynamic>));
  Map<String, dynamic> toJson() => {'body': body.toJson()};
}

class TGetApiKeyResponse {
  /// An API key.
  final v1ApiKey apiKey;

  const TGetApiKeyResponse({
    required  this.apiKey,
  });

  factory TGetApiKeyResponse.fromJson(Map<String, dynamic> json) {
    final _apiKey = v1ApiKey.fromJson(json['apiKey'] as Map<String, dynamic>);
    return TGetApiKeyResponse(
      apiKey: _apiKey,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['apiKey'] = apiKey.toJson();
    return _json;
  }
}

class TGetApiKeyBody {
  final String? organizationId;
  /// Unique identifier for a given API key.
  final String apiKeyId;

  const TGetApiKeyBody({
     this.organizationId,
    required  this.apiKeyId,
  });
  factory TGetApiKeyBody.fromJson(Map<String, dynamic> json) {
    final _organizationId = json['organizationId'] as String?;
    final _apiKeyId = json['apiKeyId'] as String;
    return TGetApiKeyBody(
      organizationId: _organizationId,
      apiKeyId: _apiKeyId,
    );
  }
  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    if (organizationId != null) {
      _json['organizationId'] = organizationId;
    }
    _json['apiKeyId'] = apiKeyId;
    return _json;
  }
}

class TGetApiKeyInput {
  final TGetApiKeyBody body;
  const TGetApiKeyInput({required this.body});
  factory TGetApiKeyInput.fromJson(Map<String, dynamic> json) => TGetApiKeyInput(body: TGetApiKeyBody.fromJson(json['body'] as Map<String, dynamic>));
  Map<String, dynamic> toJson() => {'body': body.toJson()};
}

class TGetApiKeysResponse {
  /// A list of API keys.
  final List<v1ApiKey> apiKeys;

  const TGetApiKeysResponse({
    required  this.apiKeys,
  });

  factory TGetApiKeysResponse.fromJson(Map<String, dynamic> json) {
    final _apiKeys = (json['apiKeys'] as List).map((e) => v1ApiKey.fromJson(e as Map<String, dynamic>)).toList();
    return TGetApiKeysResponse(
      apiKeys: _apiKeys,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['apiKeys'] = apiKeys.map((e) => e.toJson()).toList();
    return _json;
  }
}

class TGetApiKeysBody {
  final String? organizationId;
  /// Unique identifier for a given user.
  final String? userId;

  const TGetApiKeysBody({
     this.organizationId,
     this.userId,
  });
  factory TGetApiKeysBody.fromJson(Map<String, dynamic> json) {
    final _organizationId = json['organizationId'] as String?;
    final _userId = json['userId'] as String?;
    return TGetApiKeysBody(
      organizationId: _organizationId,
      userId: _userId,
    );
  }
  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    if (organizationId != null) {
      _json['organizationId'] = organizationId;
    }
    if (userId != null) {
      _json['userId'] = userId;
    }
    return _json;
  }
}

class TGetApiKeysInput {
  final TGetApiKeysBody body;
  const TGetApiKeysInput({required this.body});
  factory TGetApiKeysInput.fromJson(Map<String, dynamic> json) => TGetApiKeysInput(body: TGetApiKeysBody.fromJson(json['body'] as Map<String, dynamic>));
  Map<String, dynamic> toJson() => {'body': body.toJson()};
}

class TGetAttestationDocumentResponse {
  /// Raw (CBOR-encoded) attestation document.
  final String attestationDocument;

  const TGetAttestationDocumentResponse({
    required  this.attestationDocument,
  });

  factory TGetAttestationDocumentResponse.fromJson(Map<String, dynamic> json) {
    final _attestationDocument = json['attestationDocument'] as String;
    return TGetAttestationDocumentResponse(
      attestationDocument: _attestationDocument,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['attestationDocument'] = attestationDocument;
    return _json;
  }
}

class TGetAttestationDocumentBody {
  final String? organizationId;
  /// The enclave type, one of: ump, notarizer, signer, evm-parser.
  final String enclaveType;

  const TGetAttestationDocumentBody({
     this.organizationId,
    required  this.enclaveType,
  });
  factory TGetAttestationDocumentBody.fromJson(Map<String, dynamic> json) {
    final _organizationId = json['organizationId'] as String?;
    final _enclaveType = json['enclaveType'] as String;
    return TGetAttestationDocumentBody(
      organizationId: _organizationId,
      enclaveType: _enclaveType,
    );
  }
  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    if (organizationId != null) {
      _json['organizationId'] = organizationId;
    }
    _json['enclaveType'] = enclaveType;
    return _json;
  }
}

class TGetAttestationDocumentInput {
  final TGetAttestationDocumentBody body;
  const TGetAttestationDocumentInput({required this.body});
  factory TGetAttestationDocumentInput.fromJson(Map<String, dynamic> json) => TGetAttestationDocumentInput(body: TGetAttestationDocumentBody.fromJson(json['body'] as Map<String, dynamic>));
  Map<String, dynamic> toJson() => {'body': body.toJson()};
}

class TGetAuthenticatorResponse {
  /// An authenticator.
  final v1Authenticator authenticator;

  const TGetAuthenticatorResponse({
    required  this.authenticator,
  });

  factory TGetAuthenticatorResponse.fromJson(Map<String, dynamic> json) {
    final _authenticator = v1Authenticator.fromJson(json['authenticator'] as Map<String, dynamic>);
    return TGetAuthenticatorResponse(
      authenticator: _authenticator,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['authenticator'] = authenticator.toJson();
    return _json;
  }
}

class TGetAuthenticatorBody {
  final String? organizationId;
  /// Unique identifier for a given authenticator.
  final String authenticatorId;

  const TGetAuthenticatorBody({
     this.organizationId,
    required  this.authenticatorId,
  });
  factory TGetAuthenticatorBody.fromJson(Map<String, dynamic> json) {
    final _organizationId = json['organizationId'] as String?;
    final _authenticatorId = json['authenticatorId'] as String;
    return TGetAuthenticatorBody(
      organizationId: _organizationId,
      authenticatorId: _authenticatorId,
    );
  }
  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    if (organizationId != null) {
      _json['organizationId'] = organizationId;
    }
    _json['authenticatorId'] = authenticatorId;
    return _json;
  }
}

class TGetAuthenticatorInput {
  final TGetAuthenticatorBody body;
  const TGetAuthenticatorInput({required this.body});
  factory TGetAuthenticatorInput.fromJson(Map<String, dynamic> json) => TGetAuthenticatorInput(body: TGetAuthenticatorBody.fromJson(json['body'] as Map<String, dynamic>));
  Map<String, dynamic> toJson() => {'body': body.toJson()};
}

class TGetAuthenticatorsResponse {
  /// A list of authenticators.
  final List<v1Authenticator> authenticators;

  const TGetAuthenticatorsResponse({
    required  this.authenticators,
  });

  factory TGetAuthenticatorsResponse.fromJson(Map<String, dynamic> json) {
    final _authenticators = (json['authenticators'] as List).map((e) => v1Authenticator.fromJson(e as Map<String, dynamic>)).toList();
    return TGetAuthenticatorsResponse(
      authenticators: _authenticators,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['authenticators'] = authenticators.map((e) => e.toJson()).toList();
    return _json;
  }
}

class TGetAuthenticatorsBody {
  final String? organizationId;
  /// Unique identifier for a given user.
  final String userId;

  const TGetAuthenticatorsBody({
     this.organizationId,
    required  this.userId,
  });
  factory TGetAuthenticatorsBody.fromJson(Map<String, dynamic> json) {
    final _organizationId = json['organizationId'] as String?;
    final _userId = json['userId'] as String;
    return TGetAuthenticatorsBody(
      organizationId: _organizationId,
      userId: _userId,
    );
  }
  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    if (organizationId != null) {
      _json['organizationId'] = organizationId;
    }
    _json['userId'] = userId;
    return _json;
  }
}

class TGetAuthenticatorsInput {
  final TGetAuthenticatorsBody body;
  const TGetAuthenticatorsInput({required this.body});
  factory TGetAuthenticatorsInput.fromJson(Map<String, dynamic> json) => TGetAuthenticatorsInput(body: TGetAuthenticatorsBody.fromJson(json['body'] as Map<String, dynamic>));
  Map<String, dynamic> toJson() => {'body': body.toJson()};
}

class TGetBootProofResponse {
  final v1BootProof bootProof;

  const TGetBootProofResponse({
    required  this.bootProof,
  });

  factory TGetBootProofResponse.fromJson(Map<String, dynamic> json) {
    final _bootProof = v1BootProof.fromJson(json['bootProof'] as Map<String, dynamic>);
    return TGetBootProofResponse(
      bootProof: _bootProof,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['bootProof'] = bootProof.toJson();
    return _json;
  }
}

class TGetBootProofBody {
  final String? organizationId;
  /// Hex encoded ephemeral public key.
  final String ephemeralKey;

  const TGetBootProofBody({
     this.organizationId,
    required  this.ephemeralKey,
  });
  factory TGetBootProofBody.fromJson(Map<String, dynamic> json) {
    final _organizationId = json['organizationId'] as String?;
    final _ephemeralKey = json['ephemeralKey'] as String;
    return TGetBootProofBody(
      organizationId: _organizationId,
      ephemeralKey: _ephemeralKey,
    );
  }
  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    if (organizationId != null) {
      _json['organizationId'] = organizationId;
    }
    _json['ephemeralKey'] = ephemeralKey;
    return _json;
  }
}

class TGetBootProofInput {
  final TGetBootProofBody body;
  const TGetBootProofInput({required this.body});
  factory TGetBootProofInput.fromJson(Map<String, dynamic> json) => TGetBootProofInput(body: TGetBootProofBody.fromJson(json['body'] as Map<String, dynamic>));
  Map<String, dynamic> toJson() => {'body': body.toJson()};
}

class TGetGasUsageResponse {
  /// The window duration (in minutes) for the organization or sub-organization.
  final num windowDurationMinutes;
  /// The window limit (in USD) for the organization or sub-organization.
  final String windowLimitUsd;
  /// The total gas usage (in USD) of all sponsored transactions processed over the last `window_duration_minutes`
  final String usageUsd;

  const TGetGasUsageResponse({
    required  this.windowDurationMinutes,
    required  this.windowLimitUsd,
    required  this.usageUsd,
  });

  factory TGetGasUsageResponse.fromJson(Map<String, dynamic> json) {
    final _windowDurationMinutes = json['windowDurationMinutes'] as num;
    final _windowLimitUsd = json['windowLimitUsd'] as String;
    final _usageUsd = json['usageUsd'] as String;
    return TGetGasUsageResponse(
      windowDurationMinutes: _windowDurationMinutes,
      windowLimitUsd: _windowLimitUsd,
      usageUsd: _usageUsd,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['windowDurationMinutes'] = windowDurationMinutes;
    _json['windowLimitUsd'] = windowLimitUsd;
    _json['usageUsd'] = usageUsd;
    return _json;
  }
}

class TGetGasUsageBody {
  final String? organizationId;

  const TGetGasUsageBody({
     this.organizationId,
  });
  factory TGetGasUsageBody.fromJson(Map<String, dynamic> json) {
    final _organizationId = json['organizationId'] as String?;
    return TGetGasUsageBody(
      organizationId: _organizationId,
    );
  }
  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    if (organizationId != null) {
      _json['organizationId'] = organizationId;
    }
    return _json;
  }
}

class TGetGasUsageInput {
  final TGetGasUsageBody body;
  const TGetGasUsageInput({required this.body});
  factory TGetGasUsageInput.fromJson(Map<String, dynamic> json) => TGetGasUsageInput(body: TGetGasUsageBody.fromJson(json['body'] as Map<String, dynamic>));
  Map<String, dynamic> toJson() => {'body': body.toJson()};
}

class TGetLatestBootProofResponse {
  final v1BootProof bootProof;

  const TGetLatestBootProofResponse({
    required  this.bootProof,
  });

  factory TGetLatestBootProofResponse.fromJson(Map<String, dynamic> json) {
    final _bootProof = v1BootProof.fromJson(json['bootProof'] as Map<String, dynamic>);
    return TGetLatestBootProofResponse(
      bootProof: _bootProof,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['bootProof'] = bootProof.toJson();
    return _json;
  }
}

class TGetLatestBootProofBody {
  final String? organizationId;
  /// Name of enclave app.
  final String appName;

  const TGetLatestBootProofBody({
     this.organizationId,
    required  this.appName,
  });
  factory TGetLatestBootProofBody.fromJson(Map<String, dynamic> json) {
    final _organizationId = json['organizationId'] as String?;
    final _appName = json['appName'] as String;
    return TGetLatestBootProofBody(
      organizationId: _organizationId,
      appName: _appName,
    );
  }
  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    if (organizationId != null) {
      _json['organizationId'] = organizationId;
    }
    _json['appName'] = appName;
    return _json;
  }
}

class TGetLatestBootProofInput {
  final TGetLatestBootProofBody body;
  const TGetLatestBootProofInput({required this.body});
  factory TGetLatestBootProofInput.fromJson(Map<String, dynamic> json) => TGetLatestBootProofInput(body: TGetLatestBootProofBody.fromJson(json['body'] as Map<String, dynamic>));
  Map<String, dynamic> toJson() => {'body': body.toJson()};
}

class TGetNoncesResponse {
  /// The standard on-chain nonce for the address, if requested.
  final String? nonce;
  /// The gas station nonce for sponsored transactions, if requested.
  final String? gasStationNonce;

  const TGetNoncesResponse({
     this.nonce,
     this.gasStationNonce,
  });

  factory TGetNoncesResponse.fromJson(Map<String, dynamic> json) {
    final _nonce = json['nonce'] as String?;
    final _gasStationNonce = json['gasStationNonce'] as String?;
    return TGetNoncesResponse(
      nonce: _nonce,
      gasStationNonce: _gasStationNonce,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    if (nonce != null) {
      _json['nonce'] = nonce;
    }
    if (gasStationNonce != null) {
      _json['gasStationNonce'] = gasStationNonce;
    }
    return _json;
  }
}

class TGetNoncesBody {
  final String? organizationId;
  /// The Ethereum address to query nonces for.
  final String address;
  /// The network identifier in CAIP-2 format (e.g., 'eip155:1' for Ethereum mainnet).
  final String caip2;
  /// Whether to fetch the standard on-chain nonce.
  final bool? nonce;
  /// Whether to fetch the gas station nonce used for sponsored transactions.
  final bool? gasStationNonce;

  const TGetNoncesBody({
     this.organizationId,
    required  this.address,
    required  this.caip2,
     this.nonce,
     this.gasStationNonce,
  });
  factory TGetNoncesBody.fromJson(Map<String, dynamic> json) {
    final _organizationId = json['organizationId'] as String?;
    final _address = json['address'] as String;
    final _caip2 = json['caip2'] as String;
    final _nonce = json['nonce'] as bool?;
    final _gasStationNonce = json['gasStationNonce'] as bool?;
    return TGetNoncesBody(
      organizationId: _organizationId,
      address: _address,
      caip2: _caip2,
      nonce: _nonce,
      gasStationNonce: _gasStationNonce,
    );
  }
  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    if (organizationId != null) {
      _json['organizationId'] = organizationId;
    }
    _json['address'] = address;
    _json['caip2'] = caip2;
    if (nonce != null) {
      _json['nonce'] = nonce;
    }
    if (gasStationNonce != null) {
      _json['gasStationNonce'] = gasStationNonce;
    }
    return _json;
  }
}

class TGetNoncesInput {
  final TGetNoncesBody body;
  const TGetNoncesInput({required this.body});
  factory TGetNoncesInput.fromJson(Map<String, dynamic> json) => TGetNoncesInput(body: TGetNoncesBody.fromJson(json['body'] as Map<String, dynamic>));
  Map<String, dynamic> toJson() => {'body': body.toJson()};
}

class TGetOauth2CredentialResponse {
  final v1Oauth2Credential oauth2Credential;

  const TGetOauth2CredentialResponse({
    required  this.oauth2Credential,
  });

  factory TGetOauth2CredentialResponse.fromJson(Map<String, dynamic> json) {
    final _oauth2Credential = v1Oauth2Credential.fromJson(json['oauth2Credential'] as Map<String, dynamic>);
    return TGetOauth2CredentialResponse(
      oauth2Credential: _oauth2Credential,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['oauth2Credential'] = oauth2Credential.toJson();
    return _json;
  }
}

class TGetOauth2CredentialBody {
  final String? organizationId;
  /// Unique identifier for a given OAuth 2.0 Credential.
  final String oauth2CredentialId;

  const TGetOauth2CredentialBody({
     this.organizationId,
    required  this.oauth2CredentialId,
  });
  factory TGetOauth2CredentialBody.fromJson(Map<String, dynamic> json) {
    final _organizationId = json['organizationId'] as String?;
    final _oauth2CredentialId = json['oauth2CredentialId'] as String;
    return TGetOauth2CredentialBody(
      organizationId: _organizationId,
      oauth2CredentialId: _oauth2CredentialId,
    );
  }
  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    if (organizationId != null) {
      _json['organizationId'] = organizationId;
    }
    _json['oauth2CredentialId'] = oauth2CredentialId;
    return _json;
  }
}

class TGetOauth2CredentialInput {
  final TGetOauth2CredentialBody body;
  const TGetOauth2CredentialInput({required this.body});
  factory TGetOauth2CredentialInput.fromJson(Map<String, dynamic> json) => TGetOauth2CredentialInput(body: TGetOauth2CredentialBody.fromJson(json['body'] as Map<String, dynamic>));
  Map<String, dynamic> toJson() => {'body': body.toJson()};
}

class TGetOauthProvidersResponse {
  /// A list of Oauth providers.
  final List<v1OauthProvider> oauthProviders;

  const TGetOauthProvidersResponse({
    required  this.oauthProviders,
  });

  factory TGetOauthProvidersResponse.fromJson(Map<String, dynamic> json) {
    final _oauthProviders = (json['oauthProviders'] as List).map((e) => v1OauthProvider.fromJson(e as Map<String, dynamic>)).toList();
    return TGetOauthProvidersResponse(
      oauthProviders: _oauthProviders,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['oauthProviders'] = oauthProviders.map((e) => e.toJson()).toList();
    return _json;
  }
}

class TGetOauthProvidersBody {
  final String? organizationId;
  /// Unique identifier for a given user.
  final String? userId;

  const TGetOauthProvidersBody({
     this.organizationId,
     this.userId,
  });
  factory TGetOauthProvidersBody.fromJson(Map<String, dynamic> json) {
    final _organizationId = json['organizationId'] as String?;
    final _userId = json['userId'] as String?;
    return TGetOauthProvidersBody(
      organizationId: _organizationId,
      userId: _userId,
    );
  }
  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    if (organizationId != null) {
      _json['organizationId'] = organizationId;
    }
    if (userId != null) {
      _json['userId'] = userId;
    }
    return _json;
  }
}

class TGetOauthProvidersInput {
  final TGetOauthProvidersBody body;
  const TGetOauthProvidersInput({required this.body});
  factory TGetOauthProvidersInput.fromJson(Map<String, dynamic> json) => TGetOauthProvidersInput(body: TGetOauthProvidersBody.fromJson(json['body'] as Map<String, dynamic>));
  Map<String, dynamic> toJson() => {'body': body.toJson()};
}

class TGetOnRampTransactionStatusResponse {
  /// The status of the fiat on ramp transaction.
  final String transactionStatus;

  const TGetOnRampTransactionStatusResponse({
    required  this.transactionStatus,
  });

  factory TGetOnRampTransactionStatusResponse.fromJson(Map<String, dynamic> json) {
    final _transactionStatus = json['transactionStatus'] as String;
    return TGetOnRampTransactionStatusResponse(
      transactionStatus: _transactionStatus,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['transactionStatus'] = transactionStatus;
    return _json;
  }
}

class TGetOnRampTransactionStatusBody {
  final String? organizationId;
  /// The unique identifier for the fiat on ramp transaction.
  final String transactionId;
  /// Optional flag to specify if the transaction status should be refreshed from the fiat on ramp provider. Default = false.
  final bool? refresh;

  const TGetOnRampTransactionStatusBody({
     this.organizationId,
    required  this.transactionId,
     this.refresh,
  });
  factory TGetOnRampTransactionStatusBody.fromJson(Map<String, dynamic> json) {
    final _organizationId = json['organizationId'] as String?;
    final _transactionId = json['transactionId'] as String;
    final _refresh = json['refresh'] as bool?;
    return TGetOnRampTransactionStatusBody(
      organizationId: _organizationId,
      transactionId: _transactionId,
      refresh: _refresh,
    );
  }
  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    if (organizationId != null) {
      _json['organizationId'] = organizationId;
    }
    _json['transactionId'] = transactionId;
    if (refresh != null) {
      _json['refresh'] = refresh;
    }
    return _json;
  }
}

class TGetOnRampTransactionStatusInput {
  final TGetOnRampTransactionStatusBody body;
  const TGetOnRampTransactionStatusInput({required this.body});
  factory TGetOnRampTransactionStatusInput.fromJson(Map<String, dynamic> json) => TGetOnRampTransactionStatusInput(body: TGetOnRampTransactionStatusBody.fromJson(json['body'] as Map<String, dynamic>));
  Map<String, dynamic> toJson() => {'body': body.toJson()};
}

class TGetOrganizationResponse {
  /// Object representing the full current and deleted / disabled collection of users, policies, private keys, and invitations attributable to a particular organization.
  final v1OrganizationData organizationData;

  const TGetOrganizationResponse({
    required  this.organizationData,
  });

  factory TGetOrganizationResponse.fromJson(Map<String, dynamic> json) {
    final _organizationData = v1OrganizationData.fromJson(json['organizationData'] as Map<String, dynamic>);
    return TGetOrganizationResponse(
      organizationData: _organizationData,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['organizationData'] = organizationData.toJson();
    return _json;
  }
}

class TGetOrganizationBody {
  final String? organizationId;

  const TGetOrganizationBody({
     this.organizationId,
  });
  factory TGetOrganizationBody.fromJson(Map<String, dynamic> json) {
    final _organizationId = json['organizationId'] as String?;
    return TGetOrganizationBody(
      organizationId: _organizationId,
    );
  }
  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    if (organizationId != null) {
      _json['organizationId'] = organizationId;
    }
    return _json;
  }
}

class TGetOrganizationInput {
  final TGetOrganizationBody body;
  const TGetOrganizationInput({required this.body});
  factory TGetOrganizationInput.fromJson(Map<String, dynamic> json) => TGetOrganizationInput(body: TGetOrganizationBody.fromJson(json['body'] as Map<String, dynamic>));
  Map<String, dynamic> toJson() => {'body': body.toJson()};
}

class TGetOrganizationConfigsResponse {
  /// Organization configs including quorum settings and organization features.
  final v1Config configs;

  const TGetOrganizationConfigsResponse({
    required  this.configs,
  });

  factory TGetOrganizationConfigsResponse.fromJson(Map<String, dynamic> json) {
    final _configs = v1Config.fromJson(json['configs'] as Map<String, dynamic>);
    return TGetOrganizationConfigsResponse(
      configs: _configs,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['configs'] = configs.toJson();
    return _json;
  }
}

class TGetOrganizationConfigsBody {
  final String? organizationId;

  const TGetOrganizationConfigsBody({
     this.organizationId,
  });
  factory TGetOrganizationConfigsBody.fromJson(Map<String, dynamic> json) {
    final _organizationId = json['organizationId'] as String?;
    return TGetOrganizationConfigsBody(
      organizationId: _organizationId,
    );
  }
  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    if (organizationId != null) {
      _json['organizationId'] = organizationId;
    }
    return _json;
  }
}

class TGetOrganizationConfigsInput {
  final TGetOrganizationConfigsBody body;
  const TGetOrganizationConfigsInput({required this.body});
  factory TGetOrganizationConfigsInput.fromJson(Map<String, dynamic> json) => TGetOrganizationConfigsInput(body: TGetOrganizationConfigsBody.fromJson(json['body'] as Map<String, dynamic>));
  Map<String, dynamic> toJson() => {'body': body.toJson()};
}

class TGetPolicyResponse {
  /// Object that codifies rules defining the actions that are permissible within an organization.
  final v1Policy policy;

  const TGetPolicyResponse({
    required  this.policy,
  });

  factory TGetPolicyResponse.fromJson(Map<String, dynamic> json) {
    final _policy = v1Policy.fromJson(json['policy'] as Map<String, dynamic>);
    return TGetPolicyResponse(
      policy: _policy,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['policy'] = policy.toJson();
    return _json;
  }
}

class TGetPolicyBody {
  final String? organizationId;
  /// Unique identifier for a given policy.
  final String policyId;

  const TGetPolicyBody({
     this.organizationId,
    required  this.policyId,
  });
  factory TGetPolicyBody.fromJson(Map<String, dynamic> json) {
    final _organizationId = json['organizationId'] as String?;
    final _policyId = json['policyId'] as String;
    return TGetPolicyBody(
      organizationId: _organizationId,
      policyId: _policyId,
    );
  }
  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    if (organizationId != null) {
      _json['organizationId'] = organizationId;
    }
    _json['policyId'] = policyId;
    return _json;
  }
}

class TGetPolicyInput {
  final TGetPolicyBody body;
  const TGetPolicyInput({required this.body});
  factory TGetPolicyInput.fromJson(Map<String, dynamic> json) => TGetPolicyInput(body: TGetPolicyBody.fromJson(json['body'] as Map<String, dynamic>));
  Map<String, dynamic> toJson() => {'body': body.toJson()};
}

class TGetPolicyEvaluationsResponse {
  final List<externalactivityv1PolicyEvaluation> policyEvaluations;

  const TGetPolicyEvaluationsResponse({
    required  this.policyEvaluations,
  });

  factory TGetPolicyEvaluationsResponse.fromJson(Map<String, dynamic> json) {
    final _policyEvaluations = (json['policyEvaluations'] as List).map((e) => externalactivityv1PolicyEvaluation.fromJson(e as Map<String, dynamic>)).toList();
    return TGetPolicyEvaluationsResponse(
      policyEvaluations: _policyEvaluations,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['policyEvaluations'] = policyEvaluations.map((e) => e.toJson()).toList();
    return _json;
  }
}

class TGetPolicyEvaluationsBody {
  final String? organizationId;
  /// Unique identifier for a given activity.
  final String activityId;

  const TGetPolicyEvaluationsBody({
     this.organizationId,
    required  this.activityId,
  });
  factory TGetPolicyEvaluationsBody.fromJson(Map<String, dynamic> json) {
    final _organizationId = json['organizationId'] as String?;
    final _activityId = json['activityId'] as String;
    return TGetPolicyEvaluationsBody(
      organizationId: _organizationId,
      activityId: _activityId,
    );
  }
  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    if (organizationId != null) {
      _json['organizationId'] = organizationId;
    }
    _json['activityId'] = activityId;
    return _json;
  }
}

class TGetPolicyEvaluationsInput {
  final TGetPolicyEvaluationsBody body;
  const TGetPolicyEvaluationsInput({required this.body});
  factory TGetPolicyEvaluationsInput.fromJson(Map<String, dynamic> json) => TGetPolicyEvaluationsInput(body: TGetPolicyEvaluationsBody.fromJson(json['body'] as Map<String, dynamic>));
  Map<String, dynamic> toJson() => {'body': body.toJson()};
}

class TGetPrivateKeyResponse {
  /// Cryptographic public/private key pair that can be used for cryptocurrency needs or more generalized encryption.
  final v1PrivateKey privateKey;

  const TGetPrivateKeyResponse({
    required  this.privateKey,
  });

  factory TGetPrivateKeyResponse.fromJson(Map<String, dynamic> json) {
    final _privateKey = v1PrivateKey.fromJson(json['privateKey'] as Map<String, dynamic>);
    return TGetPrivateKeyResponse(
      privateKey: _privateKey,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['privateKey'] = privateKey.toJson();
    return _json;
  }
}

class TGetPrivateKeyBody {
  final String? organizationId;
  /// Unique identifier for a given private key.
  final String privateKeyId;

  const TGetPrivateKeyBody({
     this.organizationId,
    required  this.privateKeyId,
  });
  factory TGetPrivateKeyBody.fromJson(Map<String, dynamic> json) {
    final _organizationId = json['organizationId'] as String?;
    final _privateKeyId = json['privateKeyId'] as String;
    return TGetPrivateKeyBody(
      organizationId: _organizationId,
      privateKeyId: _privateKeyId,
    );
  }
  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    if (organizationId != null) {
      _json['organizationId'] = organizationId;
    }
    _json['privateKeyId'] = privateKeyId;
    return _json;
  }
}

class TGetPrivateKeyInput {
  final TGetPrivateKeyBody body;
  const TGetPrivateKeyInput({required this.body});
  factory TGetPrivateKeyInput.fromJson(Map<String, dynamic> json) => TGetPrivateKeyInput(body: TGetPrivateKeyBody.fromJson(json['body'] as Map<String, dynamic>));
  Map<String, dynamic> toJson() => {'body': body.toJson()};
}

class TGetSendTransactionStatusResponse {
  /// The current status of the send transaction.
  final String txStatus;
  /// Ethereum-specific transaction status.
  final v1EthSendTransactionStatus? eth;
  /// The error encountered when broadcasting or confirming the transaction, if any.
  final String? txError;
  /// Structured error information including revert details, if available.
  final v1TxError? error;

  const TGetSendTransactionStatusResponse({
    required  this.txStatus,
     this.eth,
     this.txError,
     this.error,
  });

  factory TGetSendTransactionStatusResponse.fromJson(Map<String, dynamic> json) {
    final _txStatus = json['txStatus'] as String;
    final _eth = json['eth'] == null ? null : v1EthSendTransactionStatus.fromJson(json['eth'] as Map<String, dynamic>);
    final _txError = json['txError'] as String?;
    final _error = json['error'] == null ? null : v1TxError.fromJson(json['error'] as Map<String, dynamic>);
    return TGetSendTransactionStatusResponse(
      txStatus: _txStatus,
      eth: _eth,
      txError: _txError,
      error: _error,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['txStatus'] = txStatus;
    if (eth != null) {
      _json['eth'] = eth?.toJson();
    }
    if (txError != null) {
      _json['txError'] = txError;
    }
    if (error != null) {
      _json['error'] = error?.toJson();
    }
    return _json;
  }
}

class TGetSendTransactionStatusBody {
  final String? organizationId;
  /// The unique identifier of a send transaction request.
  final String sendTransactionStatusId;

  const TGetSendTransactionStatusBody({
     this.organizationId,
    required  this.sendTransactionStatusId,
  });
  factory TGetSendTransactionStatusBody.fromJson(Map<String, dynamic> json) {
    final _organizationId = json['organizationId'] as String?;
    final _sendTransactionStatusId = json['sendTransactionStatusId'] as String;
    return TGetSendTransactionStatusBody(
      organizationId: _organizationId,
      sendTransactionStatusId: _sendTransactionStatusId,
    );
  }
  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    if (organizationId != null) {
      _json['organizationId'] = organizationId;
    }
    _json['sendTransactionStatusId'] = sendTransactionStatusId;
    return _json;
  }
}

class TGetSendTransactionStatusInput {
  final TGetSendTransactionStatusBody body;
  const TGetSendTransactionStatusInput({required this.body});
  factory TGetSendTransactionStatusInput.fromJson(Map<String, dynamic> json) => TGetSendTransactionStatusInput(body: TGetSendTransactionStatusBody.fromJson(json['body'] as Map<String, dynamic>));
  Map<String, dynamic> toJson() => {'body': body.toJson()};
}

class TGetSmartContractInterfaceResponse {
  /// Object to be used in conjunction with policies to guard transaction signing.
  final externaldatav1SmartContractInterface smartContractInterface;

  const TGetSmartContractInterfaceResponse({
    required  this.smartContractInterface,
  });

  factory TGetSmartContractInterfaceResponse.fromJson(Map<String, dynamic> json) {
    final _smartContractInterface = externaldatav1SmartContractInterface.fromJson(json['smartContractInterface'] as Map<String, dynamic>);
    return TGetSmartContractInterfaceResponse(
      smartContractInterface: _smartContractInterface,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['smartContractInterface'] = smartContractInterface.toJson();
    return _json;
  }
}

class TGetSmartContractInterfaceBody {
  final String? organizationId;
  /// Unique identifier for a given smart contract interface.
  final String smartContractInterfaceId;

  const TGetSmartContractInterfaceBody({
     this.organizationId,
    required  this.smartContractInterfaceId,
  });
  factory TGetSmartContractInterfaceBody.fromJson(Map<String, dynamic> json) {
    final _organizationId = json['organizationId'] as String?;
    final _smartContractInterfaceId = json['smartContractInterfaceId'] as String;
    return TGetSmartContractInterfaceBody(
      organizationId: _organizationId,
      smartContractInterfaceId: _smartContractInterfaceId,
    );
  }
  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    if (organizationId != null) {
      _json['organizationId'] = organizationId;
    }
    _json['smartContractInterfaceId'] = smartContractInterfaceId;
    return _json;
  }
}

class TGetSmartContractInterfaceInput {
  final TGetSmartContractInterfaceBody body;
  const TGetSmartContractInterfaceInput({required this.body});
  factory TGetSmartContractInterfaceInput.fromJson(Map<String, dynamic> json) => TGetSmartContractInterfaceInput(body: TGetSmartContractInterfaceBody.fromJson(json['body'] as Map<String, dynamic>));
  Map<String, dynamic> toJson() => {'body': body.toJson()};
}

class TGetTvcAppResponse {
  /// Details about a single TVC App
  final v1TvcApp tvcApp;

  const TGetTvcAppResponse({
    required  this.tvcApp,
  });

  factory TGetTvcAppResponse.fromJson(Map<String, dynamic> json) {
    final _tvcApp = v1TvcApp.fromJson(json['tvcApp'] as Map<String, dynamic>);
    return TGetTvcAppResponse(
      tvcApp: _tvcApp,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['tvcApp'] = tvcApp.toJson();
    return _json;
  }
}

class TGetTvcAppBody {
  final String? organizationId;
  /// Unique identifier for a given TVC App.
  final String tvcAppId;

  const TGetTvcAppBody({
     this.organizationId,
    required  this.tvcAppId,
  });
  factory TGetTvcAppBody.fromJson(Map<String, dynamic> json) {
    final _organizationId = json['organizationId'] as String?;
    final _tvcAppId = json['tvcAppId'] as String;
    return TGetTvcAppBody(
      organizationId: _organizationId,
      tvcAppId: _tvcAppId,
    );
  }
  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    if (organizationId != null) {
      _json['organizationId'] = organizationId;
    }
    _json['tvcAppId'] = tvcAppId;
    return _json;
  }
}

class TGetTvcAppInput {
  final TGetTvcAppBody body;
  const TGetTvcAppInput({required this.body});
  factory TGetTvcAppInput.fromJson(Map<String, dynamic> json) => TGetTvcAppInput(body: TGetTvcAppBody.fromJson(json['body'] as Map<String, dynamic>));
  Map<String, dynamic> toJson() => {'body': body.toJson()};
}

class TGetTvcDeploymentResponse {
  /// Details about a single TVC Deployment
  final v1TvcDeployment tvcDeployment;

  const TGetTvcDeploymentResponse({
    required  this.tvcDeployment,
  });

  factory TGetTvcDeploymentResponse.fromJson(Map<String, dynamic> json) {
    final _tvcDeployment = v1TvcDeployment.fromJson(json['tvcDeployment'] as Map<String, dynamic>);
    return TGetTvcDeploymentResponse(
      tvcDeployment: _tvcDeployment,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['tvcDeployment'] = tvcDeployment.toJson();
    return _json;
  }
}

class TGetTvcDeploymentBody {
  final String? organizationId;
  /// Unique identifier for a given TVC Deployment.
  final String deploymentId;

  const TGetTvcDeploymentBody({
     this.organizationId,
    required  this.deploymentId,
  });
  factory TGetTvcDeploymentBody.fromJson(Map<String, dynamic> json) {
    final _organizationId = json['organizationId'] as String?;
    final _deploymentId = json['deploymentId'] as String;
    return TGetTvcDeploymentBody(
      organizationId: _organizationId,
      deploymentId: _deploymentId,
    );
  }
  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    if (organizationId != null) {
      _json['organizationId'] = organizationId;
    }
    _json['deploymentId'] = deploymentId;
    return _json;
  }
}

class TGetTvcDeploymentInput {
  final TGetTvcDeploymentBody body;
  const TGetTvcDeploymentInput({required this.body});
  factory TGetTvcDeploymentInput.fromJson(Map<String, dynamic> json) => TGetTvcDeploymentInput(body: TGetTvcDeploymentBody.fromJson(json['body'] as Map<String, dynamic>));
  Map<String, dynamic> toJson() => {'body': body.toJson()};
}

class TGetUserResponse {
  /// Web and/or API user within your organization.
  final v1User user;

  const TGetUserResponse({
    required  this.user,
  });

  factory TGetUserResponse.fromJson(Map<String, dynamic> json) {
    final _user = v1User.fromJson(json['user'] as Map<String, dynamic>);
    return TGetUserResponse(
      user: _user,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['user'] = user.toJson();
    return _json;
  }
}

class TGetUserBody {
  final String? organizationId;
  /// Unique identifier for a given user.
  final String userId;

  const TGetUserBody({
     this.organizationId,
    required  this.userId,
  });
  factory TGetUserBody.fromJson(Map<String, dynamic> json) {
    final _organizationId = json['organizationId'] as String?;
    final _userId = json['userId'] as String;
    return TGetUserBody(
      organizationId: _organizationId,
      userId: _userId,
    );
  }
  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    if (organizationId != null) {
      _json['organizationId'] = organizationId;
    }
    _json['userId'] = userId;
    return _json;
  }
}

class TGetUserInput {
  final TGetUserBody body;
  const TGetUserInput({required this.body});
  factory TGetUserInput.fromJson(Map<String, dynamic> json) => TGetUserInput(body: TGetUserBody.fromJson(json['body'] as Map<String, dynamic>));
  Map<String, dynamic> toJson() => {'body': body.toJson()};
}

class TGetWalletResponse {
  /// A collection of deterministically generated cryptographic public / private key pairs that share a common seed.
  final v1Wallet wallet;

  const TGetWalletResponse({
    required  this.wallet,
  });

  factory TGetWalletResponse.fromJson(Map<String, dynamic> json) {
    final _wallet = v1Wallet.fromJson(json['wallet'] as Map<String, dynamic>);
    return TGetWalletResponse(
      wallet: _wallet,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['wallet'] = wallet.toJson();
    return _json;
  }
}

class TGetWalletBody {
  final String? organizationId;
  /// Unique identifier for a given wallet.
  final String walletId;

  const TGetWalletBody({
     this.organizationId,
    required  this.walletId,
  });
  factory TGetWalletBody.fromJson(Map<String, dynamic> json) {
    final _organizationId = json['organizationId'] as String?;
    final _walletId = json['walletId'] as String;
    return TGetWalletBody(
      organizationId: _organizationId,
      walletId: _walletId,
    );
  }
  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    if (organizationId != null) {
      _json['organizationId'] = organizationId;
    }
    _json['walletId'] = walletId;
    return _json;
  }
}

class TGetWalletInput {
  final TGetWalletBody body;
  const TGetWalletInput({required this.body});
  factory TGetWalletInput.fromJson(Map<String, dynamic> json) => TGetWalletInput(body: TGetWalletBody.fromJson(json['body'] as Map<String, dynamic>));
  Map<String, dynamic> toJson() => {'body': body.toJson()};
}

class TGetWalletAccountResponse {
  /// The resulting wallet account.
  final v1WalletAccount account;

  const TGetWalletAccountResponse({
    required  this.account,
  });

  factory TGetWalletAccountResponse.fromJson(Map<String, dynamic> json) {
    final _account = v1WalletAccount.fromJson(json['account'] as Map<String, dynamic>);
    return TGetWalletAccountResponse(
      account: _account,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['account'] = account.toJson();
    return _json;
  }
}

class TGetWalletAccountBody {
  final String? organizationId;
  /// Unique identifier for a given wallet.
  final String walletId;
  /// Address corresponding to a wallet account.
  final String? address;
  /// Path corresponding to a wallet account.
  final String? path;

  const TGetWalletAccountBody({
     this.organizationId,
    required  this.walletId,
     this.address,
     this.path,
  });
  factory TGetWalletAccountBody.fromJson(Map<String, dynamic> json) {
    final _organizationId = json['organizationId'] as String?;
    final _walletId = json['walletId'] as String;
    final _address = json['address'] as String?;
    final _path = json['path'] as String?;
    return TGetWalletAccountBody(
      organizationId: _organizationId,
      walletId: _walletId,
      address: _address,
      path: _path,
    );
  }
  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    if (organizationId != null) {
      _json['organizationId'] = organizationId;
    }
    _json['walletId'] = walletId;
    if (address != null) {
      _json['address'] = address;
    }
    if (path != null) {
      _json['path'] = path;
    }
    return _json;
  }
}

class TGetWalletAccountInput {
  final TGetWalletAccountBody body;
  const TGetWalletAccountInput({required this.body});
  factory TGetWalletAccountInput.fromJson(Map<String, dynamic> json) => TGetWalletAccountInput(body: TGetWalletAccountBody.fromJson(json['body'] as Map<String, dynamic>));
  Map<String, dynamic> toJson() => {'body': body.toJson()};
}

class TGetWalletAddressBalancesResponse {
  final List<v1AssetBalance>? balances;

  const TGetWalletAddressBalancesResponse({
     this.balances,
  });

  factory TGetWalletAddressBalancesResponse.fromJson(Map<String, dynamic> json) {
    final _balances = (json['balances'] as List?)?.map((e) => v1AssetBalance.fromJson(e as Map<String, dynamic>)).toList();
    return TGetWalletAddressBalancesResponse(
      balances: _balances,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    if (balances != null) {
      _json['balances'] = balances?.map((e) => e.toJson()).toList();
    }
    return _json;
  }
}

class TGetWalletAddressBalancesBody {
  final String? organizationId;
  /// Address corresponding to a wallet account.
  final String address;
  /// The network identifier in CAIP-2 format (e.g., 'eip155:1' for Ethereum mainnet).
  final String caip2;

  const TGetWalletAddressBalancesBody({
     this.organizationId,
    required  this.address,
    required  this.caip2,
  });
  factory TGetWalletAddressBalancesBody.fromJson(Map<String, dynamic> json) {
    final _organizationId = json['organizationId'] as String?;
    final _address = json['address'] as String;
    final _caip2 = json['caip2'] as String;
    return TGetWalletAddressBalancesBody(
      organizationId: _organizationId,
      address: _address,
      caip2: _caip2,
    );
  }
  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    if (organizationId != null) {
      _json['organizationId'] = organizationId;
    }
    _json['address'] = address;
    _json['caip2'] = caip2;
    return _json;
  }
}

class TGetWalletAddressBalancesInput {
  final TGetWalletAddressBalancesBody body;
  const TGetWalletAddressBalancesInput({required this.body});
  factory TGetWalletAddressBalancesInput.fromJson(Map<String, dynamic> json) => TGetWalletAddressBalancesInput(body: TGetWalletAddressBalancesBody.fromJson(json['body'] as Map<String, dynamic>));
  Map<String, dynamic> toJson() => {'body': body.toJson()};
}

class TGetActivitiesResponse {
  /// A list of activities.
  final List<v1Activity> activities;

  const TGetActivitiesResponse({
    required  this.activities,
  });

  factory TGetActivitiesResponse.fromJson(Map<String, dynamic> json) {
    final _activities = (json['activities'] as List).map((e) => v1Activity.fromJson(e as Map<String, dynamic>)).toList();
    return TGetActivitiesResponse(
      activities: _activities,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['activities'] = activities.map((e) => e.toJson()).toList();
    return _json;
  }
}

class TGetActivitiesBody {
  final String? organizationId;
  /// Array of activity statuses filtering which activities will be listed in the response.
  final List<v1ActivityStatus>? filterByStatus;
  /// Parameters used for cursor-based pagination.
  final v1Pagination? paginationOptions;
  /// Array of activity types filtering which activities will be listed in the response.
  final List<v1ActivityType>? filterByType;

  const TGetActivitiesBody({
     this.organizationId,
     this.filterByStatus,
     this.paginationOptions,
     this.filterByType,
  });
  factory TGetActivitiesBody.fromJson(Map<String, dynamic> json) {
    final _organizationId = json['organizationId'] as String?;
    final _filterByStatus = (json['filterByStatus'] as List?)?.map((e) => v1ActivityStatusFromJson(e)).toList();
    final _paginationOptions = json['paginationOptions'] == null ? null : v1Pagination.fromJson(json['paginationOptions'] as Map<String, dynamic>);
    final _filterByType = (json['filterByType'] as List?)?.map((e) => v1ActivityTypeFromJson(e)).toList();
    return TGetActivitiesBody(
      organizationId: _organizationId,
      filterByStatus: _filterByStatus,
      paginationOptions: _paginationOptions,
      filterByType: _filterByType,
    );
  }
  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    if (organizationId != null) {
      _json['organizationId'] = organizationId;
    }
    if (filterByStatus != null) {
      _json['filterByStatus'] = filterByStatus?.map((e) => v1ActivityStatusToJson(e)).toList();
    }
    if (paginationOptions != null) {
      _json['paginationOptions'] = paginationOptions?.toJson();
    }
    if (filterByType != null) {
      _json['filterByType'] = filterByType?.map((e) => v1ActivityTypeToJson(e)).toList();
    }
    return _json;
  }
}

class TGetActivitiesInput {
  final TGetActivitiesBody body;
  const TGetActivitiesInput({required this.body});
  factory TGetActivitiesInput.fromJson(Map<String, dynamic> json) => TGetActivitiesInput(body: TGetActivitiesBody.fromJson(json['body'] as Map<String, dynamic>));
  Map<String, dynamic> toJson() => {'body': body.toJson()};
}

class TGetAppProofsResponse {
  final List<v1AppProof> appProofs;

  const TGetAppProofsResponse({
    required  this.appProofs,
  });

  factory TGetAppProofsResponse.fromJson(Map<String, dynamic> json) {
    final _appProofs = (json['appProofs'] as List).map((e) => v1AppProof.fromJson(e as Map<String, dynamic>)).toList();
    return TGetAppProofsResponse(
      appProofs: _appProofs,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['appProofs'] = appProofs.map((e) => e.toJson()).toList();
    return _json;
  }
}

class TGetAppProofsBody {
  final String? organizationId;
  /// Unique identifier for a given activity.
  final String activityId;

  const TGetAppProofsBody({
     this.organizationId,
    required  this.activityId,
  });
  factory TGetAppProofsBody.fromJson(Map<String, dynamic> json) {
    final _organizationId = json['organizationId'] as String?;
    final _activityId = json['activityId'] as String;
    return TGetAppProofsBody(
      organizationId: _organizationId,
      activityId: _activityId,
    );
  }
  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    if (organizationId != null) {
      _json['organizationId'] = organizationId;
    }
    _json['activityId'] = activityId;
    return _json;
  }
}

class TGetAppProofsInput {
  final TGetAppProofsBody body;
  const TGetAppProofsInput({required this.body});
  factory TGetAppProofsInput.fromJson(Map<String, dynamic> json) => TGetAppProofsInput(body: TGetAppProofsBody.fromJson(json['body'] as Map<String, dynamic>));
  Map<String, dynamic> toJson() => {'body': body.toJson()};
}

class TListFiatOnRampCredentialsResponse {
  final List<v1FiatOnRampCredential> fiatOnRampCredentials;

  const TListFiatOnRampCredentialsResponse({
    required  this.fiatOnRampCredentials,
  });

  factory TListFiatOnRampCredentialsResponse.fromJson(Map<String, dynamic> json) {
    final _fiatOnRampCredentials = (json['fiatOnRampCredentials'] as List).map((e) => v1FiatOnRampCredential.fromJson(e as Map<String, dynamic>)).toList();
    return TListFiatOnRampCredentialsResponse(
      fiatOnRampCredentials: _fiatOnRampCredentials,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['fiatOnRampCredentials'] = fiatOnRampCredentials.map((e) => e.toJson()).toList();
    return _json;
  }
}

class TListFiatOnRampCredentialsBody {
  final String? organizationId;

  const TListFiatOnRampCredentialsBody({
     this.organizationId,
  });
  factory TListFiatOnRampCredentialsBody.fromJson(Map<String, dynamic> json) {
    final _organizationId = json['organizationId'] as String?;
    return TListFiatOnRampCredentialsBody(
      organizationId: _organizationId,
    );
  }
  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    if (organizationId != null) {
      _json['organizationId'] = organizationId;
    }
    return _json;
  }
}

class TListFiatOnRampCredentialsInput {
  final TListFiatOnRampCredentialsBody body;
  const TListFiatOnRampCredentialsInput({required this.body});
  factory TListFiatOnRampCredentialsInput.fromJson(Map<String, dynamic> json) => TListFiatOnRampCredentialsInput(body: TListFiatOnRampCredentialsBody.fromJson(json['body'] as Map<String, dynamic>));
  Map<String, dynamic> toJson() => {'body': body.toJson()};
}

class TListOauth2CredentialsResponse {
  final List<v1Oauth2Credential> oauth2Credentials;

  const TListOauth2CredentialsResponse({
    required  this.oauth2Credentials,
  });

  factory TListOauth2CredentialsResponse.fromJson(Map<String, dynamic> json) {
    final _oauth2Credentials = (json['oauth2Credentials'] as List).map((e) => v1Oauth2Credential.fromJson(e as Map<String, dynamic>)).toList();
    return TListOauth2CredentialsResponse(
      oauth2Credentials: _oauth2Credentials,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['oauth2Credentials'] = oauth2Credentials.map((e) => e.toJson()).toList();
    return _json;
  }
}

class TListOauth2CredentialsBody {
  final String? organizationId;

  const TListOauth2CredentialsBody({
     this.organizationId,
  });
  factory TListOauth2CredentialsBody.fromJson(Map<String, dynamic> json) {
    final _organizationId = json['organizationId'] as String?;
    return TListOauth2CredentialsBody(
      organizationId: _organizationId,
    );
  }
  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    if (organizationId != null) {
      _json['organizationId'] = organizationId;
    }
    return _json;
  }
}

class TListOauth2CredentialsInput {
  final TListOauth2CredentialsBody body;
  const TListOauth2CredentialsInput({required this.body});
  factory TListOauth2CredentialsInput.fromJson(Map<String, dynamic> json) => TListOauth2CredentialsInput(body: TListOauth2CredentialsBody.fromJson(json['body'] as Map<String, dynamic>));
  Map<String, dynamic> toJson() => {'body': body.toJson()};
}

class TGetPoliciesResponse {
  /// A list of policies.
  final List<v1Policy> policies;

  const TGetPoliciesResponse({
    required  this.policies,
  });

  factory TGetPoliciesResponse.fromJson(Map<String, dynamic> json) {
    final _policies = (json['policies'] as List).map((e) => v1Policy.fromJson(e as Map<String, dynamic>)).toList();
    return TGetPoliciesResponse(
      policies: _policies,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['policies'] = policies.map((e) => e.toJson()).toList();
    return _json;
  }
}

class TGetPoliciesBody {
  final String? organizationId;

  const TGetPoliciesBody({
     this.organizationId,
  });
  factory TGetPoliciesBody.fromJson(Map<String, dynamic> json) {
    final _organizationId = json['organizationId'] as String?;
    return TGetPoliciesBody(
      organizationId: _organizationId,
    );
  }
  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    if (organizationId != null) {
      _json['organizationId'] = organizationId;
    }
    return _json;
  }
}

class TGetPoliciesInput {
  final TGetPoliciesBody body;
  const TGetPoliciesInput({required this.body});
  factory TGetPoliciesInput.fromJson(Map<String, dynamic> json) => TGetPoliciesInput(body: TGetPoliciesBody.fromJson(json['body'] as Map<String, dynamic>));
  Map<String, dynamic> toJson() => {'body': body.toJson()};
}

class TListPrivateKeyTagsResponse {
  /// A list of private key tags.
  final List<datav1Tag> privateKeyTags;

  const TListPrivateKeyTagsResponse({
    required  this.privateKeyTags,
  });

  factory TListPrivateKeyTagsResponse.fromJson(Map<String, dynamic> json) {
    final _privateKeyTags = (json['privateKeyTags'] as List).map((e) => datav1Tag.fromJson(e as Map<String, dynamic>)).toList();
    return TListPrivateKeyTagsResponse(
      privateKeyTags: _privateKeyTags,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['privateKeyTags'] = privateKeyTags.map((e) => e.toJson()).toList();
    return _json;
  }
}

class TListPrivateKeyTagsBody {
  final String? organizationId;

  const TListPrivateKeyTagsBody({
     this.organizationId,
  });
  factory TListPrivateKeyTagsBody.fromJson(Map<String, dynamic> json) {
    final _organizationId = json['organizationId'] as String?;
    return TListPrivateKeyTagsBody(
      organizationId: _organizationId,
    );
  }
  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    if (organizationId != null) {
      _json['organizationId'] = organizationId;
    }
    return _json;
  }
}

class TListPrivateKeyTagsInput {
  final TListPrivateKeyTagsBody body;
  const TListPrivateKeyTagsInput({required this.body});
  factory TListPrivateKeyTagsInput.fromJson(Map<String, dynamic> json) => TListPrivateKeyTagsInput(body: TListPrivateKeyTagsBody.fromJson(json['body'] as Map<String, dynamic>));
  Map<String, dynamic> toJson() => {'body': body.toJson()};
}

class TGetPrivateKeysResponse {
  /// A list of private keys.
  final List<v1PrivateKey> privateKeys;

  const TGetPrivateKeysResponse({
    required  this.privateKeys,
  });

  factory TGetPrivateKeysResponse.fromJson(Map<String, dynamic> json) {
    final _privateKeys = (json['privateKeys'] as List).map((e) => v1PrivateKey.fromJson(e as Map<String, dynamic>)).toList();
    return TGetPrivateKeysResponse(
      privateKeys: _privateKeys,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['privateKeys'] = privateKeys.map((e) => e.toJson()).toList();
    return _json;
  }
}

class TGetPrivateKeysBody {
  final String? organizationId;

  const TGetPrivateKeysBody({
     this.organizationId,
  });
  factory TGetPrivateKeysBody.fromJson(Map<String, dynamic> json) {
    final _organizationId = json['organizationId'] as String?;
    return TGetPrivateKeysBody(
      organizationId: _organizationId,
    );
  }
  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    if (organizationId != null) {
      _json['organizationId'] = organizationId;
    }
    return _json;
  }
}

class TGetPrivateKeysInput {
  final TGetPrivateKeysBody body;
  const TGetPrivateKeysInput({required this.body});
  factory TGetPrivateKeysInput.fromJson(Map<String, dynamic> json) => TGetPrivateKeysInput(body: TGetPrivateKeysBody.fromJson(json['body'] as Map<String, dynamic>));
  Map<String, dynamic> toJson() => {'body': body.toJson()};
}

class TGetSmartContractInterfacesResponse {
  /// A list of smart contract interfaces.
  final List<externaldatav1SmartContractInterface> smartContractInterfaces;

  const TGetSmartContractInterfacesResponse({
    required  this.smartContractInterfaces,
  });

  factory TGetSmartContractInterfacesResponse.fromJson(Map<String, dynamic> json) {
    final _smartContractInterfaces = (json['smartContractInterfaces'] as List).map((e) => externaldatav1SmartContractInterface.fromJson(e as Map<String, dynamic>)).toList();
    return TGetSmartContractInterfacesResponse(
      smartContractInterfaces: _smartContractInterfaces,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['smartContractInterfaces'] = smartContractInterfaces.map((e) => e.toJson()).toList();
    return _json;
  }
}

class TGetSmartContractInterfacesBody {
  final String? organizationId;

  const TGetSmartContractInterfacesBody({
     this.organizationId,
  });
  factory TGetSmartContractInterfacesBody.fromJson(Map<String, dynamic> json) {
    final _organizationId = json['organizationId'] as String?;
    return TGetSmartContractInterfacesBody(
      organizationId: _organizationId,
    );
  }
  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    if (organizationId != null) {
      _json['organizationId'] = organizationId;
    }
    return _json;
  }
}

class TGetSmartContractInterfacesInput {
  final TGetSmartContractInterfacesBody body;
  const TGetSmartContractInterfacesInput({required this.body});
  factory TGetSmartContractInterfacesInput.fromJson(Map<String, dynamic> json) => TGetSmartContractInterfacesInput(body: TGetSmartContractInterfacesBody.fromJson(json['body'] as Map<String, dynamic>));
  Map<String, dynamic> toJson() => {'body': body.toJson()};
}

class TGetSubOrgIdsResponse {
  /// List of unique identifiers for the matching sub-organizations.
  final List<String> organizationIds;

  const TGetSubOrgIdsResponse({
    required  this.organizationIds,
  });

  factory TGetSubOrgIdsResponse.fromJson(Map<String, dynamic> json) {
    final _organizationIds = (json['organizationIds'] as List).map((e) => e as String).toList();
    return TGetSubOrgIdsResponse(
      organizationIds: _organizationIds,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['organizationIds'] = organizationIds;
    return _json;
  }
}

class TGetSubOrgIdsBody {
  final String? organizationId;
  /// Specifies the type of filter to apply, i.e 'CREDENTIAL_ID', 'NAME', 'USERNAME', 'EMAIL', 'PHONE_NUMBER', 'OIDC_TOKEN', 'WALLET_ACCOUNT_ADDRESS' or 'PUBLIC_KEY'
  final String? filterType;
  /// The value of the filter to apply for the specified type. For example, a specific email or name string.
  final String? filterValue;
  /// Parameters used for cursor-based pagination.
  final v1Pagination? paginationOptions;

  const TGetSubOrgIdsBody({
     this.organizationId,
     this.filterType,
     this.filterValue,
     this.paginationOptions,
  });
  factory TGetSubOrgIdsBody.fromJson(Map<String, dynamic> json) {
    final _organizationId = json['organizationId'] as String?;
    final _filterType = json['filterType'] as String?;
    final _filterValue = json['filterValue'] as String?;
    final _paginationOptions = json['paginationOptions'] == null ? null : v1Pagination.fromJson(json['paginationOptions'] as Map<String, dynamic>);
    return TGetSubOrgIdsBody(
      organizationId: _organizationId,
      filterType: _filterType,
      filterValue: _filterValue,
      paginationOptions: _paginationOptions,
    );
  }
  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    if (organizationId != null) {
      _json['organizationId'] = organizationId;
    }
    if (filterType != null) {
      _json['filterType'] = filterType;
    }
    if (filterValue != null) {
      _json['filterValue'] = filterValue;
    }
    if (paginationOptions != null) {
      _json['paginationOptions'] = paginationOptions?.toJson();
    }
    return _json;
  }
}

class TGetSubOrgIdsInput {
  final TGetSubOrgIdsBody body;
  const TGetSubOrgIdsInput({required this.body});
  factory TGetSubOrgIdsInput.fromJson(Map<String, dynamic> json) => TGetSubOrgIdsInput(body: TGetSubOrgIdsBody.fromJson(json['body'] as Map<String, dynamic>));
  Map<String, dynamic> toJson() => {'body': body.toJson()};
}

class TGetTvcAppDeploymentsResponse {
  /// List of deployments for this TVC App
  final List<v1TvcDeployment> tvcDeployments;

  const TGetTvcAppDeploymentsResponse({
    required  this.tvcDeployments,
  });

  factory TGetTvcAppDeploymentsResponse.fromJson(Map<String, dynamic> json) {
    final _tvcDeployments = (json['tvcDeployments'] as List).map((e) => v1TvcDeployment.fromJson(e as Map<String, dynamic>)).toList();
    return TGetTvcAppDeploymentsResponse(
      tvcDeployments: _tvcDeployments,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['tvcDeployments'] = tvcDeployments.map((e) => e.toJson()).toList();
    return _json;
  }
}

class TGetTvcAppDeploymentsBody {
  final String? organizationId;
  /// Unique identifier for a given TVC App.
  final String appId;

  const TGetTvcAppDeploymentsBody({
     this.organizationId,
    required  this.appId,
  });
  factory TGetTvcAppDeploymentsBody.fromJson(Map<String, dynamic> json) {
    final _organizationId = json['organizationId'] as String?;
    final _appId = json['appId'] as String;
    return TGetTvcAppDeploymentsBody(
      organizationId: _organizationId,
      appId: _appId,
    );
  }
  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    if (organizationId != null) {
      _json['organizationId'] = organizationId;
    }
    _json['appId'] = appId;
    return _json;
  }
}

class TGetTvcAppDeploymentsInput {
  final TGetTvcAppDeploymentsBody body;
  const TGetTvcAppDeploymentsInput({required this.body});
  factory TGetTvcAppDeploymentsInput.fromJson(Map<String, dynamic> json) => TGetTvcAppDeploymentsInput(body: TGetTvcAppDeploymentsBody.fromJson(json['body'] as Map<String, dynamic>));
  Map<String, dynamic> toJson() => {'body': body.toJson()};
}

class TGetTvcAppsResponse {
  /// A list of TVC Apps.
  final List<v1TvcApp> tvcApps;

  const TGetTvcAppsResponse({
    required  this.tvcApps,
  });

  factory TGetTvcAppsResponse.fromJson(Map<String, dynamic> json) {
    final _tvcApps = (json['tvcApps'] as List).map((e) => v1TvcApp.fromJson(e as Map<String, dynamic>)).toList();
    return TGetTvcAppsResponse(
      tvcApps: _tvcApps,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['tvcApps'] = tvcApps.map((e) => e.toJson()).toList();
    return _json;
  }
}

class TGetTvcAppsBody {
  final String? organizationId;

  const TGetTvcAppsBody({
     this.organizationId,
  });
  factory TGetTvcAppsBody.fromJson(Map<String, dynamic> json) {
    final _organizationId = json['organizationId'] as String?;
    return TGetTvcAppsBody(
      organizationId: _organizationId,
    );
  }
  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    if (organizationId != null) {
      _json['organizationId'] = organizationId;
    }
    return _json;
  }
}

class TGetTvcAppsInput {
  final TGetTvcAppsBody body;
  const TGetTvcAppsInput({required this.body});
  factory TGetTvcAppsInput.fromJson(Map<String, dynamic> json) => TGetTvcAppsInput(body: TGetTvcAppsBody.fromJson(json['body'] as Map<String, dynamic>));
  Map<String, dynamic> toJson() => {'body': body.toJson()};
}

class TListUserTagsResponse {
  /// A list of user tags.
  final List<datav1Tag> userTags;

  const TListUserTagsResponse({
    required  this.userTags,
  });

  factory TListUserTagsResponse.fromJson(Map<String, dynamic> json) {
    final _userTags = (json['userTags'] as List).map((e) => datav1Tag.fromJson(e as Map<String, dynamic>)).toList();
    return TListUserTagsResponse(
      userTags: _userTags,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['userTags'] = userTags.map((e) => e.toJson()).toList();
    return _json;
  }
}

class TListUserTagsBody {
  final String? organizationId;

  const TListUserTagsBody({
     this.organizationId,
  });
  factory TListUserTagsBody.fromJson(Map<String, dynamic> json) {
    final _organizationId = json['organizationId'] as String?;
    return TListUserTagsBody(
      organizationId: _organizationId,
    );
  }
  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    if (organizationId != null) {
      _json['organizationId'] = organizationId;
    }
    return _json;
  }
}

class TListUserTagsInput {
  final TListUserTagsBody body;
  const TListUserTagsInput({required this.body});
  factory TListUserTagsInput.fromJson(Map<String, dynamic> json) => TListUserTagsInput(body: TListUserTagsBody.fromJson(json['body'] as Map<String, dynamic>));
  Map<String, dynamic> toJson() => {'body': body.toJson()};
}

class TGetUsersResponse {
  /// A list of users.
  final List<v1User> users;

  const TGetUsersResponse({
    required  this.users,
  });

  factory TGetUsersResponse.fromJson(Map<String, dynamic> json) {
    final _users = (json['users'] as List).map((e) => v1User.fromJson(e as Map<String, dynamic>)).toList();
    return TGetUsersResponse(
      users: _users,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['users'] = users.map((e) => e.toJson()).toList();
    return _json;
  }
}

class TGetUsersBody {
  final String? organizationId;

  const TGetUsersBody({
     this.organizationId,
  });
  factory TGetUsersBody.fromJson(Map<String, dynamic> json) {
    final _organizationId = json['organizationId'] as String?;
    return TGetUsersBody(
      organizationId: _organizationId,
    );
  }
  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    if (organizationId != null) {
      _json['organizationId'] = organizationId;
    }
    return _json;
  }
}

class TGetUsersInput {
  final TGetUsersBody body;
  const TGetUsersInput({required this.body});
  factory TGetUsersInput.fromJson(Map<String, dynamic> json) => TGetUsersInput(body: TGetUsersBody.fromJson(json['body'] as Map<String, dynamic>));
  Map<String, dynamic> toJson() => {'body': body.toJson()};
}

class TGetVerifiedSubOrgIdsResponse {
  /// List of unique identifiers for the matching sub-organizations.
  final List<String> organizationIds;

  const TGetVerifiedSubOrgIdsResponse({
    required  this.organizationIds,
  });

  factory TGetVerifiedSubOrgIdsResponse.fromJson(Map<String, dynamic> json) {
    final _organizationIds = (json['organizationIds'] as List).map((e) => e as String).toList();
    return TGetVerifiedSubOrgIdsResponse(
      organizationIds: _organizationIds,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['organizationIds'] = organizationIds;
    return _json;
  }
}

class TGetVerifiedSubOrgIdsBody {
  final String? organizationId;
  /// Specifies the type of filter to apply, i.e 'EMAIL', 'PHONE_NUMBER'.
  final String? filterType;
  /// The value of the filter to apply for the specified type. For example, a specific email or phone number string.
  final String? filterValue;
  /// Parameters used for cursor-based pagination.
  final v1Pagination? paginationOptions;

  const TGetVerifiedSubOrgIdsBody({
     this.organizationId,
     this.filterType,
     this.filterValue,
     this.paginationOptions,
  });
  factory TGetVerifiedSubOrgIdsBody.fromJson(Map<String, dynamic> json) {
    final _organizationId = json['organizationId'] as String?;
    final _filterType = json['filterType'] as String?;
    final _filterValue = json['filterValue'] as String?;
    final _paginationOptions = json['paginationOptions'] == null ? null : v1Pagination.fromJson(json['paginationOptions'] as Map<String, dynamic>);
    return TGetVerifiedSubOrgIdsBody(
      organizationId: _organizationId,
      filterType: _filterType,
      filterValue: _filterValue,
      paginationOptions: _paginationOptions,
    );
  }
  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    if (organizationId != null) {
      _json['organizationId'] = organizationId;
    }
    if (filterType != null) {
      _json['filterType'] = filterType;
    }
    if (filterValue != null) {
      _json['filterValue'] = filterValue;
    }
    if (paginationOptions != null) {
      _json['paginationOptions'] = paginationOptions?.toJson();
    }
    return _json;
  }
}

class TGetVerifiedSubOrgIdsInput {
  final TGetVerifiedSubOrgIdsBody body;
  const TGetVerifiedSubOrgIdsInput({required this.body});
  factory TGetVerifiedSubOrgIdsInput.fromJson(Map<String, dynamic> json) => TGetVerifiedSubOrgIdsInput(body: TGetVerifiedSubOrgIdsBody.fromJson(json['body'] as Map<String, dynamic>));
  Map<String, dynamic> toJson() => {'body': body.toJson()};
}

class TGetWalletAccountsResponse {
  /// A list of accounts generated from a wallet that share a common seed.
  final List<v1WalletAccount> accounts;

  const TGetWalletAccountsResponse({
    required  this.accounts,
  });

  factory TGetWalletAccountsResponse.fromJson(Map<String, dynamic> json) {
    final _accounts = (json['accounts'] as List).map((e) => v1WalletAccount.fromJson(e as Map<String, dynamic>)).toList();
    return TGetWalletAccountsResponse(
      accounts: _accounts,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['accounts'] = accounts.map((e) => e.toJson()).toList();
    return _json;
  }
}

class TGetWalletAccountsBody {
  final String? organizationId;
  /// Unique identifier for a given wallet. If not provided, all accounts for the organization will be returned.
  final String? walletId;
  /// Optional flag to specify if the wallet details should be included in the response. Default = false.
  final bool? includeWalletDetails;
  /// Parameters used for cursor-based pagination.
  final v1Pagination? paginationOptions;

  const TGetWalletAccountsBody({
     this.organizationId,
     this.walletId,
     this.includeWalletDetails,
     this.paginationOptions,
  });
  factory TGetWalletAccountsBody.fromJson(Map<String, dynamic> json) {
    final _organizationId = json['organizationId'] as String?;
    final _walletId = json['walletId'] as String?;
    final _includeWalletDetails = json['includeWalletDetails'] as bool?;
    final _paginationOptions = json['paginationOptions'] == null ? null : v1Pagination.fromJson(json['paginationOptions'] as Map<String, dynamic>);
    return TGetWalletAccountsBody(
      organizationId: _organizationId,
      walletId: _walletId,
      includeWalletDetails: _includeWalletDetails,
      paginationOptions: _paginationOptions,
    );
  }
  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    if (organizationId != null) {
      _json['organizationId'] = organizationId;
    }
    if (walletId != null) {
      _json['walletId'] = walletId;
    }
    if (includeWalletDetails != null) {
      _json['includeWalletDetails'] = includeWalletDetails;
    }
    if (paginationOptions != null) {
      _json['paginationOptions'] = paginationOptions?.toJson();
    }
    return _json;
  }
}

class TGetWalletAccountsInput {
  final TGetWalletAccountsBody body;
  const TGetWalletAccountsInput({required this.body});
  factory TGetWalletAccountsInput.fromJson(Map<String, dynamic> json) => TGetWalletAccountsInput(body: TGetWalletAccountsBody.fromJson(json['body'] as Map<String, dynamic>));
  Map<String, dynamic> toJson() => {'body': body.toJson()};
}

class TGetWalletsResponse {
  /// A list of wallets.
  final List<v1Wallet> wallets;

  const TGetWalletsResponse({
    required  this.wallets,
  });

  factory TGetWalletsResponse.fromJson(Map<String, dynamic> json) {
    final _wallets = (json['wallets'] as List).map((e) => v1Wallet.fromJson(e as Map<String, dynamic>)).toList();
    return TGetWalletsResponse(
      wallets: _wallets,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['wallets'] = wallets.map((e) => e.toJson()).toList();
    return _json;
  }
}

class TGetWalletsBody {
  final String? organizationId;

  const TGetWalletsBody({
     this.organizationId,
  });
  factory TGetWalletsBody.fromJson(Map<String, dynamic> json) {
    final _organizationId = json['organizationId'] as String?;
    return TGetWalletsBody(
      organizationId: _organizationId,
    );
  }
  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    if (organizationId != null) {
      _json['organizationId'] = organizationId;
    }
    return _json;
  }
}

class TGetWalletsInput {
  final TGetWalletsBody body;
  const TGetWalletsInput({required this.body});
  factory TGetWalletsInput.fromJson(Map<String, dynamic> json) => TGetWalletsInput(body: TGetWalletsBody.fromJson(json['body'] as Map<String, dynamic>));
  Map<String, dynamic> toJson() => {'body': body.toJson()};
}

class TGetWhoamiResponse {
  /// Unique identifier for a given organization.
  final String organizationId;
  /// Human-readable name for an organization.
  final String organizationName;
  /// Unique identifier for a given user.
  final String userId;
  /// Human-readable name for a user.
  final String username;

  const TGetWhoamiResponse({
    required  this.organizationId,
    required  this.organizationName,
    required  this.userId,
    required  this.username,
  });

  factory TGetWhoamiResponse.fromJson(Map<String, dynamic> json) {
    final _organizationId = json['organizationId'] as String;
    final _organizationName = json['organizationName'] as String;
    final _userId = json['userId'] as String;
    final _username = json['username'] as String;
    return TGetWhoamiResponse(
      organizationId: _organizationId,
      organizationName: _organizationName,
      userId: _userId,
      username: _username,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['organizationId'] = organizationId;
    _json['organizationName'] = organizationName;
    _json['userId'] = userId;
    _json['username'] = username;
    return _json;
  }
}

class TGetWhoamiBody {
  final String? organizationId;

  const TGetWhoamiBody({
     this.organizationId,
  });
  factory TGetWhoamiBody.fromJson(Map<String, dynamic> json) {
    final _organizationId = json['organizationId'] as String?;
    return TGetWhoamiBody(
      organizationId: _organizationId,
    );
  }
  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    if (organizationId != null) {
      _json['organizationId'] = organizationId;
    }
    return _json;
  }
}

class TGetWhoamiInput {
  final TGetWhoamiBody body;
  const TGetWhoamiInput({required this.body});
  factory TGetWhoamiInput.fromJson(Map<String, dynamic> json) => TGetWhoamiInput(body: TGetWhoamiBody.fromJson(json['body'] as Map<String, dynamic>));
  Map<String, dynamic> toJson() => {'body': body.toJson()};
}

class TApproveActivityResponse {
  final v1Activity activity;
  const TApproveActivityResponse({required this.activity, });
  factory TApproveActivityResponse.fromJson(Map<String, dynamic> json) {
    return TApproveActivityResponse(
      activity: v1Activity.fromJson(json['activity'] as Map<String, dynamic>),
    );
  }
  Map<String, dynamic> toJson() => {
    'activity': activity.toJson(),
  };
}

class TApproveActivityBody {
  final String? timestampMs;
  final String? organizationId;
  /// An artifact verifying a User's action.
  final String fingerprint;

  const TApproveActivityBody({
     this.timestampMs,
     this.organizationId,
    required  this.fingerprint,
  });
  factory TApproveActivityBody.fromJson(Map<String, dynamic> json) {
    final _timestampMs = json['timestampMs'] as String?;
    final _organizationId = json['organizationId'] as String?;
    final _fingerprint = json['fingerprint'] as String;
    return TApproveActivityBody(
      timestampMs: _timestampMs,
      organizationId: _organizationId,
      fingerprint: _fingerprint,
    );
  }
  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    if (timestampMs != null) {
      _json['timestampMs'] = timestampMs;
    }
    if (organizationId != null) {
      _json['organizationId'] = organizationId;
    }
    _json['fingerprint'] = fingerprint;
    return _json;
  }
}

class TApproveActivityInput {
  final TApproveActivityBody body;
  const TApproveActivityInput({required this.body});
  factory TApproveActivityInput.fromJson(Map<String, dynamic> json) => TApproveActivityInput(body: TApproveActivityBody.fromJson(json['body'] as Map<String, dynamic>));
  Map<String, dynamic> toJson() => {'body': body.toJson()};
}

class TCreateApiKeysResponse {
  final v1Activity activity;
  final v1CreateApiKeysResult? result;
  const TCreateApiKeysResponse({required this.activity, this.result,});
  factory TCreateApiKeysResponse.fromJson(Map<String, dynamic> json) {
    return TCreateApiKeysResponse(
      activity: v1Activity.fromJson(json['activity'] as Map<String, dynamic>),
      result: json.containsKey('result') && json['result'] != null ? v1CreateApiKeysResult.fromJson(json['result'] as Map<String, dynamic>) : null,
    );
  }
  Map<String, dynamic> toJson() => {
    'activity': activity.toJson(),
    if (result != null) 'result': result!.toJson(),
  };
}

class TCreateApiKeysBody {
  final String? timestampMs;
  final String? organizationId;
  /// A list of API Keys.
  final List<v1ApiKeyParamsV2> apiKeys;
  /// Unique identifier for a given User.
  final String userId;

  const TCreateApiKeysBody({
     this.timestampMs,
     this.organizationId,
    required  this.apiKeys,
    required  this.userId,
  });
  factory TCreateApiKeysBody.fromJson(Map<String, dynamic> json) {
    final _timestampMs = json['timestampMs'] as String?;
    final _organizationId = json['organizationId'] as String?;
    final _apiKeys = (json['apiKeys'] as List).map((e) => v1ApiKeyParamsV2.fromJson(e as Map<String, dynamic>)).toList();
    final _userId = json['userId'] as String;
    return TCreateApiKeysBody(
      timestampMs: _timestampMs,
      organizationId: _organizationId,
      apiKeys: _apiKeys,
      userId: _userId,
    );
  }
  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    if (timestampMs != null) {
      _json['timestampMs'] = timestampMs;
    }
    if (organizationId != null) {
      _json['organizationId'] = organizationId;
    }
    _json['apiKeys'] = apiKeys.map((e) => e.toJson()).toList();
    _json['userId'] = userId;
    return _json;
  }
}

class TCreateApiKeysInput {
  final TCreateApiKeysBody body;
  const TCreateApiKeysInput({required this.body});
  factory TCreateApiKeysInput.fromJson(Map<String, dynamic> json) => TCreateApiKeysInput(body: TCreateApiKeysBody.fromJson(json['body'] as Map<String, dynamic>));
  Map<String, dynamic> toJson() => {'body': body.toJson()};
}

class TCreateApiOnlyUsersResponse {
  final v1Activity activity;
  final v1CreateApiOnlyUsersResult? result;
  const TCreateApiOnlyUsersResponse({required this.activity, this.result,});
  factory TCreateApiOnlyUsersResponse.fromJson(Map<String, dynamic> json) {
    return TCreateApiOnlyUsersResponse(
      activity: v1Activity.fromJson(json['activity'] as Map<String, dynamic>),
      result: json.containsKey('result') && json['result'] != null ? v1CreateApiOnlyUsersResult.fromJson(json['result'] as Map<String, dynamic>) : null,
    );
  }
  Map<String, dynamic> toJson() => {
    'activity': activity.toJson(),
    if (result != null) 'result': result!.toJson(),
  };
}

class TCreateApiOnlyUsersBody {
  final String? timestampMs;
  final String? organizationId;
  /// A list of API-only Users to create.
  final List<v1ApiOnlyUserParams> apiOnlyUsers;

  const TCreateApiOnlyUsersBody({
     this.timestampMs,
     this.organizationId,
    required  this.apiOnlyUsers,
  });
  factory TCreateApiOnlyUsersBody.fromJson(Map<String, dynamic> json) {
    final _timestampMs = json['timestampMs'] as String?;
    final _organizationId = json['organizationId'] as String?;
    final _apiOnlyUsers = (json['apiOnlyUsers'] as List).map((e) => v1ApiOnlyUserParams.fromJson(e as Map<String, dynamic>)).toList();
    return TCreateApiOnlyUsersBody(
      timestampMs: _timestampMs,
      organizationId: _organizationId,
      apiOnlyUsers: _apiOnlyUsers,
    );
  }
  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    if (timestampMs != null) {
      _json['timestampMs'] = timestampMs;
    }
    if (organizationId != null) {
      _json['organizationId'] = organizationId;
    }
    _json['apiOnlyUsers'] = apiOnlyUsers.map((e) => e.toJson()).toList();
    return _json;
  }
}

class TCreateApiOnlyUsersInput {
  final TCreateApiOnlyUsersBody body;
  const TCreateApiOnlyUsersInput({required this.body});
  factory TCreateApiOnlyUsersInput.fromJson(Map<String, dynamic> json) => TCreateApiOnlyUsersInput(body: TCreateApiOnlyUsersBody.fromJson(json['body'] as Map<String, dynamic>));
  Map<String, dynamic> toJson() => {'body': body.toJson()};
}

class TCreateAuthenticatorsResponse {
  final v1Activity activity;
  final v1CreateAuthenticatorsResult? result;
  const TCreateAuthenticatorsResponse({required this.activity, this.result,});
  factory TCreateAuthenticatorsResponse.fromJson(Map<String, dynamic> json) {
    return TCreateAuthenticatorsResponse(
      activity: v1Activity.fromJson(json['activity'] as Map<String, dynamic>),
      result: json.containsKey('result') && json['result'] != null ? v1CreateAuthenticatorsResult.fromJson(json['result'] as Map<String, dynamic>) : null,
    );
  }
  Map<String, dynamic> toJson() => {
    'activity': activity.toJson(),
    if (result != null) 'result': result!.toJson(),
  };
}

class TCreateAuthenticatorsBody {
  final String? timestampMs;
  final String? organizationId;
  /// A list of Authenticators.
  final List<v1AuthenticatorParamsV2> authenticators;
  /// Unique identifier for a given User.
  final String userId;

  const TCreateAuthenticatorsBody({
     this.timestampMs,
     this.organizationId,
    required  this.authenticators,
    required  this.userId,
  });
  factory TCreateAuthenticatorsBody.fromJson(Map<String, dynamic> json) {
    final _timestampMs = json['timestampMs'] as String?;
    final _organizationId = json['organizationId'] as String?;
    final _authenticators = (json['authenticators'] as List).map((e) => v1AuthenticatorParamsV2.fromJson(e as Map<String, dynamic>)).toList();
    final _userId = json['userId'] as String;
    return TCreateAuthenticatorsBody(
      timestampMs: _timestampMs,
      organizationId: _organizationId,
      authenticators: _authenticators,
      userId: _userId,
    );
  }
  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    if (timestampMs != null) {
      _json['timestampMs'] = timestampMs;
    }
    if (organizationId != null) {
      _json['organizationId'] = organizationId;
    }
    _json['authenticators'] = authenticators.map((e) => e.toJson()).toList();
    _json['userId'] = userId;
    return _json;
  }
}

class TCreateAuthenticatorsInput {
  final TCreateAuthenticatorsBody body;
  const TCreateAuthenticatorsInput({required this.body});
  factory TCreateAuthenticatorsInput.fromJson(Map<String, dynamic> json) => TCreateAuthenticatorsInput(body: TCreateAuthenticatorsBody.fromJson(json['body'] as Map<String, dynamic>));
  Map<String, dynamic> toJson() => {'body': body.toJson()};
}

class TCreateFiatOnRampCredentialResponse {
  final v1Activity activity;
  final v1CreateFiatOnRampCredentialResult? result;
  const TCreateFiatOnRampCredentialResponse({required this.activity, this.result,});
  factory TCreateFiatOnRampCredentialResponse.fromJson(Map<String, dynamic> json) {
    return TCreateFiatOnRampCredentialResponse(
      activity: v1Activity.fromJson(json['activity'] as Map<String, dynamic>),
      result: json.containsKey('result') && json['result'] != null ? v1CreateFiatOnRampCredentialResult.fromJson(json['result'] as Map<String, dynamic>) : null,
    );
  }
  Map<String, dynamic> toJson() => {
    'activity': activity.toJson(),
    if (result != null) 'result': result!.toJson(),
  };
}

class TCreateFiatOnRampCredentialBody {
  final String? timestampMs;
  final String? organizationId;
  /// The fiat on-ramp provider
  final v1FiatOnRampProvider onrampProvider;
  /// Project ID for the on-ramp provider. Some providers, like Coinbase, require this additional identifier
  final String? projectId;
  /// Publishable API key for the on-ramp provider
  final String publishableApiKey;
  /// Secret API key for the on-ramp provider encrypted to our on-ramp encryption public key
  final String encryptedSecretApiKey;
  /// Private API key for the on-ramp provider encrypted to our on-ramp encryption public key. Some providers, like Coinbase, require this additional key.
  final String? encryptedPrivateApiKey;
  /// If the on-ramp credential is a sandbox credential
  final bool? sandboxMode;

  const TCreateFiatOnRampCredentialBody({
     this.timestampMs,
     this.organizationId,
    required  this.onrampProvider,
     this.projectId,
    required  this.publishableApiKey,
    required  this.encryptedSecretApiKey,
     this.encryptedPrivateApiKey,
     this.sandboxMode,
  });
  factory TCreateFiatOnRampCredentialBody.fromJson(Map<String, dynamic> json) {
    final _timestampMs = json['timestampMs'] as String?;
    final _organizationId = json['organizationId'] as String?;
    final _onrampProvider = v1FiatOnRampProviderFromJson(json['onrampProvider']);
    final _projectId = json['projectId'] as String?;
    final _publishableApiKey = json['publishableApiKey'] as String;
    final _encryptedSecretApiKey = json['encryptedSecretApiKey'] as String;
    final _encryptedPrivateApiKey = json['encryptedPrivateApiKey'] as String?;
    final _sandboxMode = json['sandboxMode'] as bool?;
    return TCreateFiatOnRampCredentialBody(
      timestampMs: _timestampMs,
      organizationId: _organizationId,
      onrampProvider: _onrampProvider,
      projectId: _projectId,
      publishableApiKey: _publishableApiKey,
      encryptedSecretApiKey: _encryptedSecretApiKey,
      encryptedPrivateApiKey: _encryptedPrivateApiKey,
      sandboxMode: _sandboxMode,
    );
  }
  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    if (timestampMs != null) {
      _json['timestampMs'] = timestampMs;
    }
    if (organizationId != null) {
      _json['organizationId'] = organizationId;
    }
    _json['onrampProvider'] = v1FiatOnRampProviderToJson(onrampProvider);
    if (projectId != null) {
      _json['projectId'] = projectId;
    }
    _json['publishableApiKey'] = publishableApiKey;
    _json['encryptedSecretApiKey'] = encryptedSecretApiKey;
    if (encryptedPrivateApiKey != null) {
      _json['encryptedPrivateApiKey'] = encryptedPrivateApiKey;
    }
    if (sandboxMode != null) {
      _json['sandboxMode'] = sandboxMode;
    }
    return _json;
  }
}

class TCreateFiatOnRampCredentialInput {
  final TCreateFiatOnRampCredentialBody body;
  const TCreateFiatOnRampCredentialInput({required this.body});
  factory TCreateFiatOnRampCredentialInput.fromJson(Map<String, dynamic> json) => TCreateFiatOnRampCredentialInput(body: TCreateFiatOnRampCredentialBody.fromJson(json['body'] as Map<String, dynamic>));
  Map<String, dynamic> toJson() => {'body': body.toJson()};
}

class TCreateInvitationsResponse {
  final v1Activity activity;
  final v1CreateInvitationsResult? result;
  const TCreateInvitationsResponse({required this.activity, this.result,});
  factory TCreateInvitationsResponse.fromJson(Map<String, dynamic> json) {
    return TCreateInvitationsResponse(
      activity: v1Activity.fromJson(json['activity'] as Map<String, dynamic>),
      result: json.containsKey('result') && json['result'] != null ? v1CreateInvitationsResult.fromJson(json['result'] as Map<String, dynamic>) : null,
    );
  }
  Map<String, dynamic> toJson() => {
    'activity': activity.toJson(),
    if (result != null) 'result': result!.toJson(),
  };
}

class TCreateInvitationsBody {
  final String? timestampMs;
  final String? organizationId;
  /// A list of Invitations.
  final List<v1InvitationParams> invitations;

  const TCreateInvitationsBody({
     this.timestampMs,
     this.organizationId,
    required  this.invitations,
  });
  factory TCreateInvitationsBody.fromJson(Map<String, dynamic> json) {
    final _timestampMs = json['timestampMs'] as String?;
    final _organizationId = json['organizationId'] as String?;
    final _invitations = (json['invitations'] as List).map((e) => v1InvitationParams.fromJson(e as Map<String, dynamic>)).toList();
    return TCreateInvitationsBody(
      timestampMs: _timestampMs,
      organizationId: _organizationId,
      invitations: _invitations,
    );
  }
  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    if (timestampMs != null) {
      _json['timestampMs'] = timestampMs;
    }
    if (organizationId != null) {
      _json['organizationId'] = organizationId;
    }
    _json['invitations'] = invitations.map((e) => e.toJson()).toList();
    return _json;
  }
}

class TCreateInvitationsInput {
  final TCreateInvitationsBody body;
  const TCreateInvitationsInput({required this.body});
  factory TCreateInvitationsInput.fromJson(Map<String, dynamic> json) => TCreateInvitationsInput(body: TCreateInvitationsBody.fromJson(json['body'] as Map<String, dynamic>));
  Map<String, dynamic> toJson() => {'body': body.toJson()};
}

class TCreateOauth2CredentialResponse {
  final v1Activity activity;
  final v1CreateOauth2CredentialResult? result;
  const TCreateOauth2CredentialResponse({required this.activity, this.result,});
  factory TCreateOauth2CredentialResponse.fromJson(Map<String, dynamic> json) {
    return TCreateOauth2CredentialResponse(
      activity: v1Activity.fromJson(json['activity'] as Map<String, dynamic>),
      result: json.containsKey('result') && json['result'] != null ? v1CreateOauth2CredentialResult.fromJson(json['result'] as Map<String, dynamic>) : null,
    );
  }
  Map<String, dynamic> toJson() => {
    'activity': activity.toJson(),
    if (result != null) 'result': result!.toJson(),
  };
}

class TCreateOauth2CredentialBody {
  final String? timestampMs;
  final String? organizationId;
  /// The OAuth 2.0 provider
  final v1Oauth2Provider provider;
  /// The Client ID issued by the OAuth 2.0 provider
  final String clientId;
  /// The client secret issued by the OAuth 2.0 provider encrypted to the TLS Fetcher quorum key
  final String encryptedClientSecret;

  const TCreateOauth2CredentialBody({
     this.timestampMs,
     this.organizationId,
    required  this.provider,
    required  this.clientId,
    required  this.encryptedClientSecret,
  });
  factory TCreateOauth2CredentialBody.fromJson(Map<String, dynamic> json) {
    final _timestampMs = json['timestampMs'] as String?;
    final _organizationId = json['organizationId'] as String?;
    final _provider = v1Oauth2ProviderFromJson(json['provider']);
    final _clientId = json['clientId'] as String;
    final _encryptedClientSecret = json['encryptedClientSecret'] as String;
    return TCreateOauth2CredentialBody(
      timestampMs: _timestampMs,
      organizationId: _organizationId,
      provider: _provider,
      clientId: _clientId,
      encryptedClientSecret: _encryptedClientSecret,
    );
  }
  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    if (timestampMs != null) {
      _json['timestampMs'] = timestampMs;
    }
    if (organizationId != null) {
      _json['organizationId'] = organizationId;
    }
    _json['provider'] = v1Oauth2ProviderToJson(provider);
    _json['clientId'] = clientId;
    _json['encryptedClientSecret'] = encryptedClientSecret;
    return _json;
  }
}

class TCreateOauth2CredentialInput {
  final TCreateOauth2CredentialBody body;
  const TCreateOauth2CredentialInput({required this.body});
  factory TCreateOauth2CredentialInput.fromJson(Map<String, dynamic> json) => TCreateOauth2CredentialInput(body: TCreateOauth2CredentialBody.fromJson(json['body'] as Map<String, dynamic>));
  Map<String, dynamic> toJson() => {'body': body.toJson()};
}

class TCreateOauthProvidersResponse {
  final v1Activity activity;
  final v1CreateOauthProvidersResult? result;
  const TCreateOauthProvidersResponse({required this.activity, this.result,});
  factory TCreateOauthProvidersResponse.fromJson(Map<String, dynamic> json) {
    return TCreateOauthProvidersResponse(
      activity: v1Activity.fromJson(json['activity'] as Map<String, dynamic>),
      result: json.containsKey('result') && json['result'] != null ? v1CreateOauthProvidersResult.fromJson(json['result'] as Map<String, dynamic>) : null,
    );
  }
  Map<String, dynamic> toJson() => {
    'activity': activity.toJson(),
    if (result != null) 'result': result!.toJson(),
  };
}

class TCreateOauthProvidersBody {
  final String? timestampMs;
  final String? organizationId;
  /// The ID of the User to add an Oauth provider to
  final String userId;
  /// A list of Oauth providers.
  final List<v1OauthProviderParams> oauthProviders;

  const TCreateOauthProvidersBody({
     this.timestampMs,
     this.organizationId,
    required  this.userId,
    required  this.oauthProviders,
  });
  factory TCreateOauthProvidersBody.fromJson(Map<String, dynamic> json) {
    final _timestampMs = json['timestampMs'] as String?;
    final _organizationId = json['organizationId'] as String?;
    final _userId = json['userId'] as String;
    final _oauthProviders = (json['oauthProviders'] as List).map((e) => v1OauthProviderParams.fromJson(e as Map<String, dynamic>)).toList();
    return TCreateOauthProvidersBody(
      timestampMs: _timestampMs,
      organizationId: _organizationId,
      userId: _userId,
      oauthProviders: _oauthProviders,
    );
  }
  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    if (timestampMs != null) {
      _json['timestampMs'] = timestampMs;
    }
    if (organizationId != null) {
      _json['organizationId'] = organizationId;
    }
    _json['userId'] = userId;
    _json['oauthProviders'] = oauthProviders.map((e) => e.toJson()).toList();
    return _json;
  }
}

class TCreateOauthProvidersInput {
  final TCreateOauthProvidersBody body;
  const TCreateOauthProvidersInput({required this.body});
  factory TCreateOauthProvidersInput.fromJson(Map<String, dynamic> json) => TCreateOauthProvidersInput(body: TCreateOauthProvidersBody.fromJson(json['body'] as Map<String, dynamic>));
  Map<String, dynamic> toJson() => {'body': body.toJson()};
}

class TCreatePoliciesResponse {
  final v1Activity activity;
  final v1CreatePoliciesResult? result;
  const TCreatePoliciesResponse({required this.activity, this.result,});
  factory TCreatePoliciesResponse.fromJson(Map<String, dynamic> json) {
    return TCreatePoliciesResponse(
      activity: v1Activity.fromJson(json['activity'] as Map<String, dynamic>),
      result: json.containsKey('result') && json['result'] != null ? v1CreatePoliciesResult.fromJson(json['result'] as Map<String, dynamic>) : null,
    );
  }
  Map<String, dynamic> toJson() => {
    'activity': activity.toJson(),
    if (result != null) 'result': result!.toJson(),
  };
}

class TCreatePoliciesBody {
  final String? timestampMs;
  final String? organizationId;
  /// An array of policy intents to be created.
  final List<v1CreatePolicyIntentV3> policies;

  const TCreatePoliciesBody({
     this.timestampMs,
     this.organizationId,
    required  this.policies,
  });
  factory TCreatePoliciesBody.fromJson(Map<String, dynamic> json) {
    final _timestampMs = json['timestampMs'] as String?;
    final _organizationId = json['organizationId'] as String?;
    final _policies = (json['policies'] as List).map((e) => v1CreatePolicyIntentV3.fromJson(e as Map<String, dynamic>)).toList();
    return TCreatePoliciesBody(
      timestampMs: _timestampMs,
      organizationId: _organizationId,
      policies: _policies,
    );
  }
  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    if (timestampMs != null) {
      _json['timestampMs'] = timestampMs;
    }
    if (organizationId != null) {
      _json['organizationId'] = organizationId;
    }
    _json['policies'] = policies.map((e) => e.toJson()).toList();
    return _json;
  }
}

class TCreatePoliciesInput {
  final TCreatePoliciesBody body;
  const TCreatePoliciesInput({required this.body});
  factory TCreatePoliciesInput.fromJson(Map<String, dynamic> json) => TCreatePoliciesInput(body: TCreatePoliciesBody.fromJson(json['body'] as Map<String, dynamic>));
  Map<String, dynamic> toJson() => {'body': body.toJson()};
}

class TCreatePolicyResponse {
  final v1Activity activity;
  final v1CreatePolicyResult? result;
  const TCreatePolicyResponse({required this.activity, this.result,});
  factory TCreatePolicyResponse.fromJson(Map<String, dynamic> json) {
    return TCreatePolicyResponse(
      activity: v1Activity.fromJson(json['activity'] as Map<String, dynamic>),
      result: json.containsKey('result') && json['result'] != null ? v1CreatePolicyResult.fromJson(json['result'] as Map<String, dynamic>) : null,
    );
  }
  Map<String, dynamic> toJson() => {
    'activity': activity.toJson(),
    if (result != null) 'result': result!.toJson(),
  };
}

class TCreatePolicyBody {
  final String? timestampMs;
  final String? organizationId;
  /// Human-readable name for a Policy.
  final String policyName;
  /// The instruction to DENY or ALLOW an activity.
  final v1Effect effect;
  /// The condition expression that triggers the Effect
  final String? condition;
  /// The consensus expression that triggers the Effect
  final String? consensus;
  /// Notes for a Policy.
  final String notes;

  const TCreatePolicyBody({
     this.timestampMs,
     this.organizationId,
    required  this.policyName,
    required  this.effect,
     this.condition,
     this.consensus,
    required  this.notes,
  });
  factory TCreatePolicyBody.fromJson(Map<String, dynamic> json) {
    final _timestampMs = json['timestampMs'] as String?;
    final _organizationId = json['organizationId'] as String?;
    final _policyName = json['policyName'] as String;
    final _effect = v1EffectFromJson(json['effect']);
    final _condition = json['condition'] as String?;
    final _consensus = json['consensus'] as String?;
    final _notes = json['notes'] as String;
    return TCreatePolicyBody(
      timestampMs: _timestampMs,
      organizationId: _organizationId,
      policyName: _policyName,
      effect: _effect,
      condition: _condition,
      consensus: _consensus,
      notes: _notes,
    );
  }
  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    if (timestampMs != null) {
      _json['timestampMs'] = timestampMs;
    }
    if (organizationId != null) {
      _json['organizationId'] = organizationId;
    }
    _json['policyName'] = policyName;
    _json['effect'] = v1EffectToJson(effect);
    if (condition != null) {
      _json['condition'] = condition;
    }
    if (consensus != null) {
      _json['consensus'] = consensus;
    }
    _json['notes'] = notes;
    return _json;
  }
}

class TCreatePolicyInput {
  final TCreatePolicyBody body;
  const TCreatePolicyInput({required this.body});
  factory TCreatePolicyInput.fromJson(Map<String, dynamic> json) => TCreatePolicyInput(body: TCreatePolicyBody.fromJson(json['body'] as Map<String, dynamic>));
  Map<String, dynamic> toJson() => {'body': body.toJson()};
}

class TCreatePrivateKeyTagResponse {
  final v1Activity activity;
  final v1CreatePrivateKeyTagResult? result;
  const TCreatePrivateKeyTagResponse({required this.activity, this.result,});
  factory TCreatePrivateKeyTagResponse.fromJson(Map<String, dynamic> json) {
    return TCreatePrivateKeyTagResponse(
      activity: v1Activity.fromJson(json['activity'] as Map<String, dynamic>),
      result: json.containsKey('result') && json['result'] != null ? v1CreatePrivateKeyTagResult.fromJson(json['result'] as Map<String, dynamic>) : null,
    );
  }
  Map<String, dynamic> toJson() => {
    'activity': activity.toJson(),
    if (result != null) 'result': result!.toJson(),
  };
}

class TCreatePrivateKeyTagBody {
  final String? timestampMs;
  final String? organizationId;
  /// Human-readable name for a Private Key Tag.
  final String privateKeyTagName;
  /// A list of Private Key IDs.
  final List<String> privateKeyIds;

  const TCreatePrivateKeyTagBody({
     this.timestampMs,
     this.organizationId,
    required  this.privateKeyTagName,
    required  this.privateKeyIds,
  });
  factory TCreatePrivateKeyTagBody.fromJson(Map<String, dynamic> json) {
    final _timestampMs = json['timestampMs'] as String?;
    final _organizationId = json['organizationId'] as String?;
    final _privateKeyTagName = json['privateKeyTagName'] as String;
    final _privateKeyIds = (json['privateKeyIds'] as List).map((e) => e as String).toList();
    return TCreatePrivateKeyTagBody(
      timestampMs: _timestampMs,
      organizationId: _organizationId,
      privateKeyTagName: _privateKeyTagName,
      privateKeyIds: _privateKeyIds,
    );
  }
  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    if (timestampMs != null) {
      _json['timestampMs'] = timestampMs;
    }
    if (organizationId != null) {
      _json['organizationId'] = organizationId;
    }
    _json['privateKeyTagName'] = privateKeyTagName;
    _json['privateKeyIds'] = privateKeyIds;
    return _json;
  }
}

class TCreatePrivateKeyTagInput {
  final TCreatePrivateKeyTagBody body;
  const TCreatePrivateKeyTagInput({required this.body});
  factory TCreatePrivateKeyTagInput.fromJson(Map<String, dynamic> json) => TCreatePrivateKeyTagInput(body: TCreatePrivateKeyTagBody.fromJson(json['body'] as Map<String, dynamic>));
  Map<String, dynamic> toJson() => {'body': body.toJson()};
}

class TCreatePrivateKeysResponse {
  final v1Activity activity;
  final v1CreatePrivateKeysResultV2? result;
  const TCreatePrivateKeysResponse({required this.activity, this.result,});
  factory TCreatePrivateKeysResponse.fromJson(Map<String, dynamic> json) {
    return TCreatePrivateKeysResponse(
      activity: v1Activity.fromJson(json['activity'] as Map<String, dynamic>),
      result: json.containsKey('result') && json['result'] != null ? v1CreatePrivateKeysResultV2.fromJson(json['result'] as Map<String, dynamic>) : null,
    );
  }
  Map<String, dynamic> toJson() => {
    'activity': activity.toJson(),
    if (result != null) 'result': result!.toJson(),
  };
}

class TCreatePrivateKeysBody {
  final String? timestampMs;
  final String? organizationId;
  /// A list of Private Keys.
  final List<v1PrivateKeyParams> privateKeys;

  const TCreatePrivateKeysBody({
     this.timestampMs,
     this.organizationId,
    required  this.privateKeys,
  });
  factory TCreatePrivateKeysBody.fromJson(Map<String, dynamic> json) {
    final _timestampMs = json['timestampMs'] as String?;
    final _organizationId = json['organizationId'] as String?;
    final _privateKeys = (json['privateKeys'] as List).map((e) => v1PrivateKeyParams.fromJson(e as Map<String, dynamic>)).toList();
    return TCreatePrivateKeysBody(
      timestampMs: _timestampMs,
      organizationId: _organizationId,
      privateKeys: _privateKeys,
    );
  }
  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    if (timestampMs != null) {
      _json['timestampMs'] = timestampMs;
    }
    if (organizationId != null) {
      _json['organizationId'] = organizationId;
    }
    _json['privateKeys'] = privateKeys.map((e) => e.toJson()).toList();
    return _json;
  }
}

class TCreatePrivateKeysInput {
  final TCreatePrivateKeysBody body;
  const TCreatePrivateKeysInput({required this.body});
  factory TCreatePrivateKeysInput.fromJson(Map<String, dynamic> json) => TCreatePrivateKeysInput(body: TCreatePrivateKeysBody.fromJson(json['body'] as Map<String, dynamic>));
  Map<String, dynamic> toJson() => {'body': body.toJson()};
}

class TCreateReadOnlySessionResponse {
  final v1Activity activity;
  final v1CreateReadOnlySessionResult? result;
  const TCreateReadOnlySessionResponse({required this.activity, this.result,});
  factory TCreateReadOnlySessionResponse.fromJson(Map<String, dynamic> json) {
    return TCreateReadOnlySessionResponse(
      activity: v1Activity.fromJson(json['activity'] as Map<String, dynamic>),
      result: json.containsKey('result') && json['result'] != null ? v1CreateReadOnlySessionResult.fromJson(json['result'] as Map<String, dynamic>) : null,
    );
  }
  Map<String, dynamic> toJson() => {
    'activity': activity.toJson(),
    if (result != null) 'result': result!.toJson(),
  };
}

class TCreateReadOnlySessionBody {
  final String? timestampMs;
  final String? organizationId;

  const TCreateReadOnlySessionBody({
     this.timestampMs,
     this.organizationId,
  });
  factory TCreateReadOnlySessionBody.fromJson(Map<String, dynamic> json) {
    final _timestampMs = json['timestampMs'] as String?;
    final _organizationId = json['organizationId'] as String?;
    return TCreateReadOnlySessionBody(
      timestampMs: _timestampMs,
      organizationId: _organizationId,
    );
  }
  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    if (timestampMs != null) {
      _json['timestampMs'] = timestampMs;
    }
    if (organizationId != null) {
      _json['organizationId'] = organizationId;
    }
    return _json;
  }
}

class TCreateReadOnlySessionInput {
  final TCreateReadOnlySessionBody body;
  const TCreateReadOnlySessionInput({required this.body});
  factory TCreateReadOnlySessionInput.fromJson(Map<String, dynamic> json) => TCreateReadOnlySessionInput(body: TCreateReadOnlySessionBody.fromJson(json['body'] as Map<String, dynamic>));
  Map<String, dynamic> toJson() => {'body': body.toJson()};
}

class TCreateReadWriteSessionResponse {
  final v1Activity activity;
  final v1CreateReadWriteSessionResult? result;
  const TCreateReadWriteSessionResponse({required this.activity, this.result,});
  factory TCreateReadWriteSessionResponse.fromJson(Map<String, dynamic> json) {
    return TCreateReadWriteSessionResponse(
      activity: v1Activity.fromJson(json['activity'] as Map<String, dynamic>),
      result: json.containsKey('result') && json['result'] != null ? v1CreateReadWriteSessionResult.fromJson(json['result'] as Map<String, dynamic>) : null,
    );
  }
  Map<String, dynamic> toJson() => {
    'activity': activity.toJson(),
    if (result != null) 'result': result!.toJson(),
  };
}

class TCreateReadWriteSessionBody {
  final String? timestampMs;
  final String? organizationId;
  /// Client-side public key generated by the user, to which the read write session bundle (credentials) will be encrypted.
  final String targetPublicKey;
  /// Unique identifier for a given User.
  final String? userId;
  /// Optional human-readable name for an API Key. If none provided, default to Read Write Session - <Timestamp>
  final String? apiKeyName;
  /// Expiration window (in seconds) indicating how long the API key is valid for. If not provided, a default of 15 minutes will be used.
  final String? expirationSeconds;
  /// Invalidate all other previously generated ReadWriteSession API keys
  final bool? invalidateExisting;

  const TCreateReadWriteSessionBody({
     this.timestampMs,
     this.organizationId,
    required  this.targetPublicKey,
     this.userId,
     this.apiKeyName,
     this.expirationSeconds,
     this.invalidateExisting,
  });
  factory TCreateReadWriteSessionBody.fromJson(Map<String, dynamic> json) {
    final _timestampMs = json['timestampMs'] as String?;
    final _organizationId = json['organizationId'] as String?;
    final _targetPublicKey = json['targetPublicKey'] as String;
    final _userId = json['userId'] as String?;
    final _apiKeyName = json['apiKeyName'] as String?;
    final _expirationSeconds = json['expirationSeconds'] as String?;
    final _invalidateExisting = json['invalidateExisting'] as bool?;
    return TCreateReadWriteSessionBody(
      timestampMs: _timestampMs,
      organizationId: _organizationId,
      targetPublicKey: _targetPublicKey,
      userId: _userId,
      apiKeyName: _apiKeyName,
      expirationSeconds: _expirationSeconds,
      invalidateExisting: _invalidateExisting,
    );
  }
  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    if (timestampMs != null) {
      _json['timestampMs'] = timestampMs;
    }
    if (organizationId != null) {
      _json['organizationId'] = organizationId;
    }
    _json['targetPublicKey'] = targetPublicKey;
    if (userId != null) {
      _json['userId'] = userId;
    }
    if (apiKeyName != null) {
      _json['apiKeyName'] = apiKeyName;
    }
    if (expirationSeconds != null) {
      _json['expirationSeconds'] = expirationSeconds;
    }
    if (invalidateExisting != null) {
      _json['invalidateExisting'] = invalidateExisting;
    }
    return _json;
  }
}

class TCreateReadWriteSessionInput {
  final TCreateReadWriteSessionBody body;
  const TCreateReadWriteSessionInput({required this.body});
  factory TCreateReadWriteSessionInput.fromJson(Map<String, dynamic> json) => TCreateReadWriteSessionInput(body: TCreateReadWriteSessionBody.fromJson(json['body'] as Map<String, dynamic>));
  Map<String, dynamic> toJson() => {'body': body.toJson()};
}

class TCreateSmartContractInterfaceResponse {
  final v1Activity activity;
  final v1CreateSmartContractInterfaceResult? result;
  const TCreateSmartContractInterfaceResponse({required this.activity, this.result,});
  factory TCreateSmartContractInterfaceResponse.fromJson(Map<String, dynamic> json) {
    return TCreateSmartContractInterfaceResponse(
      activity: v1Activity.fromJson(json['activity'] as Map<String, dynamic>),
      result: json.containsKey('result') && json['result'] != null ? v1CreateSmartContractInterfaceResult.fromJson(json['result'] as Map<String, dynamic>) : null,
    );
  }
  Map<String, dynamic> toJson() => {
    'activity': activity.toJson(),
    if (result != null) 'result': result!.toJson(),
  };
}

class TCreateSmartContractInterfaceBody {
  final String? timestampMs;
  final String? organizationId;
  /// Corresponding contract address or program ID
  final String smartContractAddress;
  /// ABI/IDL as a JSON string. Limited to 400kb
  final String smartContractInterface;
  final v1SmartContractInterfaceType type;
  /// Human-readable name for a Smart Contract Interface.
  final String label;
  /// Notes for a Smart Contract Interface.
  final String? notes;

  const TCreateSmartContractInterfaceBody({
     this.timestampMs,
     this.organizationId,
    required  this.smartContractAddress,
    required  this.smartContractInterface,
    required  this.type,
    required  this.label,
     this.notes,
  });
  factory TCreateSmartContractInterfaceBody.fromJson(Map<String, dynamic> json) {
    final _timestampMs = json['timestampMs'] as String?;
    final _organizationId = json['organizationId'] as String?;
    final _smartContractAddress = json['smartContractAddress'] as String;
    final _smartContractInterface = json['smartContractInterface'] as String;
    final _type = v1SmartContractInterfaceTypeFromJson(json['type']);
    final _label = json['label'] as String;
    final _notes = json['notes'] as String?;
    return TCreateSmartContractInterfaceBody(
      timestampMs: _timestampMs,
      organizationId: _organizationId,
      smartContractAddress: _smartContractAddress,
      smartContractInterface: _smartContractInterface,
      type: _type,
      label: _label,
      notes: _notes,
    );
  }
  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    if (timestampMs != null) {
      _json['timestampMs'] = timestampMs;
    }
    if (organizationId != null) {
      _json['organizationId'] = organizationId;
    }
    _json['smartContractAddress'] = smartContractAddress;
    _json['smartContractInterface'] = smartContractInterface;
    _json['type'] = v1SmartContractInterfaceTypeToJson(type);
    _json['label'] = label;
    if (notes != null) {
      _json['notes'] = notes;
    }
    return _json;
  }
}

class TCreateSmartContractInterfaceInput {
  final TCreateSmartContractInterfaceBody body;
  const TCreateSmartContractInterfaceInput({required this.body});
  factory TCreateSmartContractInterfaceInput.fromJson(Map<String, dynamic> json) => TCreateSmartContractInterfaceInput(body: TCreateSmartContractInterfaceBody.fromJson(json['body'] as Map<String, dynamic>));
  Map<String, dynamic> toJson() => {'body': body.toJson()};
}

class TCreateSubOrganizationResponse {
  final v1Activity activity;
  final v1CreateSubOrganizationResultV7? result;
  const TCreateSubOrganizationResponse({required this.activity, this.result,});
  factory TCreateSubOrganizationResponse.fromJson(Map<String, dynamic> json) {
    return TCreateSubOrganizationResponse(
      activity: v1Activity.fromJson(json['activity'] as Map<String, dynamic>),
      result: json.containsKey('result') && json['result'] != null ? v1CreateSubOrganizationResultV7.fromJson(json['result'] as Map<String, dynamic>) : null,
    );
  }
  Map<String, dynamic> toJson() => {
    'activity': activity.toJson(),
    if (result != null) 'result': result!.toJson(),
  };
}

class TCreateSubOrganizationBody {
  final String? timestampMs;
  final String? organizationId;
  /// Name for this sub-organization
  final String subOrganizationName;
  /// Root users to create within this sub-organization
  final List<v1RootUserParamsV4> rootUsers;
  /// The threshold of unique approvals to reach root quorum. This value must be less than or equal to the number of root users
  final num rootQuorumThreshold;
  /// The wallet to create for the sub-organization
  final v1WalletParams? wallet;
  /// Disable email recovery for the sub-organization
  final bool? disableEmailRecovery;
  /// Disable email auth for the sub-organization
  final bool? disableEmailAuth;
  /// Disable OTP SMS auth for the sub-organization
  final bool? disableSmsAuth;
  /// Disable OTP email auth for the sub-organization
  final bool? disableOtpEmailAuth;
  /// Signed JWT containing a unique id, expiry, verification type, contact
  final String? verificationToken;
  /// Optional signature proving authorization for this sub-organization creation. The signature is over the verification token ID and the root user parameters for the root user associated with the verification token. Only required if a public key was provided during the verification step.
  final v1ClientSignature? clientSignature;

  const TCreateSubOrganizationBody({
     this.timestampMs,
     this.organizationId,
    required  this.subOrganizationName,
    required  this.rootUsers,
    required  this.rootQuorumThreshold,
     this.wallet,
     this.disableEmailRecovery,
     this.disableEmailAuth,
     this.disableSmsAuth,
     this.disableOtpEmailAuth,
     this.verificationToken,
     this.clientSignature,
  });
  factory TCreateSubOrganizationBody.fromJson(Map<String, dynamic> json) {
    final _timestampMs = json['timestampMs'] as String?;
    final _organizationId = json['organizationId'] as String?;
    final _subOrganizationName = json['subOrganizationName'] as String;
    final _rootUsers = (json['rootUsers'] as List).map((e) => v1RootUserParamsV4.fromJson(e as Map<String, dynamic>)).toList();
    final _rootQuorumThreshold = json['rootQuorumThreshold'] as num;
    final _wallet = json['wallet'] == null ? null : v1WalletParams.fromJson(json['wallet'] as Map<String, dynamic>);
    final _disableEmailRecovery = json['disableEmailRecovery'] as bool?;
    final _disableEmailAuth = json['disableEmailAuth'] as bool?;
    final _disableSmsAuth = json['disableSmsAuth'] as bool?;
    final _disableOtpEmailAuth = json['disableOtpEmailAuth'] as bool?;
    final _verificationToken = json['verificationToken'] as String?;
    final _clientSignature = json['clientSignature'] == null ? null : v1ClientSignature.fromJson(json['clientSignature'] as Map<String, dynamic>);
    return TCreateSubOrganizationBody(
      timestampMs: _timestampMs,
      organizationId: _organizationId,
      subOrganizationName: _subOrganizationName,
      rootUsers: _rootUsers,
      rootQuorumThreshold: _rootQuorumThreshold,
      wallet: _wallet,
      disableEmailRecovery: _disableEmailRecovery,
      disableEmailAuth: _disableEmailAuth,
      disableSmsAuth: _disableSmsAuth,
      disableOtpEmailAuth: _disableOtpEmailAuth,
      verificationToken: _verificationToken,
      clientSignature: _clientSignature,
    );
  }
  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    if (timestampMs != null) {
      _json['timestampMs'] = timestampMs;
    }
    if (organizationId != null) {
      _json['organizationId'] = organizationId;
    }
    _json['subOrganizationName'] = subOrganizationName;
    _json['rootUsers'] = rootUsers.map((e) => e.toJson()).toList();
    _json['rootQuorumThreshold'] = rootQuorumThreshold;
    if (wallet != null) {
      _json['wallet'] = wallet?.toJson();
    }
    if (disableEmailRecovery != null) {
      _json['disableEmailRecovery'] = disableEmailRecovery;
    }
    if (disableEmailAuth != null) {
      _json['disableEmailAuth'] = disableEmailAuth;
    }
    if (disableSmsAuth != null) {
      _json['disableSmsAuth'] = disableSmsAuth;
    }
    if (disableOtpEmailAuth != null) {
      _json['disableOtpEmailAuth'] = disableOtpEmailAuth;
    }
    if (verificationToken != null) {
      _json['verificationToken'] = verificationToken;
    }
    if (clientSignature != null) {
      _json['clientSignature'] = clientSignature?.toJson();
    }
    return _json;
  }
}

class TCreateSubOrganizationInput {
  final TCreateSubOrganizationBody body;
  const TCreateSubOrganizationInput({required this.body});
  factory TCreateSubOrganizationInput.fromJson(Map<String, dynamic> json) => TCreateSubOrganizationInput(body: TCreateSubOrganizationBody.fromJson(json['body'] as Map<String, dynamic>));
  Map<String, dynamic> toJson() => {'body': body.toJson()};
}

class TCreateTvcAppResponse {
  final v1Activity activity;
  final v1CreateTvcAppResult? result;
  const TCreateTvcAppResponse({required this.activity, this.result,});
  factory TCreateTvcAppResponse.fromJson(Map<String, dynamic> json) {
    return TCreateTvcAppResponse(
      activity: v1Activity.fromJson(json['activity'] as Map<String, dynamic>),
      result: json.containsKey('result') && json['result'] != null ? v1CreateTvcAppResult.fromJson(json['result'] as Map<String, dynamic>) : null,
    );
  }
  Map<String, dynamic> toJson() => {
    'activity': activity.toJson(),
    if (result != null) 'result': result!.toJson(),
  };
}

class TCreateTvcAppBody {
  final String? timestampMs;
  final String? organizationId;
  /// The name of the new TVC application
  final String name;
  /// Quorum public key to use for this application
  final String quorumPublicKey;
  /// Unique identifier for an existing TVC operator set to use as the Manifest Set for this TVC application. If left empty, a new Manifest Set configuration is required
  final String? manifestSetId;
  /// Configuration to create a new TVC operator set, used as the Manifest Set for this TVC application. If left empty, a Manifest Set ID is required
  final v1TvcOperatorSetParams? manifestSetParams;
  /// Unique identifier for an existing TVC operator set to use as the Share Set for this TVC application. If left empty, a new Share Set configuration is required
  final String? shareSetId;
  /// Configuration to create a new TVC operator set, used as the Share Set for this TVC application. If left empty, a Share Set ID is required
  final v1TvcOperatorSetParams? shareSetParams;
  /// Enables external connectivity for this TVC app. Default if not provided: false.
  final bool? externalConnectivity;

  const TCreateTvcAppBody({
     this.timestampMs,
     this.organizationId,
    required  this.name,
    required  this.quorumPublicKey,
     this.manifestSetId,
     this.manifestSetParams,
     this.shareSetId,
     this.shareSetParams,
     this.externalConnectivity,
  });
  factory TCreateTvcAppBody.fromJson(Map<String, dynamic> json) {
    final _timestampMs = json['timestampMs'] as String?;
    final _organizationId = json['organizationId'] as String?;
    final _name = json['name'] as String;
    final _quorumPublicKey = json['quorumPublicKey'] as String;
    final _manifestSetId = json['manifestSetId'] as String?;
    final _manifestSetParams = json['manifestSetParams'] == null ? null : v1TvcOperatorSetParams.fromJson(json['manifestSetParams'] as Map<String, dynamic>);
    final _shareSetId = json['shareSetId'] as String?;
    final _shareSetParams = json['shareSetParams'] == null ? null : v1TvcOperatorSetParams.fromJson(json['shareSetParams'] as Map<String, dynamic>);
    final _externalConnectivity = json['externalConnectivity'] as bool?;
    return TCreateTvcAppBody(
      timestampMs: _timestampMs,
      organizationId: _organizationId,
      name: _name,
      quorumPublicKey: _quorumPublicKey,
      manifestSetId: _manifestSetId,
      manifestSetParams: _manifestSetParams,
      shareSetId: _shareSetId,
      shareSetParams: _shareSetParams,
      externalConnectivity: _externalConnectivity,
    );
  }
  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    if (timestampMs != null) {
      _json['timestampMs'] = timestampMs;
    }
    if (organizationId != null) {
      _json['organizationId'] = organizationId;
    }
    _json['name'] = name;
    _json['quorumPublicKey'] = quorumPublicKey;
    if (manifestSetId != null) {
      _json['manifestSetId'] = manifestSetId;
    }
    if (manifestSetParams != null) {
      _json['manifestSetParams'] = manifestSetParams?.toJson();
    }
    if (shareSetId != null) {
      _json['shareSetId'] = shareSetId;
    }
    if (shareSetParams != null) {
      _json['shareSetParams'] = shareSetParams?.toJson();
    }
    if (externalConnectivity != null) {
      _json['externalConnectivity'] = externalConnectivity;
    }
    return _json;
  }
}

class TCreateTvcAppInput {
  final TCreateTvcAppBody body;
  const TCreateTvcAppInput({required this.body});
  factory TCreateTvcAppInput.fromJson(Map<String, dynamic> json) => TCreateTvcAppInput(body: TCreateTvcAppBody.fromJson(json['body'] as Map<String, dynamic>));
  Map<String, dynamic> toJson() => {'body': body.toJson()};
}

class TCreateTvcDeploymentResponse {
  final v1Activity activity;
  final v1CreateTvcDeploymentResult? result;
  const TCreateTvcDeploymentResponse({required this.activity, this.result,});
  factory TCreateTvcDeploymentResponse.fromJson(Map<String, dynamic> json) {
    return TCreateTvcDeploymentResponse(
      activity: v1Activity.fromJson(json['activity'] as Map<String, dynamic>),
      result: json.containsKey('result') && json['result'] != null ? v1CreateTvcDeploymentResult.fromJson(json['result'] as Map<String, dynamic>) : null,
    );
  }
  Map<String, dynamic> toJson() => {
    'activity': activity.toJson(),
    if (result != null) 'result': result!.toJson(),
  };
}

class TCreateTvcDeploymentBody {
  final String? timestampMs;
  final String? organizationId;
  /// The unique identifier of the to-be-deployed TVC application
  final String appId;
  /// The QuorumOS version to use to deploy this application
  final String qosVersion;
  /// URL of the container containing the pivot binary
  final String pivotContainerImageUrl;
  /// Location of the binary in the pivot container
  final String pivotPath;
  /// Arguments to pass to the pivot binary at startup. Encoded as a list of strings, for example ["--foo", "bar"]
  final List<String> pivotArgs;
  /// Digest of the pivot binary in the pivot container. This value will be inserted in the QOS manifest to ensure application integrity.
  final String expectedPivotDigest;
  /// URL of the container containing the host binary
  final String hostContainerImageUrl;
  /// Location of the binary inside the host container
  final String hostPath;
  /// Arguments to pass to the host binary at startup. Encoded as a list of strings, for example ["--foo", "bar"]
  final List<String> hostArgs;
  /// Optional nonce to ensure uniqueness of the deployment manifest. If not provided, it defaults to the current Unix timestamp in seconds.
  final num? nonce;

  const TCreateTvcDeploymentBody({
     this.timestampMs,
     this.organizationId,
    required  this.appId,
    required  this.qosVersion,
    required  this.pivotContainerImageUrl,
    required  this.pivotPath,
    required  this.pivotArgs,
    required  this.expectedPivotDigest,
    required  this.hostContainerImageUrl,
    required  this.hostPath,
    required  this.hostArgs,
     this.nonce,
  });
  factory TCreateTvcDeploymentBody.fromJson(Map<String, dynamic> json) {
    final _timestampMs = json['timestampMs'] as String?;
    final _organizationId = json['organizationId'] as String?;
    final _appId = json['appId'] as String;
    final _qosVersion = json['qosVersion'] as String;
    final _pivotContainerImageUrl = json['pivotContainerImageUrl'] as String;
    final _pivotPath = json['pivotPath'] as String;
    final _pivotArgs = (json['pivotArgs'] as List).map((e) => e as String).toList();
    final _expectedPivotDigest = json['expectedPivotDigest'] as String;
    final _hostContainerImageUrl = json['hostContainerImageUrl'] as String;
    final _hostPath = json['hostPath'] as String;
    final _hostArgs = (json['hostArgs'] as List).map((e) => e as String).toList();
    final _nonce = json['nonce'] as num?;
    return TCreateTvcDeploymentBody(
      timestampMs: _timestampMs,
      organizationId: _organizationId,
      appId: _appId,
      qosVersion: _qosVersion,
      pivotContainerImageUrl: _pivotContainerImageUrl,
      pivotPath: _pivotPath,
      pivotArgs: _pivotArgs,
      expectedPivotDigest: _expectedPivotDigest,
      hostContainerImageUrl: _hostContainerImageUrl,
      hostPath: _hostPath,
      hostArgs: _hostArgs,
      nonce: _nonce,
    );
  }
  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    if (timestampMs != null) {
      _json['timestampMs'] = timestampMs;
    }
    if (organizationId != null) {
      _json['organizationId'] = organizationId;
    }
    _json['appId'] = appId;
    _json['qosVersion'] = qosVersion;
    _json['pivotContainerImageUrl'] = pivotContainerImageUrl;
    _json['pivotPath'] = pivotPath;
    _json['pivotArgs'] = pivotArgs;
    _json['expectedPivotDigest'] = expectedPivotDigest;
    _json['hostContainerImageUrl'] = hostContainerImageUrl;
    _json['hostPath'] = hostPath;
    _json['hostArgs'] = hostArgs;
    if (nonce != null) {
      _json['nonce'] = nonce;
    }
    return _json;
  }
}

class TCreateTvcDeploymentInput {
  final TCreateTvcDeploymentBody body;
  const TCreateTvcDeploymentInput({required this.body});
  factory TCreateTvcDeploymentInput.fromJson(Map<String, dynamic> json) => TCreateTvcDeploymentInput(body: TCreateTvcDeploymentBody.fromJson(json['body'] as Map<String, dynamic>));
  Map<String, dynamic> toJson() => {'body': body.toJson()};
}

class TCreateTvcManifestApprovalsResponse {
  final v1Activity activity;
  final v1CreateTvcManifestApprovalsResult? result;
  const TCreateTvcManifestApprovalsResponse({required this.activity, this.result,});
  factory TCreateTvcManifestApprovalsResponse.fromJson(Map<String, dynamic> json) {
    return TCreateTvcManifestApprovalsResponse(
      activity: v1Activity.fromJson(json['activity'] as Map<String, dynamic>),
      result: json.containsKey('result') && json['result'] != null ? v1CreateTvcManifestApprovalsResult.fromJson(json['result'] as Map<String, dynamic>) : null,
    );
  }
  Map<String, dynamic> toJson() => {
    'activity': activity.toJson(),
    if (result != null) 'result': result!.toJson(),
  };
}

class TCreateTvcManifestApprovalsBody {
  final String? timestampMs;
  final String? organizationId;
  /// Unique identifier of the TVC deployment to approve
  final String manifestId;
  /// List of manifest approvals
  final List<v1TvcManifestApproval> approvals;

  const TCreateTvcManifestApprovalsBody({
     this.timestampMs,
     this.organizationId,
    required  this.manifestId,
    required  this.approvals,
  });
  factory TCreateTvcManifestApprovalsBody.fromJson(Map<String, dynamic> json) {
    final _timestampMs = json['timestampMs'] as String?;
    final _organizationId = json['organizationId'] as String?;
    final _manifestId = json['manifestId'] as String;
    final _approvals = (json['approvals'] as List).map((e) => v1TvcManifestApproval.fromJson(e as Map<String, dynamic>)).toList();
    return TCreateTvcManifestApprovalsBody(
      timestampMs: _timestampMs,
      organizationId: _organizationId,
      manifestId: _manifestId,
      approvals: _approvals,
    );
  }
  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    if (timestampMs != null) {
      _json['timestampMs'] = timestampMs;
    }
    if (organizationId != null) {
      _json['organizationId'] = organizationId;
    }
    _json['manifestId'] = manifestId;
    _json['approvals'] = approvals.map((e) => e.toJson()).toList();
    return _json;
  }
}

class TCreateTvcManifestApprovalsInput {
  final TCreateTvcManifestApprovalsBody body;
  const TCreateTvcManifestApprovalsInput({required this.body});
  factory TCreateTvcManifestApprovalsInput.fromJson(Map<String, dynamic> json) => TCreateTvcManifestApprovalsInput(body: TCreateTvcManifestApprovalsBody.fromJson(json['body'] as Map<String, dynamic>));
  Map<String, dynamic> toJson() => {'body': body.toJson()};
}

class TCreateUserTagResponse {
  final v1Activity activity;
  final v1CreateUserTagResult? result;
  const TCreateUserTagResponse({required this.activity, this.result,});
  factory TCreateUserTagResponse.fromJson(Map<String, dynamic> json) {
    return TCreateUserTagResponse(
      activity: v1Activity.fromJson(json['activity'] as Map<String, dynamic>),
      result: json.containsKey('result') && json['result'] != null ? v1CreateUserTagResult.fromJson(json['result'] as Map<String, dynamic>) : null,
    );
  }
  Map<String, dynamic> toJson() => {
    'activity': activity.toJson(),
    if (result != null) 'result': result!.toJson(),
  };
}

class TCreateUserTagBody {
  final String? timestampMs;
  final String? organizationId;
  /// Human-readable name for a User Tag.
  final String userTagName;
  /// A list of User IDs.
  final List<String> userIds;

  const TCreateUserTagBody({
     this.timestampMs,
     this.organizationId,
    required  this.userTagName,
    required  this.userIds,
  });
  factory TCreateUserTagBody.fromJson(Map<String, dynamic> json) {
    final _timestampMs = json['timestampMs'] as String?;
    final _organizationId = json['organizationId'] as String?;
    final _userTagName = json['userTagName'] as String;
    final _userIds = (json['userIds'] as List).map((e) => e as String).toList();
    return TCreateUserTagBody(
      timestampMs: _timestampMs,
      organizationId: _organizationId,
      userTagName: _userTagName,
      userIds: _userIds,
    );
  }
  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    if (timestampMs != null) {
      _json['timestampMs'] = timestampMs;
    }
    if (organizationId != null) {
      _json['organizationId'] = organizationId;
    }
    _json['userTagName'] = userTagName;
    _json['userIds'] = userIds;
    return _json;
  }
}

class TCreateUserTagInput {
  final TCreateUserTagBody body;
  const TCreateUserTagInput({required this.body});
  factory TCreateUserTagInput.fromJson(Map<String, dynamic> json) => TCreateUserTagInput(body: TCreateUserTagBody.fromJson(json['body'] as Map<String, dynamic>));
  Map<String, dynamic> toJson() => {'body': body.toJson()};
}

class TCreateUsersResponse {
  final v1Activity activity;
  final v1CreateUsersResult? result;
  const TCreateUsersResponse({required this.activity, this.result,});
  factory TCreateUsersResponse.fromJson(Map<String, dynamic> json) {
    return TCreateUsersResponse(
      activity: v1Activity.fromJson(json['activity'] as Map<String, dynamic>),
      result: json.containsKey('result') && json['result'] != null ? v1CreateUsersResult.fromJson(json['result'] as Map<String, dynamic>) : null,
    );
  }
  Map<String, dynamic> toJson() => {
    'activity': activity.toJson(),
    if (result != null) 'result': result!.toJson(),
  };
}

class TCreateUsersBody {
  final String? timestampMs;
  final String? organizationId;
  /// A list of Users.
  final List<v1UserParamsV3> users;

  const TCreateUsersBody({
     this.timestampMs,
     this.organizationId,
    required  this.users,
  });
  factory TCreateUsersBody.fromJson(Map<String, dynamic> json) {
    final _timestampMs = json['timestampMs'] as String?;
    final _organizationId = json['organizationId'] as String?;
    final _users = (json['users'] as List).map((e) => v1UserParamsV3.fromJson(e as Map<String, dynamic>)).toList();
    return TCreateUsersBody(
      timestampMs: _timestampMs,
      organizationId: _organizationId,
      users: _users,
    );
  }
  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    if (timestampMs != null) {
      _json['timestampMs'] = timestampMs;
    }
    if (organizationId != null) {
      _json['organizationId'] = organizationId;
    }
    _json['users'] = users.map((e) => e.toJson()).toList();
    return _json;
  }
}

class TCreateUsersInput {
  final TCreateUsersBody body;
  const TCreateUsersInput({required this.body});
  factory TCreateUsersInput.fromJson(Map<String, dynamic> json) => TCreateUsersInput(body: TCreateUsersBody.fromJson(json['body'] as Map<String, dynamic>));
  Map<String, dynamic> toJson() => {'body': body.toJson()};
}

class TCreateWalletResponse {
  final v1Activity activity;
  final v1CreateWalletResult? result;
  const TCreateWalletResponse({required this.activity, this.result,});
  factory TCreateWalletResponse.fromJson(Map<String, dynamic> json) {
    return TCreateWalletResponse(
      activity: v1Activity.fromJson(json['activity'] as Map<String, dynamic>),
      result: json.containsKey('result') && json['result'] != null ? v1CreateWalletResult.fromJson(json['result'] as Map<String, dynamic>) : null,
    );
  }
  Map<String, dynamic> toJson() => {
    'activity': activity.toJson(),
    if (result != null) 'result': result!.toJson(),
  };
}

class TCreateWalletBody {
  final String? timestampMs;
  final String? organizationId;
  /// Human-readable name for a Wallet.
  final String walletName;
  /// A list of wallet Accounts. This field, if not needed, should be an empty array in your request body.
  final List<v1WalletAccountParams> accounts;
  /// Length of mnemonic to generate the Wallet seed. Defaults to 12. Accepted values: 12, 15, 18, 21, 24.
  final num? mnemonicLength;

  const TCreateWalletBody({
     this.timestampMs,
     this.organizationId,
    required  this.walletName,
    required  this.accounts,
     this.mnemonicLength,
  });
  factory TCreateWalletBody.fromJson(Map<String, dynamic> json) {
    final _timestampMs = json['timestampMs'] as String?;
    final _organizationId = json['organizationId'] as String?;
    final _walletName = json['walletName'] as String;
    final _accounts = (json['accounts'] as List).map((e) => v1WalletAccountParams.fromJson(e as Map<String, dynamic>)).toList();
    final _mnemonicLength = json['mnemonicLength'] as num?;
    return TCreateWalletBody(
      timestampMs: _timestampMs,
      organizationId: _organizationId,
      walletName: _walletName,
      accounts: _accounts,
      mnemonicLength: _mnemonicLength,
    );
  }
  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    if (timestampMs != null) {
      _json['timestampMs'] = timestampMs;
    }
    if (organizationId != null) {
      _json['organizationId'] = organizationId;
    }
    _json['walletName'] = walletName;
    _json['accounts'] = accounts.map((e) => e.toJson()).toList();
    if (mnemonicLength != null) {
      _json['mnemonicLength'] = mnemonicLength;
    }
    return _json;
  }
}

class TCreateWalletInput {
  final TCreateWalletBody body;
  const TCreateWalletInput({required this.body});
  factory TCreateWalletInput.fromJson(Map<String, dynamic> json) => TCreateWalletInput(body: TCreateWalletBody.fromJson(json['body'] as Map<String, dynamic>));
  Map<String, dynamic> toJson() => {'body': body.toJson()};
}

class TCreateWalletAccountsResponse {
  final v1Activity activity;
  final v1CreateWalletAccountsResult? result;
  const TCreateWalletAccountsResponse({required this.activity, this.result,});
  factory TCreateWalletAccountsResponse.fromJson(Map<String, dynamic> json) {
    return TCreateWalletAccountsResponse(
      activity: v1Activity.fromJson(json['activity'] as Map<String, dynamic>),
      result: json.containsKey('result') && json['result'] != null ? v1CreateWalletAccountsResult.fromJson(json['result'] as Map<String, dynamic>) : null,
    );
  }
  Map<String, dynamic> toJson() => {
    'activity': activity.toJson(),
    if (result != null) 'result': result!.toJson(),
  };
}

class TCreateWalletAccountsBody {
  final String? timestampMs;
  final String? organizationId;
  /// Unique identifier for a given Wallet.
  final String walletId;
  /// A list of wallet Accounts.
  final List<v1WalletAccountParams> accounts;
  /// Indicates if the wallet accounts should be persisted. This is helpful if you'd like to see the addresses of different derivation paths without actually creating the accounts. Defaults to true.
  final bool? persist;

  const TCreateWalletAccountsBody({
     this.timestampMs,
     this.organizationId,
    required  this.walletId,
    required  this.accounts,
     this.persist,
  });
  factory TCreateWalletAccountsBody.fromJson(Map<String, dynamic> json) {
    final _timestampMs = json['timestampMs'] as String?;
    final _organizationId = json['organizationId'] as String?;
    final _walletId = json['walletId'] as String;
    final _accounts = (json['accounts'] as List).map((e) => v1WalletAccountParams.fromJson(e as Map<String, dynamic>)).toList();
    final _persist = json['persist'] as bool?;
    return TCreateWalletAccountsBody(
      timestampMs: _timestampMs,
      organizationId: _organizationId,
      walletId: _walletId,
      accounts: _accounts,
      persist: _persist,
    );
  }
  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    if (timestampMs != null) {
      _json['timestampMs'] = timestampMs;
    }
    if (organizationId != null) {
      _json['organizationId'] = organizationId;
    }
    _json['walletId'] = walletId;
    _json['accounts'] = accounts.map((e) => e.toJson()).toList();
    if (persist != null) {
      _json['persist'] = persist;
    }
    return _json;
  }
}

class TCreateWalletAccountsInput {
  final TCreateWalletAccountsBody body;
  const TCreateWalletAccountsInput({required this.body});
  factory TCreateWalletAccountsInput.fromJson(Map<String, dynamic> json) => TCreateWalletAccountsInput(body: TCreateWalletAccountsBody.fromJson(json['body'] as Map<String, dynamic>));
  Map<String, dynamic> toJson() => {'body': body.toJson()};
}

class TDeleteApiKeysResponse {
  final v1Activity activity;
  final v1DeleteApiKeysResult? result;
  const TDeleteApiKeysResponse({required this.activity, this.result,});
  factory TDeleteApiKeysResponse.fromJson(Map<String, dynamic> json) {
    return TDeleteApiKeysResponse(
      activity: v1Activity.fromJson(json['activity'] as Map<String, dynamic>),
      result: json.containsKey('result') && json['result'] != null ? v1DeleteApiKeysResult.fromJson(json['result'] as Map<String, dynamic>) : null,
    );
  }
  Map<String, dynamic> toJson() => {
    'activity': activity.toJson(),
    if (result != null) 'result': result!.toJson(),
  };
}

class TDeleteApiKeysBody {
  final String? timestampMs;
  final String? organizationId;
  /// Unique identifier for a given User.
  final String userId;
  /// A list of API Key IDs.
  final List<String> apiKeyIds;

  const TDeleteApiKeysBody({
     this.timestampMs,
     this.organizationId,
    required  this.userId,
    required  this.apiKeyIds,
  });
  factory TDeleteApiKeysBody.fromJson(Map<String, dynamic> json) {
    final _timestampMs = json['timestampMs'] as String?;
    final _organizationId = json['organizationId'] as String?;
    final _userId = json['userId'] as String;
    final _apiKeyIds = (json['apiKeyIds'] as List).map((e) => e as String).toList();
    return TDeleteApiKeysBody(
      timestampMs: _timestampMs,
      organizationId: _organizationId,
      userId: _userId,
      apiKeyIds: _apiKeyIds,
    );
  }
  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    if (timestampMs != null) {
      _json['timestampMs'] = timestampMs;
    }
    if (organizationId != null) {
      _json['organizationId'] = organizationId;
    }
    _json['userId'] = userId;
    _json['apiKeyIds'] = apiKeyIds;
    return _json;
  }
}

class TDeleteApiKeysInput {
  final TDeleteApiKeysBody body;
  const TDeleteApiKeysInput({required this.body});
  factory TDeleteApiKeysInput.fromJson(Map<String, dynamic> json) => TDeleteApiKeysInput(body: TDeleteApiKeysBody.fromJson(json['body'] as Map<String, dynamic>));
  Map<String, dynamic> toJson() => {'body': body.toJson()};
}

class TDeleteAuthenticatorsResponse {
  final v1Activity activity;
  final v1DeleteAuthenticatorsResult? result;
  const TDeleteAuthenticatorsResponse({required this.activity, this.result,});
  factory TDeleteAuthenticatorsResponse.fromJson(Map<String, dynamic> json) {
    return TDeleteAuthenticatorsResponse(
      activity: v1Activity.fromJson(json['activity'] as Map<String, dynamic>),
      result: json.containsKey('result') && json['result'] != null ? v1DeleteAuthenticatorsResult.fromJson(json['result'] as Map<String, dynamic>) : null,
    );
  }
  Map<String, dynamic> toJson() => {
    'activity': activity.toJson(),
    if (result != null) 'result': result!.toJson(),
  };
}

class TDeleteAuthenticatorsBody {
  final String? timestampMs;
  final String? organizationId;
  /// Unique identifier for a given User.
  final String userId;
  /// A list of Authenticator IDs.
  final List<String> authenticatorIds;

  const TDeleteAuthenticatorsBody({
     this.timestampMs,
     this.organizationId,
    required  this.userId,
    required  this.authenticatorIds,
  });
  factory TDeleteAuthenticatorsBody.fromJson(Map<String, dynamic> json) {
    final _timestampMs = json['timestampMs'] as String?;
    final _organizationId = json['organizationId'] as String?;
    final _userId = json['userId'] as String;
    final _authenticatorIds = (json['authenticatorIds'] as List).map((e) => e as String).toList();
    return TDeleteAuthenticatorsBody(
      timestampMs: _timestampMs,
      organizationId: _organizationId,
      userId: _userId,
      authenticatorIds: _authenticatorIds,
    );
  }
  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    if (timestampMs != null) {
      _json['timestampMs'] = timestampMs;
    }
    if (organizationId != null) {
      _json['organizationId'] = organizationId;
    }
    _json['userId'] = userId;
    _json['authenticatorIds'] = authenticatorIds;
    return _json;
  }
}

class TDeleteAuthenticatorsInput {
  final TDeleteAuthenticatorsBody body;
  const TDeleteAuthenticatorsInput({required this.body});
  factory TDeleteAuthenticatorsInput.fromJson(Map<String, dynamic> json) => TDeleteAuthenticatorsInput(body: TDeleteAuthenticatorsBody.fromJson(json['body'] as Map<String, dynamic>));
  Map<String, dynamic> toJson() => {'body': body.toJson()};
}

class TDeleteFiatOnRampCredentialResponse {
  final v1Activity activity;
  final v1DeleteFiatOnRampCredentialResult? result;
  const TDeleteFiatOnRampCredentialResponse({required this.activity, this.result,});
  factory TDeleteFiatOnRampCredentialResponse.fromJson(Map<String, dynamic> json) {
    return TDeleteFiatOnRampCredentialResponse(
      activity: v1Activity.fromJson(json['activity'] as Map<String, dynamic>),
      result: json.containsKey('result') && json['result'] != null ? v1DeleteFiatOnRampCredentialResult.fromJson(json['result'] as Map<String, dynamic>) : null,
    );
  }
  Map<String, dynamic> toJson() => {
    'activity': activity.toJson(),
    if (result != null) 'result': result!.toJson(),
  };
}

class TDeleteFiatOnRampCredentialBody {
  final String? timestampMs;
  final String? organizationId;
  /// The ID of the fiat on-ramp credential to delete
  final String fiatOnrampCredentialId;

  const TDeleteFiatOnRampCredentialBody({
     this.timestampMs,
     this.organizationId,
    required  this.fiatOnrampCredentialId,
  });
  factory TDeleteFiatOnRampCredentialBody.fromJson(Map<String, dynamic> json) {
    final _timestampMs = json['timestampMs'] as String?;
    final _organizationId = json['organizationId'] as String?;
    final _fiatOnrampCredentialId = json['fiatOnrampCredentialId'] as String;
    return TDeleteFiatOnRampCredentialBody(
      timestampMs: _timestampMs,
      organizationId: _organizationId,
      fiatOnrampCredentialId: _fiatOnrampCredentialId,
    );
  }
  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    if (timestampMs != null) {
      _json['timestampMs'] = timestampMs;
    }
    if (organizationId != null) {
      _json['organizationId'] = organizationId;
    }
    _json['fiatOnrampCredentialId'] = fiatOnrampCredentialId;
    return _json;
  }
}

class TDeleteFiatOnRampCredentialInput {
  final TDeleteFiatOnRampCredentialBody body;
  const TDeleteFiatOnRampCredentialInput({required this.body});
  factory TDeleteFiatOnRampCredentialInput.fromJson(Map<String, dynamic> json) => TDeleteFiatOnRampCredentialInput(body: TDeleteFiatOnRampCredentialBody.fromJson(json['body'] as Map<String, dynamic>));
  Map<String, dynamic> toJson() => {'body': body.toJson()};
}

class TDeleteInvitationResponse {
  final v1Activity activity;
  final v1DeleteInvitationResult? result;
  const TDeleteInvitationResponse({required this.activity, this.result,});
  factory TDeleteInvitationResponse.fromJson(Map<String, dynamic> json) {
    return TDeleteInvitationResponse(
      activity: v1Activity.fromJson(json['activity'] as Map<String, dynamic>),
      result: json.containsKey('result') && json['result'] != null ? v1DeleteInvitationResult.fromJson(json['result'] as Map<String, dynamic>) : null,
    );
  }
  Map<String, dynamic> toJson() => {
    'activity': activity.toJson(),
    if (result != null) 'result': result!.toJson(),
  };
}

class TDeleteInvitationBody {
  final String? timestampMs;
  final String? organizationId;
  /// Unique identifier for a given Invitation object.
  final String invitationId;

  const TDeleteInvitationBody({
     this.timestampMs,
     this.organizationId,
    required  this.invitationId,
  });
  factory TDeleteInvitationBody.fromJson(Map<String, dynamic> json) {
    final _timestampMs = json['timestampMs'] as String?;
    final _organizationId = json['organizationId'] as String?;
    final _invitationId = json['invitationId'] as String;
    return TDeleteInvitationBody(
      timestampMs: _timestampMs,
      organizationId: _organizationId,
      invitationId: _invitationId,
    );
  }
  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    if (timestampMs != null) {
      _json['timestampMs'] = timestampMs;
    }
    if (organizationId != null) {
      _json['organizationId'] = organizationId;
    }
    _json['invitationId'] = invitationId;
    return _json;
  }
}

class TDeleteInvitationInput {
  final TDeleteInvitationBody body;
  const TDeleteInvitationInput({required this.body});
  factory TDeleteInvitationInput.fromJson(Map<String, dynamic> json) => TDeleteInvitationInput(body: TDeleteInvitationBody.fromJson(json['body'] as Map<String, dynamic>));
  Map<String, dynamic> toJson() => {'body': body.toJson()};
}

class TDeleteOauth2CredentialResponse {
  final v1Activity activity;
  final v1DeleteOauth2CredentialResult? result;
  const TDeleteOauth2CredentialResponse({required this.activity, this.result,});
  factory TDeleteOauth2CredentialResponse.fromJson(Map<String, dynamic> json) {
    return TDeleteOauth2CredentialResponse(
      activity: v1Activity.fromJson(json['activity'] as Map<String, dynamic>),
      result: json.containsKey('result') && json['result'] != null ? v1DeleteOauth2CredentialResult.fromJson(json['result'] as Map<String, dynamic>) : null,
    );
  }
  Map<String, dynamic> toJson() => {
    'activity': activity.toJson(),
    if (result != null) 'result': result!.toJson(),
  };
}

class TDeleteOauth2CredentialBody {
  final String? timestampMs;
  final String? organizationId;
  /// The ID of the OAuth 2.0 credential to delete
  final String oauth2CredentialId;

  const TDeleteOauth2CredentialBody({
     this.timestampMs,
     this.organizationId,
    required  this.oauth2CredentialId,
  });
  factory TDeleteOauth2CredentialBody.fromJson(Map<String, dynamic> json) {
    final _timestampMs = json['timestampMs'] as String?;
    final _organizationId = json['organizationId'] as String?;
    final _oauth2CredentialId = json['oauth2CredentialId'] as String;
    return TDeleteOauth2CredentialBody(
      timestampMs: _timestampMs,
      organizationId: _organizationId,
      oauth2CredentialId: _oauth2CredentialId,
    );
  }
  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    if (timestampMs != null) {
      _json['timestampMs'] = timestampMs;
    }
    if (organizationId != null) {
      _json['organizationId'] = organizationId;
    }
    _json['oauth2CredentialId'] = oauth2CredentialId;
    return _json;
  }
}

class TDeleteOauth2CredentialInput {
  final TDeleteOauth2CredentialBody body;
  const TDeleteOauth2CredentialInput({required this.body});
  factory TDeleteOauth2CredentialInput.fromJson(Map<String, dynamic> json) => TDeleteOauth2CredentialInput(body: TDeleteOauth2CredentialBody.fromJson(json['body'] as Map<String, dynamic>));
  Map<String, dynamic> toJson() => {'body': body.toJson()};
}

class TDeleteOauthProvidersResponse {
  final v1Activity activity;
  final v1DeleteOauthProvidersResult? result;
  const TDeleteOauthProvidersResponse({required this.activity, this.result,});
  factory TDeleteOauthProvidersResponse.fromJson(Map<String, dynamic> json) {
    return TDeleteOauthProvidersResponse(
      activity: v1Activity.fromJson(json['activity'] as Map<String, dynamic>),
      result: json.containsKey('result') && json['result'] != null ? v1DeleteOauthProvidersResult.fromJson(json['result'] as Map<String, dynamic>) : null,
    );
  }
  Map<String, dynamic> toJson() => {
    'activity': activity.toJson(),
    if (result != null) 'result': result!.toJson(),
  };
}

class TDeleteOauthProvidersBody {
  final String? timestampMs;
  final String? organizationId;
  /// The ID of the User to remove an Oauth provider from
  final String userId;
  /// Unique identifier for a given Provider.
  final List<String> providerIds;

  const TDeleteOauthProvidersBody({
     this.timestampMs,
     this.organizationId,
    required  this.userId,
    required  this.providerIds,
  });
  factory TDeleteOauthProvidersBody.fromJson(Map<String, dynamic> json) {
    final _timestampMs = json['timestampMs'] as String?;
    final _organizationId = json['organizationId'] as String?;
    final _userId = json['userId'] as String;
    final _providerIds = (json['providerIds'] as List).map((e) => e as String).toList();
    return TDeleteOauthProvidersBody(
      timestampMs: _timestampMs,
      organizationId: _organizationId,
      userId: _userId,
      providerIds: _providerIds,
    );
  }
  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    if (timestampMs != null) {
      _json['timestampMs'] = timestampMs;
    }
    if (organizationId != null) {
      _json['organizationId'] = organizationId;
    }
    _json['userId'] = userId;
    _json['providerIds'] = providerIds;
    return _json;
  }
}

class TDeleteOauthProvidersInput {
  final TDeleteOauthProvidersBody body;
  const TDeleteOauthProvidersInput({required this.body});
  factory TDeleteOauthProvidersInput.fromJson(Map<String, dynamic> json) => TDeleteOauthProvidersInput(body: TDeleteOauthProvidersBody.fromJson(json['body'] as Map<String, dynamic>));
  Map<String, dynamic> toJson() => {'body': body.toJson()};
}

class TDeletePoliciesResponse {
  final v1Activity activity;
  final v1DeletePoliciesResult? result;
  const TDeletePoliciesResponse({required this.activity, this.result,});
  factory TDeletePoliciesResponse.fromJson(Map<String, dynamic> json) {
    return TDeletePoliciesResponse(
      activity: v1Activity.fromJson(json['activity'] as Map<String, dynamic>),
      result: json.containsKey('result') && json['result'] != null ? v1DeletePoliciesResult.fromJson(json['result'] as Map<String, dynamic>) : null,
    );
  }
  Map<String, dynamic> toJson() => {
    'activity': activity.toJson(),
    if (result != null) 'result': result!.toJson(),
  };
}

class TDeletePoliciesBody {
  final String? timestampMs;
  final String? organizationId;
  /// List of unique identifiers for policies within an organization
  final List<String> policyIds;

  const TDeletePoliciesBody({
     this.timestampMs,
     this.organizationId,
    required  this.policyIds,
  });
  factory TDeletePoliciesBody.fromJson(Map<String, dynamic> json) {
    final _timestampMs = json['timestampMs'] as String?;
    final _organizationId = json['organizationId'] as String?;
    final _policyIds = (json['policyIds'] as List).map((e) => e as String).toList();
    return TDeletePoliciesBody(
      timestampMs: _timestampMs,
      organizationId: _organizationId,
      policyIds: _policyIds,
    );
  }
  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    if (timestampMs != null) {
      _json['timestampMs'] = timestampMs;
    }
    if (organizationId != null) {
      _json['organizationId'] = organizationId;
    }
    _json['policyIds'] = policyIds;
    return _json;
  }
}

class TDeletePoliciesInput {
  final TDeletePoliciesBody body;
  const TDeletePoliciesInput({required this.body});
  factory TDeletePoliciesInput.fromJson(Map<String, dynamic> json) => TDeletePoliciesInput(body: TDeletePoliciesBody.fromJson(json['body'] as Map<String, dynamic>));
  Map<String, dynamic> toJson() => {'body': body.toJson()};
}

class TDeletePolicyResponse {
  final v1Activity activity;
  final v1DeletePolicyResult? result;
  const TDeletePolicyResponse({required this.activity, this.result,});
  factory TDeletePolicyResponse.fromJson(Map<String, dynamic> json) {
    return TDeletePolicyResponse(
      activity: v1Activity.fromJson(json['activity'] as Map<String, dynamic>),
      result: json.containsKey('result') && json['result'] != null ? v1DeletePolicyResult.fromJson(json['result'] as Map<String, dynamic>) : null,
    );
  }
  Map<String, dynamic> toJson() => {
    'activity': activity.toJson(),
    if (result != null) 'result': result!.toJson(),
  };
}

class TDeletePolicyBody {
  final String? timestampMs;
  final String? organizationId;
  /// Unique identifier for a given Policy.
  final String policyId;

  const TDeletePolicyBody({
     this.timestampMs,
     this.organizationId,
    required  this.policyId,
  });
  factory TDeletePolicyBody.fromJson(Map<String, dynamic> json) {
    final _timestampMs = json['timestampMs'] as String?;
    final _organizationId = json['organizationId'] as String?;
    final _policyId = json['policyId'] as String;
    return TDeletePolicyBody(
      timestampMs: _timestampMs,
      organizationId: _organizationId,
      policyId: _policyId,
    );
  }
  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    if (timestampMs != null) {
      _json['timestampMs'] = timestampMs;
    }
    if (organizationId != null) {
      _json['organizationId'] = organizationId;
    }
    _json['policyId'] = policyId;
    return _json;
  }
}

class TDeletePolicyInput {
  final TDeletePolicyBody body;
  const TDeletePolicyInput({required this.body});
  factory TDeletePolicyInput.fromJson(Map<String, dynamic> json) => TDeletePolicyInput(body: TDeletePolicyBody.fromJson(json['body'] as Map<String, dynamic>));
  Map<String, dynamic> toJson() => {'body': body.toJson()};
}

class TDeletePrivateKeyTagsResponse {
  final v1Activity activity;
  final v1DeletePrivateKeyTagsResult? result;
  const TDeletePrivateKeyTagsResponse({required this.activity, this.result,});
  factory TDeletePrivateKeyTagsResponse.fromJson(Map<String, dynamic> json) {
    return TDeletePrivateKeyTagsResponse(
      activity: v1Activity.fromJson(json['activity'] as Map<String, dynamic>),
      result: json.containsKey('result') && json['result'] != null ? v1DeletePrivateKeyTagsResult.fromJson(json['result'] as Map<String, dynamic>) : null,
    );
  }
  Map<String, dynamic> toJson() => {
    'activity': activity.toJson(),
    if (result != null) 'result': result!.toJson(),
  };
}

class TDeletePrivateKeyTagsBody {
  final String? timestampMs;
  final String? organizationId;
  /// A list of Private Key Tag IDs.
  final List<String> privateKeyTagIds;

  const TDeletePrivateKeyTagsBody({
     this.timestampMs,
     this.organizationId,
    required  this.privateKeyTagIds,
  });
  factory TDeletePrivateKeyTagsBody.fromJson(Map<String, dynamic> json) {
    final _timestampMs = json['timestampMs'] as String?;
    final _organizationId = json['organizationId'] as String?;
    final _privateKeyTagIds = (json['privateKeyTagIds'] as List).map((e) => e as String).toList();
    return TDeletePrivateKeyTagsBody(
      timestampMs: _timestampMs,
      organizationId: _organizationId,
      privateKeyTagIds: _privateKeyTagIds,
    );
  }
  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    if (timestampMs != null) {
      _json['timestampMs'] = timestampMs;
    }
    if (organizationId != null) {
      _json['organizationId'] = organizationId;
    }
    _json['privateKeyTagIds'] = privateKeyTagIds;
    return _json;
  }
}

class TDeletePrivateKeyTagsInput {
  final TDeletePrivateKeyTagsBody body;
  const TDeletePrivateKeyTagsInput({required this.body});
  factory TDeletePrivateKeyTagsInput.fromJson(Map<String, dynamic> json) => TDeletePrivateKeyTagsInput(body: TDeletePrivateKeyTagsBody.fromJson(json['body'] as Map<String, dynamic>));
  Map<String, dynamic> toJson() => {'body': body.toJson()};
}

class TDeletePrivateKeysResponse {
  final v1Activity activity;
  final v1DeletePrivateKeysResult? result;
  const TDeletePrivateKeysResponse({required this.activity, this.result,});
  factory TDeletePrivateKeysResponse.fromJson(Map<String, dynamic> json) {
    return TDeletePrivateKeysResponse(
      activity: v1Activity.fromJson(json['activity'] as Map<String, dynamic>),
      result: json.containsKey('result') && json['result'] != null ? v1DeletePrivateKeysResult.fromJson(json['result'] as Map<String, dynamic>) : null,
    );
  }
  Map<String, dynamic> toJson() => {
    'activity': activity.toJson(),
    if (result != null) 'result': result!.toJson(),
  };
}

class TDeletePrivateKeysBody {
  final String? timestampMs;
  final String? organizationId;
  /// List of unique identifiers for private keys within an organization
  final List<String> privateKeyIds;
  /// Optional parameter for deleting the private keys, even if any have not been previously exported. If they have been exported, this field is ignored.
  final bool? deleteWithoutExport;

  const TDeletePrivateKeysBody({
     this.timestampMs,
     this.organizationId,
    required  this.privateKeyIds,
     this.deleteWithoutExport,
  });
  factory TDeletePrivateKeysBody.fromJson(Map<String, dynamic> json) {
    final _timestampMs = json['timestampMs'] as String?;
    final _organizationId = json['organizationId'] as String?;
    final _privateKeyIds = (json['privateKeyIds'] as List).map((e) => e as String).toList();
    final _deleteWithoutExport = json['deleteWithoutExport'] as bool?;
    return TDeletePrivateKeysBody(
      timestampMs: _timestampMs,
      organizationId: _organizationId,
      privateKeyIds: _privateKeyIds,
      deleteWithoutExport: _deleteWithoutExport,
    );
  }
  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    if (timestampMs != null) {
      _json['timestampMs'] = timestampMs;
    }
    if (organizationId != null) {
      _json['organizationId'] = organizationId;
    }
    _json['privateKeyIds'] = privateKeyIds;
    if (deleteWithoutExport != null) {
      _json['deleteWithoutExport'] = deleteWithoutExport;
    }
    return _json;
  }
}

class TDeletePrivateKeysInput {
  final TDeletePrivateKeysBody body;
  const TDeletePrivateKeysInput({required this.body});
  factory TDeletePrivateKeysInput.fromJson(Map<String, dynamic> json) => TDeletePrivateKeysInput(body: TDeletePrivateKeysBody.fromJson(json['body'] as Map<String, dynamic>));
  Map<String, dynamic> toJson() => {'body': body.toJson()};
}

class TDeleteSmartContractInterfaceResponse {
  final v1Activity activity;
  final v1DeleteSmartContractInterfaceResult? result;
  const TDeleteSmartContractInterfaceResponse({required this.activity, this.result,});
  factory TDeleteSmartContractInterfaceResponse.fromJson(Map<String, dynamic> json) {
    return TDeleteSmartContractInterfaceResponse(
      activity: v1Activity.fromJson(json['activity'] as Map<String, dynamic>),
      result: json.containsKey('result') && json['result'] != null ? v1DeleteSmartContractInterfaceResult.fromJson(json['result'] as Map<String, dynamic>) : null,
    );
  }
  Map<String, dynamic> toJson() => {
    'activity': activity.toJson(),
    if (result != null) 'result': result!.toJson(),
  };
}

class TDeleteSmartContractInterfaceBody {
  final String? timestampMs;
  final String? organizationId;
  /// The ID of a Smart Contract Interface intended for deletion.
  final String smartContractInterfaceId;

  const TDeleteSmartContractInterfaceBody({
     this.timestampMs,
     this.organizationId,
    required  this.smartContractInterfaceId,
  });
  factory TDeleteSmartContractInterfaceBody.fromJson(Map<String, dynamic> json) {
    final _timestampMs = json['timestampMs'] as String?;
    final _organizationId = json['organizationId'] as String?;
    final _smartContractInterfaceId = json['smartContractInterfaceId'] as String;
    return TDeleteSmartContractInterfaceBody(
      timestampMs: _timestampMs,
      organizationId: _organizationId,
      smartContractInterfaceId: _smartContractInterfaceId,
    );
  }
  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    if (timestampMs != null) {
      _json['timestampMs'] = timestampMs;
    }
    if (organizationId != null) {
      _json['organizationId'] = organizationId;
    }
    _json['smartContractInterfaceId'] = smartContractInterfaceId;
    return _json;
  }
}

class TDeleteSmartContractInterfaceInput {
  final TDeleteSmartContractInterfaceBody body;
  const TDeleteSmartContractInterfaceInput({required this.body});
  factory TDeleteSmartContractInterfaceInput.fromJson(Map<String, dynamic> json) => TDeleteSmartContractInterfaceInput(body: TDeleteSmartContractInterfaceBody.fromJson(json['body'] as Map<String, dynamic>));
  Map<String, dynamic> toJson() => {'body': body.toJson()};
}

class TDeleteSubOrganizationResponse {
  final v1Activity activity;
  final v1DeleteSubOrganizationResult? result;
  const TDeleteSubOrganizationResponse({required this.activity, this.result,});
  factory TDeleteSubOrganizationResponse.fromJson(Map<String, dynamic> json) {
    return TDeleteSubOrganizationResponse(
      activity: v1Activity.fromJson(json['activity'] as Map<String, dynamic>),
      result: json.containsKey('result') && json['result'] != null ? v1DeleteSubOrganizationResult.fromJson(json['result'] as Map<String, dynamic>) : null,
    );
  }
  Map<String, dynamic> toJson() => {
    'activity': activity.toJson(),
    if (result != null) 'result': result!.toJson(),
  };
}

class TDeleteSubOrganizationBody {
  final String? timestampMs;
  final String? organizationId;
  /// Sub-organization deletion, by default, requires associated wallets and private keys to be exported for security reasons. Set this boolean to true to force sub-organization deletion even if some wallets or private keys within it have not been exported yet. Default: false.
  final bool? deleteWithoutExport;

  const TDeleteSubOrganizationBody({
     this.timestampMs,
     this.organizationId,
     this.deleteWithoutExport,
  });
  factory TDeleteSubOrganizationBody.fromJson(Map<String, dynamic> json) {
    final _timestampMs = json['timestampMs'] as String?;
    final _organizationId = json['organizationId'] as String?;
    final _deleteWithoutExport = json['deleteWithoutExport'] as bool?;
    return TDeleteSubOrganizationBody(
      timestampMs: _timestampMs,
      organizationId: _organizationId,
      deleteWithoutExport: _deleteWithoutExport,
    );
  }
  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    if (timestampMs != null) {
      _json['timestampMs'] = timestampMs;
    }
    if (organizationId != null) {
      _json['organizationId'] = organizationId;
    }
    if (deleteWithoutExport != null) {
      _json['deleteWithoutExport'] = deleteWithoutExport;
    }
    return _json;
  }
}

class TDeleteSubOrganizationInput {
  final TDeleteSubOrganizationBody body;
  const TDeleteSubOrganizationInput({required this.body});
  factory TDeleteSubOrganizationInput.fromJson(Map<String, dynamic> json) => TDeleteSubOrganizationInput(body: TDeleteSubOrganizationBody.fromJson(json['body'] as Map<String, dynamic>));
  Map<String, dynamic> toJson() => {'body': body.toJson()};
}

class TDeleteUserTagsResponse {
  final v1Activity activity;
  final v1DeleteUserTagsResult? result;
  const TDeleteUserTagsResponse({required this.activity, this.result,});
  factory TDeleteUserTagsResponse.fromJson(Map<String, dynamic> json) {
    return TDeleteUserTagsResponse(
      activity: v1Activity.fromJson(json['activity'] as Map<String, dynamic>),
      result: json.containsKey('result') && json['result'] != null ? v1DeleteUserTagsResult.fromJson(json['result'] as Map<String, dynamic>) : null,
    );
  }
  Map<String, dynamic> toJson() => {
    'activity': activity.toJson(),
    if (result != null) 'result': result!.toJson(),
  };
}

class TDeleteUserTagsBody {
  final String? timestampMs;
  final String? organizationId;
  /// A list of User Tag IDs.
  final List<String> userTagIds;

  const TDeleteUserTagsBody({
     this.timestampMs,
     this.organizationId,
    required  this.userTagIds,
  });
  factory TDeleteUserTagsBody.fromJson(Map<String, dynamic> json) {
    final _timestampMs = json['timestampMs'] as String?;
    final _organizationId = json['organizationId'] as String?;
    final _userTagIds = (json['userTagIds'] as List).map((e) => e as String).toList();
    return TDeleteUserTagsBody(
      timestampMs: _timestampMs,
      organizationId: _organizationId,
      userTagIds: _userTagIds,
    );
  }
  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    if (timestampMs != null) {
      _json['timestampMs'] = timestampMs;
    }
    if (organizationId != null) {
      _json['organizationId'] = organizationId;
    }
    _json['userTagIds'] = userTagIds;
    return _json;
  }
}

class TDeleteUserTagsInput {
  final TDeleteUserTagsBody body;
  const TDeleteUserTagsInput({required this.body});
  factory TDeleteUserTagsInput.fromJson(Map<String, dynamic> json) => TDeleteUserTagsInput(body: TDeleteUserTagsBody.fromJson(json['body'] as Map<String, dynamic>));
  Map<String, dynamic> toJson() => {'body': body.toJson()};
}

class TDeleteUsersResponse {
  final v1Activity activity;
  final v1DeleteUsersResult? result;
  const TDeleteUsersResponse({required this.activity, this.result,});
  factory TDeleteUsersResponse.fromJson(Map<String, dynamic> json) {
    return TDeleteUsersResponse(
      activity: v1Activity.fromJson(json['activity'] as Map<String, dynamic>),
      result: json.containsKey('result') && json['result'] != null ? v1DeleteUsersResult.fromJson(json['result'] as Map<String, dynamic>) : null,
    );
  }
  Map<String, dynamic> toJson() => {
    'activity': activity.toJson(),
    if (result != null) 'result': result!.toJson(),
  };
}

class TDeleteUsersBody {
  final String? timestampMs;
  final String? organizationId;
  /// A list of User IDs.
  final List<String> userIds;

  const TDeleteUsersBody({
     this.timestampMs,
     this.organizationId,
    required  this.userIds,
  });
  factory TDeleteUsersBody.fromJson(Map<String, dynamic> json) {
    final _timestampMs = json['timestampMs'] as String?;
    final _organizationId = json['organizationId'] as String?;
    final _userIds = (json['userIds'] as List).map((e) => e as String).toList();
    return TDeleteUsersBody(
      timestampMs: _timestampMs,
      organizationId: _organizationId,
      userIds: _userIds,
    );
  }
  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    if (timestampMs != null) {
      _json['timestampMs'] = timestampMs;
    }
    if (organizationId != null) {
      _json['organizationId'] = organizationId;
    }
    _json['userIds'] = userIds;
    return _json;
  }
}

class TDeleteUsersInput {
  final TDeleteUsersBody body;
  const TDeleteUsersInput({required this.body});
  factory TDeleteUsersInput.fromJson(Map<String, dynamic> json) => TDeleteUsersInput(body: TDeleteUsersBody.fromJson(json['body'] as Map<String, dynamic>));
  Map<String, dynamic> toJson() => {'body': body.toJson()};
}

class TDeleteWalletAccountsResponse {
  final v1Activity activity;
  final v1DeleteWalletAccountsResult? result;
  const TDeleteWalletAccountsResponse({required this.activity, this.result,});
  factory TDeleteWalletAccountsResponse.fromJson(Map<String, dynamic> json) {
    return TDeleteWalletAccountsResponse(
      activity: v1Activity.fromJson(json['activity'] as Map<String, dynamic>),
      result: json.containsKey('result') && json['result'] != null ? v1DeleteWalletAccountsResult.fromJson(json['result'] as Map<String, dynamic>) : null,
    );
  }
  Map<String, dynamic> toJson() => {
    'activity': activity.toJson(),
    if (result != null) 'result': result!.toJson(),
  };
}

class TDeleteWalletAccountsBody {
  final String? timestampMs;
  final String? organizationId;
  /// List of unique identifiers for wallet accounts within an organization
  final List<String> walletAccountIds;
  /// Optional parameter for deleting the wallet accounts, even if any have not been previously exported. If they have been exported, this field is ignored.
  final bool? deleteWithoutExport;

  const TDeleteWalletAccountsBody({
     this.timestampMs,
     this.organizationId,
    required  this.walletAccountIds,
     this.deleteWithoutExport,
  });
  factory TDeleteWalletAccountsBody.fromJson(Map<String, dynamic> json) {
    final _timestampMs = json['timestampMs'] as String?;
    final _organizationId = json['organizationId'] as String?;
    final _walletAccountIds = (json['walletAccountIds'] as List).map((e) => e as String).toList();
    final _deleteWithoutExport = json['deleteWithoutExport'] as bool?;
    return TDeleteWalletAccountsBody(
      timestampMs: _timestampMs,
      organizationId: _organizationId,
      walletAccountIds: _walletAccountIds,
      deleteWithoutExport: _deleteWithoutExport,
    );
  }
  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    if (timestampMs != null) {
      _json['timestampMs'] = timestampMs;
    }
    if (organizationId != null) {
      _json['organizationId'] = organizationId;
    }
    _json['walletAccountIds'] = walletAccountIds;
    if (deleteWithoutExport != null) {
      _json['deleteWithoutExport'] = deleteWithoutExport;
    }
    return _json;
  }
}

class TDeleteWalletAccountsInput {
  final TDeleteWalletAccountsBody body;
  const TDeleteWalletAccountsInput({required this.body});
  factory TDeleteWalletAccountsInput.fromJson(Map<String, dynamic> json) => TDeleteWalletAccountsInput(body: TDeleteWalletAccountsBody.fromJson(json['body'] as Map<String, dynamic>));
  Map<String, dynamic> toJson() => {'body': body.toJson()};
}

class TDeleteWalletsResponse {
  final v1Activity activity;
  final v1DeleteWalletsResult? result;
  const TDeleteWalletsResponse({required this.activity, this.result,});
  factory TDeleteWalletsResponse.fromJson(Map<String, dynamic> json) {
    return TDeleteWalletsResponse(
      activity: v1Activity.fromJson(json['activity'] as Map<String, dynamic>),
      result: json.containsKey('result') && json['result'] != null ? v1DeleteWalletsResult.fromJson(json['result'] as Map<String, dynamic>) : null,
    );
  }
  Map<String, dynamic> toJson() => {
    'activity': activity.toJson(),
    if (result != null) 'result': result!.toJson(),
  };
}

class TDeleteWalletsBody {
  final String? timestampMs;
  final String? organizationId;
  /// List of unique identifiers for wallets within an organization
  final List<String> walletIds;
  /// Optional parameter for deleting the wallets, even if any have not been previously exported. If they have been exported, this field is ignored.
  final bool? deleteWithoutExport;

  const TDeleteWalletsBody({
     this.timestampMs,
     this.organizationId,
    required  this.walletIds,
     this.deleteWithoutExport,
  });
  factory TDeleteWalletsBody.fromJson(Map<String, dynamic> json) {
    final _timestampMs = json['timestampMs'] as String?;
    final _organizationId = json['organizationId'] as String?;
    final _walletIds = (json['walletIds'] as List).map((e) => e as String).toList();
    final _deleteWithoutExport = json['deleteWithoutExport'] as bool?;
    return TDeleteWalletsBody(
      timestampMs: _timestampMs,
      organizationId: _organizationId,
      walletIds: _walletIds,
      deleteWithoutExport: _deleteWithoutExport,
    );
  }
  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    if (timestampMs != null) {
      _json['timestampMs'] = timestampMs;
    }
    if (organizationId != null) {
      _json['organizationId'] = organizationId;
    }
    _json['walletIds'] = walletIds;
    if (deleteWithoutExport != null) {
      _json['deleteWithoutExport'] = deleteWithoutExport;
    }
    return _json;
  }
}

class TDeleteWalletsInput {
  final TDeleteWalletsBody body;
  const TDeleteWalletsInput({required this.body});
  factory TDeleteWalletsInput.fromJson(Map<String, dynamic> json) => TDeleteWalletsInput(body: TDeleteWalletsBody.fromJson(json['body'] as Map<String, dynamic>));
  Map<String, dynamic> toJson() => {'body': body.toJson()};
}

class TEmailAuthResponse {
  final v1Activity activity;
  final v1EmailAuthResult? result;
  const TEmailAuthResponse({required this.activity, this.result,});
  factory TEmailAuthResponse.fromJson(Map<String, dynamic> json) {
    return TEmailAuthResponse(
      activity: v1Activity.fromJson(json['activity'] as Map<String, dynamic>),
      result: json.containsKey('result') && json['result'] != null ? v1EmailAuthResult.fromJson(json['result'] as Map<String, dynamic>) : null,
    );
  }
  Map<String, dynamic> toJson() => {
    'activity': activity.toJson(),
    if (result != null) 'result': result!.toJson(),
  };
}

class TEmailAuthBody {
  final String? timestampMs;
  final String? organizationId;
  /// Email of the authenticating user.
  final String email;
  /// Client-side public key generated by the user, to which the email auth bundle (credentials) will be encrypted.
  final String targetPublicKey;
  /// Optional human-readable name for an API Key. If none provided, default to Email Auth - <Timestamp>
  final String? apiKeyName;
  /// Expiration window (in seconds) indicating how long the API key is valid for. If not provided, a default of 15 minutes will be used.
  final String? expirationSeconds;
  /// Optional parameters for customizing emails. If not provided, the default email will be used.
  final v1EmailCustomizationParams? emailCustomization;
  /// Invalidate all other previously generated Email Auth API keys
  final bool? invalidateExisting;
  /// Optional custom email address from which to send the email
  final String? sendFromEmailAddress;
  /// Optional custom sender name for use with sendFromEmailAddress; if left empty, will default to 'Notifications'
  final String? sendFromEmailSenderName;
  /// Optional custom email address to use as reply-to
  final String? replyToEmailAddress;

  const TEmailAuthBody({
     this.timestampMs,
     this.organizationId,
    required  this.email,
    required  this.targetPublicKey,
     this.apiKeyName,
     this.expirationSeconds,
     this.emailCustomization,
     this.invalidateExisting,
     this.sendFromEmailAddress,
     this.sendFromEmailSenderName,
     this.replyToEmailAddress,
  });
  factory TEmailAuthBody.fromJson(Map<String, dynamic> json) {
    final _timestampMs = json['timestampMs'] as String?;
    final _organizationId = json['organizationId'] as String?;
    final _email = json['email'] as String;
    final _targetPublicKey = json['targetPublicKey'] as String;
    final _apiKeyName = json['apiKeyName'] as String?;
    final _expirationSeconds = json['expirationSeconds'] as String?;
    final _emailCustomization = json['emailCustomization'] == null ? null : v1EmailCustomizationParams.fromJson(json['emailCustomization'] as Map<String, dynamic>);
    final _invalidateExisting = json['invalidateExisting'] as bool?;
    final _sendFromEmailAddress = json['sendFromEmailAddress'] as String?;
    final _sendFromEmailSenderName = json['sendFromEmailSenderName'] as String?;
    final _replyToEmailAddress = json['replyToEmailAddress'] as String?;
    return TEmailAuthBody(
      timestampMs: _timestampMs,
      organizationId: _organizationId,
      email: _email,
      targetPublicKey: _targetPublicKey,
      apiKeyName: _apiKeyName,
      expirationSeconds: _expirationSeconds,
      emailCustomization: _emailCustomization,
      invalidateExisting: _invalidateExisting,
      sendFromEmailAddress: _sendFromEmailAddress,
      sendFromEmailSenderName: _sendFromEmailSenderName,
      replyToEmailAddress: _replyToEmailAddress,
    );
  }
  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    if (timestampMs != null) {
      _json['timestampMs'] = timestampMs;
    }
    if (organizationId != null) {
      _json['organizationId'] = organizationId;
    }
    _json['email'] = email;
    _json['targetPublicKey'] = targetPublicKey;
    if (apiKeyName != null) {
      _json['apiKeyName'] = apiKeyName;
    }
    if (expirationSeconds != null) {
      _json['expirationSeconds'] = expirationSeconds;
    }
    if (emailCustomization != null) {
      _json['emailCustomization'] = emailCustomization?.toJson();
    }
    if (invalidateExisting != null) {
      _json['invalidateExisting'] = invalidateExisting;
    }
    if (sendFromEmailAddress != null) {
      _json['sendFromEmailAddress'] = sendFromEmailAddress;
    }
    if (sendFromEmailSenderName != null) {
      _json['sendFromEmailSenderName'] = sendFromEmailSenderName;
    }
    if (replyToEmailAddress != null) {
      _json['replyToEmailAddress'] = replyToEmailAddress;
    }
    return _json;
  }
}

class TEmailAuthInput {
  final TEmailAuthBody body;
  const TEmailAuthInput({required this.body});
  factory TEmailAuthInput.fromJson(Map<String, dynamic> json) => TEmailAuthInput(body: TEmailAuthBody.fromJson(json['body'] as Map<String, dynamic>));
  Map<String, dynamic> toJson() => {'body': body.toJson()};
}

class TEthSendRawTransactionResponse {
  final v1Activity activity;
  final v1EthSendRawTransactionResult? result;
  const TEthSendRawTransactionResponse({required this.activity, this.result,});
  factory TEthSendRawTransactionResponse.fromJson(Map<String, dynamic> json) {
    return TEthSendRawTransactionResponse(
      activity: v1Activity.fromJson(json['activity'] as Map<String, dynamic>),
      result: json.containsKey('result') && json['result'] != null ? v1EthSendRawTransactionResult.fromJson(json['result'] as Map<String, dynamic>) : null,
    );
  }
  Map<String, dynamic> toJson() => {
    'activity': activity.toJson(),
    if (result != null) 'result': result!.toJson(),
  };
}

class TEthSendRawTransactionBody {
  final String? timestampMs;
  final String? organizationId;
  /// The raw, signed transaction to be sent.
  final String signedTransaction;
  /// CAIP-2 chain ID (e.g., 'eip155:1' for Ethereum mainnet).
  final String caip2;

  const TEthSendRawTransactionBody({
     this.timestampMs,
     this.organizationId,
    required  this.signedTransaction,
    required  this.caip2,
  });
  factory TEthSendRawTransactionBody.fromJson(Map<String, dynamic> json) {
    final _timestampMs = json['timestampMs'] as String?;
    final _organizationId = json['organizationId'] as String?;
    final _signedTransaction = json['signedTransaction'] as String;
    final _caip2 = json['caip2'] as String;
    return TEthSendRawTransactionBody(
      timestampMs: _timestampMs,
      organizationId: _organizationId,
      signedTransaction: _signedTransaction,
      caip2: _caip2,
    );
  }
  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    if (timestampMs != null) {
      _json['timestampMs'] = timestampMs;
    }
    if (organizationId != null) {
      _json['organizationId'] = organizationId;
    }
    _json['signedTransaction'] = signedTransaction;
    _json['caip2'] = caip2;
    return _json;
  }
}

class TEthSendRawTransactionInput {
  final TEthSendRawTransactionBody body;
  const TEthSendRawTransactionInput({required this.body});
  factory TEthSendRawTransactionInput.fromJson(Map<String, dynamic> json) => TEthSendRawTransactionInput(body: TEthSendRawTransactionBody.fromJson(json['body'] as Map<String, dynamic>));
  Map<String, dynamic> toJson() => {'body': body.toJson()};
}

class TEthSendTransactionResponse {
  final v1Activity activity;
  final v1EthSendTransactionResult? result;
  const TEthSendTransactionResponse({required this.activity, this.result,});
  factory TEthSendTransactionResponse.fromJson(Map<String, dynamic> json) {
    return TEthSendTransactionResponse(
      activity: v1Activity.fromJson(json['activity'] as Map<String, dynamic>),
      result: json.containsKey('result') && json['result'] != null ? v1EthSendTransactionResult.fromJson(json['result'] as Map<String, dynamic>) : null,
    );
  }
  Map<String, dynamic> toJson() => {
    'activity': activity.toJson(),
    if (result != null) 'result': result!.toJson(),
  };
}

class TEthSendTransactionBody {
  final String? timestampMs;
  final String? organizationId;
  /// A wallet or private key address to sign with. This does not support private key IDs.
  final String from;
  /// Whether to sponsor this transaction via Gas Station.
  final bool? sponsor;
  /// CAIP-2 chain ID (e.g., 'eip155:1' for Ethereum mainnet).
  final String caip2;
  /// Recipient address as a hex string with 0x prefix.
  final String to;
  /// Amount of native asset to send in wei.
  final String? value;
  /// Hex-encoded call data for contract interactions.
  final String? data;
  /// Transaction nonce, for EIP-1559 and Turnkey Gas Station authorizations.
  final String? nonce;
  /// Maximum amount of gas to use for this transaction, for EIP-1559 transactions.
  final String? gasLimit;
  /// Maximum total fee per gas unit (base fee + priority fee) in wei. Required for non-sponsored (EIP-1559) transactions. Not used for sponsored transactions.
  final String? maxFeePerGas;
  /// Maximum priority fee (tip) per gas unit in wei. Required for non-sponsored (EIP-1559) transactions. Not used for sponsored transactions.
  final String? maxPriorityFeePerGas;
  /// The gas station delegate contract nonce. Only used when sponsor=true. Include this if you want maximal security posture.
  final String? gasStationNonce;

  const TEthSendTransactionBody({
     this.timestampMs,
     this.organizationId,
    required  this.from,
     this.sponsor,
    required  this.caip2,
    required  this.to,
     this.value,
     this.data,
     this.nonce,
     this.gasLimit,
     this.maxFeePerGas,
     this.maxPriorityFeePerGas,
     this.gasStationNonce,
  });
  factory TEthSendTransactionBody.fromJson(Map<String, dynamic> json) {
    final _timestampMs = json['timestampMs'] as String?;
    final _organizationId = json['organizationId'] as String?;
    final _from = json['from'] as String;
    final _sponsor = json['sponsor'] as bool?;
    final _caip2 = json['caip2'] as String;
    final _to = json['to'] as String;
    final _value = json['value'] as String?;
    final _data = json['data'] as String?;
    final _nonce = json['nonce'] as String?;
    final _gasLimit = json['gasLimit'] as String?;
    final _maxFeePerGas = json['maxFeePerGas'] as String?;
    final _maxPriorityFeePerGas = json['maxPriorityFeePerGas'] as String?;
    final _gasStationNonce = json['gasStationNonce'] as String?;
    return TEthSendTransactionBody(
      timestampMs: _timestampMs,
      organizationId: _organizationId,
      from: _from,
      sponsor: _sponsor,
      caip2: _caip2,
      to: _to,
      value: _value,
      data: _data,
      nonce: _nonce,
      gasLimit: _gasLimit,
      maxFeePerGas: _maxFeePerGas,
      maxPriorityFeePerGas: _maxPriorityFeePerGas,
      gasStationNonce: _gasStationNonce,
    );
  }
  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    if (timestampMs != null) {
      _json['timestampMs'] = timestampMs;
    }
    if (organizationId != null) {
      _json['organizationId'] = organizationId;
    }
    _json['from'] = from;
    if (sponsor != null) {
      _json['sponsor'] = sponsor;
    }
    _json['caip2'] = caip2;
    _json['to'] = to;
    if (value != null) {
      _json['value'] = value;
    }
    if (data != null) {
      _json['data'] = data;
    }
    if (nonce != null) {
      _json['nonce'] = nonce;
    }
    if (gasLimit != null) {
      _json['gasLimit'] = gasLimit;
    }
    if (maxFeePerGas != null) {
      _json['maxFeePerGas'] = maxFeePerGas;
    }
    if (maxPriorityFeePerGas != null) {
      _json['maxPriorityFeePerGas'] = maxPriorityFeePerGas;
    }
    if (gasStationNonce != null) {
      _json['gasStationNonce'] = gasStationNonce;
    }
    return _json;
  }
}

class TEthSendTransactionInput {
  final TEthSendTransactionBody body;
  const TEthSendTransactionInput({required this.body});
  factory TEthSendTransactionInput.fromJson(Map<String, dynamic> json) => TEthSendTransactionInput(body: TEthSendTransactionBody.fromJson(json['body'] as Map<String, dynamic>));
  Map<String, dynamic> toJson() => {'body': body.toJson()};
}

class TExportPrivateKeyResponse {
  final v1Activity activity;
  final v1ExportPrivateKeyResult? result;
  const TExportPrivateKeyResponse({required this.activity, this.result,});
  factory TExportPrivateKeyResponse.fromJson(Map<String, dynamic> json) {
    return TExportPrivateKeyResponse(
      activity: v1Activity.fromJson(json['activity'] as Map<String, dynamic>),
      result: json.containsKey('result') && json['result'] != null ? v1ExportPrivateKeyResult.fromJson(json['result'] as Map<String, dynamic>) : null,
    );
  }
  Map<String, dynamic> toJson() => {
    'activity': activity.toJson(),
    if (result != null) 'result': result!.toJson(),
  };
}

class TExportPrivateKeyBody {
  final String? timestampMs;
  final String? organizationId;
  /// Unique identifier for a given Private Key.
  final String privateKeyId;
  /// Client-side public key generated by the user, to which the export bundle will be encrypted.
  final String targetPublicKey;

  const TExportPrivateKeyBody({
     this.timestampMs,
     this.organizationId,
    required  this.privateKeyId,
    required  this.targetPublicKey,
  });
  factory TExportPrivateKeyBody.fromJson(Map<String, dynamic> json) {
    final _timestampMs = json['timestampMs'] as String?;
    final _organizationId = json['organizationId'] as String?;
    final _privateKeyId = json['privateKeyId'] as String;
    final _targetPublicKey = json['targetPublicKey'] as String;
    return TExportPrivateKeyBody(
      timestampMs: _timestampMs,
      organizationId: _organizationId,
      privateKeyId: _privateKeyId,
      targetPublicKey: _targetPublicKey,
    );
  }
  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    if (timestampMs != null) {
      _json['timestampMs'] = timestampMs;
    }
    if (organizationId != null) {
      _json['organizationId'] = organizationId;
    }
    _json['privateKeyId'] = privateKeyId;
    _json['targetPublicKey'] = targetPublicKey;
    return _json;
  }
}

class TExportPrivateKeyInput {
  final TExportPrivateKeyBody body;
  const TExportPrivateKeyInput({required this.body});
  factory TExportPrivateKeyInput.fromJson(Map<String, dynamic> json) => TExportPrivateKeyInput(body: TExportPrivateKeyBody.fromJson(json['body'] as Map<String, dynamic>));
  Map<String, dynamic> toJson() => {'body': body.toJson()};
}

class TExportWalletResponse {
  final v1Activity activity;
  final v1ExportWalletResult? result;
  const TExportWalletResponse({required this.activity, this.result,});
  factory TExportWalletResponse.fromJson(Map<String, dynamic> json) {
    return TExportWalletResponse(
      activity: v1Activity.fromJson(json['activity'] as Map<String, dynamic>),
      result: json.containsKey('result') && json['result'] != null ? v1ExportWalletResult.fromJson(json['result'] as Map<String, dynamic>) : null,
    );
  }
  Map<String, dynamic> toJson() => {
    'activity': activity.toJson(),
    if (result != null) 'result': result!.toJson(),
  };
}

class TExportWalletBody {
  final String? timestampMs;
  final String? organizationId;
  /// Unique identifier for a given Wallet.
  final String walletId;
  /// Client-side public key generated by the user, to which the export bundle will be encrypted.
  final String targetPublicKey;
  /// The language of the mnemonic to export. Defaults to English.
  final v1MnemonicLanguage? language;

  const TExportWalletBody({
     this.timestampMs,
     this.organizationId,
    required  this.walletId,
    required  this.targetPublicKey,
     this.language,
  });
  factory TExportWalletBody.fromJson(Map<String, dynamic> json) {
    final _timestampMs = json['timestampMs'] as String?;
    final _organizationId = json['organizationId'] as String?;
    final _walletId = json['walletId'] as String;
    final _targetPublicKey = json['targetPublicKey'] as String;
    final _language = json['language'] == null ? null : v1MnemonicLanguageFromJson(json['language']);
    return TExportWalletBody(
      timestampMs: _timestampMs,
      organizationId: _organizationId,
      walletId: _walletId,
      targetPublicKey: _targetPublicKey,
      language: _language,
    );
  }
  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    if (timestampMs != null) {
      _json['timestampMs'] = timestampMs;
    }
    if (organizationId != null) {
      _json['organizationId'] = organizationId;
    }
    _json['walletId'] = walletId;
    _json['targetPublicKey'] = targetPublicKey;
    if (language != null) {
      _json['language'] = v1MnemonicLanguageToJson(language!);
    }
    return _json;
  }
}

class TExportWalletInput {
  final TExportWalletBody body;
  const TExportWalletInput({required this.body});
  factory TExportWalletInput.fromJson(Map<String, dynamic> json) => TExportWalletInput(body: TExportWalletBody.fromJson(json['body'] as Map<String, dynamic>));
  Map<String, dynamic> toJson() => {'body': body.toJson()};
}

class TExportWalletAccountResponse {
  final v1Activity activity;
  final v1ExportWalletAccountResult? result;
  const TExportWalletAccountResponse({required this.activity, this.result,});
  factory TExportWalletAccountResponse.fromJson(Map<String, dynamic> json) {
    return TExportWalletAccountResponse(
      activity: v1Activity.fromJson(json['activity'] as Map<String, dynamic>),
      result: json.containsKey('result') && json['result'] != null ? v1ExportWalletAccountResult.fromJson(json['result'] as Map<String, dynamic>) : null,
    );
  }
  Map<String, dynamic> toJson() => {
    'activity': activity.toJson(),
    if (result != null) 'result': result!.toJson(),
  };
}

class TExportWalletAccountBody {
  final String? timestampMs;
  final String? organizationId;
  /// Address to identify Wallet Account.
  final String address;
  /// Client-side public key generated by the user, to which the export bundle will be encrypted.
  final String targetPublicKey;

  const TExportWalletAccountBody({
     this.timestampMs,
     this.organizationId,
    required  this.address,
    required  this.targetPublicKey,
  });
  factory TExportWalletAccountBody.fromJson(Map<String, dynamic> json) {
    final _timestampMs = json['timestampMs'] as String?;
    final _organizationId = json['organizationId'] as String?;
    final _address = json['address'] as String;
    final _targetPublicKey = json['targetPublicKey'] as String;
    return TExportWalletAccountBody(
      timestampMs: _timestampMs,
      organizationId: _organizationId,
      address: _address,
      targetPublicKey: _targetPublicKey,
    );
  }
  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    if (timestampMs != null) {
      _json['timestampMs'] = timestampMs;
    }
    if (organizationId != null) {
      _json['organizationId'] = organizationId;
    }
    _json['address'] = address;
    _json['targetPublicKey'] = targetPublicKey;
    return _json;
  }
}

class TExportWalletAccountInput {
  final TExportWalletAccountBody body;
  const TExportWalletAccountInput({required this.body});
  factory TExportWalletAccountInput.fromJson(Map<String, dynamic> json) => TExportWalletAccountInput(body: TExportWalletAccountBody.fromJson(json['body'] as Map<String, dynamic>));
  Map<String, dynamic> toJson() => {'body': body.toJson()};
}

class TImportPrivateKeyResponse {
  final v1Activity activity;
  final v1ImportPrivateKeyResult? result;
  const TImportPrivateKeyResponse({required this.activity, this.result,});
  factory TImportPrivateKeyResponse.fromJson(Map<String, dynamic> json) {
    return TImportPrivateKeyResponse(
      activity: v1Activity.fromJson(json['activity'] as Map<String, dynamic>),
      result: json.containsKey('result') && json['result'] != null ? v1ImportPrivateKeyResult.fromJson(json['result'] as Map<String, dynamic>) : null,
    );
  }
  Map<String, dynamic> toJson() => {
    'activity': activity.toJson(),
    if (result != null) 'result': result!.toJson(),
  };
}

class TImportPrivateKeyBody {
  final String? timestampMs;
  final String? organizationId;
  /// The ID of the User importing a Private Key.
  final String userId;
  /// Human-readable name for a Private Key.
  final String privateKeyName;
  /// Bundle containing a raw private key encrypted to the enclave's target public key.
  final String encryptedBundle;
  /// Cryptographic Curve used to generate a given Private Key.
  final v1Curve curve;
  /// Cryptocurrency-specific formats for a derived address (e.g., Ethereum).
  final List<v1AddressFormat> addressFormats;

  const TImportPrivateKeyBody({
     this.timestampMs,
     this.organizationId,
    required  this.userId,
    required  this.privateKeyName,
    required  this.encryptedBundle,
    required  this.curve,
    required  this.addressFormats,
  });
  factory TImportPrivateKeyBody.fromJson(Map<String, dynamic> json) {
    final _timestampMs = json['timestampMs'] as String?;
    final _organizationId = json['organizationId'] as String?;
    final _userId = json['userId'] as String;
    final _privateKeyName = json['privateKeyName'] as String;
    final _encryptedBundle = json['encryptedBundle'] as String;
    final _curve = v1CurveFromJson(json['curve']);
    final _addressFormats = (json['addressFormats'] as List).map((e) => v1AddressFormatFromJson(e)).toList();
    return TImportPrivateKeyBody(
      timestampMs: _timestampMs,
      organizationId: _organizationId,
      userId: _userId,
      privateKeyName: _privateKeyName,
      encryptedBundle: _encryptedBundle,
      curve: _curve,
      addressFormats: _addressFormats,
    );
  }
  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    if (timestampMs != null) {
      _json['timestampMs'] = timestampMs;
    }
    if (organizationId != null) {
      _json['organizationId'] = organizationId;
    }
    _json['userId'] = userId;
    _json['privateKeyName'] = privateKeyName;
    _json['encryptedBundle'] = encryptedBundle;
    _json['curve'] = v1CurveToJson(curve);
    _json['addressFormats'] = addressFormats.map((e) => v1AddressFormatToJson(e)).toList();
    return _json;
  }
}

class TImportPrivateKeyInput {
  final TImportPrivateKeyBody body;
  const TImportPrivateKeyInput({required this.body});
  factory TImportPrivateKeyInput.fromJson(Map<String, dynamic> json) => TImportPrivateKeyInput(body: TImportPrivateKeyBody.fromJson(json['body'] as Map<String, dynamic>));
  Map<String, dynamic> toJson() => {'body': body.toJson()};
}

class TImportWalletResponse {
  final v1Activity activity;
  final v1ImportWalletResult? result;
  const TImportWalletResponse({required this.activity, this.result,});
  factory TImportWalletResponse.fromJson(Map<String, dynamic> json) {
    return TImportWalletResponse(
      activity: v1Activity.fromJson(json['activity'] as Map<String, dynamic>),
      result: json.containsKey('result') && json['result'] != null ? v1ImportWalletResult.fromJson(json['result'] as Map<String, dynamic>) : null,
    );
  }
  Map<String, dynamic> toJson() => {
    'activity': activity.toJson(),
    if (result != null) 'result': result!.toJson(),
  };
}

class TImportWalletBody {
  final String? timestampMs;
  final String? organizationId;
  /// The ID of the User importing a Wallet.
  final String userId;
  /// Human-readable name for a Wallet.
  final String walletName;
  /// Bundle containing a wallet mnemonic encrypted to the enclave's target public key.
  final String encryptedBundle;
  /// A list of wallet Accounts.
  final List<v1WalletAccountParams> accounts;

  const TImportWalletBody({
     this.timestampMs,
     this.organizationId,
    required  this.userId,
    required  this.walletName,
    required  this.encryptedBundle,
    required  this.accounts,
  });
  factory TImportWalletBody.fromJson(Map<String, dynamic> json) {
    final _timestampMs = json['timestampMs'] as String?;
    final _organizationId = json['organizationId'] as String?;
    final _userId = json['userId'] as String;
    final _walletName = json['walletName'] as String;
    final _encryptedBundle = json['encryptedBundle'] as String;
    final _accounts = (json['accounts'] as List).map((e) => v1WalletAccountParams.fromJson(e as Map<String, dynamic>)).toList();
    return TImportWalletBody(
      timestampMs: _timestampMs,
      organizationId: _organizationId,
      userId: _userId,
      walletName: _walletName,
      encryptedBundle: _encryptedBundle,
      accounts: _accounts,
    );
  }
  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    if (timestampMs != null) {
      _json['timestampMs'] = timestampMs;
    }
    if (organizationId != null) {
      _json['organizationId'] = organizationId;
    }
    _json['userId'] = userId;
    _json['walletName'] = walletName;
    _json['encryptedBundle'] = encryptedBundle;
    _json['accounts'] = accounts.map((e) => e.toJson()).toList();
    return _json;
  }
}

class TImportWalletInput {
  final TImportWalletBody body;
  const TImportWalletInput({required this.body});
  factory TImportWalletInput.fromJson(Map<String, dynamic> json) => TImportWalletInput(body: TImportWalletBody.fromJson(json['body'] as Map<String, dynamic>));
  Map<String, dynamic> toJson() => {'body': body.toJson()};
}

class TInitFiatOnRampResponse {
  final v1Activity activity;
  final v1InitFiatOnRampResult? result;
  const TInitFiatOnRampResponse({required this.activity, this.result,});
  factory TInitFiatOnRampResponse.fromJson(Map<String, dynamic> json) {
    return TInitFiatOnRampResponse(
      activity: v1Activity.fromJson(json['activity'] as Map<String, dynamic>),
      result: json.containsKey('result') && json['result'] != null ? v1InitFiatOnRampResult.fromJson(json['result'] as Map<String, dynamic>) : null,
    );
  }
  Map<String, dynamic> toJson() => {
    'activity': activity.toJson(),
    if (result != null) 'result': result!.toJson(),
  };
}

class TInitFiatOnRampBody {
  final String? timestampMs;
  final String? organizationId;
  /// Enum to specifiy which on-ramp provider to use
  final v1FiatOnRampProvider onrampProvider;
  /// Destination wallet address for the buy transaction.
  final String walletAddress;
  /// Blockchain network to be used for the transaction, e.g., bitcoin, ethereum. Maps to MoonPay's network or Coinbase's defaultNetwork.
  final v1FiatOnRampBlockchainNetwork network;
  /// Code for the cryptocurrency to be purchased, e.g., btc, eth. Maps to MoonPay's currencyCode or Coinbase's defaultAsset.
  final v1FiatOnRampCryptoCurrency cryptoCurrencyCode;
  /// Code for the fiat currency to be used in the transaction, e.g., USD, EUR.
  final v1FiatOnRampCurrency? fiatCurrencyCode;
  /// Specifies a preset fiat amount for the transaction, e.g., '100'. Must be greater than '20'. If not provided, the user will be prompted to enter an amount.
  final String? fiatCurrencyAmount;
  /// Pre-selected payment method, e.g., CREDIT_DEBIT_CARD, APPLE_PAY. Validated against the chosen provider.
  final v1FiatOnRampPaymentMethod? paymentMethod;
  /// ISO 3166-1 two-digit country code for Coinbase representing the purchasing users country of residence, e.g., US, GB.
  final String? countryCode;
  /// ISO 3166-2 two-digit country subdivision code for Coinbase representing the purchasing users subdivision of residence within their country, e.g. NY. Required if country_code=US.
  final String? countrySubdivisionCode;
  /// Optional flag to indicate whether to use the sandbox mode to simulate transactions for the on-ramp provider. Default is false.
  final bool? sandboxMode;
  /// Optional MoonPay Widget URL to sign when using MoonPay client SDKs with URL Signing enabled.
  final String? urlForSignature;

  const TInitFiatOnRampBody({
     this.timestampMs,
     this.organizationId,
    required  this.onrampProvider,
    required  this.walletAddress,
    required  this.network,
    required  this.cryptoCurrencyCode,
     this.fiatCurrencyCode,
     this.fiatCurrencyAmount,
     this.paymentMethod,
     this.countryCode,
     this.countrySubdivisionCode,
     this.sandboxMode,
     this.urlForSignature,
  });
  factory TInitFiatOnRampBody.fromJson(Map<String, dynamic> json) {
    final _timestampMs = json['timestampMs'] as String?;
    final _organizationId = json['organizationId'] as String?;
    final _onrampProvider = v1FiatOnRampProviderFromJson(json['onrampProvider']);
    final _walletAddress = json['walletAddress'] as String;
    final _network = v1FiatOnRampBlockchainNetworkFromJson(json['network']);
    final _cryptoCurrencyCode = v1FiatOnRampCryptoCurrencyFromJson(json['cryptoCurrencyCode']);
    final _fiatCurrencyCode = json['fiatCurrencyCode'] == null ? null : v1FiatOnRampCurrencyFromJson(json['fiatCurrencyCode']);
    final _fiatCurrencyAmount = json['fiatCurrencyAmount'] as String?;
    final _paymentMethod = json['paymentMethod'] == null ? null : v1FiatOnRampPaymentMethodFromJson(json['paymentMethod']);
    final _countryCode = json['countryCode'] as String?;
    final _countrySubdivisionCode = json['countrySubdivisionCode'] as String?;
    final _sandboxMode = json['sandboxMode'] as bool?;
    final _urlForSignature = json['urlForSignature'] as String?;
    return TInitFiatOnRampBody(
      timestampMs: _timestampMs,
      organizationId: _organizationId,
      onrampProvider: _onrampProvider,
      walletAddress: _walletAddress,
      network: _network,
      cryptoCurrencyCode: _cryptoCurrencyCode,
      fiatCurrencyCode: _fiatCurrencyCode,
      fiatCurrencyAmount: _fiatCurrencyAmount,
      paymentMethod: _paymentMethod,
      countryCode: _countryCode,
      countrySubdivisionCode: _countrySubdivisionCode,
      sandboxMode: _sandboxMode,
      urlForSignature: _urlForSignature,
    );
  }
  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    if (timestampMs != null) {
      _json['timestampMs'] = timestampMs;
    }
    if (organizationId != null) {
      _json['organizationId'] = organizationId;
    }
    _json['onrampProvider'] = v1FiatOnRampProviderToJson(onrampProvider);
    _json['walletAddress'] = walletAddress;
    _json['network'] = v1FiatOnRampBlockchainNetworkToJson(network);
    _json['cryptoCurrencyCode'] = v1FiatOnRampCryptoCurrencyToJson(cryptoCurrencyCode);
    if (fiatCurrencyCode != null) {
      _json['fiatCurrencyCode'] = v1FiatOnRampCurrencyToJson(fiatCurrencyCode!);
    }
    if (fiatCurrencyAmount != null) {
      _json['fiatCurrencyAmount'] = fiatCurrencyAmount;
    }
    if (paymentMethod != null) {
      _json['paymentMethod'] = v1FiatOnRampPaymentMethodToJson(paymentMethod!);
    }
    if (countryCode != null) {
      _json['countryCode'] = countryCode;
    }
    if (countrySubdivisionCode != null) {
      _json['countrySubdivisionCode'] = countrySubdivisionCode;
    }
    if (sandboxMode != null) {
      _json['sandboxMode'] = sandboxMode;
    }
    if (urlForSignature != null) {
      _json['urlForSignature'] = urlForSignature;
    }
    return _json;
  }
}

class TInitFiatOnRampInput {
  final TInitFiatOnRampBody body;
  const TInitFiatOnRampInput({required this.body});
  factory TInitFiatOnRampInput.fromJson(Map<String, dynamic> json) => TInitFiatOnRampInput(body: TInitFiatOnRampBody.fromJson(json['body'] as Map<String, dynamic>));
  Map<String, dynamic> toJson() => {'body': body.toJson()};
}

class TInitImportPrivateKeyResponse {
  final v1Activity activity;
  final v1InitImportPrivateKeyResult? result;
  const TInitImportPrivateKeyResponse({required this.activity, this.result,});
  factory TInitImportPrivateKeyResponse.fromJson(Map<String, dynamic> json) {
    return TInitImportPrivateKeyResponse(
      activity: v1Activity.fromJson(json['activity'] as Map<String, dynamic>),
      result: json.containsKey('result') && json['result'] != null ? v1InitImportPrivateKeyResult.fromJson(json['result'] as Map<String, dynamic>) : null,
    );
  }
  Map<String, dynamic> toJson() => {
    'activity': activity.toJson(),
    if (result != null) 'result': result!.toJson(),
  };
}

class TInitImportPrivateKeyBody {
  final String? timestampMs;
  final String? organizationId;
  /// The ID of the User importing a Private Key.
  final String userId;

  const TInitImportPrivateKeyBody({
     this.timestampMs,
     this.organizationId,
    required  this.userId,
  });
  factory TInitImportPrivateKeyBody.fromJson(Map<String, dynamic> json) {
    final _timestampMs = json['timestampMs'] as String?;
    final _organizationId = json['organizationId'] as String?;
    final _userId = json['userId'] as String;
    return TInitImportPrivateKeyBody(
      timestampMs: _timestampMs,
      organizationId: _organizationId,
      userId: _userId,
    );
  }
  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    if (timestampMs != null) {
      _json['timestampMs'] = timestampMs;
    }
    if (organizationId != null) {
      _json['organizationId'] = organizationId;
    }
    _json['userId'] = userId;
    return _json;
  }
}

class TInitImportPrivateKeyInput {
  final TInitImportPrivateKeyBody body;
  const TInitImportPrivateKeyInput({required this.body});
  factory TInitImportPrivateKeyInput.fromJson(Map<String, dynamic> json) => TInitImportPrivateKeyInput(body: TInitImportPrivateKeyBody.fromJson(json['body'] as Map<String, dynamic>));
  Map<String, dynamic> toJson() => {'body': body.toJson()};
}

class TInitImportWalletResponse {
  final v1Activity activity;
  final v1InitImportWalletResult? result;
  const TInitImportWalletResponse({required this.activity, this.result,});
  factory TInitImportWalletResponse.fromJson(Map<String, dynamic> json) {
    return TInitImportWalletResponse(
      activity: v1Activity.fromJson(json['activity'] as Map<String, dynamic>),
      result: json.containsKey('result') && json['result'] != null ? v1InitImportWalletResult.fromJson(json['result'] as Map<String, dynamic>) : null,
    );
  }
  Map<String, dynamic> toJson() => {
    'activity': activity.toJson(),
    if (result != null) 'result': result!.toJson(),
  };
}

class TInitImportWalletBody {
  final String? timestampMs;
  final String? organizationId;
  /// The ID of the User importing a Wallet.
  final String userId;

  const TInitImportWalletBody({
     this.timestampMs,
     this.organizationId,
    required  this.userId,
  });
  factory TInitImportWalletBody.fromJson(Map<String, dynamic> json) {
    final _timestampMs = json['timestampMs'] as String?;
    final _organizationId = json['organizationId'] as String?;
    final _userId = json['userId'] as String;
    return TInitImportWalletBody(
      timestampMs: _timestampMs,
      organizationId: _organizationId,
      userId: _userId,
    );
  }
  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    if (timestampMs != null) {
      _json['timestampMs'] = timestampMs;
    }
    if (organizationId != null) {
      _json['organizationId'] = organizationId;
    }
    _json['userId'] = userId;
    return _json;
  }
}

class TInitImportWalletInput {
  final TInitImportWalletBody body;
  const TInitImportWalletInput({required this.body});
  factory TInitImportWalletInput.fromJson(Map<String, dynamic> json) => TInitImportWalletInput(body: TInitImportWalletBody.fromJson(json['body'] as Map<String, dynamic>));
  Map<String, dynamic> toJson() => {'body': body.toJson()};
}

class TInitOtpResponse {
  final v1Activity activity;
  final v1InitOtpResult? result;
  const TInitOtpResponse({required this.activity, this.result,});
  factory TInitOtpResponse.fromJson(Map<String, dynamic> json) {
    return TInitOtpResponse(
      activity: v1Activity.fromJson(json['activity'] as Map<String, dynamic>),
      result: json.containsKey('result') && json['result'] != null ? v1InitOtpResult.fromJson(json['result'] as Map<String, dynamic>) : null,
    );
  }
  Map<String, dynamic> toJson() => {
    'activity': activity.toJson(),
    if (result != null) 'result': result!.toJson(),
  };
}

class TInitOtpBody {
  final String? timestampMs;
  final String? organizationId;
  /// Whether to send OTP via SMS or email. Possible values: OTP_TYPE_SMS, OTP_TYPE_EMAIL
  final String otpType;
  /// Email or phone number to send the OTP code to
  final String contact;
  /// Optional length of the OTP code. Default = 9
  final num? otpLength;
  /// Optional parameters for customizing emails. If not provided, the default email will be used.
  final v1EmailCustomizationParams? emailCustomization;
  /// Optional parameters for customizing SMS message. If not provided, the default sms message will be used.
  final v1SmsCustomizationParams? smsCustomization;
  /// Optional client-generated user identifier to enable per-user rate limiting for SMS auth. We recommend using a hash of the client-side IP address.
  final String? userIdentifier;
  /// Optional custom email address from which to send the OTP email
  final String? sendFromEmailAddress;
  /// Optional flag to specify if the OTP code should be alphanumeric (Crockfords Base32). Default = true
  final bool? alphanumeric;
  /// Optional custom sender name for use with sendFromEmailAddress; if left empty, will default to 'Notifications'
  final String? sendFromEmailSenderName;
  /// Expiration window (in seconds) indicating how long the OTP is valid for. If not provided, a default of 5 minutes will be used. Maximum value is 600 seconds (10 minutes)
  final String? expirationSeconds;
  /// Optional custom email address to use as reply-to
  final String? replyToEmailAddress;

  const TInitOtpBody({
     this.timestampMs,
     this.organizationId,
    required  this.otpType,
    required  this.contact,
     this.otpLength,
     this.emailCustomization,
     this.smsCustomization,
     this.userIdentifier,
     this.sendFromEmailAddress,
     this.alphanumeric,
     this.sendFromEmailSenderName,
     this.expirationSeconds,
     this.replyToEmailAddress,
  });
  factory TInitOtpBody.fromJson(Map<String, dynamic> json) {
    final _timestampMs = json['timestampMs'] as String?;
    final _organizationId = json['organizationId'] as String?;
    final _otpType = json['otpType'] as String;
    final _contact = json['contact'] as String;
    final _otpLength = json['otpLength'] as num?;
    final _emailCustomization = json['emailCustomization'] == null ? null : v1EmailCustomizationParams.fromJson(json['emailCustomization'] as Map<String, dynamic>);
    final _smsCustomization = json['smsCustomization'] == null ? null : v1SmsCustomizationParams.fromJson(json['smsCustomization'] as Map<String, dynamic>);
    final _userIdentifier = json['userIdentifier'] as String?;
    final _sendFromEmailAddress = json['sendFromEmailAddress'] as String?;
    final _alphanumeric = json['alphanumeric'] as bool?;
    final _sendFromEmailSenderName = json['sendFromEmailSenderName'] as String?;
    final _expirationSeconds = json['expirationSeconds'] as String?;
    final _replyToEmailAddress = json['replyToEmailAddress'] as String?;
    return TInitOtpBody(
      timestampMs: _timestampMs,
      organizationId: _organizationId,
      otpType: _otpType,
      contact: _contact,
      otpLength: _otpLength,
      emailCustomization: _emailCustomization,
      smsCustomization: _smsCustomization,
      userIdentifier: _userIdentifier,
      sendFromEmailAddress: _sendFromEmailAddress,
      alphanumeric: _alphanumeric,
      sendFromEmailSenderName: _sendFromEmailSenderName,
      expirationSeconds: _expirationSeconds,
      replyToEmailAddress: _replyToEmailAddress,
    );
  }
  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    if (timestampMs != null) {
      _json['timestampMs'] = timestampMs;
    }
    if (organizationId != null) {
      _json['organizationId'] = organizationId;
    }
    _json['otpType'] = otpType;
    _json['contact'] = contact;
    if (otpLength != null) {
      _json['otpLength'] = otpLength;
    }
    if (emailCustomization != null) {
      _json['emailCustomization'] = emailCustomization?.toJson();
    }
    if (smsCustomization != null) {
      _json['smsCustomization'] = smsCustomization?.toJson();
    }
    if (userIdentifier != null) {
      _json['userIdentifier'] = userIdentifier;
    }
    if (sendFromEmailAddress != null) {
      _json['sendFromEmailAddress'] = sendFromEmailAddress;
    }
    if (alphanumeric != null) {
      _json['alphanumeric'] = alphanumeric;
    }
    if (sendFromEmailSenderName != null) {
      _json['sendFromEmailSenderName'] = sendFromEmailSenderName;
    }
    if (expirationSeconds != null) {
      _json['expirationSeconds'] = expirationSeconds;
    }
    if (replyToEmailAddress != null) {
      _json['replyToEmailAddress'] = replyToEmailAddress;
    }
    return _json;
  }
}

class TInitOtpInput {
  final TInitOtpBody body;
  const TInitOtpInput({required this.body});
  factory TInitOtpInput.fromJson(Map<String, dynamic> json) => TInitOtpInput(body: TInitOtpBody.fromJson(json['body'] as Map<String, dynamic>));
  Map<String, dynamic> toJson() => {'body': body.toJson()};
}

class TInitOtpAuthResponse {
  final v1Activity activity;
  final v1InitOtpAuthResultV2? result;
  const TInitOtpAuthResponse({required this.activity, this.result,});
  factory TInitOtpAuthResponse.fromJson(Map<String, dynamic> json) {
    return TInitOtpAuthResponse(
      activity: v1Activity.fromJson(json['activity'] as Map<String, dynamic>),
      result: json.containsKey('result') && json['result'] != null ? v1InitOtpAuthResultV2.fromJson(json['result'] as Map<String, dynamic>) : null,
    );
  }
  Map<String, dynamic> toJson() => {
    'activity': activity.toJson(),
    if (result != null) 'result': result!.toJson(),
  };
}

class TInitOtpAuthBody {
  final String? timestampMs;
  final String? organizationId;
  /// Enum to specifiy whether to send OTP via SMS or email
  final String otpType;
  /// Email or phone number to send the OTP code to
  final String contact;
  /// Optional length of the OTP code. Default = 9
  final num? otpLength;
  /// Optional parameters for customizing emails. If not provided, the default email will be used.
  final v1EmailCustomizationParams? emailCustomization;
  /// Optional parameters for customizing SMS message. If not provided, the default SMS message will be used.
  final v1SmsCustomizationParams? smsCustomization;
  /// Optional client-generated user identifier to enable per-user rate limiting for SMS auth. We recommend using a hash of the client-side IP address.
  final String? userIdentifier;
  /// Optional custom email address from which to send the OTP email
  final String? sendFromEmailAddress;
  /// Optional flag to specify if the OTP code should be alphanumeric (Crockfords Base32). Default = true
  final bool? alphanumeric;
  /// Optional custom sender name for use with sendFromEmailAddress; if left empty, will default to 'Notifications'
  final String? sendFromEmailSenderName;
  /// Optional custom email address to use as reply-to
  final String? replyToEmailAddress;

  const TInitOtpAuthBody({
     this.timestampMs,
     this.organizationId,
    required  this.otpType,
    required  this.contact,
     this.otpLength,
     this.emailCustomization,
     this.smsCustomization,
     this.userIdentifier,
     this.sendFromEmailAddress,
     this.alphanumeric,
     this.sendFromEmailSenderName,
     this.replyToEmailAddress,
  });
  factory TInitOtpAuthBody.fromJson(Map<String, dynamic> json) {
    final _timestampMs = json['timestampMs'] as String?;
    final _organizationId = json['organizationId'] as String?;
    final _otpType = json['otpType'] as String;
    final _contact = json['contact'] as String;
    final _otpLength = json['otpLength'] as num?;
    final _emailCustomization = json['emailCustomization'] == null ? null : v1EmailCustomizationParams.fromJson(json['emailCustomization'] as Map<String, dynamic>);
    final _smsCustomization = json['smsCustomization'] == null ? null : v1SmsCustomizationParams.fromJson(json['smsCustomization'] as Map<String, dynamic>);
    final _userIdentifier = json['userIdentifier'] as String?;
    final _sendFromEmailAddress = json['sendFromEmailAddress'] as String?;
    final _alphanumeric = json['alphanumeric'] as bool?;
    final _sendFromEmailSenderName = json['sendFromEmailSenderName'] as String?;
    final _replyToEmailAddress = json['replyToEmailAddress'] as String?;
    return TInitOtpAuthBody(
      timestampMs: _timestampMs,
      organizationId: _organizationId,
      otpType: _otpType,
      contact: _contact,
      otpLength: _otpLength,
      emailCustomization: _emailCustomization,
      smsCustomization: _smsCustomization,
      userIdentifier: _userIdentifier,
      sendFromEmailAddress: _sendFromEmailAddress,
      alphanumeric: _alphanumeric,
      sendFromEmailSenderName: _sendFromEmailSenderName,
      replyToEmailAddress: _replyToEmailAddress,
    );
  }
  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    if (timestampMs != null) {
      _json['timestampMs'] = timestampMs;
    }
    if (organizationId != null) {
      _json['organizationId'] = organizationId;
    }
    _json['otpType'] = otpType;
    _json['contact'] = contact;
    if (otpLength != null) {
      _json['otpLength'] = otpLength;
    }
    if (emailCustomization != null) {
      _json['emailCustomization'] = emailCustomization?.toJson();
    }
    if (smsCustomization != null) {
      _json['smsCustomization'] = smsCustomization?.toJson();
    }
    if (userIdentifier != null) {
      _json['userIdentifier'] = userIdentifier;
    }
    if (sendFromEmailAddress != null) {
      _json['sendFromEmailAddress'] = sendFromEmailAddress;
    }
    if (alphanumeric != null) {
      _json['alphanumeric'] = alphanumeric;
    }
    if (sendFromEmailSenderName != null) {
      _json['sendFromEmailSenderName'] = sendFromEmailSenderName;
    }
    if (replyToEmailAddress != null) {
      _json['replyToEmailAddress'] = replyToEmailAddress;
    }
    return _json;
  }
}

class TInitOtpAuthInput {
  final TInitOtpAuthBody body;
  const TInitOtpAuthInput({required this.body});
  factory TInitOtpAuthInput.fromJson(Map<String, dynamic> json) => TInitOtpAuthInput(body: TInitOtpAuthBody.fromJson(json['body'] as Map<String, dynamic>));
  Map<String, dynamic> toJson() => {'body': body.toJson()};
}

class TInitUserEmailRecoveryResponse {
  final v1Activity activity;
  final v1InitUserEmailRecoveryResult? result;
  const TInitUserEmailRecoveryResponse({required this.activity, this.result,});
  factory TInitUserEmailRecoveryResponse.fromJson(Map<String, dynamic> json) {
    return TInitUserEmailRecoveryResponse(
      activity: v1Activity.fromJson(json['activity'] as Map<String, dynamic>),
      result: json.containsKey('result') && json['result'] != null ? v1InitUserEmailRecoveryResult.fromJson(json['result'] as Map<String, dynamic>) : null,
    );
  }
  Map<String, dynamic> toJson() => {
    'activity': activity.toJson(),
    if (result != null) 'result': result!.toJson(),
  };
}

class TInitUserEmailRecoveryBody {
  final String? timestampMs;
  final String? organizationId;
  /// Email of the user starting recovery
  final String email;
  /// Client-side public key generated by the user, to which the recovery bundle will be encrypted.
  final String targetPublicKey;
  /// Expiration window (in seconds) indicating how long the recovery credential is valid for. If not provided, a default of 15 minutes will be used.
  final String? expirationSeconds;
  /// Optional parameters for customizing emails. If not provided, the default email will be used.
  final v1EmailCustomizationParams? emailCustomization;
  /// Optional custom email address from which to send the OTP email
  final String? sendFromEmailAddress;
  /// Optional custom sender name for use with sendFromEmailAddress; if left empty, will default to 'Notifications'
  final String? sendFromEmailSenderName;
  /// Optional custom email address to use as reply-to
  final String? replyToEmailAddress;

  const TInitUserEmailRecoveryBody({
     this.timestampMs,
     this.organizationId,
    required  this.email,
    required  this.targetPublicKey,
     this.expirationSeconds,
     this.emailCustomization,
     this.sendFromEmailAddress,
     this.sendFromEmailSenderName,
     this.replyToEmailAddress,
  });
  factory TInitUserEmailRecoveryBody.fromJson(Map<String, dynamic> json) {
    final _timestampMs = json['timestampMs'] as String?;
    final _organizationId = json['organizationId'] as String?;
    final _email = json['email'] as String;
    final _targetPublicKey = json['targetPublicKey'] as String;
    final _expirationSeconds = json['expirationSeconds'] as String?;
    final _emailCustomization = json['emailCustomization'] == null ? null : v1EmailCustomizationParams.fromJson(json['emailCustomization'] as Map<String, dynamic>);
    final _sendFromEmailAddress = json['sendFromEmailAddress'] as String?;
    final _sendFromEmailSenderName = json['sendFromEmailSenderName'] as String?;
    final _replyToEmailAddress = json['replyToEmailAddress'] as String?;
    return TInitUserEmailRecoveryBody(
      timestampMs: _timestampMs,
      organizationId: _organizationId,
      email: _email,
      targetPublicKey: _targetPublicKey,
      expirationSeconds: _expirationSeconds,
      emailCustomization: _emailCustomization,
      sendFromEmailAddress: _sendFromEmailAddress,
      sendFromEmailSenderName: _sendFromEmailSenderName,
      replyToEmailAddress: _replyToEmailAddress,
    );
  }
  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    if (timestampMs != null) {
      _json['timestampMs'] = timestampMs;
    }
    if (organizationId != null) {
      _json['organizationId'] = organizationId;
    }
    _json['email'] = email;
    _json['targetPublicKey'] = targetPublicKey;
    if (expirationSeconds != null) {
      _json['expirationSeconds'] = expirationSeconds;
    }
    if (emailCustomization != null) {
      _json['emailCustomization'] = emailCustomization?.toJson();
    }
    if (sendFromEmailAddress != null) {
      _json['sendFromEmailAddress'] = sendFromEmailAddress;
    }
    if (sendFromEmailSenderName != null) {
      _json['sendFromEmailSenderName'] = sendFromEmailSenderName;
    }
    if (replyToEmailAddress != null) {
      _json['replyToEmailAddress'] = replyToEmailAddress;
    }
    return _json;
  }
}

class TInitUserEmailRecoveryInput {
  final TInitUserEmailRecoveryBody body;
  const TInitUserEmailRecoveryInput({required this.body});
  factory TInitUserEmailRecoveryInput.fromJson(Map<String, dynamic> json) => TInitUserEmailRecoveryInput(body: TInitUserEmailRecoveryBody.fromJson(json['body'] as Map<String, dynamic>));
  Map<String, dynamic> toJson() => {'body': body.toJson()};
}

class TOauthResponse {
  final v1Activity activity;
  final v1OauthResult? result;
  const TOauthResponse({required this.activity, this.result,});
  factory TOauthResponse.fromJson(Map<String, dynamic> json) {
    return TOauthResponse(
      activity: v1Activity.fromJson(json['activity'] as Map<String, dynamic>),
      result: json.containsKey('result') && json['result'] != null ? v1OauthResult.fromJson(json['result'] as Map<String, dynamic>) : null,
    );
  }
  Map<String, dynamic> toJson() => {
    'activity': activity.toJson(),
    if (result != null) 'result': result!.toJson(),
  };
}

class TOauthBody {
  final String? timestampMs;
  final String? organizationId;
  /// Base64 encoded OIDC token
  final String oidcToken;
  /// Client-side public key generated by the user, to which the oauth bundle (credentials) will be encrypted.
  final String targetPublicKey;
  /// Optional human-readable name for an API Key. If none provided, default to Oauth - <Timestamp>
  final String? apiKeyName;
  /// Expiration window (in seconds) indicating how long the API key is valid for. If not provided, a default of 15 minutes will be used.
  final String? expirationSeconds;
  /// Invalidate all other previously generated Oauth API keys
  final bool? invalidateExisting;

  const TOauthBody({
     this.timestampMs,
     this.organizationId,
    required  this.oidcToken,
    required  this.targetPublicKey,
     this.apiKeyName,
     this.expirationSeconds,
     this.invalidateExisting,
  });
  factory TOauthBody.fromJson(Map<String, dynamic> json) {
    final _timestampMs = json['timestampMs'] as String?;
    final _organizationId = json['organizationId'] as String?;
    final _oidcToken = json['oidcToken'] as String;
    final _targetPublicKey = json['targetPublicKey'] as String;
    final _apiKeyName = json['apiKeyName'] as String?;
    final _expirationSeconds = json['expirationSeconds'] as String?;
    final _invalidateExisting = json['invalidateExisting'] as bool?;
    return TOauthBody(
      timestampMs: _timestampMs,
      organizationId: _organizationId,
      oidcToken: _oidcToken,
      targetPublicKey: _targetPublicKey,
      apiKeyName: _apiKeyName,
      expirationSeconds: _expirationSeconds,
      invalidateExisting: _invalidateExisting,
    );
  }
  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    if (timestampMs != null) {
      _json['timestampMs'] = timestampMs;
    }
    if (organizationId != null) {
      _json['organizationId'] = organizationId;
    }
    _json['oidcToken'] = oidcToken;
    _json['targetPublicKey'] = targetPublicKey;
    if (apiKeyName != null) {
      _json['apiKeyName'] = apiKeyName;
    }
    if (expirationSeconds != null) {
      _json['expirationSeconds'] = expirationSeconds;
    }
    if (invalidateExisting != null) {
      _json['invalidateExisting'] = invalidateExisting;
    }
    return _json;
  }
}

class TOauthInput {
  final TOauthBody body;
  const TOauthInput({required this.body});
  factory TOauthInput.fromJson(Map<String, dynamic> json) => TOauthInput(body: TOauthBody.fromJson(json['body'] as Map<String, dynamic>));
  Map<String, dynamic> toJson() => {'body': body.toJson()};
}

class TOauth2AuthenticateResponse {
  final v1Activity activity;
  final v1Oauth2AuthenticateResult? result;
  const TOauth2AuthenticateResponse({required this.activity, this.result,});
  factory TOauth2AuthenticateResponse.fromJson(Map<String, dynamic> json) {
    return TOauth2AuthenticateResponse(
      activity: v1Activity.fromJson(json['activity'] as Map<String, dynamic>),
      result: json.containsKey('result') && json['result'] != null ? v1Oauth2AuthenticateResult.fromJson(json['result'] as Map<String, dynamic>) : null,
    );
  }
  Map<String, dynamic> toJson() => {
    'activity': activity.toJson(),
    if (result != null) 'result': result!.toJson(),
  };
}

class TOauth2AuthenticateBody {
  final String? timestampMs;
  final String? organizationId;
  /// The OAuth 2.0 credential id whose client_id and client_secret will be used in the OAuth 2.0 flow
  final String oauth2CredentialId;
  /// The auth_code provided by the OAuth 2.0 provider to the end user to be exchanged for a Bearer token in the OAuth 2.0 flow
  final String authCode;
  /// The URI the user is redirected to after they have authenticated with the OAuth 2.0 provider
  final String redirectUri;
  /// The code verifier used by OAuth 2.0 PKCE providers
  final String codeVerifier;
  /// An optional nonce used by the client to prevent replay/substitution of an ID token
  final String? nonce;
  /// An optional P256 public key to which, if provided, the bearer token will be encrypted and returned via the `encrypted_bearer_token` claim of the OIDC Token
  final String? bearerTokenTargetPublicKey;

  const TOauth2AuthenticateBody({
     this.timestampMs,
     this.organizationId,
    required  this.oauth2CredentialId,
    required  this.authCode,
    required  this.redirectUri,
    required  this.codeVerifier,
     this.nonce,
     this.bearerTokenTargetPublicKey,
  });
  factory TOauth2AuthenticateBody.fromJson(Map<String, dynamic> json) {
    final _timestampMs = json['timestampMs'] as String?;
    final _organizationId = json['organizationId'] as String?;
    final _oauth2CredentialId = json['oauth2CredentialId'] as String;
    final _authCode = json['authCode'] as String;
    final _redirectUri = json['redirectUri'] as String;
    final _codeVerifier = json['codeVerifier'] as String;
    final _nonce = json['nonce'] as String?;
    final _bearerTokenTargetPublicKey = json['bearerTokenTargetPublicKey'] as String?;
    return TOauth2AuthenticateBody(
      timestampMs: _timestampMs,
      organizationId: _organizationId,
      oauth2CredentialId: _oauth2CredentialId,
      authCode: _authCode,
      redirectUri: _redirectUri,
      codeVerifier: _codeVerifier,
      nonce: _nonce,
      bearerTokenTargetPublicKey: _bearerTokenTargetPublicKey,
    );
  }
  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    if (timestampMs != null) {
      _json['timestampMs'] = timestampMs;
    }
    if (organizationId != null) {
      _json['organizationId'] = organizationId;
    }
    _json['oauth2CredentialId'] = oauth2CredentialId;
    _json['authCode'] = authCode;
    _json['redirectUri'] = redirectUri;
    _json['codeVerifier'] = codeVerifier;
    if (nonce != null) {
      _json['nonce'] = nonce;
    }
    if (bearerTokenTargetPublicKey != null) {
      _json['bearerTokenTargetPublicKey'] = bearerTokenTargetPublicKey;
    }
    return _json;
  }
}

class TOauth2AuthenticateInput {
  final TOauth2AuthenticateBody body;
  const TOauth2AuthenticateInput({required this.body});
  factory TOauth2AuthenticateInput.fromJson(Map<String, dynamic> json) => TOauth2AuthenticateInput(body: TOauth2AuthenticateBody.fromJson(json['body'] as Map<String, dynamic>));
  Map<String, dynamic> toJson() => {'body': body.toJson()};
}

class TOauthLoginResponse {
  final v1Activity activity;
  final v1OauthLoginResult? result;
  const TOauthLoginResponse({required this.activity, this.result,});
  factory TOauthLoginResponse.fromJson(Map<String, dynamic> json) {
    return TOauthLoginResponse(
      activity: v1Activity.fromJson(json['activity'] as Map<String, dynamic>),
      result: json.containsKey('result') && json['result'] != null ? v1OauthLoginResult.fromJson(json['result'] as Map<String, dynamic>) : null,
    );
  }
  Map<String, dynamic> toJson() => {
    'activity': activity.toJson(),
    if (result != null) 'result': result!.toJson(),
  };
}

class TOauthLoginBody {
  final String? timestampMs;
  final String? organizationId;
  /// Base64 encoded OIDC token
  final String oidcToken;
  /// Client-side public key generated by the user, which will be conditionally added to org data based on the validity of the oidc token associated with this request
  final String publicKey;
  /// Expiration window (in seconds) indicating how long the Session is valid for. If not provided, a default of 15 minutes will be used.
  final String? expirationSeconds;
  /// Invalidate all other previously generated Login API keys
  final bool? invalidateExisting;

  const TOauthLoginBody({
     this.timestampMs,
     this.organizationId,
    required  this.oidcToken,
    required  this.publicKey,
     this.expirationSeconds,
     this.invalidateExisting,
  });
  factory TOauthLoginBody.fromJson(Map<String, dynamic> json) {
    final _timestampMs = json['timestampMs'] as String?;
    final _organizationId = json['organizationId'] as String?;
    final _oidcToken = json['oidcToken'] as String;
    final _publicKey = json['publicKey'] as String;
    final _expirationSeconds = json['expirationSeconds'] as String?;
    final _invalidateExisting = json['invalidateExisting'] as bool?;
    return TOauthLoginBody(
      timestampMs: _timestampMs,
      organizationId: _organizationId,
      oidcToken: _oidcToken,
      publicKey: _publicKey,
      expirationSeconds: _expirationSeconds,
      invalidateExisting: _invalidateExisting,
    );
  }
  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    if (timestampMs != null) {
      _json['timestampMs'] = timestampMs;
    }
    if (organizationId != null) {
      _json['organizationId'] = organizationId;
    }
    _json['oidcToken'] = oidcToken;
    _json['publicKey'] = publicKey;
    if (expirationSeconds != null) {
      _json['expirationSeconds'] = expirationSeconds;
    }
    if (invalidateExisting != null) {
      _json['invalidateExisting'] = invalidateExisting;
    }
    return _json;
  }
}

class TOauthLoginInput {
  final TOauthLoginBody body;
  const TOauthLoginInput({required this.body});
  factory TOauthLoginInput.fromJson(Map<String, dynamic> json) => TOauthLoginInput(body: TOauthLoginBody.fromJson(json['body'] as Map<String, dynamic>));
  Map<String, dynamic> toJson() => {'body': body.toJson()};
}

class TOtpAuthResponse {
  final v1Activity activity;
  final v1OtpAuthResult? result;
  const TOtpAuthResponse({required this.activity, this.result,});
  factory TOtpAuthResponse.fromJson(Map<String, dynamic> json) {
    return TOtpAuthResponse(
      activity: v1Activity.fromJson(json['activity'] as Map<String, dynamic>),
      result: json.containsKey('result') && json['result'] != null ? v1OtpAuthResult.fromJson(json['result'] as Map<String, dynamic>) : null,
    );
  }
  Map<String, dynamic> toJson() => {
    'activity': activity.toJson(),
    if (result != null) 'result': result!.toJson(),
  };
}

class TOtpAuthBody {
  final String? timestampMs;
  final String? organizationId;
  /// ID representing the result of an init OTP activity.
  final String otpId;
  /// OTP sent out to a user's contact (email or SMS)
  final String otpCode;
  /// Client-side public key generated by the user, to which the OTP bundle (credentials) will be encrypted.
  final String targetPublicKey;
  /// Optional human-readable name for an API Key. If none provided, default to OTP Auth - <Timestamp>
  final String? apiKeyName;
  /// Expiration window (in seconds) indicating how long the API key is valid for. If not provided, a default of 15 minutes will be used.
  final String? expirationSeconds;
  /// Invalidate all other previously generated OTP Auth API keys
  final bool? invalidateExisting;

  const TOtpAuthBody({
     this.timestampMs,
     this.organizationId,
    required  this.otpId,
    required  this.otpCode,
    required  this.targetPublicKey,
     this.apiKeyName,
     this.expirationSeconds,
     this.invalidateExisting,
  });
  factory TOtpAuthBody.fromJson(Map<String, dynamic> json) {
    final _timestampMs = json['timestampMs'] as String?;
    final _organizationId = json['organizationId'] as String?;
    final _otpId = json['otpId'] as String;
    final _otpCode = json['otpCode'] as String;
    final _targetPublicKey = json['targetPublicKey'] as String;
    final _apiKeyName = json['apiKeyName'] as String?;
    final _expirationSeconds = json['expirationSeconds'] as String?;
    final _invalidateExisting = json['invalidateExisting'] as bool?;
    return TOtpAuthBody(
      timestampMs: _timestampMs,
      organizationId: _organizationId,
      otpId: _otpId,
      otpCode: _otpCode,
      targetPublicKey: _targetPublicKey,
      apiKeyName: _apiKeyName,
      expirationSeconds: _expirationSeconds,
      invalidateExisting: _invalidateExisting,
    );
  }
  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    if (timestampMs != null) {
      _json['timestampMs'] = timestampMs;
    }
    if (organizationId != null) {
      _json['organizationId'] = organizationId;
    }
    _json['otpId'] = otpId;
    _json['otpCode'] = otpCode;
    _json['targetPublicKey'] = targetPublicKey;
    if (apiKeyName != null) {
      _json['apiKeyName'] = apiKeyName;
    }
    if (expirationSeconds != null) {
      _json['expirationSeconds'] = expirationSeconds;
    }
    if (invalidateExisting != null) {
      _json['invalidateExisting'] = invalidateExisting;
    }
    return _json;
  }
}

class TOtpAuthInput {
  final TOtpAuthBody body;
  const TOtpAuthInput({required this.body});
  factory TOtpAuthInput.fromJson(Map<String, dynamic> json) => TOtpAuthInput(body: TOtpAuthBody.fromJson(json['body'] as Map<String, dynamic>));
  Map<String, dynamic> toJson() => {'body': body.toJson()};
}

class TOtpLoginResponse {
  final v1Activity activity;
  final v1OtpLoginResult? result;
  const TOtpLoginResponse({required this.activity, this.result,});
  factory TOtpLoginResponse.fromJson(Map<String, dynamic> json) {
    return TOtpLoginResponse(
      activity: v1Activity.fromJson(json['activity'] as Map<String, dynamic>),
      result: json.containsKey('result') && json['result'] != null ? v1OtpLoginResult.fromJson(json['result'] as Map<String, dynamic>) : null,
    );
  }
  Map<String, dynamic> toJson() => {
    'activity': activity.toJson(),
    if (result != null) 'result': result!.toJson(),
  };
}

class TOtpLoginBody {
  final String? timestampMs;
  final String? organizationId;
  /// Signed JWT containing a unique id, expiry, verification type, contact
  final String verificationToken;
  /// Client-side public key generated by the user, which will be conditionally added to org data based on the validity of the verification token
  final String publicKey;
  /// Expiration window (in seconds) indicating how long the Session is valid for. If not provided, a default of 15 minutes will be used.
  final String? expirationSeconds;
  /// Invalidate all other previously generated Login API keys
  final bool? invalidateExisting;
  /// Optional signature proving authorization for this login. The signature is over the verification token ID and the public key. Only required if a public key was provided during the verification step.
  final v1ClientSignature? clientSignature;

  const TOtpLoginBody({
     this.timestampMs,
     this.organizationId,
    required  this.verificationToken,
    required  this.publicKey,
     this.expirationSeconds,
     this.invalidateExisting,
     this.clientSignature,
  });
  factory TOtpLoginBody.fromJson(Map<String, dynamic> json) {
    final _timestampMs = json['timestampMs'] as String?;
    final _organizationId = json['organizationId'] as String?;
    final _verificationToken = json['verificationToken'] as String;
    final _publicKey = json['publicKey'] as String;
    final _expirationSeconds = json['expirationSeconds'] as String?;
    final _invalidateExisting = json['invalidateExisting'] as bool?;
    final _clientSignature = json['clientSignature'] == null ? null : v1ClientSignature.fromJson(json['clientSignature'] as Map<String, dynamic>);
    return TOtpLoginBody(
      timestampMs: _timestampMs,
      organizationId: _organizationId,
      verificationToken: _verificationToken,
      publicKey: _publicKey,
      expirationSeconds: _expirationSeconds,
      invalidateExisting: _invalidateExisting,
      clientSignature: _clientSignature,
    );
  }
  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    if (timestampMs != null) {
      _json['timestampMs'] = timestampMs;
    }
    if (organizationId != null) {
      _json['organizationId'] = organizationId;
    }
    _json['verificationToken'] = verificationToken;
    _json['publicKey'] = publicKey;
    if (expirationSeconds != null) {
      _json['expirationSeconds'] = expirationSeconds;
    }
    if (invalidateExisting != null) {
      _json['invalidateExisting'] = invalidateExisting;
    }
    if (clientSignature != null) {
      _json['clientSignature'] = clientSignature?.toJson();
    }
    return _json;
  }
}

class TOtpLoginInput {
  final TOtpLoginBody body;
  const TOtpLoginInput({required this.body});
  factory TOtpLoginInput.fromJson(Map<String, dynamic> json) => TOtpLoginInput(body: TOtpLoginBody.fromJson(json['body'] as Map<String, dynamic>));
  Map<String, dynamic> toJson() => {'body': body.toJson()};
}

class TRecoverUserResponse {
  final v1Activity activity;
  final v1RecoverUserResult? result;
  const TRecoverUserResponse({required this.activity, this.result,});
  factory TRecoverUserResponse.fromJson(Map<String, dynamic> json) {
    return TRecoverUserResponse(
      activity: v1Activity.fromJson(json['activity'] as Map<String, dynamic>),
      result: json.containsKey('result') && json['result'] != null ? v1RecoverUserResult.fromJson(json['result'] as Map<String, dynamic>) : null,
    );
  }
  Map<String, dynamic> toJson() => {
    'activity': activity.toJson(),
    if (result != null) 'result': result!.toJson(),
  };
}

class TRecoverUserBody {
  final String? timestampMs;
  final String? organizationId;
  /// The new authenticator to register.
  final v1AuthenticatorParamsV2 authenticator;
  /// Unique identifier for the user performing recovery.
  final String userId;

  const TRecoverUserBody({
     this.timestampMs,
     this.organizationId,
    required  this.authenticator,
    required  this.userId,
  });
  factory TRecoverUserBody.fromJson(Map<String, dynamic> json) {
    final _timestampMs = json['timestampMs'] as String?;
    final _organizationId = json['organizationId'] as String?;
    final _authenticator = v1AuthenticatorParamsV2.fromJson(json['authenticator'] as Map<String, dynamic>);
    final _userId = json['userId'] as String;
    return TRecoverUserBody(
      timestampMs: _timestampMs,
      organizationId: _organizationId,
      authenticator: _authenticator,
      userId: _userId,
    );
  }
  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    if (timestampMs != null) {
      _json['timestampMs'] = timestampMs;
    }
    if (organizationId != null) {
      _json['organizationId'] = organizationId;
    }
    _json['authenticator'] = authenticator.toJson();
    _json['userId'] = userId;
    return _json;
  }
}

class TRecoverUserInput {
  final TRecoverUserBody body;
  const TRecoverUserInput({required this.body});
  factory TRecoverUserInput.fromJson(Map<String, dynamic> json) => TRecoverUserInput(body: TRecoverUserBody.fromJson(json['body'] as Map<String, dynamic>));
  Map<String, dynamic> toJson() => {'body': body.toJson()};
}

class TRejectActivityResponse {
  final v1Activity activity;
  const TRejectActivityResponse({required this.activity, });
  factory TRejectActivityResponse.fromJson(Map<String, dynamic> json) {
    return TRejectActivityResponse(
      activity: v1Activity.fromJson(json['activity'] as Map<String, dynamic>),
    );
  }
  Map<String, dynamic> toJson() => {
    'activity': activity.toJson(),
  };
}

class TRejectActivityBody {
  final String? timestampMs;
  final String? organizationId;
  /// An artifact verifying a User's action.
  final String fingerprint;

  const TRejectActivityBody({
     this.timestampMs,
     this.organizationId,
    required  this.fingerprint,
  });
  factory TRejectActivityBody.fromJson(Map<String, dynamic> json) {
    final _timestampMs = json['timestampMs'] as String?;
    final _organizationId = json['organizationId'] as String?;
    final _fingerprint = json['fingerprint'] as String;
    return TRejectActivityBody(
      timestampMs: _timestampMs,
      organizationId: _organizationId,
      fingerprint: _fingerprint,
    );
  }
  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    if (timestampMs != null) {
      _json['timestampMs'] = timestampMs;
    }
    if (organizationId != null) {
      _json['organizationId'] = organizationId;
    }
    _json['fingerprint'] = fingerprint;
    return _json;
  }
}

class TRejectActivityInput {
  final TRejectActivityBody body;
  const TRejectActivityInput({required this.body});
  factory TRejectActivityInput.fromJson(Map<String, dynamic> json) => TRejectActivityInput(body: TRejectActivityBody.fromJson(json['body'] as Map<String, dynamic>));
  Map<String, dynamic> toJson() => {'body': body.toJson()};
}

class TRemoveOrganizationFeatureResponse {
  final v1Activity activity;
  final v1RemoveOrganizationFeatureResult? result;
  const TRemoveOrganizationFeatureResponse({required this.activity, this.result,});
  factory TRemoveOrganizationFeatureResponse.fromJson(Map<String, dynamic> json) {
    return TRemoveOrganizationFeatureResponse(
      activity: v1Activity.fromJson(json['activity'] as Map<String, dynamic>),
      result: json.containsKey('result') && json['result'] != null ? v1RemoveOrganizationFeatureResult.fromJson(json['result'] as Map<String, dynamic>) : null,
    );
  }
  Map<String, dynamic> toJson() => {
    'activity': activity.toJson(),
    if (result != null) 'result': result!.toJson(),
  };
}

class TRemoveOrganizationFeatureBody {
  final String? timestampMs;
  final String? organizationId;
  /// Name of the feature to remove
  final v1FeatureName name;

  const TRemoveOrganizationFeatureBody({
     this.timestampMs,
     this.organizationId,
    required  this.name,
  });
  factory TRemoveOrganizationFeatureBody.fromJson(Map<String, dynamic> json) {
    final _timestampMs = json['timestampMs'] as String?;
    final _organizationId = json['organizationId'] as String?;
    final _name = v1FeatureNameFromJson(json['name']);
    return TRemoveOrganizationFeatureBody(
      timestampMs: _timestampMs,
      organizationId: _organizationId,
      name: _name,
    );
  }
  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    if (timestampMs != null) {
      _json['timestampMs'] = timestampMs;
    }
    if (organizationId != null) {
      _json['organizationId'] = organizationId;
    }
    _json['name'] = v1FeatureNameToJson(name);
    return _json;
  }
}

class TRemoveOrganizationFeatureInput {
  final TRemoveOrganizationFeatureBody body;
  const TRemoveOrganizationFeatureInput({required this.body});
  factory TRemoveOrganizationFeatureInput.fromJson(Map<String, dynamic> json) => TRemoveOrganizationFeatureInput(body: TRemoveOrganizationFeatureBody.fromJson(json['body'] as Map<String, dynamic>));
  Map<String, dynamic> toJson() => {'body': body.toJson()};
}

class TSetOrganizationFeatureResponse {
  final v1Activity activity;
  final v1SetOrganizationFeatureResult? result;
  const TSetOrganizationFeatureResponse({required this.activity, this.result,});
  factory TSetOrganizationFeatureResponse.fromJson(Map<String, dynamic> json) {
    return TSetOrganizationFeatureResponse(
      activity: v1Activity.fromJson(json['activity'] as Map<String, dynamic>),
      result: json.containsKey('result') && json['result'] != null ? v1SetOrganizationFeatureResult.fromJson(json['result'] as Map<String, dynamic>) : null,
    );
  }
  Map<String, dynamic> toJson() => {
    'activity': activity.toJson(),
    if (result != null) 'result': result!.toJson(),
  };
}

class TSetOrganizationFeatureBody {
  final String? timestampMs;
  final String? organizationId;
  /// Name of the feature to set
  final v1FeatureName name;
  /// Optional value for the feature. Will override existing values if feature is already set.
  final String value;

  const TSetOrganizationFeatureBody({
     this.timestampMs,
     this.organizationId,
    required  this.name,
    required  this.value,
  });
  factory TSetOrganizationFeatureBody.fromJson(Map<String, dynamic> json) {
    final _timestampMs = json['timestampMs'] as String?;
    final _organizationId = json['organizationId'] as String?;
    final _name = v1FeatureNameFromJson(json['name']);
    final _value = json['value'] as String;
    return TSetOrganizationFeatureBody(
      timestampMs: _timestampMs,
      organizationId: _organizationId,
      name: _name,
      value: _value,
    );
  }
  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    if (timestampMs != null) {
      _json['timestampMs'] = timestampMs;
    }
    if (organizationId != null) {
      _json['organizationId'] = organizationId;
    }
    _json['name'] = v1FeatureNameToJson(name);
    _json['value'] = value;
    return _json;
  }
}

class TSetOrganizationFeatureInput {
  final TSetOrganizationFeatureBody body;
  const TSetOrganizationFeatureInput({required this.body});
  factory TSetOrganizationFeatureInput.fromJson(Map<String, dynamic> json) => TSetOrganizationFeatureInput(body: TSetOrganizationFeatureBody.fromJson(json['body'] as Map<String, dynamic>));
  Map<String, dynamic> toJson() => {'body': body.toJson()};
}

class TSignRawPayloadResponse {
  final v1Activity activity;
  final v1SignRawPayloadResult? result;
  const TSignRawPayloadResponse({required this.activity, this.result,});
  factory TSignRawPayloadResponse.fromJson(Map<String, dynamic> json) {
    return TSignRawPayloadResponse(
      activity: v1Activity.fromJson(json['activity'] as Map<String, dynamic>),
      result: json.containsKey('result') && json['result'] != null ? v1SignRawPayloadResult.fromJson(json['result'] as Map<String, dynamic>) : null,
    );
  }
  Map<String, dynamic> toJson() => {
    'activity': activity.toJson(),
    if (result != null) 'result': result!.toJson(),
  };
}

class TSignRawPayloadBody {
  final String? timestampMs;
  final String? organizationId;
  /// A Wallet account address, Private Key address, or Private Key identifier.
  final String signWith;
  /// Raw unsigned payload to be signed.
  final String payload;
  /// Encoding of the `payload` string. Turnkey uses this information to convert `payload` into bytes with the correct decoder (e.g. hex, utf8).
  final v1PayloadEncoding encoding;
  /// Hash function to apply to payload bytes before signing. This field must be set to HASH_FUNCTION_NOT_APPLICABLE for EdDSA/ed25519 signature requests; configurable payload hashing is not supported by RFC 8032.
  final v1HashFunction hashFunction;

  const TSignRawPayloadBody({
     this.timestampMs,
     this.organizationId,
    required  this.signWith,
    required  this.payload,
    required  this.encoding,
    required  this.hashFunction,
  });
  factory TSignRawPayloadBody.fromJson(Map<String, dynamic> json) {
    final _timestampMs = json['timestampMs'] as String?;
    final _organizationId = json['organizationId'] as String?;
    final _signWith = json['signWith'] as String;
    final _payload = json['payload'] as String;
    final _encoding = v1PayloadEncodingFromJson(json['encoding']);
    final _hashFunction = v1HashFunctionFromJson(json['hashFunction']);
    return TSignRawPayloadBody(
      timestampMs: _timestampMs,
      organizationId: _organizationId,
      signWith: _signWith,
      payload: _payload,
      encoding: _encoding,
      hashFunction: _hashFunction,
    );
  }
  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    if (timestampMs != null) {
      _json['timestampMs'] = timestampMs;
    }
    if (organizationId != null) {
      _json['organizationId'] = organizationId;
    }
    _json['signWith'] = signWith;
    _json['payload'] = payload;
    _json['encoding'] = v1PayloadEncodingToJson(encoding);
    _json['hashFunction'] = v1HashFunctionToJson(hashFunction);
    return _json;
  }
}

class TSignRawPayloadInput {
  final TSignRawPayloadBody body;
  const TSignRawPayloadInput({required this.body});
  factory TSignRawPayloadInput.fromJson(Map<String, dynamic> json) => TSignRawPayloadInput(body: TSignRawPayloadBody.fromJson(json['body'] as Map<String, dynamic>));
  Map<String, dynamic> toJson() => {'body': body.toJson()};
}

class TSignRawPayloadsResponse {
  final v1Activity activity;
  final v1SignRawPayloadsResult? result;
  const TSignRawPayloadsResponse({required this.activity, this.result,});
  factory TSignRawPayloadsResponse.fromJson(Map<String, dynamic> json) {
    return TSignRawPayloadsResponse(
      activity: v1Activity.fromJson(json['activity'] as Map<String, dynamic>),
      result: json.containsKey('result') && json['result'] != null ? v1SignRawPayloadsResult.fromJson(json['result'] as Map<String, dynamic>) : null,
    );
  }
  Map<String, dynamic> toJson() => {
    'activity': activity.toJson(),
    if (result != null) 'result': result!.toJson(),
  };
}

class TSignRawPayloadsBody {
  final String? timestampMs;
  final String? organizationId;
  /// A Wallet account address, Private Key address, or Private Key identifier.
  final String signWith;
  /// An array of raw unsigned payloads to be signed.
  final List<String> payloads;
  /// Encoding of the `payload` string. Turnkey uses this information to convert `payload` into bytes with the correct decoder (e.g. hex, utf8).
  final v1PayloadEncoding encoding;
  /// Hash function to apply to payload bytes before signing. This field must be set to HASH_FUNCTION_NOT_APPLICABLE for EdDSA/ed25519 signature requests; configurable payload hashing is not supported by RFC 8032.
  final v1HashFunction hashFunction;

  const TSignRawPayloadsBody({
     this.timestampMs,
     this.organizationId,
    required  this.signWith,
    required  this.payloads,
    required  this.encoding,
    required  this.hashFunction,
  });
  factory TSignRawPayloadsBody.fromJson(Map<String, dynamic> json) {
    final _timestampMs = json['timestampMs'] as String?;
    final _organizationId = json['organizationId'] as String?;
    final _signWith = json['signWith'] as String;
    final _payloads = (json['payloads'] as List).map((e) => e as String).toList();
    final _encoding = v1PayloadEncodingFromJson(json['encoding']);
    final _hashFunction = v1HashFunctionFromJson(json['hashFunction']);
    return TSignRawPayloadsBody(
      timestampMs: _timestampMs,
      organizationId: _organizationId,
      signWith: _signWith,
      payloads: _payloads,
      encoding: _encoding,
      hashFunction: _hashFunction,
    );
  }
  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    if (timestampMs != null) {
      _json['timestampMs'] = timestampMs;
    }
    if (organizationId != null) {
      _json['organizationId'] = organizationId;
    }
    _json['signWith'] = signWith;
    _json['payloads'] = payloads;
    _json['encoding'] = v1PayloadEncodingToJson(encoding);
    _json['hashFunction'] = v1HashFunctionToJson(hashFunction);
    return _json;
  }
}

class TSignRawPayloadsInput {
  final TSignRawPayloadsBody body;
  const TSignRawPayloadsInput({required this.body});
  factory TSignRawPayloadsInput.fromJson(Map<String, dynamic> json) => TSignRawPayloadsInput(body: TSignRawPayloadsBody.fromJson(json['body'] as Map<String, dynamic>));
  Map<String, dynamic> toJson() => {'body': body.toJson()};
}

class TSignTransactionResponse {
  final v1Activity activity;
  final v1SignTransactionResult? result;
  const TSignTransactionResponse({required this.activity, this.result,});
  factory TSignTransactionResponse.fromJson(Map<String, dynamic> json) {
    return TSignTransactionResponse(
      activity: v1Activity.fromJson(json['activity'] as Map<String, dynamic>),
      result: json.containsKey('result') && json['result'] != null ? v1SignTransactionResult.fromJson(json['result'] as Map<String, dynamic>) : null,
    );
  }
  Map<String, dynamic> toJson() => {
    'activity': activity.toJson(),
    if (result != null) 'result': result!.toJson(),
  };
}

class TSignTransactionBody {
  final String? timestampMs;
  final String? organizationId;
  /// A Wallet account address, Private Key address, or Private Key identifier.
  final String signWith;
  /// Raw unsigned transaction to be signed
  final String unsignedTransaction;
  final v1TransactionType type;

  const TSignTransactionBody({
     this.timestampMs,
     this.organizationId,
    required  this.signWith,
    required  this.unsignedTransaction,
    required  this.type,
  });
  factory TSignTransactionBody.fromJson(Map<String, dynamic> json) {
    final _timestampMs = json['timestampMs'] as String?;
    final _organizationId = json['organizationId'] as String?;
    final _signWith = json['signWith'] as String;
    final _unsignedTransaction = json['unsignedTransaction'] as String;
    final _type = v1TransactionTypeFromJson(json['type']);
    return TSignTransactionBody(
      timestampMs: _timestampMs,
      organizationId: _organizationId,
      signWith: _signWith,
      unsignedTransaction: _unsignedTransaction,
      type: _type,
    );
  }
  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    if (timestampMs != null) {
      _json['timestampMs'] = timestampMs;
    }
    if (organizationId != null) {
      _json['organizationId'] = organizationId;
    }
    _json['signWith'] = signWith;
    _json['unsignedTransaction'] = unsignedTransaction;
    _json['type'] = v1TransactionTypeToJson(type);
    return _json;
  }
}

class TSignTransactionInput {
  final TSignTransactionBody body;
  const TSignTransactionInput({required this.body});
  factory TSignTransactionInput.fromJson(Map<String, dynamic> json) => TSignTransactionInput(body: TSignTransactionBody.fromJson(json['body'] as Map<String, dynamic>));
  Map<String, dynamic> toJson() => {'body': body.toJson()};
}

class TSolSendTransactionResponse {
  final v1Activity activity;
  final v1SolSendTransactionResult? result;
  const TSolSendTransactionResponse({required this.activity, this.result,});
  factory TSolSendTransactionResponse.fromJson(Map<String, dynamic> json) {
    return TSolSendTransactionResponse(
      activity: v1Activity.fromJson(json['activity'] as Map<String, dynamic>),
      result: json.containsKey('result') && json['result'] != null ? v1SolSendTransactionResult.fromJson(json['result'] as Map<String, dynamic>) : null,
    );
  }
  Map<String, dynamic> toJson() => {
    'activity': activity.toJson(),
    if (result != null) 'result': result!.toJson(),
  };
}

class TSolSendTransactionBody {
  final String? timestampMs;
  final String? organizationId;
  /// Base64-encoded serialized unsigned Solana transaction
  final String unsignedTransaction;
  /// A wallet or private key address to sign with. This does not support private key IDs.
  final String signWith;
  /// Whether to sponsor this transaction via Gas Station.
  final bool? sponsor;
  /// CAIP-2 chain ID (e.g., 'solana:5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp' for Solana mainnet).
  final String caip2;
  /// user-provided blockhash for replay protection / deadline control. If omitted and sponsor=true, we fetch a fresh blockhash during execution
  final String? recentBlockhash;

  const TSolSendTransactionBody({
     this.timestampMs,
     this.organizationId,
    required  this.unsignedTransaction,
    required  this.signWith,
     this.sponsor,
    required  this.caip2,
     this.recentBlockhash,
  });
  factory TSolSendTransactionBody.fromJson(Map<String, dynamic> json) {
    final _timestampMs = json['timestampMs'] as String?;
    final _organizationId = json['organizationId'] as String?;
    final _unsignedTransaction = json['unsignedTransaction'] as String;
    final _signWith = json['signWith'] as String;
    final _sponsor = json['sponsor'] as bool?;
    final _caip2 = json['caip2'] as String;
    final _recentBlockhash = json['recentBlockhash'] as String?;
    return TSolSendTransactionBody(
      timestampMs: _timestampMs,
      organizationId: _organizationId,
      unsignedTransaction: _unsignedTransaction,
      signWith: _signWith,
      sponsor: _sponsor,
      caip2: _caip2,
      recentBlockhash: _recentBlockhash,
    );
  }
  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    if (timestampMs != null) {
      _json['timestampMs'] = timestampMs;
    }
    if (organizationId != null) {
      _json['organizationId'] = organizationId;
    }
    _json['unsignedTransaction'] = unsignedTransaction;
    _json['signWith'] = signWith;
    if (sponsor != null) {
      _json['sponsor'] = sponsor;
    }
    _json['caip2'] = caip2;
    if (recentBlockhash != null) {
      _json['recentBlockhash'] = recentBlockhash;
    }
    return _json;
  }
}

class TSolSendTransactionInput {
  final TSolSendTransactionBody body;
  const TSolSendTransactionInput({required this.body});
  factory TSolSendTransactionInput.fromJson(Map<String, dynamic> json) => TSolSendTransactionInput(body: TSolSendTransactionBody.fromJson(json['body'] as Map<String, dynamic>));
  Map<String, dynamic> toJson() => {'body': body.toJson()};
}

class TStampLoginResponse {
  final v1Activity activity;
  final v1StampLoginResult? result;
  const TStampLoginResponse({required this.activity, this.result,});
  factory TStampLoginResponse.fromJson(Map<String, dynamic> json) {
    return TStampLoginResponse(
      activity: v1Activity.fromJson(json['activity'] as Map<String, dynamic>),
      result: json.containsKey('result') && json['result'] != null ? v1StampLoginResult.fromJson(json['result'] as Map<String, dynamic>) : null,
    );
  }
  Map<String, dynamic> toJson() => {
    'activity': activity.toJson(),
    if (result != null) 'result': result!.toJson(),
  };
}

class TStampLoginBody {
  final String? timestampMs;
  final String? organizationId;
  /// Client-side public key generated by the user, which will be conditionally added to org data based on the passkey stamp associated with this request
  final String publicKey;
  /// Expiration window (in seconds) indicating how long the Session is valid for. If not provided, a default of 15 minutes will be used.
  final String? expirationSeconds;
  /// Invalidate all other previously generated Login API keys
  final bool? invalidateExisting;

  const TStampLoginBody({
     this.timestampMs,
     this.organizationId,
    required  this.publicKey,
     this.expirationSeconds,
     this.invalidateExisting,
  });
  factory TStampLoginBody.fromJson(Map<String, dynamic> json) {
    final _timestampMs = json['timestampMs'] as String?;
    final _organizationId = json['organizationId'] as String?;
    final _publicKey = json['publicKey'] as String;
    final _expirationSeconds = json['expirationSeconds'] as String?;
    final _invalidateExisting = json['invalidateExisting'] as bool?;
    return TStampLoginBody(
      timestampMs: _timestampMs,
      organizationId: _organizationId,
      publicKey: _publicKey,
      expirationSeconds: _expirationSeconds,
      invalidateExisting: _invalidateExisting,
    );
  }
  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    if (timestampMs != null) {
      _json['timestampMs'] = timestampMs;
    }
    if (organizationId != null) {
      _json['organizationId'] = organizationId;
    }
    _json['publicKey'] = publicKey;
    if (expirationSeconds != null) {
      _json['expirationSeconds'] = expirationSeconds;
    }
    if (invalidateExisting != null) {
      _json['invalidateExisting'] = invalidateExisting;
    }
    return _json;
  }
}

class TStampLoginInput {
  final TStampLoginBody body;
  const TStampLoginInput({required this.body});
  factory TStampLoginInput.fromJson(Map<String, dynamic> json) => TStampLoginInput(body: TStampLoginBody.fromJson(json['body'] as Map<String, dynamic>));
  Map<String, dynamic> toJson() => {'body': body.toJson()};
}

class TUpdateFiatOnRampCredentialResponse {
  final v1Activity activity;
  final v1UpdateFiatOnRampCredentialResult? result;
  const TUpdateFiatOnRampCredentialResponse({required this.activity, this.result,});
  factory TUpdateFiatOnRampCredentialResponse.fromJson(Map<String, dynamic> json) {
    return TUpdateFiatOnRampCredentialResponse(
      activity: v1Activity.fromJson(json['activity'] as Map<String, dynamic>),
      result: json.containsKey('result') && json['result'] != null ? v1UpdateFiatOnRampCredentialResult.fromJson(json['result'] as Map<String, dynamic>) : null,
    );
  }
  Map<String, dynamic> toJson() => {
    'activity': activity.toJson(),
    if (result != null) 'result': result!.toJson(),
  };
}

class TUpdateFiatOnRampCredentialBody {
  final String? timestampMs;
  final String? organizationId;
  /// The ID of the fiat on-ramp credential to update
  final String fiatOnrampCredentialId;
  /// The fiat on-ramp provider
  final v1FiatOnRampProvider onrampProvider;
  /// Project ID for the on-ramp provider. Some providers, like Coinbase, require this additional identifier.
  final String? projectId;
  /// Publishable API key for the on-ramp provider
  final String publishableApiKey;
  /// Secret API key for the on-ramp provider encrypted to our on-ramp encryption public key
  final String encryptedSecretApiKey;
  /// Private API key for the on-ramp provider encrypted to our on-ramp encryption public key. Some providers, like Coinbase, require this additional key.
  final String? encryptedPrivateApiKey;

  const TUpdateFiatOnRampCredentialBody({
     this.timestampMs,
     this.organizationId,
    required  this.fiatOnrampCredentialId,
    required  this.onrampProvider,
     this.projectId,
    required  this.publishableApiKey,
    required  this.encryptedSecretApiKey,
     this.encryptedPrivateApiKey,
  });
  factory TUpdateFiatOnRampCredentialBody.fromJson(Map<String, dynamic> json) {
    final _timestampMs = json['timestampMs'] as String?;
    final _organizationId = json['organizationId'] as String?;
    final _fiatOnrampCredentialId = json['fiatOnrampCredentialId'] as String;
    final _onrampProvider = v1FiatOnRampProviderFromJson(json['onrampProvider']);
    final _projectId = json['projectId'] as String?;
    final _publishableApiKey = json['publishableApiKey'] as String;
    final _encryptedSecretApiKey = json['encryptedSecretApiKey'] as String;
    final _encryptedPrivateApiKey = json['encryptedPrivateApiKey'] as String?;
    return TUpdateFiatOnRampCredentialBody(
      timestampMs: _timestampMs,
      organizationId: _organizationId,
      fiatOnrampCredentialId: _fiatOnrampCredentialId,
      onrampProvider: _onrampProvider,
      projectId: _projectId,
      publishableApiKey: _publishableApiKey,
      encryptedSecretApiKey: _encryptedSecretApiKey,
      encryptedPrivateApiKey: _encryptedPrivateApiKey,
    );
  }
  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    if (timestampMs != null) {
      _json['timestampMs'] = timestampMs;
    }
    if (organizationId != null) {
      _json['organizationId'] = organizationId;
    }
    _json['fiatOnrampCredentialId'] = fiatOnrampCredentialId;
    _json['onrampProvider'] = v1FiatOnRampProviderToJson(onrampProvider);
    if (projectId != null) {
      _json['projectId'] = projectId;
    }
    _json['publishableApiKey'] = publishableApiKey;
    _json['encryptedSecretApiKey'] = encryptedSecretApiKey;
    if (encryptedPrivateApiKey != null) {
      _json['encryptedPrivateApiKey'] = encryptedPrivateApiKey;
    }
    return _json;
  }
}

class TUpdateFiatOnRampCredentialInput {
  final TUpdateFiatOnRampCredentialBody body;
  const TUpdateFiatOnRampCredentialInput({required this.body});
  factory TUpdateFiatOnRampCredentialInput.fromJson(Map<String, dynamic> json) => TUpdateFiatOnRampCredentialInput(body: TUpdateFiatOnRampCredentialBody.fromJson(json['body'] as Map<String, dynamic>));
  Map<String, dynamic> toJson() => {'body': body.toJson()};
}

class TUpdateOauth2CredentialResponse {
  final v1Activity activity;
  final v1UpdateOauth2CredentialResult? result;
  const TUpdateOauth2CredentialResponse({required this.activity, this.result,});
  factory TUpdateOauth2CredentialResponse.fromJson(Map<String, dynamic> json) {
    return TUpdateOauth2CredentialResponse(
      activity: v1Activity.fromJson(json['activity'] as Map<String, dynamic>),
      result: json.containsKey('result') && json['result'] != null ? v1UpdateOauth2CredentialResult.fromJson(json['result'] as Map<String, dynamic>) : null,
    );
  }
  Map<String, dynamic> toJson() => {
    'activity': activity.toJson(),
    if (result != null) 'result': result!.toJson(),
  };
}

class TUpdateOauth2CredentialBody {
  final String? timestampMs;
  final String? organizationId;
  /// The ID of the OAuth 2.0 credential to update
  final String oauth2CredentialId;
  /// The OAuth 2.0 provider
  final v1Oauth2Provider provider;
  /// The Client ID issued by the OAuth 2.0 provider
  final String clientId;
  /// The client secret issued by the OAuth 2.0 provider encrypted to the TLS Fetcher quorum key
  final String encryptedClientSecret;

  const TUpdateOauth2CredentialBody({
     this.timestampMs,
     this.organizationId,
    required  this.oauth2CredentialId,
    required  this.provider,
    required  this.clientId,
    required  this.encryptedClientSecret,
  });
  factory TUpdateOauth2CredentialBody.fromJson(Map<String, dynamic> json) {
    final _timestampMs = json['timestampMs'] as String?;
    final _organizationId = json['organizationId'] as String?;
    final _oauth2CredentialId = json['oauth2CredentialId'] as String;
    final _provider = v1Oauth2ProviderFromJson(json['provider']);
    final _clientId = json['clientId'] as String;
    final _encryptedClientSecret = json['encryptedClientSecret'] as String;
    return TUpdateOauth2CredentialBody(
      timestampMs: _timestampMs,
      organizationId: _organizationId,
      oauth2CredentialId: _oauth2CredentialId,
      provider: _provider,
      clientId: _clientId,
      encryptedClientSecret: _encryptedClientSecret,
    );
  }
  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    if (timestampMs != null) {
      _json['timestampMs'] = timestampMs;
    }
    if (organizationId != null) {
      _json['organizationId'] = organizationId;
    }
    _json['oauth2CredentialId'] = oauth2CredentialId;
    _json['provider'] = v1Oauth2ProviderToJson(provider);
    _json['clientId'] = clientId;
    _json['encryptedClientSecret'] = encryptedClientSecret;
    return _json;
  }
}

class TUpdateOauth2CredentialInput {
  final TUpdateOauth2CredentialBody body;
  const TUpdateOauth2CredentialInput({required this.body});
  factory TUpdateOauth2CredentialInput.fromJson(Map<String, dynamic> json) => TUpdateOauth2CredentialInput(body: TUpdateOauth2CredentialBody.fromJson(json['body'] as Map<String, dynamic>));
  Map<String, dynamic> toJson() => {'body': body.toJson()};
}

class TUpdatePolicyResponse {
  final v1Activity activity;
  final v1UpdatePolicyResultV2? result;
  const TUpdatePolicyResponse({required this.activity, this.result,});
  factory TUpdatePolicyResponse.fromJson(Map<String, dynamic> json) {
    return TUpdatePolicyResponse(
      activity: v1Activity.fromJson(json['activity'] as Map<String, dynamic>),
      result: json.containsKey('result') && json['result'] != null ? v1UpdatePolicyResultV2.fromJson(json['result'] as Map<String, dynamic>) : null,
    );
  }
  Map<String, dynamic> toJson() => {
    'activity': activity.toJson(),
    if (result != null) 'result': result!.toJson(),
  };
}

class TUpdatePolicyBody {
  final String? timestampMs;
  final String? organizationId;
  /// Unique identifier for a given Policy.
  final String policyId;
  /// Human-readable name for a Policy.
  final String? policyName;
  /// The instruction to DENY or ALLOW an activity (optional).
  final v1Effect? policyEffect;
  /// The condition expression that triggers the Effect (optional).
  final String? policyCondition;
  /// The consensus expression that triggers the Effect (optional).
  final String? policyConsensus;
  /// Accompanying notes for a Policy (optional).
  final String? policyNotes;

  const TUpdatePolicyBody({
     this.timestampMs,
     this.organizationId,
    required  this.policyId,
     this.policyName,
     this.policyEffect,
     this.policyCondition,
     this.policyConsensus,
     this.policyNotes,
  });
  factory TUpdatePolicyBody.fromJson(Map<String, dynamic> json) {
    final _timestampMs = json['timestampMs'] as String?;
    final _organizationId = json['organizationId'] as String?;
    final _policyId = json['policyId'] as String;
    final _policyName = json['policyName'] as String?;
    final _policyEffect = json['policyEffect'] == null ? null : v1EffectFromJson(json['policyEffect']);
    final _policyCondition = json['policyCondition'] as String?;
    final _policyConsensus = json['policyConsensus'] as String?;
    final _policyNotes = json['policyNotes'] as String?;
    return TUpdatePolicyBody(
      timestampMs: _timestampMs,
      organizationId: _organizationId,
      policyId: _policyId,
      policyName: _policyName,
      policyEffect: _policyEffect,
      policyCondition: _policyCondition,
      policyConsensus: _policyConsensus,
      policyNotes: _policyNotes,
    );
  }
  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    if (timestampMs != null) {
      _json['timestampMs'] = timestampMs;
    }
    if (organizationId != null) {
      _json['organizationId'] = organizationId;
    }
    _json['policyId'] = policyId;
    if (policyName != null) {
      _json['policyName'] = policyName;
    }
    if (policyEffect != null) {
      _json['policyEffect'] = v1EffectToJson(policyEffect!);
    }
    if (policyCondition != null) {
      _json['policyCondition'] = policyCondition;
    }
    if (policyConsensus != null) {
      _json['policyConsensus'] = policyConsensus;
    }
    if (policyNotes != null) {
      _json['policyNotes'] = policyNotes;
    }
    return _json;
  }
}

class TUpdatePolicyInput {
  final TUpdatePolicyBody body;
  const TUpdatePolicyInput({required this.body});
  factory TUpdatePolicyInput.fromJson(Map<String, dynamic> json) => TUpdatePolicyInput(body: TUpdatePolicyBody.fromJson(json['body'] as Map<String, dynamic>));
  Map<String, dynamic> toJson() => {'body': body.toJson()};
}

class TUpdatePrivateKeyTagResponse {
  final v1Activity activity;
  final v1UpdatePrivateKeyTagResult? result;
  const TUpdatePrivateKeyTagResponse({required this.activity, this.result,});
  factory TUpdatePrivateKeyTagResponse.fromJson(Map<String, dynamic> json) {
    return TUpdatePrivateKeyTagResponse(
      activity: v1Activity.fromJson(json['activity'] as Map<String, dynamic>),
      result: json.containsKey('result') && json['result'] != null ? v1UpdatePrivateKeyTagResult.fromJson(json['result'] as Map<String, dynamic>) : null,
    );
  }
  Map<String, dynamic> toJson() => {
    'activity': activity.toJson(),
    if (result != null) 'result': result!.toJson(),
  };
}

class TUpdatePrivateKeyTagBody {
  final String? timestampMs;
  final String? organizationId;
  /// Unique identifier for a given Private Key Tag.
  final String privateKeyTagId;
  /// The new, human-readable name for the tag with the given ID.
  final String? newPrivateKeyTagName;
  /// A list of Private Keys IDs to add this tag to.
  final List<String> addPrivateKeyIds;
  /// A list of Private Key IDs to remove this tag from.
  final List<String> removePrivateKeyIds;

  const TUpdatePrivateKeyTagBody({
     this.timestampMs,
     this.organizationId,
    required  this.privateKeyTagId,
     this.newPrivateKeyTagName,
    required  this.addPrivateKeyIds,
    required  this.removePrivateKeyIds,
  });
  factory TUpdatePrivateKeyTagBody.fromJson(Map<String, dynamic> json) {
    final _timestampMs = json['timestampMs'] as String?;
    final _organizationId = json['organizationId'] as String?;
    final _privateKeyTagId = json['privateKeyTagId'] as String;
    final _newPrivateKeyTagName = json['newPrivateKeyTagName'] as String?;
    final _addPrivateKeyIds = (json['addPrivateKeyIds'] as List).map((e) => e as String).toList();
    final _removePrivateKeyIds = (json['removePrivateKeyIds'] as List).map((e) => e as String).toList();
    return TUpdatePrivateKeyTagBody(
      timestampMs: _timestampMs,
      organizationId: _organizationId,
      privateKeyTagId: _privateKeyTagId,
      newPrivateKeyTagName: _newPrivateKeyTagName,
      addPrivateKeyIds: _addPrivateKeyIds,
      removePrivateKeyIds: _removePrivateKeyIds,
    );
  }
  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    if (timestampMs != null) {
      _json['timestampMs'] = timestampMs;
    }
    if (organizationId != null) {
      _json['organizationId'] = organizationId;
    }
    _json['privateKeyTagId'] = privateKeyTagId;
    if (newPrivateKeyTagName != null) {
      _json['newPrivateKeyTagName'] = newPrivateKeyTagName;
    }
    _json['addPrivateKeyIds'] = addPrivateKeyIds;
    _json['removePrivateKeyIds'] = removePrivateKeyIds;
    return _json;
  }
}

class TUpdatePrivateKeyTagInput {
  final TUpdatePrivateKeyTagBody body;
  const TUpdatePrivateKeyTagInput({required this.body});
  factory TUpdatePrivateKeyTagInput.fromJson(Map<String, dynamic> json) => TUpdatePrivateKeyTagInput(body: TUpdatePrivateKeyTagBody.fromJson(json['body'] as Map<String, dynamic>));
  Map<String, dynamic> toJson() => {'body': body.toJson()};
}

class TUpdateRootQuorumResponse {
  final v1Activity activity;
  final v1UpdateRootQuorumResult? result;
  const TUpdateRootQuorumResponse({required this.activity, this.result,});
  factory TUpdateRootQuorumResponse.fromJson(Map<String, dynamic> json) {
    return TUpdateRootQuorumResponse(
      activity: v1Activity.fromJson(json['activity'] as Map<String, dynamic>),
      result: json.containsKey('result') && json['result'] != null ? v1UpdateRootQuorumResult.fromJson(json['result'] as Map<String, dynamic>) : null,
    );
  }
  Map<String, dynamic> toJson() => {
    'activity': activity.toJson(),
    if (result != null) 'result': result!.toJson(),
  };
}

class TUpdateRootQuorumBody {
  final String? timestampMs;
  final String? organizationId;
  /// The threshold of unique approvals to reach quorum.
  final num threshold;
  /// The unique identifiers of users who comprise the quorum set.
  final List<String> userIds;

  const TUpdateRootQuorumBody({
     this.timestampMs,
     this.organizationId,
    required  this.threshold,
    required  this.userIds,
  });
  factory TUpdateRootQuorumBody.fromJson(Map<String, dynamic> json) {
    final _timestampMs = json['timestampMs'] as String?;
    final _organizationId = json['organizationId'] as String?;
    final _threshold = json['threshold'] as num;
    final _userIds = (json['userIds'] as List).map((e) => e as String).toList();
    return TUpdateRootQuorumBody(
      timestampMs: _timestampMs,
      organizationId: _organizationId,
      threshold: _threshold,
      userIds: _userIds,
    );
  }
  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    if (timestampMs != null) {
      _json['timestampMs'] = timestampMs;
    }
    if (organizationId != null) {
      _json['organizationId'] = organizationId;
    }
    _json['threshold'] = threshold;
    _json['userIds'] = userIds;
    return _json;
  }
}

class TUpdateRootQuorumInput {
  final TUpdateRootQuorumBody body;
  const TUpdateRootQuorumInput({required this.body});
  factory TUpdateRootQuorumInput.fromJson(Map<String, dynamic> json) => TUpdateRootQuorumInput(body: TUpdateRootQuorumBody.fromJson(json['body'] as Map<String, dynamic>));
  Map<String, dynamic> toJson() => {'body': body.toJson()};
}

class TUpdateUserResponse {
  final v1Activity activity;
  final v1UpdateUserResult? result;
  const TUpdateUserResponse({required this.activity, this.result,});
  factory TUpdateUserResponse.fromJson(Map<String, dynamic> json) {
    return TUpdateUserResponse(
      activity: v1Activity.fromJson(json['activity'] as Map<String, dynamic>),
      result: json.containsKey('result') && json['result'] != null ? v1UpdateUserResult.fromJson(json['result'] as Map<String, dynamic>) : null,
    );
  }
  Map<String, dynamic> toJson() => {
    'activity': activity.toJson(),
    if (result != null) 'result': result!.toJson(),
  };
}

class TUpdateUserBody {
  final String? timestampMs;
  final String? organizationId;
  /// Unique identifier for a given User.
  final String userId;
  /// Human-readable name for a User.
  final String? userName;
  /// The user's email address.
  final String? userEmail;
  /// An updated list of User Tags to apply to this User. This field, if not needed, should be an empty array in your request body.
  final List<String>? userTagIds;
  /// The user's phone number in E.164 format e.g. +13214567890
  final String? userPhoneNumber;

  const TUpdateUserBody({
     this.timestampMs,
     this.organizationId,
    required  this.userId,
     this.userName,
     this.userEmail,
     this.userTagIds,
     this.userPhoneNumber,
  });
  factory TUpdateUserBody.fromJson(Map<String, dynamic> json) {
    final _timestampMs = json['timestampMs'] as String?;
    final _organizationId = json['organizationId'] as String?;
    final _userId = json['userId'] as String;
    final _userName = json['userName'] as String?;
    final _userEmail = json['userEmail'] as String?;
    final _userTagIds = (json['userTagIds'] as List?)?.map((e) => e as String).toList();
    final _userPhoneNumber = json['userPhoneNumber'] as String?;
    return TUpdateUserBody(
      timestampMs: _timestampMs,
      organizationId: _organizationId,
      userId: _userId,
      userName: _userName,
      userEmail: _userEmail,
      userTagIds: _userTagIds,
      userPhoneNumber: _userPhoneNumber,
    );
  }
  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    if (timestampMs != null) {
      _json['timestampMs'] = timestampMs;
    }
    if (organizationId != null) {
      _json['organizationId'] = organizationId;
    }
    _json['userId'] = userId;
    if (userName != null) {
      _json['userName'] = userName;
    }
    if (userEmail != null) {
      _json['userEmail'] = userEmail;
    }
    if (userTagIds != null) {
      _json['userTagIds'] = userTagIds;
    }
    if (userPhoneNumber != null) {
      _json['userPhoneNumber'] = userPhoneNumber;
    }
    return _json;
  }
}

class TUpdateUserInput {
  final TUpdateUserBody body;
  const TUpdateUserInput({required this.body});
  factory TUpdateUserInput.fromJson(Map<String, dynamic> json) => TUpdateUserInput(body: TUpdateUserBody.fromJson(json['body'] as Map<String, dynamic>));
  Map<String, dynamic> toJson() => {'body': body.toJson()};
}

class TUpdateUserEmailResponse {
  final v1Activity activity;
  final v1UpdateUserEmailResult? result;
  const TUpdateUserEmailResponse({required this.activity, this.result,});
  factory TUpdateUserEmailResponse.fromJson(Map<String, dynamic> json) {
    return TUpdateUserEmailResponse(
      activity: v1Activity.fromJson(json['activity'] as Map<String, dynamic>),
      result: json.containsKey('result') && json['result'] != null ? v1UpdateUserEmailResult.fromJson(json['result'] as Map<String, dynamic>) : null,
    );
  }
  Map<String, dynamic> toJson() => {
    'activity': activity.toJson(),
    if (result != null) 'result': result!.toJson(),
  };
}

class TUpdateUserEmailBody {
  final String? timestampMs;
  final String? organizationId;
  /// Unique identifier for a given User.
  final String userId;
  /// The user's email address. Setting this to an empty string will remove the user's email.
  final String userEmail;
  /// Signed JWT containing a unique id, expiry, verification type, contact
  final String? verificationToken;

  const TUpdateUserEmailBody({
     this.timestampMs,
     this.organizationId,
    required  this.userId,
    required  this.userEmail,
     this.verificationToken,
  });
  factory TUpdateUserEmailBody.fromJson(Map<String, dynamic> json) {
    final _timestampMs = json['timestampMs'] as String?;
    final _organizationId = json['organizationId'] as String?;
    final _userId = json['userId'] as String;
    final _userEmail = json['userEmail'] as String;
    final _verificationToken = json['verificationToken'] as String?;
    return TUpdateUserEmailBody(
      timestampMs: _timestampMs,
      organizationId: _organizationId,
      userId: _userId,
      userEmail: _userEmail,
      verificationToken: _verificationToken,
    );
  }
  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    if (timestampMs != null) {
      _json['timestampMs'] = timestampMs;
    }
    if (organizationId != null) {
      _json['organizationId'] = organizationId;
    }
    _json['userId'] = userId;
    _json['userEmail'] = userEmail;
    if (verificationToken != null) {
      _json['verificationToken'] = verificationToken;
    }
    return _json;
  }
}

class TUpdateUserEmailInput {
  final TUpdateUserEmailBody body;
  const TUpdateUserEmailInput({required this.body});
  factory TUpdateUserEmailInput.fromJson(Map<String, dynamic> json) => TUpdateUserEmailInput(body: TUpdateUserEmailBody.fromJson(json['body'] as Map<String, dynamic>));
  Map<String, dynamic> toJson() => {'body': body.toJson()};
}

class TUpdateUserNameResponse {
  final v1Activity activity;
  final v1UpdateUserNameResult? result;
  const TUpdateUserNameResponse({required this.activity, this.result,});
  factory TUpdateUserNameResponse.fromJson(Map<String, dynamic> json) {
    return TUpdateUserNameResponse(
      activity: v1Activity.fromJson(json['activity'] as Map<String, dynamic>),
      result: json.containsKey('result') && json['result'] != null ? v1UpdateUserNameResult.fromJson(json['result'] as Map<String, dynamic>) : null,
    );
  }
  Map<String, dynamic> toJson() => {
    'activity': activity.toJson(),
    if (result != null) 'result': result!.toJson(),
  };
}

class TUpdateUserNameBody {
  final String? timestampMs;
  final String? organizationId;
  /// Unique identifier for a given User.
  final String userId;
  /// Human-readable name for a User.
  final String userName;

  const TUpdateUserNameBody({
     this.timestampMs,
     this.organizationId,
    required  this.userId,
    required  this.userName,
  });
  factory TUpdateUserNameBody.fromJson(Map<String, dynamic> json) {
    final _timestampMs = json['timestampMs'] as String?;
    final _organizationId = json['organizationId'] as String?;
    final _userId = json['userId'] as String;
    final _userName = json['userName'] as String;
    return TUpdateUserNameBody(
      timestampMs: _timestampMs,
      organizationId: _organizationId,
      userId: _userId,
      userName: _userName,
    );
  }
  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    if (timestampMs != null) {
      _json['timestampMs'] = timestampMs;
    }
    if (organizationId != null) {
      _json['organizationId'] = organizationId;
    }
    _json['userId'] = userId;
    _json['userName'] = userName;
    return _json;
  }
}

class TUpdateUserNameInput {
  final TUpdateUserNameBody body;
  const TUpdateUserNameInput({required this.body});
  factory TUpdateUserNameInput.fromJson(Map<String, dynamic> json) => TUpdateUserNameInput(body: TUpdateUserNameBody.fromJson(json['body'] as Map<String, dynamic>));
  Map<String, dynamic> toJson() => {'body': body.toJson()};
}

class TUpdateUserPhoneNumberResponse {
  final v1Activity activity;
  final v1UpdateUserPhoneNumberResult? result;
  const TUpdateUserPhoneNumberResponse({required this.activity, this.result,});
  factory TUpdateUserPhoneNumberResponse.fromJson(Map<String, dynamic> json) {
    return TUpdateUserPhoneNumberResponse(
      activity: v1Activity.fromJson(json['activity'] as Map<String, dynamic>),
      result: json.containsKey('result') && json['result'] != null ? v1UpdateUserPhoneNumberResult.fromJson(json['result'] as Map<String, dynamic>) : null,
    );
  }
  Map<String, dynamic> toJson() => {
    'activity': activity.toJson(),
    if (result != null) 'result': result!.toJson(),
  };
}

class TUpdateUserPhoneNumberBody {
  final String? timestampMs;
  final String? organizationId;
  /// Unique identifier for a given User.
  final String userId;
  /// The user's phone number in E.164 format e.g. +13214567890. Setting this to an empty string will remove the user's phone number.
  final String userPhoneNumber;
  /// Signed JWT containing a unique id, expiry, verification type, contact
  final String? verificationToken;

  const TUpdateUserPhoneNumberBody({
     this.timestampMs,
     this.organizationId,
    required  this.userId,
    required  this.userPhoneNumber,
     this.verificationToken,
  });
  factory TUpdateUserPhoneNumberBody.fromJson(Map<String, dynamic> json) {
    final _timestampMs = json['timestampMs'] as String?;
    final _organizationId = json['organizationId'] as String?;
    final _userId = json['userId'] as String;
    final _userPhoneNumber = json['userPhoneNumber'] as String;
    final _verificationToken = json['verificationToken'] as String?;
    return TUpdateUserPhoneNumberBody(
      timestampMs: _timestampMs,
      organizationId: _organizationId,
      userId: _userId,
      userPhoneNumber: _userPhoneNumber,
      verificationToken: _verificationToken,
    );
  }
  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    if (timestampMs != null) {
      _json['timestampMs'] = timestampMs;
    }
    if (organizationId != null) {
      _json['organizationId'] = organizationId;
    }
    _json['userId'] = userId;
    _json['userPhoneNumber'] = userPhoneNumber;
    if (verificationToken != null) {
      _json['verificationToken'] = verificationToken;
    }
    return _json;
  }
}

class TUpdateUserPhoneNumberInput {
  final TUpdateUserPhoneNumberBody body;
  const TUpdateUserPhoneNumberInput({required this.body});
  factory TUpdateUserPhoneNumberInput.fromJson(Map<String, dynamic> json) => TUpdateUserPhoneNumberInput(body: TUpdateUserPhoneNumberBody.fromJson(json['body'] as Map<String, dynamic>));
  Map<String, dynamic> toJson() => {'body': body.toJson()};
}

class TUpdateUserTagResponse {
  final v1Activity activity;
  final v1UpdateUserTagResult? result;
  const TUpdateUserTagResponse({required this.activity, this.result,});
  factory TUpdateUserTagResponse.fromJson(Map<String, dynamic> json) {
    return TUpdateUserTagResponse(
      activity: v1Activity.fromJson(json['activity'] as Map<String, dynamic>),
      result: json.containsKey('result') && json['result'] != null ? v1UpdateUserTagResult.fromJson(json['result'] as Map<String, dynamic>) : null,
    );
  }
  Map<String, dynamic> toJson() => {
    'activity': activity.toJson(),
    if (result != null) 'result': result!.toJson(),
  };
}

class TUpdateUserTagBody {
  final String? timestampMs;
  final String? organizationId;
  /// Unique identifier for a given User Tag.
  final String userTagId;
  /// The new, human-readable name for the tag with the given ID.
  final String? newUserTagName;
  /// A list of User IDs to add this tag to.
  final List<String> addUserIds;
  /// A list of User IDs to remove this tag from.
  final List<String> removeUserIds;

  const TUpdateUserTagBody({
     this.timestampMs,
     this.organizationId,
    required  this.userTagId,
     this.newUserTagName,
    required  this.addUserIds,
    required  this.removeUserIds,
  });
  factory TUpdateUserTagBody.fromJson(Map<String, dynamic> json) {
    final _timestampMs = json['timestampMs'] as String?;
    final _organizationId = json['organizationId'] as String?;
    final _userTagId = json['userTagId'] as String;
    final _newUserTagName = json['newUserTagName'] as String?;
    final _addUserIds = (json['addUserIds'] as List).map((e) => e as String).toList();
    final _removeUserIds = (json['removeUserIds'] as List).map((e) => e as String).toList();
    return TUpdateUserTagBody(
      timestampMs: _timestampMs,
      organizationId: _organizationId,
      userTagId: _userTagId,
      newUserTagName: _newUserTagName,
      addUserIds: _addUserIds,
      removeUserIds: _removeUserIds,
    );
  }
  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    if (timestampMs != null) {
      _json['timestampMs'] = timestampMs;
    }
    if (organizationId != null) {
      _json['organizationId'] = organizationId;
    }
    _json['userTagId'] = userTagId;
    if (newUserTagName != null) {
      _json['newUserTagName'] = newUserTagName;
    }
    _json['addUserIds'] = addUserIds;
    _json['removeUserIds'] = removeUserIds;
    return _json;
  }
}

class TUpdateUserTagInput {
  final TUpdateUserTagBody body;
  const TUpdateUserTagInput({required this.body});
  factory TUpdateUserTagInput.fromJson(Map<String, dynamic> json) => TUpdateUserTagInput(body: TUpdateUserTagBody.fromJson(json['body'] as Map<String, dynamic>));
  Map<String, dynamic> toJson() => {'body': body.toJson()};
}

class TUpdateWalletResponse {
  final v1Activity activity;
  final v1UpdateWalletResult? result;
  const TUpdateWalletResponse({required this.activity, this.result,});
  factory TUpdateWalletResponse.fromJson(Map<String, dynamic> json) {
    return TUpdateWalletResponse(
      activity: v1Activity.fromJson(json['activity'] as Map<String, dynamic>),
      result: json.containsKey('result') && json['result'] != null ? v1UpdateWalletResult.fromJson(json['result'] as Map<String, dynamic>) : null,
    );
  }
  Map<String, dynamic> toJson() => {
    'activity': activity.toJson(),
    if (result != null) 'result': result!.toJson(),
  };
}

class TUpdateWalletBody {
  final String? timestampMs;
  final String? organizationId;
  /// Unique identifier for a given Wallet.
  final String walletId;
  /// Human-readable name for a Wallet.
  final String? walletName;

  const TUpdateWalletBody({
     this.timestampMs,
     this.organizationId,
    required  this.walletId,
     this.walletName,
  });
  factory TUpdateWalletBody.fromJson(Map<String, dynamic> json) {
    final _timestampMs = json['timestampMs'] as String?;
    final _organizationId = json['organizationId'] as String?;
    final _walletId = json['walletId'] as String;
    final _walletName = json['walletName'] as String?;
    return TUpdateWalletBody(
      timestampMs: _timestampMs,
      organizationId: _organizationId,
      walletId: _walletId,
      walletName: _walletName,
    );
  }
  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    if (timestampMs != null) {
      _json['timestampMs'] = timestampMs;
    }
    if (organizationId != null) {
      _json['organizationId'] = organizationId;
    }
    _json['walletId'] = walletId;
    if (walletName != null) {
      _json['walletName'] = walletName;
    }
    return _json;
  }
}

class TUpdateWalletInput {
  final TUpdateWalletBody body;
  const TUpdateWalletInput({required this.body});
  factory TUpdateWalletInput.fromJson(Map<String, dynamic> json) => TUpdateWalletInput(body: TUpdateWalletBody.fromJson(json['body'] as Map<String, dynamic>));
  Map<String, dynamic> toJson() => {'body': body.toJson()};
}

class TVerifyOtpResponse {
  final v1Activity activity;
  final v1VerifyOtpResult? result;
  const TVerifyOtpResponse({required this.activity, this.result,});
  factory TVerifyOtpResponse.fromJson(Map<String, dynamic> json) {
    return TVerifyOtpResponse(
      activity: v1Activity.fromJson(json['activity'] as Map<String, dynamic>),
      result: json.containsKey('result') && json['result'] != null ? v1VerifyOtpResult.fromJson(json['result'] as Map<String, dynamic>) : null,
    );
  }
  Map<String, dynamic> toJson() => {
    'activity': activity.toJson(),
    if (result != null) 'result': result!.toJson(),
  };
}

class TVerifyOtpBody {
  final String? timestampMs;
  final String? organizationId;
  /// ID representing the result of an init OTP activity.
  final String otpId;
  /// OTP sent out to a user's contact (email or SMS)
  final String otpCode;
  /// Expiration window (in seconds) indicating how long the verification token is valid for. If not provided, a default of 1 hour will be used. Maximum value is 86400 seconds (24 hours)
  final String? expirationSeconds;
  /// Client-side public key generated by the user, which will be added to the JWT response and verified in subsequent requests via a client proof signature
  final String? publicKey;

  const TVerifyOtpBody({
     this.timestampMs,
     this.organizationId,
    required  this.otpId,
    required  this.otpCode,
     this.expirationSeconds,
     this.publicKey,
  });
  factory TVerifyOtpBody.fromJson(Map<String, dynamic> json) {
    final _timestampMs = json['timestampMs'] as String?;
    final _organizationId = json['organizationId'] as String?;
    final _otpId = json['otpId'] as String;
    final _otpCode = json['otpCode'] as String;
    final _expirationSeconds = json['expirationSeconds'] as String?;
    final _publicKey = json['publicKey'] as String?;
    return TVerifyOtpBody(
      timestampMs: _timestampMs,
      organizationId: _organizationId,
      otpId: _otpId,
      otpCode: _otpCode,
      expirationSeconds: _expirationSeconds,
      publicKey: _publicKey,
    );
  }
  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    if (timestampMs != null) {
      _json['timestampMs'] = timestampMs;
    }
    if (organizationId != null) {
      _json['organizationId'] = organizationId;
    }
    _json['otpId'] = otpId;
    _json['otpCode'] = otpCode;
    if (expirationSeconds != null) {
      _json['expirationSeconds'] = expirationSeconds;
    }
    if (publicKey != null) {
      _json['publicKey'] = publicKey;
    }
    return _json;
  }
}

class TVerifyOtpInput {
  final TVerifyOtpBody body;
  const TVerifyOtpInput({required this.body});
  factory TVerifyOtpInput.fromJson(Map<String, dynamic> json) => TVerifyOtpInput(body: TVerifyOtpBody.fromJson(json['body'] as Map<String, dynamic>));
  Map<String, dynamic> toJson() => {'body': body.toJson()};
}

class TNOOPCodegenAnchorResponse {
  final v1WebAuthnStamp stamp;
  final v1TokenUsage? tokenUsage;

  const TNOOPCodegenAnchorResponse({
    required  this.stamp,
     this.tokenUsage,
  });

  factory TNOOPCodegenAnchorResponse.fromJson(Map<String, dynamic> json) {
    final _stamp = v1WebAuthnStamp.fromJson(json['stamp'] as Map<String, dynamic>);
    final _tokenUsage = json['tokenUsage'] == null ? null : v1TokenUsage.fromJson(json['tokenUsage'] as Map<String, dynamic>);
    return TNOOPCodegenAnchorResponse(
      stamp: _stamp,
      tokenUsage: _tokenUsage,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['stamp'] = stamp.toJson();
    if (tokenUsage != null) {
      _json['tokenUsage'] = tokenUsage?.toJson();
    }
    return _json;
  }
}

class TNOOPCodegenAnchorBody {
  const TNOOPCodegenAnchorBody();
  factory TNOOPCodegenAnchorBody.fromJson(Map<String, dynamic> json) => const TNOOPCodegenAnchorBody();
  Map<String, dynamic> toJson() => {};
}

class TNOOPCodegenAnchorInput {
  final TNOOPCodegenAnchorBody body;
  const TNOOPCodegenAnchorInput({required this.body});
  factory TNOOPCodegenAnchorInput.fromJson(Map<String, dynamic> json) => TNOOPCodegenAnchorInput(body: json['body'] is Map<String, dynamic> ? TNOOPCodegenAnchorBody.fromJson(json['body'] as Map<String, dynamic>) : const TNOOPCodegenAnchorBody());
  Map<String, dynamic> toJson() => {'body': body.toJson()};
}

class TRefreshFeatureFlagsResponse {
  final v1Activity activity;
  const TRefreshFeatureFlagsResponse({required this.activity, });
  factory TRefreshFeatureFlagsResponse.fromJson(Map<String, dynamic> json) {
    return TRefreshFeatureFlagsResponse(
      activity: v1Activity.fromJson(json['activity'] as Map<String, dynamic>),
    );
  }
  Map<String, dynamic> toJson() => {
    'activity': activity.toJson(),
  };
}

class TRefreshFeatureFlagsBody {
  final String? timestampMs;
  final String? organizationId;

  const TRefreshFeatureFlagsBody({
     this.timestampMs,
     this.organizationId,
  });
  factory TRefreshFeatureFlagsBody.fromJson(Map<String, dynamic> json) {
    final _timestampMs = json['timestampMs'] as String?;
    final _organizationId = json['organizationId'] as String?;
    return TRefreshFeatureFlagsBody(
      timestampMs: _timestampMs,
      organizationId: _organizationId,
    );
  }
  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    if (timestampMs != null) {
      _json['timestampMs'] = timestampMs;
    }
    if (organizationId != null) {
      _json['organizationId'] = organizationId;
    }
    return _json;
  }
}

class TRefreshFeatureFlagsInput {
  final TRefreshFeatureFlagsBody body;
  const TRefreshFeatureFlagsInput({required this.body});
  factory TRefreshFeatureFlagsInput.fromJson(Map<String, dynamic> json) => TRefreshFeatureFlagsInput(body: TRefreshFeatureFlagsBody.fromJson(json['body'] as Map<String, dynamic>));
  Map<String, dynamic> toJson() => {'body': body.toJson()};
}

class TTestRateLimitsResponse {
  const TTestRateLimitsResponse();
  factory TTestRateLimitsResponse.fromJson(Map<String, dynamic> json) => const TTestRateLimitsResponse();
  Map<String, dynamic> toJson() => {};
}

class TTestRateLimitsBody {
  final String? organizationId;
  /// Whether or not to set a limit on this request.
  final bool isSetLimit;
  /// Rate limit to set for org, if is_set_limit is set to true.
  final num limit;

  const TTestRateLimitsBody({
     this.organizationId,
    required  this.isSetLimit,
    required  this.limit,
  });
  factory TTestRateLimitsBody.fromJson(Map<String, dynamic> json) {
    final _organizationId = json['organizationId'] as String?;
    final _isSetLimit = json['isSetLimit'] as bool;
    final _limit = json['limit'] as num;
    return TTestRateLimitsBody(
      organizationId: _organizationId,
      isSetLimit: _isSetLimit,
      limit: _limit,
    );
  }
  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    if (organizationId != null) {
      _json['organizationId'] = organizationId;
    }
    _json['isSetLimit'] = isSetLimit;
    _json['limit'] = limit;
    return _json;
  }
}

class TTestRateLimitsInput {
  final TTestRateLimitsBody body;
  const TTestRateLimitsInput({required this.body});
  factory TTestRateLimitsInput.fromJson(Map<String, dynamic> json) => TTestRateLimitsInput(body: TTestRateLimitsBody.fromJson(json['body'] as Map<String, dynamic>));
  Map<String, dynamic> toJson() => {'body': body.toJson()};
}

class ProxyTGetAccountResponse {
  final String? organizationId;

  const ProxyTGetAccountResponse({
     this.organizationId,
  });

  factory ProxyTGetAccountResponse.fromJson(Map<String, dynamic> json) {
    final _organizationId = json['organizationId'] as String?;
    return ProxyTGetAccountResponse(
      organizationId: _organizationId,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    if (organizationId != null) {
      _json['organizationId'] = organizationId;
    }
    return _json;
  }
}

class ProxyTGetAccountBody {
  /// Specifies the type of filter to apply, i.e 'CREDENTIAL_ID', 'NAME', 'USERNAME', 'EMAIL', 'PHONE_NUMBER', 'OIDC_TOKEN' or 'PUBLIC_KEY'
  final String filterType;
  /// The value of the filter to apply for the specified type. For example, a specific email or name string.
  final String filterValue;
  /// Signed JWT containing a unique id, expiry, verification type, contact. Used to verify access to PII (email/phone number) when filter_type is 'EMAIL' or 'PHONE_NUMBER'.
  final String? verificationToken;

  const ProxyTGetAccountBody({
    required  this.filterType,
    required  this.filterValue,
     this.verificationToken,
  });
  factory ProxyTGetAccountBody.fromJson(Map<String, dynamic> json) {
    final _filterType = json['filterType'] as String;
    final _filterValue = json['filterValue'] as String;
    final _verificationToken = json['verificationToken'] as String?;
    return ProxyTGetAccountBody(
      filterType: _filterType,
      filterValue: _filterValue,
      verificationToken: _verificationToken,
    );
  }
  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['filterType'] = filterType;
    _json['filterValue'] = filterValue;
    if (verificationToken != null) {
      _json['verificationToken'] = verificationToken;
    }
    return _json;
  }
}

class ProxyTGetAccountInput {
  final ProxyTGetAccountBody body;
  const ProxyTGetAccountInput({required this.body});
  factory ProxyTGetAccountInput.fromJson(Map<String, dynamic> json) => ProxyTGetAccountInput(body: ProxyTGetAccountBody.fromJson(json['body'] as Map<String, dynamic>));
  Map<String, dynamic> toJson() => {'body': body.toJson()};
}

class ProxyTOAuth2AuthenticateResponse {
  /// A Turnkey issued OIDC token to be used with the LoginWithOAuth activity
  final String oidcToken;

  const ProxyTOAuth2AuthenticateResponse({
    required  this.oidcToken,
  });

  factory ProxyTOAuth2AuthenticateResponse.fromJson(Map<String, dynamic> json) {
    final _oidcToken = json['oidcToken'] as String;
    return ProxyTOAuth2AuthenticateResponse(
      oidcToken: _oidcToken,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['oidcToken'] = oidcToken;
    return _json;
  }
}

class ProxyTOAuth2AuthenticateBody {
  /// The OAuth 2.0 provider to authenticate with
  final v1Oauth2Provider provider;
  /// The auth_code provided by the OAuth 2.0 to the end user to be exchanged for a Bearer token in the OAuth 2.0 flow
  final String authCode;
  /// The URI the user is redirected to after they have authenticated with the OAuth 2.0 provider
  final String redirectUri;
  /// The code verifier used by OAuth 2.0 PKCE providers
  final String codeVerifier;
  /// An optional nonce used by the client to prevent replay/substitution of an ID token
  final String? nonce;
  /// The client ID registered with the OAuth 2.0 provider
  final String clientId;

  const ProxyTOAuth2AuthenticateBody({
    required  this.provider,
    required  this.authCode,
    required  this.redirectUri,
    required  this.codeVerifier,
     this.nonce,
    required  this.clientId,
  });
  factory ProxyTOAuth2AuthenticateBody.fromJson(Map<String, dynamic> json) {
    final _provider = v1Oauth2ProviderFromJson(json['provider']);
    final _authCode = json['authCode'] as String;
    final _redirectUri = json['redirectUri'] as String;
    final _codeVerifier = json['codeVerifier'] as String;
    final _nonce = json['nonce'] as String?;
    final _clientId = json['clientId'] as String;
    return ProxyTOAuth2AuthenticateBody(
      provider: _provider,
      authCode: _authCode,
      redirectUri: _redirectUri,
      codeVerifier: _codeVerifier,
      nonce: _nonce,
      clientId: _clientId,
    );
  }
  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['provider'] = v1Oauth2ProviderToJson(provider);
    _json['authCode'] = authCode;
    _json['redirectUri'] = redirectUri;
    _json['codeVerifier'] = codeVerifier;
    if (nonce != null) {
      _json['nonce'] = nonce;
    }
    _json['clientId'] = clientId;
    return _json;
  }
}

class ProxyTOAuth2AuthenticateInput {
  final ProxyTOAuth2AuthenticateBody body;
  const ProxyTOAuth2AuthenticateInput({required this.body});
  factory ProxyTOAuth2AuthenticateInput.fromJson(Map<String, dynamic> json) => ProxyTOAuth2AuthenticateInput(body: ProxyTOAuth2AuthenticateBody.fromJson(json['body'] as Map<String, dynamic>));
  Map<String, dynamic> toJson() => {'body': body.toJson()};
}

class ProxyTOAuthLoginResponse {
  /// Signed JWT containing an expiry, public key, session type, user id, and organization id
  final String session;

  const ProxyTOAuthLoginResponse({
    required  this.session,
  });

  factory ProxyTOAuthLoginResponse.fromJson(Map<String, dynamic> json) {
    final _session = json['session'] as String;
    return ProxyTOAuthLoginResponse(
      session: _session,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['session'] = session;
    return _json;
  }
}

class ProxyTOAuthLoginBody {
  /// Base64 encoded OIDC token
  final String oidcToken;
  /// Client-side public key generated by the user, which will be conditionally added to org data based on the validity of the oidc token associated with this request
  final String publicKey;
  /// Invalidate all other previously generated Login API keys
  final bool? invalidateExisting;
  /// Unique identifier for a given Organization. If provided, this organization id will be used directly. If omitted, uses the OIDC token to look up the associated organization id.
  final String? organizationId;

  const ProxyTOAuthLoginBody({
    required  this.oidcToken,
    required  this.publicKey,
     this.invalidateExisting,
     this.organizationId,
  });
  factory ProxyTOAuthLoginBody.fromJson(Map<String, dynamic> json) {
    final _oidcToken = json['oidcToken'] as String;
    final _publicKey = json['publicKey'] as String;
    final _invalidateExisting = json['invalidateExisting'] as bool?;
    final _organizationId = json['organizationId'] as String?;
    return ProxyTOAuthLoginBody(
      oidcToken: _oidcToken,
      publicKey: _publicKey,
      invalidateExisting: _invalidateExisting,
      organizationId: _organizationId,
    );
  }
  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['oidcToken'] = oidcToken;
    _json['publicKey'] = publicKey;
    if (invalidateExisting != null) {
      _json['invalidateExisting'] = invalidateExisting;
    }
    if (organizationId != null) {
      _json['organizationId'] = organizationId;
    }
    return _json;
  }
}

class ProxyTOAuthLoginInput {
  final ProxyTOAuthLoginBody body;
  const ProxyTOAuthLoginInput({required this.body});
  factory ProxyTOAuthLoginInput.fromJson(Map<String, dynamic> json) => ProxyTOAuthLoginInput(body: ProxyTOAuthLoginBody.fromJson(json['body'] as Map<String, dynamic>));
  Map<String, dynamic> toJson() => {'body': body.toJson()};
}

class ProxyTInitOtpResponse {
  /// Unique identifier for an OTP authentication
  final String otpId;

  const ProxyTInitOtpResponse({
    required  this.otpId,
  });

  factory ProxyTInitOtpResponse.fromJson(Map<String, dynamic> json) {
    final _otpId = json['otpId'] as String;
    return ProxyTInitOtpResponse(
      otpId: _otpId,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['otpId'] = otpId;
    return _json;
  }
}

class ProxyTInitOtpBody {
  /// Enum to specifiy whether to send OTP via SMS or email
  final String otpType;
  /// Email or phone number to send the OTP code to
  final String contact;

  const ProxyTInitOtpBody({
    required  this.otpType,
    required  this.contact,
  });
  factory ProxyTInitOtpBody.fromJson(Map<String, dynamic> json) {
    final _otpType = json['otpType'] as String;
    final _contact = json['contact'] as String;
    return ProxyTInitOtpBody(
      otpType: _otpType,
      contact: _contact,
    );
  }
  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['otpType'] = otpType;
    _json['contact'] = contact;
    return _json;
  }
}

class ProxyTInitOtpInput {
  final ProxyTInitOtpBody body;
  const ProxyTInitOtpInput({required this.body});
  factory ProxyTInitOtpInput.fromJson(Map<String, dynamic> json) => ProxyTInitOtpInput(body: ProxyTInitOtpBody.fromJson(json['body'] as Map<String, dynamic>));
  Map<String, dynamic> toJson() => {'body': body.toJson()};
}

class ProxyTOtpLoginResponse {
  /// Signed JWT containing an expiry, public key, session type, user id, and organization id
  final String session;

  const ProxyTOtpLoginResponse({
    required  this.session,
  });

  factory ProxyTOtpLoginResponse.fromJson(Map<String, dynamic> json) {
    final _session = json['session'] as String;
    return ProxyTOtpLoginResponse(
      session: _session,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['session'] = session;
    return _json;
  }
}

class ProxyTOtpLoginBody {
  /// Signed JWT containing a unique id, expiry, verification type, contact. Verification status of a user is updated when the token is consumed (in OTP_LOGIN requests)
  final String verificationToken;
  /// Client-side public key generated by the user, which will be conditionally added to org data based on the validity of the verification token
  final String publicKey;
  /// Invalidate all other previously generated Login API keys
  final bool? invalidateExisting;
  /// Unique identifier for a given Organization. If provided, this organization id will be used directly. If omitted, uses the verification token to look up the verified sub-organization based on the contact and verification type.
  final String? organizationId;
  /// Optional signature proving authorization for this login. The signature is over the verification token ID and the public key. Only required if a public key was provided during the verification step.
  final v1ClientSignature? clientSignature;

  const ProxyTOtpLoginBody({
    required  this.verificationToken,
    required  this.publicKey,
     this.invalidateExisting,
     this.organizationId,
     this.clientSignature,
  });
  factory ProxyTOtpLoginBody.fromJson(Map<String, dynamic> json) {
    final _verificationToken = json['verificationToken'] as String;
    final _publicKey = json['publicKey'] as String;
    final _invalidateExisting = json['invalidateExisting'] as bool?;
    final _organizationId = json['organizationId'] as String?;
    final _clientSignature = json['clientSignature'] == null ? null : v1ClientSignature.fromJson(json['clientSignature'] as Map<String, dynamic>);
    return ProxyTOtpLoginBody(
      verificationToken: _verificationToken,
      publicKey: _publicKey,
      invalidateExisting: _invalidateExisting,
      organizationId: _organizationId,
      clientSignature: _clientSignature,
    );
  }
  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['verificationToken'] = verificationToken;
    _json['publicKey'] = publicKey;
    if (invalidateExisting != null) {
      _json['invalidateExisting'] = invalidateExisting;
    }
    if (organizationId != null) {
      _json['organizationId'] = organizationId;
    }
    if (clientSignature != null) {
      _json['clientSignature'] = clientSignature?.toJson();
    }
    return _json;
  }
}

class ProxyTOtpLoginInput {
  final ProxyTOtpLoginBody body;
  const ProxyTOtpLoginInput({required this.body});
  factory ProxyTOtpLoginInput.fromJson(Map<String, dynamic> json) => ProxyTOtpLoginInput(body: ProxyTOtpLoginBody.fromJson(json['body'] as Map<String, dynamic>));
  Map<String, dynamic> toJson() => {'body': body.toJson()};
}

class ProxyTVerifyOtpResponse {
  /// Signed JWT containing a unique id, expiry, verification type, contact. Verification status of a user is updated when the token is consumed (in OTP_LOGIN requests)
  final String verificationToken;

  const ProxyTVerifyOtpResponse({
    required  this.verificationToken,
  });

  factory ProxyTVerifyOtpResponse.fromJson(Map<String, dynamic> json) {
    final _verificationToken = json['verificationToken'] as String;
    return ProxyTVerifyOtpResponse(
      verificationToken: _verificationToken,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['verificationToken'] = verificationToken;
    return _json;
  }
}

class ProxyTVerifyOtpBody {
  /// ID representing the result of an init OTP activity.
  final String otpId;
  /// OTP sent out to a user's contact (email or SMS)
  final String otpCode;
  /// Client-side public key generated by the user, which will be added to the JWT response and verified in subsequent requests via a client proof signature
  final String? publicKey;

  const ProxyTVerifyOtpBody({
    required  this.otpId,
    required  this.otpCode,
     this.publicKey,
  });
  factory ProxyTVerifyOtpBody.fromJson(Map<String, dynamic> json) {
    final _otpId = json['otpId'] as String;
    final _otpCode = json['otpCode'] as String;
    final _publicKey = json['publicKey'] as String?;
    return ProxyTVerifyOtpBody(
      otpId: _otpId,
      otpCode: _otpCode,
      publicKey: _publicKey,
    );
  }
  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['otpId'] = otpId;
    _json['otpCode'] = otpCode;
    if (publicKey != null) {
      _json['publicKey'] = publicKey;
    }
    return _json;
  }
}

class ProxyTVerifyOtpInput {
  final ProxyTVerifyOtpBody body;
  const ProxyTVerifyOtpInput({required this.body});
  factory ProxyTVerifyOtpInput.fromJson(Map<String, dynamic> json) => ProxyTVerifyOtpInput(body: ProxyTVerifyOtpBody.fromJson(json['body'] as Map<String, dynamic>));
  Map<String, dynamic> toJson() => {'body': body.toJson()};
}

class ProxyTSignupResponse {
  final String organizationId;
  /// Wallet created for the sub-organization, if provided in the request
  final v1WalletResult? wallet;
  /// Root user ID created for this sub-organization
  final String userId;
  /// A list of App Proofs generated by enclaves during activity execution, providing verifiable attestations of performed operations.
  final List<v1AppProof>? appProofs;

  const ProxyTSignupResponse({
    required  this.organizationId,
     this.wallet,
    required  this.userId,
     this.appProofs,
  });

  factory ProxyTSignupResponse.fromJson(Map<String, dynamic> json) {
    final _organizationId = json['organizationId'] as String;
    final _wallet = json['wallet'] == null ? null : v1WalletResult.fromJson(json['wallet'] as Map<String, dynamic>);
    final _userId = json['userId'] as String;
    final _appProofs = (json['appProofs'] as List?)?.map((e) => v1AppProof.fromJson(e as Map<String, dynamic>)).toList();
    return ProxyTSignupResponse(
      organizationId: _organizationId,
      wallet: _wallet,
      userId: _userId,
      appProofs: _appProofs,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['organizationId'] = organizationId;
    if (wallet != null) {
      _json['wallet'] = wallet?.toJson();
    }
    _json['userId'] = userId;
    if (appProofs != null) {
      _json['appProofs'] = appProofs?.map((e) => e.toJson()).toList();
    }
    return _json;
  }
}

class ProxyTSignupBody {
  final String? userEmail;
  final String? userPhoneNumber;
  final String? userTag;
  final String? userName;
  final String? organizationName;
  final String? verificationToken;
  /// A list of API Key parameters. This field, if not needed, should be an empty array in your request body.
  final List<v1ApiKeyParamsV2> apiKeys;
  /// A list of Authenticator parameters. This field, if not needed, should be an empty array in your request body.
  final List<v1AuthenticatorParamsV2> authenticators;
  /// A list of Oauth providers. This field, if not needed, should be an empty array in your request body.
  final List<v1OauthProviderParams> oauthProviders;
  /// The wallet to create for the sub-organization
  final v1WalletParams? wallet;
  /// Optional signature proving authorization for this signup. The signature is over the verification token ID and the root user parameters for the root user associated with the verification token. Only required if a public key was provided during the verification step.
  final v1ClientSignature? clientSignature;

  const ProxyTSignupBody({
     this.userEmail,
     this.userPhoneNumber,
     this.userTag,
     this.userName,
     this.organizationName,
     this.verificationToken,
    required  this.apiKeys,
    required  this.authenticators,
    required  this.oauthProviders,
     this.wallet,
     this.clientSignature,
  });
  factory ProxyTSignupBody.fromJson(Map<String, dynamic> json) {
    final _userEmail = json['userEmail'] as String?;
    final _userPhoneNumber = json['userPhoneNumber'] as String?;
    final _userTag = json['userTag'] as String?;
    final _userName = json['userName'] as String?;
    final _organizationName = json['organizationName'] as String?;
    final _verificationToken = json['verificationToken'] as String?;
    final _apiKeys = (json['apiKeys'] as List).map((e) => v1ApiKeyParamsV2.fromJson(e as Map<String, dynamic>)).toList();
    final _authenticators = (json['authenticators'] as List).map((e) => v1AuthenticatorParamsV2.fromJson(e as Map<String, dynamic>)).toList();
    final _oauthProviders = (json['oauthProviders'] as List).map((e) => v1OauthProviderParams.fromJson(e as Map<String, dynamic>)).toList();
    final _wallet = json['wallet'] == null ? null : v1WalletParams.fromJson(json['wallet'] as Map<String, dynamic>);
    final _clientSignature = json['clientSignature'] == null ? null : v1ClientSignature.fromJson(json['clientSignature'] as Map<String, dynamic>);
    return ProxyTSignupBody(
      userEmail: _userEmail,
      userPhoneNumber: _userPhoneNumber,
      userTag: _userTag,
      userName: _userName,
      organizationName: _organizationName,
      verificationToken: _verificationToken,
      apiKeys: _apiKeys,
      authenticators: _authenticators,
      oauthProviders: _oauthProviders,
      wallet: _wallet,
      clientSignature: _clientSignature,
    );
  }
  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    if (userEmail != null) {
      _json['userEmail'] = userEmail;
    }
    if (userPhoneNumber != null) {
      _json['userPhoneNumber'] = userPhoneNumber;
    }
    if (userTag != null) {
      _json['userTag'] = userTag;
    }
    if (userName != null) {
      _json['userName'] = userName;
    }
    if (organizationName != null) {
      _json['organizationName'] = organizationName;
    }
    if (verificationToken != null) {
      _json['verificationToken'] = verificationToken;
    }
    _json['apiKeys'] = apiKeys.map((e) => e.toJson()).toList();
    _json['authenticators'] = authenticators.map((e) => e.toJson()).toList();
    _json['oauthProviders'] = oauthProviders.map((e) => e.toJson()).toList();
    if (wallet != null) {
      _json['wallet'] = wallet?.toJson();
    }
    if (clientSignature != null) {
      _json['clientSignature'] = clientSignature?.toJson();
    }
    return _json;
  }
}

class ProxyTSignupInput {
  final ProxyTSignupBody body;
  const ProxyTSignupInput({required this.body});
  factory ProxyTSignupInput.fromJson(Map<String, dynamic> json) => ProxyTSignupInput(body: ProxyTSignupBody.fromJson(json['body'] as Map<String, dynamic>));
  Map<String, dynamic> toJson() => {'body': body.toJson()};
}

class ProxyTGetWalletKitConfigResponse {
  /// List of enabled authentication providers (e.g., 'facebook', 'google', 'apple', 'email', 'sms', 'passkey', 'wallet')
  final List<String> enabledProviders;
  /// Session expiration duration in seconds
  final String sessionExpirationSeconds;
  /// The organization ID this configuration applies to
  final String organizationId;
  /// Mapping of social login providers to their OAuth client IDs.
  final Map<String, dynamic>? oauthClientIds;
  /// OAuth redirect URL to be used for social login flows.
  final String? oauthRedirectUrl;
  final bool? otpAlphanumeric;
  final String? otpLength;

  const ProxyTGetWalletKitConfigResponse({
    required  this.enabledProviders,
    required  this.sessionExpirationSeconds,
    required  this.organizationId,
     this.oauthClientIds,
     this.oauthRedirectUrl,
     this.otpAlphanumeric,
     this.otpLength,
  });

  factory ProxyTGetWalletKitConfigResponse.fromJson(Map<String, dynamic> json) {
    final _enabledProviders = (json['enabledProviders'] as List).map((e) => e as String).toList();
    final _sessionExpirationSeconds = json['sessionExpirationSeconds'] as String;
    final _organizationId = json['organizationId'] as String;
    final _oauthClientIds = json['oauthClientIds'] as Map<String, dynamic>?;
    final _oauthRedirectUrl = json['oauthRedirectUrl'] as String?;
    final _otpAlphanumeric = json['otpAlphanumeric'] as bool?;
    final _otpLength = json['otpLength'] as String?;
    return ProxyTGetWalletKitConfigResponse(
      enabledProviders: _enabledProviders,
      sessionExpirationSeconds: _sessionExpirationSeconds,
      organizationId: _organizationId,
      oauthClientIds: _oauthClientIds,
      oauthRedirectUrl: _oauthRedirectUrl,
      otpAlphanumeric: _otpAlphanumeric,
      otpLength: _otpLength,
    );
  }

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    _json['enabledProviders'] = enabledProviders;
    _json['sessionExpirationSeconds'] = sessionExpirationSeconds;
    _json['organizationId'] = organizationId;
    if (oauthClientIds != null) {
      _json['oauthClientIds'] = oauthClientIds;
    }
    if (oauthRedirectUrl != null) {
      _json['oauthRedirectUrl'] = oauthRedirectUrl;
    }
    if (otpAlphanumeric != null) {
      _json['otpAlphanumeric'] = otpAlphanumeric;
    }
    if (otpLength != null) {
      _json['otpLength'] = otpLength;
    }
    return _json;
  }
}

class ProxyTGetWalletKitConfigBody {

  const ProxyTGetWalletKitConfigBody(
  );
  factory ProxyTGetWalletKitConfigBody.fromJson(Map<String, dynamic> json) {
    return ProxyTGetWalletKitConfigBody(
    );
  }
  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    return _json;
  }
}

class ProxyTGetWalletKitConfigInput {
  final ProxyTGetWalletKitConfigBody body;
  const ProxyTGetWalletKitConfigInput({required this.body});
  factory ProxyTGetWalletKitConfigInput.fromJson(Map<String, dynamic> json) => ProxyTGetWalletKitConfigInput(body: ProxyTGetWalletKitConfigBody.fromJson(json['body'] as Map<String, dynamic>));
  Map<String, dynamic> toJson() => {'body': body.toJson()};
}

